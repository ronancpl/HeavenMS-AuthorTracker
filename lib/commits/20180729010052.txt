{"fetchDate": "2019-12-19", "content": [{"sha": "cc541f39d571673c813ce1bed180f1575caacd60", "node_id": "MDY6Q29tbWl0NDUwODIwMjM6Y2M1NDFmMzlkNTcxNjczYzgxM2NlMWJlZDE4MGYxNTc1Y2FhY2Q2MA==", "commit": {"author": {"name": "ronancpl", "email": "rcpl2010@gmail.com", "date": "2018-07-29T01:00:52Z"}, "committer": {"name": "ronancpl", "email": "rcpl2010@gmail.com", "date": "2018-07-29T01:00:52Z"}, "message": "Dynamic World/Channel shutdown + Equip levels on Duey + AP/SP patch\n\nImplemented dynamic world/channel shutdown, coupling with the dynamic deployment from last commit rendering on a fully automated world/channel management.\nFixed some spawned mobs not being properly registered on events.\nImplemented a respawn mechanic sensitive to number of players on map. More mobs will spawn the greater the number of players is. Server flag: USE_ENABLE_FULL_RESPAWN = false.\nImplemented a mechanic for delayed mob loot drops, on which the delay is determined by the death animation duration. Server flag: USE_SPAWN_LOOT_ON_ANIMATION = true.\nFixed EIM being disposed incorrectly when the dispose is called through scripts.\nProtected concurrently AP and SP distribution handlers.\nSlightly improved HealOvertimeHandler performance.\nFixed Duey not propagating equipment level and experience when transfering items.\nBuyback now has a short grace period, granting the returning player time for decision making (players won't die right away, rather sticks at 1HP).\nReviewed item monitor task not properly protected concurrently.\nFixed some issues with ropes on some Kampung Village maps.\nFixed \"maxhpmp\" command allowing to pass negative values.", "tree": {"sha": "d68ebe3dfd1bd2f97c31ce0db0d2ac6a3301469c", "url": "https://api.github.com/repos/ronancpl/HeavenMS/git/trees/d68ebe3dfd1bd2f97c31ce0db0d2ac6a3301469c"}, "url": "https://api.github.com/repos/ronancpl/HeavenMS/git/commits/cc541f39d571673c813ce1bed180f1575caacd60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/ronancpl/HeavenMS/commits/cc541f39d571673c813ce1bed180f1575caacd60", "html_url": "https://github.com/ronancpl/HeavenMS/commit/cc541f39d571673c813ce1bed180f1575caacd60", "comments_url": "https://api.github.com/repos/ronancpl/HeavenMS/commits/cc541f39d571673c813ce1bed180f1575caacd60/comments", "author": {"login": "ronancpl", "id": 9257761, "node_id": "MDQ6VXNlcjkyNTc3NjE=", "avatar_url": "https://avatars2.githubusercontent.com/u/9257761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ronancpl", "html_url": "https://github.com/ronancpl", "followers_url": "https://api.github.com/users/ronancpl/followers", "following_url": "https://api.github.com/users/ronancpl/following{/other_user}", "gists_url": "https://api.github.com/users/ronancpl/gists{/gist_id}", "starred_url": "https://api.github.com/users/ronancpl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ronancpl/subscriptions", "organizations_url": "https://api.github.com/users/ronancpl/orgs", "repos_url": "https://api.github.com/users/ronancpl/repos", "events_url": "https://api.github.com/users/ronancpl/events{/privacy}", "received_events_url": "https://api.github.com/users/ronancpl/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ronancpl", "id": 9257761, "node_id": "MDQ6VXNlcjkyNTc3NjE=", "avatar_url": "https://avatars2.githubusercontent.com/u/9257761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ronancpl", "html_url": "https://github.com/ronancpl", "followers_url": "https://api.github.com/users/ronancpl/followers", "following_url": "https://api.github.com/users/ronancpl/following{/other_user}", "gists_url": "https://api.github.com/users/ronancpl/gists{/gist_id}", "starred_url": "https://api.github.com/users/ronancpl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ronancpl/subscriptions", "organizations_url": "https://api.github.com/users/ronancpl/orgs", "repos_url": "https://api.github.com/users/ronancpl/repos", "events_url": "https://api.github.com/users/ronancpl/events{/privacy}", "received_events_url": "https://api.github.com/users/ronancpl/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8aadf7c369340f5cdcfd1a13bacfb4d557a084c6", "url": "https://api.github.com/repos/ronancpl/HeavenMS/commits/8aadf7c369340f5cdcfd1a13bacfb4d557a084c6", "html_url": "https://github.com/ronancpl/HeavenMS/commit/8aadf7c369340f5cdcfd1a13bacfb4d557a084c6"}], "stats": {"total": 49979, "additions": 25405, "deletions": 24574}, "files": [{"sha": "66bc810125ca4c1bd2ac4c6c1fa435fed14ae919", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/README.md", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/README.md", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/README.md?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -3,7 +3,7 @@\n \n ## Head developer: Ronan C. P. Lana\n \n-Besides myself for maintaining this repository, credits are to be given to Nexon(Duh!), the original MapleSolaxia staff and other colaborators, as just some changes/patches on the game were applied by myself, in which some of them diverged from the original v83 patch contents.\n+Besides myself for maintaining this repository, credits are to be given to Nexon(Duh!), the original MapleSolaxia staff and other colaborators, as just some changes/patches on the game were applied by myself, in which some of them diverged from the original v83 patch contents (alright, not just \"some patches\" by now since a whole lot of major server core changes have been applied on this development).\n \n Regarding distributability and usage of the code presented here: like it was before, this MapleStory server is open-source. By that, it is meant that anyone is **free to install, use, modify and redistribute the contents**, as long as there is **no kind of commercial trading involved** and the **credits to the original creators are maintained** within the codes.\n "}, {"sha": "f67c136e9d38d909d6d01d2784bebea252ba7e70", "filename": "docs/issues.txt", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/docs/issues.txt", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/docs/issues.txt", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/docs/issues.txt?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -7,7 +7,6 @@ Vcoc - Freelance Developer\n Known issues:\n - Everytime two people click on an npc at the same time, one of them dcs and the other needs to @dispose to talk to the npc.\n - If multiple people hit boxes/reactors at the same time, they both dc with invalid pointer error.\n-- Passwords on minirooms are not encoded for players entering/logging into the map.\n - Some criticals (e.g. from Aran skills) will not show up as crit for other players.\n - Deadlocks may start appearing if the server stays online long enough with many players logged in.\n - If there are multiple bosses that shows HPBar on the map, if a player hits more than one the HPBar may start flickering on the screen."}, {"sha": "7a96d18335fb6556e05bf5575384276fc7bb2fcd", "filename": "docs/mychanges_ptbr.txt", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/docs/mychanges_ptbr.txt", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/docs/mychanges_ptbr.txt", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/docs/mychanges_ptbr.txt?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -1172,4 +1172,26 @@ Refatorado v\u00e1rios m\u00e9todos de liberamento de recursos do server, tais como em:\n Implementado c\u00f3digo que ofere\u00e7e suporte para abrir novos worlds e channels sob demanda.\n Adicionado scheduler dedicado para a\u00e7\u00f5es de event managers.\n Corrigido potencial de deadlock em alguns pontos do sistema de schedulers de canais.\n-Refatorado v\u00e1rios temporizadores utilizados pelo EventManager e Channel, como o respawn de mobs e o disposeInstance.\n\\ No newline at end of file\n+Refatorado v\u00e1rios temporizadores utilizados pelo EventManager e Channel, como o respawn de mobs e o disposeInstance.\n+\n+24 Julho 2018,\n+Implementado c\u00f3digo que ofere\u00e7e suporte para remover worlds e channels sob demanda.\n+Corrigido alguns problemas com deadlocks ao tentar remover worlds e channels.\n+Melhorado envio de packets de objetos de ambiente. Agora \u00e9 necess\u00e1rio enviar somente um packet, que lista o estado corrente de todos os obst\u00e1culos de um mapa (usado bastante na CWKPQ).\n+Corrigido mobs n\u00e3o sendo devidamente registrados em eventos e n\u00e3o sumindo em certos cen\u00e1rios (e.g. quando chamado por outros mobs/bosses).\n+\n+25 - 26 Julho 2018,\n+Melhorado sistema de respawn de mobs. Agora a quantidade de mobs em campo depende do n\u00famero de jogadores no mesmo mapa.\n+Corrigido certos pontos em MapleClient n\u00e3o liberando devidamente o jogador da estrutura que mantem todos os jogadores online num mundo.\n+Corrigido corda atuando erroneamente em mapas de Malaysia.\n+Remodelado viagens para Malaysia, agora por dois trajetos: CBD e Boat Quay. Para voltar de Malaysia somente conversando com Audrey (NPC agente de viagens) agora.\n+Implementado um temporizador para drops de mobs. Aparentemente GMS drops levavam em conta o tempo de despawn do mob antes de lan\u00e7ar itens em campo.\n+Corrigido dispose de EIM finalizando incorretamente se a fun\u00e7\u00e3o \"dispose\" estiver sendo disparado via scripts.\n+Protegido concorrentemente acesso a m\u00f3dulos de distribui\u00e7\u00e3o de APs, evitando assim exploits cr\u00edticos com APs.\n+Melhorado desempenho do HealOvertimeHandler por fazendo buscar informa\u00e7\u00e3o de mapas com recovery rate maior do XML ao inv\u00e9s de testar um conjunto limitado de mapas.\n+\n+27 Julho 2018,\n+Corrigido comando \"maxhpmp\" permitindo efetivar valores negativos ao alvo.\n+Corrigido Duey n\u00e3o registrando n\u00edvel e experi\u00eancia de equipamentos ao envi\u00e1-los.\n+Buff no buyback: por um curto per\u00edodo ap\u00f3s respawnar o jogador n\u00e3o morre (m\u00ednimo 1 HP), assim permitindo um tempo m\u00ednimo de rea\u00e7\u00e3o.\n+Revisado task do item monitor em MapleMap mal-protegido contra acessos concorrentes.\n\\ No newline at end of file"}, {"sha": "b542d1a65531446c58ca493765fc76903e827335", "filename": "scripts/event/0_EXAMPLE.js", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/scripts/event/0_EXAMPLE.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/scripts/event/0_EXAMPLE.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/event/0_EXAMPLE.js?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -112,6 +112,10 @@ function playerDead(eim, player) {\n     // Happens when player dies\n }\n \n+function monsterRevive(mob, eim) {\n+    // Happens when an opposing mob revives\n+}\n+\n function playerRevive(eim, player) {\n     // Happens when player's revived.\n     // @Param : returns true/false"}, {"sha": "dd640d2da1a8f8e03372c1aa916104a5be788051", "filename": "scripts/npc/1061010.js", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/scripts/npc/1061010.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/scripts/npc/1061010.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/1061010.js?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -28,8 +28,6 @@ function action(mode, type, selection) {\n                 else if(mapid == 108010401) cm.getPlayer().changeMap(107000402);\n                 else if(mapid == 108010501) cm.getPlayer().changeMap(105070200);\n \n-                var em = cm.getEventManager(\"3rdjob\");\n-                em.getInstance(cm.getPlayer().getName()).unregisterPlayer(cm.getPlayer());\n                 cm.dispose();\n         }\n     }"}, {"sha": "5387617294b9f0a992eccc2886ecfff3d3b99747", "filename": "scripts/npc/2042000.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/scripts/npc/2042000.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/scripts/npc/2042000.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/2042000.js?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -80,7 +80,7 @@ function action(mode, type, selection) {\n                         if(allDone) {\n                             cm.sendOk(\"Done. Thanks for showing up~.\");\n                         } else {\n-                            cm.sendOk(\"Done. Be aware some of the items could not be synthetized because either you have a lack of space on your ETC inventory or there's not enough mesos to cover the fee.\");\n+                            cm.sendOk(\"Done. Be aware some of the items #rcould not be synthetized#k because either you have a lack of space on your ETC inventory or there's not enough mesos to cover the fee.\");\n                         }\n                         cm.dispose();\n                 }"}, {"sha": "1a35a90e59ab93f3a58e20a6ff1170878d9561e0", "filename": "scripts/npc/9000020.js", "status": "modified", "additions": 54, "deletions": 12, "changes": 66, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/scripts/npc/9000020.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/scripts/npc/9000020.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/9000020.js?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -21,10 +21,50 @@\n */\n status = -1;\n \n+\n+var travelFrom = [777777777, 541000000];\n+var travelFee = [3000, 10000];\n+\n+var travelMap = [800000000, 550000000];\n+var travelPlace = [\"Mushroom Shrine of Japan\", \"Trend Zone of Malaysia\"];\n+var travelPlaceShort = [\"Mushroom Shrine\", \"Metropolis\"];\n+var travelPlaceCountry = [\"Japan\", \"Malaysia\"];\n+var travelAgent = [\"I\", \"#r#p9201135##k\"];\n+\n+var travelDescription = [\"If you desire to feel the essence of Japan, there's nothing like visiting the Shrine, a Japanese cultural melting pot. Mushroom Shrine is a mythical place that serves the incomparable Mushroom God from ancient times.\",\n+                        \"If you desire to feel the heat of the tropics on an upbeat environment, the residents of Malaysia are eager to welcome you. Also, the metropolis itself is the heart of the local economy, that place is known to always offer something to do or to visit around.\"];\n+\n+var travelDescription2 = [\"Check out the female shaman serving the Mushroom God, and I strongly recommend trying Takoyaki, Yakisoba, and other delocious food sold in the streets of Japan. Now, let's head over to #bMushroom Shrine#k, a mythical place if there ever was one.\",\n+                        \"Once there, I strongly suggest you to schedule a visit to Kampung Village. Why? Surely you've come to know about the fantasy theme park Spooky World? No? It's simply put the greatest theme park around there, it's worth a visit! Now, let's head over to the #bTrend Zone of Malaysia#k.\"];\n+\n+var travelType;\n+var travelStatus;\n+\n function start() {\n+    travelStatus = getTravelingStatus(cm.getPlayer().getMapId());\n     action(1,0,0);\n }\n \n+function getTravelingStatus(mapid) {\n+    for(var i = 0; i < travelMap.length; i++) {\n+        if(mapid == travelMap[i]) {\n+            return i;\n+        }\n+    }\n+    \n+    return -1;\n+}\n+\n+function getTravelType(mapid) {\n+    for(var i = 0; i < travelFrom.length; i++) {\n+        if(mapid == travelFrom[i]) {\n+            return i;\n+        }\n+    }\n+    \n+    return 0;\n+}\n+\n function action(mode, type, selection) {\n     status++;\n     if(mode != 1){\n@@ -35,7 +75,8 @@ function action(mode, type, selection) {\n             return;\n         }\n     }\n-    if (cm.getPlayer().getMapId() == 800000000) {\n+    \n+    if (travelStatus != -1) {\n         if (status == 0) \n             cm.sendSimple(\"How's the traveling? Are you enjoying it?#b\\r\\n#L0#Yes, I'm done with traveling. Can I go back to #m\" + cm.getPlayer().peekSavedLocation(\"WORLDTOUR\") + \"#?\\r\\n#L1#No, I'd like to continue exploring this place.\");\n         else if (status == 1) {\n@@ -53,23 +94,24 @@ function action(mode, type, selection) {\n             cm.dispose();\n         }\n     } else {\n-        if (status == 0) \n-            cm.sendNext(\"If you're tired of the monotonous daily life, how about getting out for a change? there's nothing quite like soaking up a new culture, learning something new by the minute! It's time for you to get out and travel. We, at the Maple Travel Agency recommend you going on a #bWorld Tour#k! Are you worried about the travel expense? You shouldn't be! We, the #bMaple Travel Agency#k, havecarefully come up with a plan to let you travel for ONLY #b3,000 mesos#k!\");\n-        else if (status == 1) \n-            cm.sendSimple(\"We currently offer this place for you traveling pleasure: #bMushroom Shrine of Japan#k. I'll be there serving you as the travel guide. Rest assured, the number of destinations will be increase over time. Now, would you like to head over to the Mushroom Shrine?#b\\r\\n#L0#Yes, take me to Mushroom Shrine (Japan)\");\n-        else if (status == 2)\n-            cm.sendNext(\"Would you like to travel to #bMushroom Shrine of Japan#k? If you desire to feel the essence of Japan, there's nothing like visiting the Shrine, a Japanese cultural melting pot. Mushroom Shrine is a mythical place that serves the incomparable Mushroom God from ancient times.\");\n-        else if (status == 3) {\n-            if(cm.getMeso() < 3000){\n+        if (status == 0) {\n+            travelType = getTravelType(cm.getPlayer().getMapId());\n+            cm.sendNext(\"If you're tired of the monotonous daily life, how about getting out for a change? there's nothing quite like soaking up a new culture, learning something new by the minute! It's time for you to get out and travel. We, at the Maple Travel Agency recommend you going on a #bWorld Tour#k! Are you worried about the travel expense? You shouldn't be! We, the #bMaple Travel Agency#k, have carefully come up with a plan to let you travel for ONLY #b\" + cm.numberWithCommas(travelFee[travelType]) + \" mesos#k!\");\n+        } else if (status == 1) {\n+            cm.sendSimple(\"We currently offer this place for you traveling pleasure: #b\" + travelPlace[travelType] + \"#k. \" + travelAgent[travelType] + \"'ll be there serving you as the travel guide. Rest assured, the number of destinations will be increase over time. Now, would you like to head over to the \" + travelPlaceShort[travelType] + \"?#b\\r\\n#L0#Yes, take me to \" + travelPlaceShort[travelType] + \" (\" + travelPlaceCountry[travelType] + \")\");\n+        } else if (status == 2) {\n+            cm.sendNext(\"Would you like to travel to #b\" + travelPlace[travelType] + \"#k? \" + travelDescription[travelType]);\n+        } else if (status == 3) {\n+            if(cm.getMeso() < travelFee[travelType]){\n                 cm.sendNext(\"You don't have enough mesos to take the travel.\");\n                 cm.dispose();\n                 return;\n             }\n-            cm.sendNextPrev(\"Check out the female shaman serving the Mushroom God, and I strongly recommend trying Takoyaki, Yakisoba, and other delocious food sold in the streets of Japan. Now, let's head over to #bMushroom Shrine#k, a mythical place if there ever was one.\");\n+            cm.sendNextPrev(travelDescription2[travelType]);\n         } else if (status == 4) {\n-            cm.gainMeso(-3000);\n+            cm.gainMeso(-travelFee[travelType]);\n             cm.getPlayer().saveLocation(\"WORLDTOUR\");\n-            cm.warp(800000000, 0);\n+            cm.warp(travelMap[travelType], 0);\n             cm.dispose();\n         }\n     }"}, {"sha": "84a20758ea0a590e3b7dc6a572b538b657dce4fc", "filename": "scripts/npc/9201135.js", "status": "modified", "additions": 74, "deletions": 22, "changes": 96, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/scripts/npc/9201135.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/scripts/npc/9201135.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/9201135.js?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -19,26 +19,55 @@\n     along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \n-var toMap = new Array(550000000, 551000000, 540000000,540000000);\n-var inMap = new Array(540000000, 540000000, 551000000, 550000000);\n-var cost = new Array(10000, 50000, 50000, 10000);\n+var inMap = new Array(540000000, 550000000, 551000000);\n+var toMap = new Array(550000000, new Array(551000000, 541000000), 550000000);\n+var cost = new Array(42000, new Array(10000, 0), 10000);\n+var toMapSp = new Array(0, new Array(2, 4), 4);\n+\n var location;\n-var text = \"Where would you like to travel?\\n\\n\";\n+var text;\n+\n+var travelCost;\n+var travelMap;\n+var travelSp;\n+\n+var startedTravel = false;\n+\n var status = 0;\n \n function start() {\n \tif (cm.getPlayer().getMap().getId() != 540000000) {\n-\t\tfor (var i = 0; i < toMap.length; i ++) {\n-\t\t\tif (inMap[i] == cm.getPlayer().getMap().getId()) {\n-\t\t\t\tlocation = i;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\ttext +=\"\\t\\r\\n#b#L0##m\" + toMap[location] + \"# (\" + cost[location] + \"mesos)#l#k\";\n+                text = \"Hey I'm #p9201135#, your tour guide here in #rMalaysia#k. Where would you like to travel?\\n\\n\";\n \t} else {\n-    \ttext += \"\\t\\r\\n#b#L0##m\" + toMap[0] + \"# (\" + cost[0] + \"mesos)#l\\n\\t\\r\\n#L1##m\" + toMap[1] + \"# (\" + cost[1] + \"mesos)#l#k\";\n+                text = \"Hey I'm #p9201135#, a tour guide on #rMalaysia#k. Since you're not registered in our special travel package with our partner #bMaple Travel Agency#k, the ride will be significantly more expensive. So, would you like to ride now?\\n\\n\";\n+                startedTravel = true;\n \t}\n-    cm.sendSimple(text);\n+        \n+        for (var i = 0; i < toMap.length; i ++) {\n+                if (inMap[i] == cm.getPlayer().getMap().getId()) {\n+                        if(inMap[i] == 550000000) {\n+                                toMap[1][1] = cm.getPlayer().peekSavedLocation(\"WORLDTOUR\");\n+                        }\n+                    \n+                        location = i;\n+                        break;\n+                }\n+        }\n+\n+        if(toMap[location] instanceof Array) {\n+                var maps = toMap[location];\n+                var costs = cost[location];\n+\n+                for(var i = 0; i < maps.length; i++) {\n+                        text +=\"\\t\\r\\n#b#L\" + i + \"##m\" + maps[i] + \"# \" + (costs[i] > 0 ?  \"(\" + costs[i] + \"mesos)\" : \"\") + \"#l\";\n+                }\n+        } else {\n+                text +=\"\\t\\r\\n#b#L0##m\" + toMap[location] + \"# \" + (cost[location] > 0 ?  \"(\" + cost[location] + \"mesos)\" : \"\") + \"#l\";\n+        }\n+\n+        text += \"#k\";\n+        \n+        cm.sendSimple(text);\n }\n \n function action(mode, type, selection) {\n@@ -51,22 +80,45 @@ function action(mode, type, selection) {\n         return;\n     } else {\n         status++;\n-     }\n+    }\n     if (status == 1) {\n-        if (cm.getPlayer().getMap().getId() == 540000000) {\n-            location = selection;\n-        }\n         if (toMap[location] == null) {\n-            cm.dipose();\n+            cm.dispose();\n             return;\n         }\n-        cm.sendYesNo(\"Would you like to travel to #b#m\"+toMap[location]+\"##k? To head over to #b#m\"+toMap[location]+\"##k, it'll cost you cost you #b\" + cost[location] + \"#k. Would you like to go right now?\");\n+        \n+        if(toMap[location] instanceof Array) {\n+            var maps = toMap[location];\n+            var costs = cost[location];\n+            var sps = toMapSp[location];\n+\n+            travelCost = costs[selection];\n+            travelMap = maps[selection];\n+            travelSp = sps[selection];\n+        } else {\n+            travelCost = cost[location];\n+            travelMap = toMap[location];\n+            travelSp = toMapSp[location];\n+        }\n+        \n+        if(travelCost > 0) {\n+            cm.sendYesNo(\"Would you like to travel to #b#m\" + travelMap + \"##k? To head over to #b#m\" + travelMap + \"##k, it'll cost you #r\" + cm.numberWithCommas(travelCost) + \" mesos#k. Would you like to go right now?\");\n+        } else {\n+            cm.sendNext(\"Had a great time in #rMalaysia#k? I hope so, have a safe travel back!\");\n+        }\n     } else if (status == 2) {\n-        if (cm.getMeso() < cost[location]) {\n+        if (cm.getMeso() < travelCost) {\n             cm.sendNext(\"You do not seem to have enough mesos.\");\n         } else {\n-            cm.warp(toMap[location]);\n-            cm.gainMeso(-cost[location]);\n+            if(travelCost > 0) {\n+                cm.gainMeso(-travelCost);\n+                if(startedTravel) cm.getPlayer().saveLocation(\"WORLDTOUR\");\n+            }\n+            else {\n+                travelMap = cm.getPlayer().getSavedLocation(\"WORLDTOUR\");\n+            }\n+            \n+            cm.warp(travelMap, travelSp);\n         }\n         cm.dispose();\n     }"}, {"sha": "b12b2112610f9fc6effbe86ef240581b1968a63b", "filename": "scripts/npc/9270033.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/scripts/npc/9270033.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/scripts/npc/9270033.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/9270033.js?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -53,7 +53,7 @@ function action(mode, type, selection) {\n                         }\n                 } else if(status == 1) {\n                         if(eim.isEventCleared()) {\n-                                if(!eim.giveEventReward(cm.getPlayer)) {\n+                                if(!eim.giveEventReward(cm.getPlayer())) {\n                                         cm.sendOk(\"Please make a room on your inventory to receive the loot.\");\n                                         cm.dispose();\n                                         return;"}, {"sha": "fca11f92860580c7e6f0d2e138ad5dd5672381e9", "filename": "sql/db_database.sql", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/sql/db_database.sql", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/sql/db_database.sql", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/sql/db_database.sql?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -12804,6 +12804,8 @@ CREATE TABLE IF NOT EXISTS `dueyitems` (\n   `quantity` int(10) unsigned NOT NULL DEFAULT '0',\n   `upgradeslots` int(11) DEFAULT '0',\n   `level` int(11) DEFAULT '0',\n+  `itemlevel` int(11) DEFAULT '0',\n+  `itemexp` int(11) DEFAULT '0',\n   `str` int(11) DEFAULT '0',\n   `dex` int(11) DEFAULT '0',\n   `int` int(11) DEFAULT '0',"}, {"sha": "bbeb373149d391996ef5ba903a10c3c729dc919a", "filename": "src/client/MapleCharacter.java", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/client/MapleCharacter.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/client/MapleCharacter.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/client/MapleCharacter.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -157,7 +157,7 @@\n import scripting.item.ItemScriptManager;\n import server.maps.MapleMapItem;\n import net.server.audit.locks.MonitoredLockType;\n-import net.server.audit.locks.MonitoredReentrantLock;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n \n public class MapleCharacter extends AbstractAnimatedMapleMapObject {\n     private static MapleItemInformationProvider ii = MapleItemInformationProvider.getInstance();\n@@ -275,10 +275,10 @@\n     private ScheduledFuture<?> extraRecoveryTask = null;\n     private ScheduledFuture<?> chairRecoveryTask = null;\n     private ScheduledFuture<?> pendantOfSpirit = null; //1122017\n-    private Lock chrLock = new MonitoredReentrantLock(MonitoredLockType.CHARACTER_CHR, true);\n-    private Lock effLock = new MonitoredReentrantLock(MonitoredLockType.CHARACTER_EFF, true);\n-    private Lock petLock = new MonitoredReentrantLock(MonitoredLockType.CHARACTER_PET, true); // for quest tasks as well\n-    private Lock prtLock = new MonitoredReentrantLock(MonitoredLockType.CHARACTER_PRT);\n+    private Lock chrLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.CHARACTER_CHR, true);\n+    private Lock effLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.CHARACTER_EFF, true);\n+    private Lock petLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.CHARACTER_PET, true); // for quest tasks as well\n+    private Lock prtLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.CHARACTER_PRT);\n     private Map<Integer, Set<Integer>> excluded = new LinkedHashMap<>();\n     private Set<Integer> excludedItems = new LinkedHashSet<>();\n     private static String[] ariantroomleader = new String[3];\n@@ -445,8 +445,27 @@ public boolean isAwayFromWorld() {\n         return awayFromWorld.get();\n     }\n     \n-    public void setAwayFromWorld(boolean away) {\n-        awayFromWorld.set(away);\n+    public void setEnteredChannelWorld() {\n+        awayFromWorld.set(false);\n+        client.getChannelServer().removePlayerAway(id);\n+    }\n+    \n+    public void setAwayFromChannelWorld() {\n+        setAwayFromChannelWorld(false);\n+    }\n+            \n+    public void setDisconnectedFromChannelWorld() {\n+        setAwayFromChannelWorld(true);\n+    }\n+    \n+    private void setAwayFromChannelWorld(boolean disconnect) {\n+        awayFromWorld.set(true);\n+        \n+        if(!disconnect) {\n+            client.getChannelServer().insertPlayerAway(id);\n+        } else {\n+            client.getChannelServer().removePlayerAway(id);\n+        }\n     }\n     \n     public long getPetLootCd() {\n@@ -1548,9 +1567,7 @@ private void changeMapInternal(final MapleMap to, final Point pos, final byte[]\n             }\n \n             // if this map has obstacle components moving, make it do so for this client\n-            for(Entry<String, Integer> e: map.getEnvironment().entrySet()) {\n-                announce(MaplePacketCreator.environmentMove(e.getKey(), e.getValue()));\n-            }\n+            announce(MaplePacketCreator.environmentMoveList(map.getEnvironment().entrySet()));\n         }\n     }\n     \n@@ -5273,6 +5290,10 @@ private long getNextBuybackTime() {\n         return lastBuyback + ServerConstants.BUYBACK_COOLDOWN_MINUTES * 60 * 1000;\n     }\n     \n+    private boolean isBuybackInvincible() {\n+        return Server.getInstance().getCurrentTime() - lastBuyback < 4200;\n+    }\n+    \n     private int getBuybackFee() {\n         float fee = ServerConstants.BUYBACK_FEE;\n         int grade = Math.min(Math.max(level, 30), 120) - 30;\n@@ -5282,10 +5303,10 @@ private int getBuybackFee() {\n     }\n     \n     public boolean couldBuyback() {  // Ronan's buyback system\n-        long timeNow = System.currentTimeMillis();\n+        long timeNow = Server.getInstance().getCurrentTime();\n         \n         if(timeNow - lastDeathtime > ServerConstants.BUYBACK_RETURN_MINUTES * 60 * 1000) {\n-            this.dropMessage(5, \"You are unable to buyback now since the time available to decide has expired.\");\n+            this.dropMessage(5, \"The time available to decide has expired, therefore you are unable to buyback now.\");\n             return false;\n         }\n         \n@@ -7621,7 +7642,11 @@ public void setHp(int newhp, boolean silent) {\n             updatePartyMemberHP();\n         }\n         if (oldHp > hp && !isAlive()) {\n-            playerDead();\n+            if(!isBuybackInvincible()) {\n+                playerDead();\n+            } else {\n+                this.hp = 1;\n+            }\n         }\n     }\n "}, {"sha": "70282315401c71b6be372ea203558e2ae1c185e7", "filename": "src/client/MapleClient.java", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/client/MapleClient.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/client/MapleClient.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/client/MapleClient.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -75,7 +75,7 @@\n import server.quest.MapleQuest;\n \n import net.server.audit.locks.MonitoredLockType;\n-import net.server.audit.locks.MonitoredReentrantLock;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n \n public class MapleClient {\n \n@@ -107,9 +107,9 @@\n \tprivate int picattempt = 0;\n \tprivate byte gender = -1;\n \tprivate boolean disconnecting = false;\n-\tprivate final Lock lock = new MonitoredReentrantLock(MonitoredLockType.CLIENT, true);\n-        private final Lock encoderLock = new MonitoredReentrantLock(MonitoredLockType.CLIENT_ENCODER, true);\n-        private static final Lock loginLock = new MonitoredReentrantLock(MonitoredLockType.CLIENT_LOGIN, true);\n+\tprivate final Lock lock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.CLIENT, true);\n+        private final Lock encoderLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.CLIENT_ENCODER, true);\n+        private static final Lock loginLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.CLIENT_LOGIN, true);\n \tprivate int votePoints;\n \tprivate int voteTime = -1;\n \tprivate long lastNpcClick;\n@@ -792,7 +792,7 @@ public boolean checkBirthDate(Calendar date) {\n \n \tprivate void removePlayer() {\n \t\ttry {\n-                        player.setAwayFromWorld(true);\n+                        player.setDisconnectedFromChannelWorld();\n                         player.notifyMapTransferToPartner(-1);\n                         player.cancelAllBuffs(true);\n                         player.cancelAllDebuffs();\n@@ -836,10 +836,13 @@ public final synchronized void disconnect(boolean shutdown, boolean cashshop) {/\n                         \n                         player.cancelMagicDoor();\n \n+                        final World wserv = getWorldServer();\n \t\t\tif (channel == -1 || shutdown) {\n                                 if(chrg != null) chrg.setCharacter(null);\n-                            \n+                                \n+                                if(wserv != null) wserv.removePlayer(player);\n                                 removePlayer();\n+                                \n                                 player.saveCooldowns();\n                                 player.saveCharToDB(true);\n                                 \n@@ -849,12 +852,11 @@ public final synchronized void disconnect(boolean shutdown, boolean cashshop) {/\n                         \n                         removePlayer();\n \t\t\t\n-\t\t\tfinal World worlda = getWorldServer();\n                         try {\n \t\t\t\tif (!cashshop) {\n \t\t\t\t\tif (!this.serverTransition) { // meaning not changing channels\n \t\t\t\t\t\tif (messengerid > 0) {\n-\t\t\t\t\t\t\tworlda.leaveMessenger(messengerid, chrm);\n+\t\t\t\t\t\t\twserv.leaveMessenger(messengerid, chrm);\n \t\t\t\t\t\t}\n                                                 /*      \n \t\t\t\t\t\tif (fid > 0) {\n@@ -877,7 +879,7 @@ public final synchronized void disconnect(boolean shutdown, boolean cashshop) {/\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (party != null) {\n \t\t\t\t\t\t\tchrp.setOnline(false);\n-\t\t\t\t\t\t\tworlda.updateParty(party.getId(), PartyOperation.LOG_ONOFF, chrp);\n+\t\t\t\t\t\t\twserv.updateParty(party.getId(), PartyOperation.LOG_ONOFF, chrp);\n \t\t\t\t\t\t\tif (map != null && party.getLeader().getId() == idz) {\n \t\t\t\t\t\t\t\tMaplePartyCharacter lchr = null;\n \t\t\t\t\t\t\t\tfor (MaplePartyCharacter pchr : party.getMembers()) {\n@@ -886,19 +888,19 @@ public final synchronized void disconnect(boolean shutdown, boolean cashshop) {/\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (lchr != null) {\n-\t\t\t\t\t\t\t\t\tworlda.updateParty(party.getId(), PartyOperation.CHANGE_LEADER, lchr);\n+\t\t\t\t\t\t\t\t\twserv.updateParty(party.getId(), PartyOperation.CHANGE_LEADER, lchr);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}                   \n                                                 if (bl != null) {\n-\t\t\t\t\t\t\tworlda.loggedOff(player.getName(), player.getId(), channel, player.getBuddylist().getBuddyIds());\n+\t\t\t\t\t\t\twserv.loggedOff(player.getName(), player.getId(), channel, player.getBuddylist().getBuddyIds());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif (!this.serverTransition) { // if dc inside of cash shop.\n \t\t\t\t\t\tif (party != null) {\n \t\t\t\t\t\t\tchrp.setOnline(false);\n-\t\t\t\t\t\t\tworlda.updateParty(party.getId(), PartyOperation.LOG_ONOFF, chrp);\n+\t\t\t\t\t\t\twserv.updateParty(party.getId(), PartyOperation.LOG_ONOFF, chrp);\n \t\t\t\t\t\t\tif (map != null && party.getLeader().getId() == idz) {\n \t\t\t\t\t\t\t\tMaplePartyCharacter lchr = null;\n \t\t\t\t\t\t\t\tfor (MaplePartyCharacter pchr : party.getMembers()) {\n@@ -907,20 +909,20 @@ public final synchronized void disconnect(boolean shutdown, boolean cashshop) {/\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (lchr != null) {\n-\t\t\t\t\t\t\t\t\tworlda.updateParty(party.getId(), PartyOperation.CHANGE_LEADER, lchr);\n+\t\t\t\t\t\t\t\t\twserv.updateParty(party.getId(), PartyOperation.CHANGE_LEADER, lchr);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\t                \n \t\t\t\t\t\tif (bl != null) {\n-\t\t\t\t\t\t\tworlda.loggedOff(player.getName(), player.getId(), channel, player.getBuddylist().getBuddyIds());\n+\t\t\t\t\t\t\twserv.loggedOff(player.getName(), player.getId(), channel, player.getBuddylist().getBuddyIds());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} catch (final Exception e) {\n \t\t\t\tFilePrinter.printError(FilePrinter.ACCOUNT_STUCK, e);\n \t\t\t} finally {\n                                 if (!this.serverTransition) {\n-\t\t\t\t\tworlda.removePlayer(player);\n+\t\t\t\t\twserv.removePlayer(player);\n                                         //getChannelServer().removePlayer(player); already being done\n                                         \n                                         player.saveCooldowns();\n@@ -1309,7 +1311,15 @@ public void changeChannel(int channel) {\n \t\t\treturn;\n                 }\n                 \n-\t\tString[] socket = Server.getInstance().getIP(getWorld(), channel).split(\":\");\n+                String[] socket;\n+                try {\n+                        socket = Server.getInstance().getIP(getWorld(), channel).split(\":\");\n+                } catch (Exception e) {\n+                        announce(MaplePacketCreator.serverNotice(1, \"Channel \" + channel + \" is currently disabled. Try another channel.\"));\n+                        announce(MaplePacketCreator.enableActions());\n+\t\t\treturn;\n+                }\n+                \n \t\tif (player.getTrade() != null) {\n \t\t\tMapleTrade.cancelTrade(getPlayer());\n \t\t}\n@@ -1325,7 +1335,7 @@ public void changeChannel(int channel) {\n                 player.unregisterChairBuff();\n \t\tserver.getPlayerBuffStorage().addBuffsToStorage(player.getId(), player.getAllBuffs());\n                 server.getPlayerBuffStorage().addDiseasesToStorage(player.getId(), player.getAllDiseases());\n-                player.setAwayFromWorld(true);\n+                player.setDisconnectedFromChannelWorld();\n                 player.notifyMapTransferToPartner(-1);\n \t\tplayer.cancelAllBuffs(true);\n                 player.cancelAllDebuffs();"}, {"sha": "1d2c6e41e3e981da4b7df2eb0bfde1b3afde3c67", "filename": "src/client/MonsterBook.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/client/MonsterBook.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/client/MonsterBook.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/client/MonsterBook.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -32,10 +32,10 @@\n import java.util.Set;\n import java.util.concurrent.locks.Lock;\n import java.util.concurrent.Semaphore;\n-import net.server.audit.locks.MonitoredReentrantLock;\n import tools.DatabaseConnection;\n import tools.MaplePacketCreator;\n import net.server.audit.locks.MonitoredLockType;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n \n public final class MonsterBook {\n     private static final Semaphore semaphore = new Semaphore(10);\n@@ -44,7 +44,7 @@\n     private int normalCard = 0;\n     private int bookLevel = 1;\n     private Map<Integer, Integer> cards = new LinkedHashMap<>();\n-    private Lock lock = new MonitoredReentrantLock(MonitoredLockType.BOOK);\n+    private Lock lock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.BOOK);\n \n     private Set<Entry<Integer, Integer>> getCardSet() {\n         lock.lock();"}, {"sha": "1c5805bb2e3da46a0e650fab5d2219d6da26380d", "filename": "src/client/command/Commands.java", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/client/command/Commands.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/client/command/Commands.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/client/command/Commands.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -1804,29 +1804,31 @@ public static boolean executeHeavenMsCommandLv3(Channel cserv, Server srv, Maple\n                         \n                         if (sub.length >= 3) {\n                                 victim = c.getWorldServer().getPlayerStorage().getCharacterByName(sub[1]);\n-                                statUpdate = Integer.valueOf(sub[2]);\n+                                statUpdate = Math.max(1, Integer.valueOf(sub[2]));\n                         } else if(sub.length == 2) {\n-                                statUpdate = Integer.valueOf(sub[1]);\n+                                statUpdate = Math.max(1, Integer.valueOf(sub[1]));\n                         } else {\n \t\t\t\tplayer.yellowMessage(\"Syntax: !maxhpmp [<playername>] <value>\");\n                         }\n                     \n                         if(victim != null) {\n+                                List<Pair<MapleStat, Integer>> statup = new ArrayList<>(4);\n+                            \n                                 if(victim.getHp() > statUpdate) {\n                                         victim.setHp(statUpdate);\n-                                        victim.updateSingleStat(MapleStat.HP, statUpdate);\n+                                        statup.add(new Pair<>(MapleStat.HP, statUpdate));\n                                 }\n+                                statup.add(new Pair<>(MapleStat.MAXHP, statUpdate));\n                                 \n                                 if(victim.getMp() > statUpdate) {\n                                         victim.setMp(statUpdate);\n-                                        victim.updateSingleStat(MapleStat.MP, statUpdate);\n+                                        statup.add(new Pair<>(MapleStat.MP, statUpdate));\n                                 }\n+                                statup.add(new Pair<>(MapleStat.MAXMP, statUpdate));\n+                                c.announce(MaplePacketCreator.updatePlayerStats(statup, victim));\n                             \n                                 victim.setMaxHp(statUpdate);\n                                 victim.setMaxMp(statUpdate);\n-                                victim.updateSingleStat(MapleStat.MAXHP, statUpdate);\n-                                victim.updateSingleStat(MapleStat.MAXMP, statUpdate);\n-                                \n                                 victim.checkBerserk(victim.isHidden());\n                         } else {\n                                 player.message(\"Player '\" + sub[1] + \"' could not be found on this world.\");\n@@ -2895,7 +2897,6 @@ public static boolean executeHeavenMsCommandLv6(Channel cserv, Server srv, Maple\n                         \n                         break;\n                     \n-                        /*\n                     case \"removechannel\":\n                         if (sub.length < 2) {\n                             player.dropMessage(5, \"Syntax: @removechannel <worldid>\");\n@@ -2929,7 +2930,6 @@ public static boolean executeHeavenMsCommandLv6(Channel cserv, Server srv, Maple\n                         }\n                         \n                         break;\n-                                */\n                         \n                     case \"shutdown\":\n                     case \"shutdownnow\":"}, {"sha": "eb6661835c4bc54f404de089507afd716eeb1127", "filename": "src/client/inventory/ItemFactory.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/client/inventory/ItemFactory.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/client/inventory/ItemFactory.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/client/inventory/ItemFactory.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -28,10 +28,10 @@\n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.locks.Lock;\n-import net.server.audit.locks.MonitoredReentrantLock;\n import tools.DatabaseConnection;\n import tools.Pair;\n import net.server.audit.locks.MonitoredLockType;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n \n /**\n  *\n@@ -47,7 +47,7 @@\n     MERCHANT(6, false);\n     private final int value;\n     private final boolean account;\n-    private static final Lock lock = new MonitoredReentrantLock(MonitoredLockType.ITEM, true);\n+    private static final Lock lock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.ITEM, true);\n \n     private ItemFactory(int value, boolean account) {\n         this.value = value;"}, {"sha": "d8f20304fca763c0e03cb2f5d99b7432fdf1b22a", "filename": "src/client/inventory/MapleInventory.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/client/inventory/MapleInventory.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/client/inventory/MapleInventory.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/client/inventory/MapleInventory.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -32,7 +32,7 @@\n import java.util.Map.Entry;\n import java.util.Map;\n import java.util.concurrent.locks.Lock;\n-import net.server.audit.locks.MonitoredReentrantLock;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n \n import tools.Pair;\n import client.MapleCharacter;\n@@ -53,7 +53,7 @@\n     protected byte slotLimit;\n     protected MapleInventoryType type;\n     protected boolean checked = false;\n-    protected Lock lock = new MonitoredReentrantLock(MonitoredLockType.INVENTORY, true);\n+    protected Lock lock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.INVENTORY, true);\n     \n     public MapleInventory(MapleCharacter mc, MapleInventoryType type, byte slotLimit) {\n         this.owner = mc;"}, {"sha": "603ead60668fcad32ab47dc7d2c5054c4a2591d3", "filename": "src/client/processor/AssignAPProcessor.java", "status": "added", "additions": 881, "deletions": 0, "changes": 881, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/client/processor/AssignAPProcessor.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/client/processor/AssignAPProcessor.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/client/processor/AssignAPProcessor.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -0,0 +1,881 @@\n+/*\n+\tThis file is part of the OdinMS Maple Story Server\n+    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n+\t\t       Matthias Butz <matze@odinms.de>\n+\t\t       Jan Christian Meyer <vimes@odinms.de>\n+\n+    Copyleft (L) 2016 - 2018 RonanLana (HeavenMS)\n+\n+    This program is free software: you can redistribute it and/or modify\n+    it under the terms of the GNU Affero General Public License as\n+    published by the Free Software Foundation version 3 as published by\n+    the Free Software Foundation. You may not use, modify or distribute\n+    this program under any other version of the GNU Affero General Public\n+    License.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU Affero General Public License for more details.\n+\n+    You should have received a copy of the GNU Affero General Public License\n+    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+*/\n+package client.processor;\n+\n+import client.MapleCharacter;\n+import client.MapleClient;\n+import client.MapleJob;\n+import client.MapleStat;\n+import client.Skill;\n+import client.SkillFactory;\n+import client.autoban.AutobanFactory;\n+import client.inventory.Equip;\n+import client.inventory.Item;\n+import client.inventory.MapleInventoryType;\n+import constants.ServerConstants;\n+import constants.skills.BlazeWizard;\n+import constants.skills.Brawler;\n+import constants.skills.DawnWarrior;\n+import constants.skills.Magician;\n+import constants.skills.Warrior;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import tools.MaplePacketCreator;\n+import tools.Pair;\n+import tools.Randomizer;\n+import tools.data.input.SeekableLittleEndianAccessor;\n+\n+/**\n+ *\n+ * @author RonanLana (synchronization of AP transaction modules)\n+ */\n+public class AssignAPProcessor {\n+    \n+    public static void APAutoAssignAction(SeekableLittleEndianAccessor slea, MapleClient c) {\n+        MapleCharacter chr = c.getPlayer();\n+        if (chr.getRemainingAp() < 1) return;\n+        \n+        Collection<Item> equippedC = chr.getInventory(MapleInventoryType.EQUIPPED).list();\n+        \n+        c.lockClient();\n+        try {\n+            int[] statGain = new int[4];\n+            int[] statEqpd = new int[4];\n+            statGain[0] = 0; statGain[1] = 0; statGain[2] = 0; statGain[3] = 0;\n+\n+            slea.skip(8);\n+\n+            if(ServerConstants.USE_SERVER_AUTOASSIGNER) {\n+                // --------- Ronan Lana's AUTOASSIGNER ---------\n+                // This method excels for assigning APs in such a way to cover all equipments AP requirements.\n+                byte opt = slea.readByte();     // useful for pirate autoassigning\n+\n+                int str = 0, dex = 0, luk = 0, int_ = 0;\n+                List<Short> eqpStrList = new ArrayList<>();\n+                List<Short> eqpDexList = new ArrayList<>();\n+                List<Short> eqpLukList = new ArrayList<>();\n+\n+                Equip nEquip;\n+\n+                for (Item item : equippedC) {   //selecting the biggest AP value of each stat from each equipped item.\n+                    nEquip = (Equip)item;\n+                    if(nEquip.getStr() > 0) eqpStrList.add(nEquip.getStr());\n+                    str += nEquip.getStr();\n+\n+                    if(nEquip.getDex() > 0) eqpDexList.add(nEquip.getDex());\n+                    dex += nEquip.getDex();\n+\n+                    if(nEquip.getLuk() > 0) eqpLukList.add(nEquip.getLuk());\n+                    luk += nEquip.getLuk();\n+\n+                    //if(nEquip.getInt() > 0) eqpIntList.add(nEquip.getInt()); //not needed...\n+                    int_ += nEquip.getInt();\n+                }\n+\n+                statEqpd[0] = str;\n+                statEqpd[1] = dex;\n+                statEqpd[2] = luk;\n+                statEqpd[3] = int_;\n+\n+                Collections.sort(eqpStrList, Collections.reverseOrder());\n+                Collections.sort(eqpDexList, Collections.reverseOrder());\n+                Collections.sort(eqpLukList, Collections.reverseOrder());\n+\n+                //Autoassigner looks up the 1st/2nd placed equips for their stats to calculate the optimal upgrade.\n+                int eqpStr = getNthHighestStat(eqpStrList, (short) 0) + getNthHighestStat(eqpStrList, (short) 1);\n+                int eqpDex = getNthHighestStat(eqpDexList, (short) 0) + getNthHighestStat(eqpDexList, (short) 1);\n+                int eqpLuk = getNthHighestStat(eqpLukList, (short) 0) + getNthHighestStat(eqpLukList, (short) 1);\n+\n+                //c.getPlayer().message(\"----------------------------------------\");\n+                //c.getPlayer().message(\"SDL: s\" + eqpStr + \" d\" + eqpDex + \" l\" + eqpLuk + \" BASE STATS --> STR: \" + chr.getStr() + \" DEX: \" + chr.getDex() + \" INT: \" + chr.getInt() + \" LUK: \" + chr.getLuk());\n+                //c.getPlayer().message(\"SUM EQUIP STATS -> STR: \" + str + \" DEX: \" + dex + \" LUK: \" + luk + \" INT: \" + int_);\n+\n+                MapleJob stance = c.getPlayer().getJobStyle(opt);\n+                int prStat = 0, scStat = 0, trStat = 0, temp, tempAp = chr.getRemainingAp(), CAP;\n+                if (tempAp < 1) return;\n+\n+                MapleStat primary, secondary, tertiary = MapleStat.LUK;\n+                switch(stance) {\n+                    case MAGICIAN:\n+                        CAP = 165;\n+                        scStat = (chr.getLevel() + 3) - (chr.getLuk() + luk - eqpLuk);\n+                        if(scStat < 0) scStat = 0;\n+                        scStat = Math.min(scStat, tempAp);\n+\n+                        if(tempAp > scStat) tempAp -= scStat;\n+                        else tempAp = 0;\n+\n+                        prStat = tempAp;\n+                        int_ = prStat;\n+                        luk = scStat;\n+                        str = 0; dex = 0;\n+\n+                        if(luk + chr.getLuk() > CAP) {\n+                            temp = luk + chr.getLuk() - CAP;\n+                            luk -= temp;\n+                            int_ += temp;\n+                        }\n+\n+                        primary = MapleStat.INT;\n+                        secondary = MapleStat.LUK;\n+                        tertiary = MapleStat.DEX;\n+\n+                        break;\n+\n+                    case BOWMAN:\n+                        CAP = 125;\n+                        scStat = (chr.getLevel() + 5) - (chr.getStr() + str - eqpStr);\n+                        if(scStat < 0) scStat = 0;\n+                        scStat = Math.min(scStat, tempAp);\n+\n+                        if(tempAp > scStat) tempAp -= scStat;\n+                        else tempAp = 0;\n+\n+                        prStat = tempAp;\n+                        dex = prStat;\n+                        str = scStat;\n+                        int_ = 0; luk = 0;\n+\n+                        if(str + chr.getStr() > CAP) {\n+                            temp = str + chr.getStr() - CAP;\n+                            str -= temp;\n+                            dex += temp;\n+                        }\n+\n+                        primary = MapleStat.DEX;\n+                        secondary = MapleStat.STR;\n+\n+                        break;\n+\n+                    case GUNSLINGER:\n+                    case CROSSBOWMAN:\n+                        CAP = 120;\n+                        scStat = chr.getLevel() - (chr.getStr() + str - eqpStr);\n+                        if(scStat < 0) scStat = 0;\n+                        scStat = Math.min(scStat, tempAp);\n+\n+                        if(tempAp > scStat) tempAp -= scStat;\n+                        else tempAp = 0;\n+\n+                        prStat = tempAp;\n+                        dex = prStat;\n+                        str = scStat;\n+                        int_ = 0; luk = 0;\n+\n+                        if(str + chr.getStr() > CAP) {\n+                            temp = str + chr.getStr() - CAP;\n+                            str -= temp;\n+                            dex += temp;\n+                        }\n+\n+                        primary = MapleStat.DEX;\n+                        secondary = MapleStat.STR;\n+\n+                        break;\n+\n+                    case THIEF:\n+                        CAP = 160;\n+\n+                        scStat = 0;\n+                        if(chr.getDex() < 80) {\n+                            scStat = (2 * chr.getLevel()) - (chr.getDex() + dex - eqpDex);\n+                            if(scStat < 0) scStat = 0;\n+\n+                            scStat = Math.min(80 - chr.getDex(), scStat);\n+                            scStat = Math.min(tempAp, scStat);\n+                            tempAp -= scStat;\n+                        }\n+\n+                        temp = (chr.getLevel() + 40) - Math.max(80, scStat + chr.getDex() + dex - eqpDex);\n+                        if(temp < 0) temp = 0;\n+                        temp = Math.min(tempAp, temp);\n+                        scStat += temp;\n+                        tempAp -= temp;\n+\n+                        // thieves will upgrade STR as well only if a level-based threshold is reached.\n+                        if(chr.getStr() >= Math.max(13, (int)(0.4 * chr.getLevel()))) {\n+                            if(chr.getStr() < 50) {\n+                                trStat = (chr.getLevel() - 10) - (chr.getStr() + str - eqpStr);\n+                                if(trStat < 0) trStat = 0;\n+\n+                                trStat = Math.min(50 - chr.getStr(), trStat);\n+                                trStat = Math.min(tempAp, trStat);\n+                                tempAp -= trStat;\n+                            }\n+\n+                            temp = (20 + (chr.getLevel() / 2)) - Math.max(50, trStat + chr.getStr() + str - eqpStr);\n+                            if(temp < 0) temp = 0;\n+                            temp = Math.min(tempAp, temp);\n+                            trStat += temp;\n+                            tempAp -= temp;\n+                        }\n+\n+                        prStat = tempAp;\n+                        luk = prStat;\n+                        dex = scStat;\n+                        str = trStat;\n+                        int_ = 0;\n+\n+                        if(dex + chr.getDex() > CAP) {\n+                            temp = dex + chr.getDex() - CAP;\n+                            dex -= temp;\n+                            luk += temp;\n+                        }\n+                        if(str + chr.getStr() > CAP) {\n+                            temp = str + chr.getStr() - CAP;\n+                            str -= temp;\n+                            luk += temp;\n+                        }\n+\n+                        primary = MapleStat.LUK;\n+                        secondary = MapleStat.DEX;\n+                        tertiary = MapleStat.STR;\n+\n+                        break;\n+\n+                    case BRAWLER:\n+                        CAP = 120;\n+\n+                        scStat = chr.getLevel() - (chr.getDex() + dex - eqpDex);\n+                        if(scStat < 0) scStat = 0;\n+                        scStat = Math.min(scStat, tempAp);\n+\n+                        if(tempAp > scStat) tempAp -= scStat;\n+                        else tempAp = 0;\n+\n+                        prStat = tempAp;\n+                        str = prStat;\n+                        dex = scStat;\n+                        int_ = 0; luk = 0;\n+\n+                        if(dex + chr.getDex() > CAP) {\n+                            temp = dex + chr.getDex() - CAP;\n+                            dex -= temp;\n+                            str += temp;\n+                        }\n+\n+                        primary = MapleStat.STR;\n+                        secondary = MapleStat.DEX;\n+\n+                        break;\n+\n+                    default:    //warrior, beginner, ...\n+                        CAP = 80;\n+\n+                        scStat = ((2 * chr.getLevel()) / 3) - (chr.getDex() + dex - eqpDex);\n+                        if(scStat < 0) scStat = 0;\n+                        scStat = Math.min(scStat, tempAp);\n+\n+                        if(tempAp > scStat) tempAp -= scStat;\n+                        else tempAp = 0;\n+\n+                        prStat = tempAp;\n+                        str = prStat;\n+                        dex = scStat;\n+                        int_ = 0; luk = 0;\n+\n+                        if(dex + chr.getDex() > CAP) {\n+                            temp = dex + chr.getDex() - CAP;\n+                            dex -= temp;\n+                            str += temp;\n+                        }\n+\n+                        primary = MapleStat.STR;\n+                        secondary = MapleStat.DEX;\n+                }\n+\n+                //-------------------------------------------------------------------------------------\n+\n+                int extras = 0;\n+\n+                extras = gainStatByType(chr, primary, statGain, prStat + extras);\n+                extras = gainStatByType(chr, secondary, statGain, scStat + extras);\n+                extras = gainStatByType(chr, tertiary, statGain, trStat + extras);\n+\n+                if(extras > 0) {    //redistribute surplus in priority order\n+                    extras = gainStatByType(chr, primary, statGain, extras);\n+                    extras = gainStatByType(chr, secondary, statGain, extras);\n+                    extras = gainStatByType(chr, tertiary, statGain, extras);\n+                    gainStatByType(chr, getQuaternaryStat(stance), statGain, extras);\n+                }\n+\n+                int remainingAp = (chr.getRemainingAp() - getAccumulatedStatGain(statGain));\n+                chr.setRemainingAp(remainingAp);\n+                chr.updateSingleStat(MapleStat.AVAILABLEAP, remainingAp);\n+                c.announce(MaplePacketCreator.enableActions());\n+\n+                //----------------------------------------------------------------------------------------\n+\n+                c.announce(MaplePacketCreator.serverNotice(1, \"Better AP applications detected:\\r\\nSTR: +\" + statGain[0] + \"\\r\\nDEX: +\" + statGain[1] + \"\\r\\nINT: +\" + statGain[3] + \"\\r\\nLUK: +\" + statGain[2]));\n+            } else {\n+                if(slea.available() < 16) {\n+                    AutobanFactory.PACKET_EDIT.alert(chr, \"Didn't send full packet for Auto Assign.\");\n+                    \n+                    final MapleClient client = c;\n+                    Thread t = new Thread(new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            client.disconnect(false, false);\n+                        }\n+                    });\n+                    t.start();\n+                    \n+                    return;\n+                }\n+\n+                for (Item item : equippedC) {   //selecting the biggest AP value of each stat from each equipped item.\n+                    Equip nEquip = (Equip)item;\n+\n+                    statEqpd[0] += nEquip.getStr();\n+                    statEqpd[1] += nEquip.getDex();\n+                    statEqpd[2] += nEquip.getLuk();\n+                    statEqpd[3] += nEquip.getInt();\n+                }\n+\n+                int total = 0;\n+                int extras = 0;\n+                for (int i = 0; i < 2; i++) {\n+                    int type = slea.readInt();\n+                    int tempVal = slea.readInt();\n+                    if (tempVal < 0 || tempVal > chr.getRemainingAp()) {\n+                        return;\n+                    }\n+                    total += tempVal;\n+                    extras += gainStatByType(chr, MapleStat.getBy5ByteEncoding(type), statGain, tempVal);\n+                }\n+                int remainingAp = (chr.getRemainingAp() - total) + extras;\n+                chr.setRemainingAp(remainingAp);\n+                chr.updateSingleStat(MapleStat.AVAILABLEAP, remainingAp);\n+                c.announce(MaplePacketCreator.enableActions());\n+            }\n+        } finally {\n+            c.unlockClient();\n+        }\n+    }\n+    \n+    private static int getNthHighestStat(List<Short> statList, short rank) {    // ranks from 0\n+        return(statList.size() <= rank ? 0 : statList.get(rank));\n+    }\n+    \n+    private static int gainStatByType(MapleCharacter chr, MapleStat type, int[] statGain, int gain) {\n+        if(gain <= 0) return 0;\n+        \n+        int newVal = 0;\n+        if (type.equals(MapleStat.STR)) {\n+            newVal = chr.getStr() + gain;\n+            if (newVal > ServerConstants.MAX_AP) {\n+                statGain[0] += (gain - (newVal - ServerConstants.MAX_AP));\n+                chr.setStr(ServerConstants.MAX_AP);\n+            } else {\n+                statGain[0] += gain;\n+                chr.setStr(newVal);\n+            }\n+        } else if (type.equals(MapleStat.INT)) {\n+            newVal = chr.getInt() + gain;\n+            if (newVal > ServerConstants.MAX_AP) {\n+                statGain[3] += (gain - (newVal - ServerConstants.MAX_AP));\n+                chr.setInt(ServerConstants.MAX_AP);\n+            } else {\n+                statGain[3] += gain;\n+                chr.setInt(newVal);\n+            }\n+        } else if (type.equals(MapleStat.LUK)) {\n+            newVal = chr.getLuk() + gain;\n+            if (newVal > ServerConstants.MAX_AP) {\n+                statGain[2] += (gain - (newVal - ServerConstants.MAX_AP));\n+                chr.setLuk(ServerConstants.MAX_AP);\n+            } else {\n+                statGain[2] += gain;\n+                chr.setLuk(newVal);\n+            }\n+        } else if (type.equals(MapleStat.DEX)) {\n+            newVal = chr.getDex() + gain;\n+            if (newVal > ServerConstants.MAX_AP) {\n+                statGain[1] += (gain - (newVal - ServerConstants.MAX_AP));\n+                chr.setDex(ServerConstants.MAX_AP);\n+            } else {\n+                statGain[1] += gain;\n+                chr.setDex(newVal);\n+            }\n+        }\n+        \n+        if (newVal > ServerConstants.MAX_AP) {\n+            chr.updateSingleStat(type, ServerConstants.MAX_AP);\n+            return newVal - ServerConstants.MAX_AP;\n+        }\n+        chr.updateSingleStat(type, newVal);\n+        return 0;\n+    }\n+    \n+    private static MapleStat getQuaternaryStat(MapleJob stance) {\n+        if(stance != MapleJob.MAGICIAN) return MapleStat.INT;\n+        return MapleStat.STR;\n+    }\n+    \n+    private static int getAccumulatedStatGain(int[] statGain) {\n+        int acc = 0;\n+        \n+        for(byte i = 0; i < statGain.length; i++) {\n+            acc += statGain[i];\n+        }\n+        \n+        return acc;\n+    }\n+    \n+    public static boolean APResetAction(MapleClient c, int APFrom, int APTo) {\n+        c.lockClient();\n+        try {\n+            List<Pair<MapleStat, Integer>> statupdate = new ArrayList<>(2);\n+            MapleCharacter player = c.getPlayer();\n+\n+            switch (APFrom) {\n+                case 64: // str\n+                    if (player.getStr() < 5) {\n+                        player.message(\"You don't have the minimum STR required to swap.\");\n+                        c.announce(MaplePacketCreator.enableActions());\n+                        return false;\n+                    }\n+                    player.addStat(1, -1);\n+                    break;\n+                case 128: // dex\n+                    if (player.getDex() < 5) {\n+                        player.message(\"You don't have the minimum DEX required to swap.\");\n+                        c.announce(MaplePacketCreator.enableActions());\n+                        return false;\n+                    }\n+                    player.addStat(2, -1);\n+                    break;\n+                case 256: // int\n+                    if (player.getInt() < 5) {\n+                        player.message(\"You don't have the minimum INT required to swap.\");\n+                        c.announce(MaplePacketCreator.enableActions());\n+                        return false;\n+                    }\n+                    player.addStat(3, -1);\n+                    break;\n+                case 512: // luk\n+                    if (player.getLuk() < 5) {\n+                        player.message(\"You don't have the minimum LUK required to swap.\");\n+                        c.announce(MaplePacketCreator.enableActions());\n+                        return false;\n+                    }\n+                    player.addStat(4, -1);\n+                    break;\n+                case 2048: // HP\n+                    if(ServerConstants.USE_ENFORCE_HPMP_SWAP) {\n+                        if (APTo != 8192) {\n+                            player.message(\"You can only swap HP ability points to MP.\");\n+                            c.announce(MaplePacketCreator.enableActions());\n+                            return false;\n+                        }\n+                    }\n+                    if (player.getHpMpApUsed() < 1) {\n+                        player.message(\"You don't have enough HPMP stat points to spend on AP Reset.\");\n+                        c.announce(MaplePacketCreator.enableActions());\n+                        return false;\n+                    }\n+\n+                    int hp = player.getMaxHp();\n+                    int level_ = player.getLevel();\n+\n+                    boolean canWash_ = true;\n+                    if (hp < level_ * 14 + 148) {\n+                        canWash_ = false;\n+                    }\n+\n+                    if (!canWash_) {\n+                        player.message(\"You don't have the minimum HP pool required to swap.\");\n+                        c.announce(MaplePacketCreator.enableActions());\n+                        return false;\n+                    }\n+\n+                    player.setHpMpApUsed(player.getHpMpApUsed() - 1);\n+                    int hplose = -takeHp(player.getJob());\n+                    int nextHp = Math.max(1, player.getHp() + hplose), nextMaxHp = Math.max(50, player.getMaxHp() + hplose);\n+\n+                    player.setHp(nextHp);\n+                    player.setMaxHp(nextMaxHp);\n+                    statupdate.add(new Pair<>(MapleStat.HP, nextHp));\n+                    statupdate.add(new Pair<>(MapleStat.MAXHP, nextMaxHp));\n+\n+                    break;\n+                case 8192: // MP\n+                    if(ServerConstants.USE_ENFORCE_HPMP_SWAP) {\n+                        if (APTo != 2048) {\n+                            player.message(\"You can only swap MP ability points to HP.\");\n+                            c.announce(MaplePacketCreator.enableActions());\n+                            return false;\n+                        }\n+                    }\n+                    if (player.getHpMpApUsed() < 1) {\n+                        player.message(\"You don't have enough HPMP stat points to spend on AP Reset.\");\n+                        c.announce(MaplePacketCreator.enableActions());\n+                        return false;\n+                    }\n+\n+                    int mp = player.getMaxMp();\n+                    int level = player.getLevel();\n+                    MapleJob job = player.getJob();\n+\n+                    boolean canWash = true;\n+                    if (job.isA(MapleJob.SPEARMAN) && mp < 4 * level + 156) {\n+                        canWash = false;\n+                    } else if (job.isA(MapleJob.FIGHTER) && mp < 4 * level + 56) {\n+                        canWash = false;\n+                    } else if (job.isA(MapleJob.THIEF) && job.getId() % 100 > 0 && mp < level * 14 - 4) {\n+                        canWash = false;\n+                    } else if (mp < level * 14 + 148) {\n+                        canWash = false;\n+                    }\n+\n+                    if (!canWash) {\n+                        player.message(\"You don't have the minimum MP pool required to swap.\");\n+                        c.announce(MaplePacketCreator.enableActions());\n+                        return false;\n+                    }\n+\n+                    player.setHpMpApUsed(player.getHpMpApUsed() - 1);\n+                    int mplose = -takeMp(job);\n+                    int nextMp = Math.max(0, player.getMp() + mplose), nextMaxMp = Math.max(5, player.getMaxMp() + mplose);\n+\n+                    player.setMp(nextMp);\n+                    player.setMaxMp(nextMaxMp);\n+                    statupdate.add(new Pair<>(MapleStat.MP, nextMp));\n+                    statupdate.add(new Pair<>(MapleStat.MAXMP, nextMaxMp));\n+\n+                    break;\n+                default:\n+                    c.announce(MaplePacketCreator.updatePlayerStats(MaplePacketCreator.EMPTY_STATUPDATE, true, player));\n+                    return false;\n+            }\n+\n+            addStat(c, APTo, true);\n+            c.announce(MaplePacketCreator.updatePlayerStats(statupdate, true, player));\n+            return true;\n+        } finally {\n+            c.unlockClient();\n+        }\n+    }\n+    \n+    public static void APAssignAction(MapleClient c, int num) {\n+        c.lockClient();\n+        try {\n+            if (c.getPlayer().getRemainingAp() > 0) {\n+                if (addStat(c, num, false)) {\n+                    c.getPlayer().setRemainingAp(c.getPlayer().getRemainingAp() - 1);\n+                    c.getPlayer().updateSingleStat(MapleStat.AVAILABLEAP, c.getPlayer().getRemainingAp());\n+                }\n+            }\n+            c.announce(MaplePacketCreator.enableActions());\n+        } finally {\n+            c.unlockClient();\n+        }\n+    }\n+    \n+    private static boolean addStat(MapleClient c, int apTo, boolean usedAPReset) {\n+        switch (apTo) {\n+            case 64: // Str\n+                if (c.getPlayer().getStr() >= 32767) {\n+                    return false;\n+                }\n+                c.getPlayer().addStat(1, 1);\n+                break;\n+            case 128: // Dex\n+                if (c.getPlayer().getDex() >= 32767) {\n+                    return false;\n+                }\n+                c.getPlayer().addStat(2, 1);\n+                break;\n+            case 256: // Int\n+                if (c.getPlayer().getInt() >= 32767) {\n+                    return false;\n+                }\n+                c.getPlayer().addStat(3, 1);\n+                break;\n+            case 512: // Luk\n+                if (c.getPlayer().getLuk() >= 32767) {\n+                    return false;\n+                }\n+                c.getPlayer().addStat(4, 1);\n+                break;\n+            case 2048: // HP\n+                addHP(c.getPlayer(), addHP(c, usedAPReset));\n+                break;\n+            case 8192: // MP\n+                addMP(c.getPlayer(), addMP(c, usedAPReset));\n+                break;\n+            default:\n+                c.announce(MaplePacketCreator.updatePlayerStats(MaplePacketCreator.EMPTY_STATUPDATE, true, c.getPlayer()));\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    private static int addHP(MapleClient c, boolean usedAPReset) {\n+        MapleCharacter player = c.getPlayer();\n+        MapleJob job = player.getJob();\n+        int MaxHP = player.getMaxHp();\n+        if (player.getHpMpApUsed() > 9999 || MaxHP >= 30000) {\n+            return MaxHP;\n+        }\n+        \n+        return MaxHP + calcHpChange(player, job, usedAPReset);\n+    }\n+    \n+    private static int calcHpChange(MapleCharacter player, MapleJob job, boolean usedAPReset) {\n+        int MaxHP = 0;\n+        \n+        if (job.isA(MapleJob.WARRIOR) || job.isA(MapleJob.DAWNWARRIOR1)) {\n+            if(!usedAPReset) {\n+                Skill increaseHP = SkillFactory.getSkill(job.isA(MapleJob.DAWNWARRIOR1) ? DawnWarrior.MAX_HP_INCREASE : Warrior.IMPROVED_MAXHP);\n+                int sLvl = player.getSkillLevel(increaseHP);\n+\n+                if(sLvl > 0)\n+                    MaxHP += increaseHP.getEffect(sLvl).getY();\n+            }\n+            \n+            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n+                if (usedAPReset) {\n+                    MaxHP += 20;\n+                } else {\n+                    MaxHP += Randomizer.rand(18, 22);\n+                }\n+            } else {\n+                MaxHP += 20;\n+            }\n+        } else if(job.isA(MapleJob.ARAN1)) {\n+            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n+                if (usedAPReset) {\n+                    MaxHP += 20;\n+                } else {\n+                    MaxHP += Randomizer.rand(26, 30);\n+                }\n+            } else {\n+                MaxHP += 28;\n+            }\n+        } else if (job.isA(MapleJob.MAGICIAN) || job.isA(MapleJob.BLAZEWIZARD1)) {\n+            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n+                if (usedAPReset) {\n+                    MaxHP += 6;\n+                } else {\n+                    MaxHP += Randomizer.rand(5, 9);\n+                }\n+            } else {\n+                MaxHP += 6;\n+            }\n+        } else if (job.isA(MapleJob.THIEF) || job.isA(MapleJob.NIGHTWALKER1)) {\n+            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n+                if (usedAPReset) {\n+                    MaxHP += 16;\n+                } else {\n+                    MaxHP += Randomizer.rand(14, 18);\n+                }\n+            } else {\n+                MaxHP += 16;\n+            }\n+        } else if(job.isA(MapleJob.BOWMAN) || job.isA(MapleJob.WINDARCHER1)) {\n+            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n+                if (usedAPReset) {\n+                    MaxHP += 16;\n+                } else {\n+                    MaxHP += Randomizer.rand(14, 18);\n+                }\n+            } else {\n+                MaxHP += 16;\n+            }\n+        } else if (job.isA(MapleJob.PIRATE) || job.isA(MapleJob.THUNDERBREAKER1)) {\n+            if(!usedAPReset) {\n+                Skill increaseHP = SkillFactory.getSkill(Brawler.IMPROVE_MAX_HP);\n+                int sLvl = player.getSkillLevel(increaseHP);\n+\n+                if(sLvl > 0)\n+                    MaxHP += increaseHP.getEffect(sLvl).getY();\n+            }\n+            \n+            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n+                if (usedAPReset) {\n+                    MaxHP += 18;\n+                } else {\n+                    MaxHP += Randomizer.rand(16, 20);\n+                }\n+            } else {\n+                MaxHP += 18;\n+            }\n+        } else if (usedAPReset) {\n+            MaxHP += 8;\n+        } else {\n+            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n+                MaxHP += Randomizer.rand(8, 12);\n+            } else {\n+                MaxHP += 10;\n+            }\n+        }\n+        \n+        return MaxHP;\n+    }\n+\n+    private static int addMP(MapleClient c, boolean usedAPReset) {\n+        MapleCharacter player = c.getPlayer();\n+        int MaxMP = player.getMaxMp();\n+        MapleJob job = player.getJob();\n+        if (player.getHpMpApUsed() > 9999 || player.getMaxMp() >= 30000) {\n+            return MaxMP;\n+        }\n+        \n+        return MaxMP + calcMpChange(player, job, usedAPReset);\n+    }\n+    \n+    private static int calcMpChange(MapleCharacter player, MapleJob job, boolean usedAPReset) {\n+        int MaxMP = 0;\n+        \n+        if (job.isA(MapleJob.WARRIOR) || job.isA(MapleJob.DAWNWARRIOR1) || job.isA(MapleJob.ARAN1)) {\n+            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n+                if(!usedAPReset) {\n+                    MaxMP += (Randomizer.rand(2, 4) + (player.getInt() / 10));\n+                } else {\n+                    MaxMP += 2;\n+                }\n+            } else {\n+                MaxMP += 3;\n+            }\n+        } else if (job.isA(MapleJob.MAGICIAN) || job.isA(MapleJob.BLAZEWIZARD1)) {\n+            if(!usedAPReset) {\n+                Skill increaseMP = SkillFactory.getSkill(job.isA(MapleJob.BLAZEWIZARD1) ? BlazeWizard.INCREASING_MAX_MP : Magician.IMPROVED_MAX_MP_INCREASE);\n+                int sLvl = player.getSkillLevel(increaseMP);\n+\n+                if(sLvl > 0)\n+                    MaxMP += increaseMP.getEffect(sLvl).getY();\n+            }\n+            \n+            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n+                if(!usedAPReset) {\n+                    MaxMP += (Randomizer.rand(12, 16) + (player.getInt() / 20));\n+                } else {\n+                    MaxMP += 18;\n+                }\n+            } else {\n+                MaxMP += 18;\n+            }\n+        } else if (job.isA(MapleJob.BOWMAN) || job.isA(MapleJob.WINDARCHER1)) {\n+            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n+                if(!usedAPReset) {\n+                    MaxMP += (Randomizer.rand(6, 8) + (player.getInt() / 10));\n+                } else {\n+                    MaxMP += 10;\n+                }\n+            } else {\n+                MaxMP += 10;\n+            }\n+        } else if(job.isA(MapleJob.THIEF) || job.isA(MapleJob.NIGHTWALKER1)) {\n+            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n+                if(!usedAPReset) {\n+                    MaxMP += (Randomizer.rand(6, 8) + (player.getInt() / 10));\n+                } else {\n+                    MaxMP += 10;\n+                }\n+            } else {\n+                MaxMP += 10;\n+            }\n+        } else if (job.isA(MapleJob.PIRATE) || job.isA(MapleJob.THUNDERBREAKER1)) {\n+            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n+                if(!usedAPReset) {\n+                    MaxMP += (Randomizer.rand(7, 9) + (player.getInt() / 10));\n+                } else {\n+                    MaxMP += 14;\n+                }\n+            } else {\n+                MaxMP += 14;\n+            }\n+        } else {\n+            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n+                if(!usedAPReset) {\n+                    MaxMP += (Randomizer.rand(4, 6) + (player.getInt() / 10));\n+                } else {\n+                    MaxMP += 6;\n+                }\n+            } else {\n+                MaxMP += 6;\n+            }\n+        }\n+        \n+        return MaxMP;\n+    }\n+\n+    private static void addHP(MapleCharacter player, int MaxHP) {\n+        MaxHP = Math.min(30000, MaxHP);\n+        player.setHpMpApUsed(player.getHpMpApUsed() + 1);\n+        player.setMaxHp(MaxHP);\n+        player.updateSingleStat(MapleStat.MAXHP, MaxHP);\n+    }\n+\n+    private static void addMP(MapleCharacter player, int MaxMP) {\n+        MaxMP = Math.min(30000, MaxMP);\n+        player.setHpMpApUsed(player.getHpMpApUsed() + 1);\n+        player.setMaxMp(MaxMP);\n+        player.updateSingleStat(MapleStat.MAXMP, MaxMP);\n+    }\n+    \n+    private static int takeHp(MapleJob job) {\n+        int MaxHP = 0;\n+        \n+        if (job.isA(MapleJob.WARRIOR) || job.isA(MapleJob.DAWNWARRIOR1) || job.isA(MapleJob.ARAN1)) {\n+            MaxHP += 54;\n+        } else if (job.isA(MapleJob.MAGICIAN) || job.isA(MapleJob.BLAZEWIZARD1)) {\n+            MaxHP += 10;\n+        } else if (job.isA(MapleJob.THIEF) || job.isA(MapleJob.NIGHTWALKER1)) {\n+            MaxHP += 20;\n+        } else if(job.isA(MapleJob.BOWMAN) || job.isA(MapleJob.WINDARCHER1)) {\n+            MaxHP += 20;\n+        } else if (job.isA(MapleJob.PIRATE) || job.isA(MapleJob.THUNDERBREAKER1)) {\n+            MaxHP += 42;\n+        } else {\n+            MaxHP += 12;\n+        }\n+        \n+        return MaxHP;\n+    }\n+    \n+    private static int takeMp(MapleJob job) {\n+        int MaxMP = 0;\n+        \n+        if (job.isA(MapleJob.WARRIOR) || job.isA(MapleJob.DAWNWARRIOR1) || job.isA(MapleJob.ARAN1)) {\n+            MaxMP += 4;\n+        } else if (job.isA(MapleJob.MAGICIAN) || job.isA(MapleJob.BLAZEWIZARD1)) {\n+            MaxMP += 31;\n+        } else if (job.isA(MapleJob.BOWMAN) || job.isA(MapleJob.WINDARCHER1)) {\n+            MaxMP += 12;\n+        } else if(job.isA(MapleJob.THIEF) || job.isA(MapleJob.NIGHTWALKER1)) {\n+            MaxMP += 12;\n+        } else if (job.isA(MapleJob.PIRATE) || job.isA(MapleJob.THUNDERBREAKER1)) {\n+            MaxMP += 16;\n+        } else {\n+            MaxMP += 8;\n+        }\n+        \n+        return MaxMP;\n+    }\n+    \n+}"}, {"sha": "35fcd302505d7e121f4b6fb9625d9039c4fbebd0", "filename": "src/client/processor/AssignSPProcessor.java", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/client/processor/AssignSPProcessor.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/client/processor/AssignSPProcessor.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/client/processor/AssignSPProcessor.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -0,0 +1,100 @@\n+/*\n+\tThis file is part of the OdinMS Maple Story Server\n+    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n+\t\t       Matthias Butz <matze@odinms.de>\n+\t\t       Jan Christian Meyer <vimes@odinms.de>\n+\n+    Copyleft (L) 2016 - 2018 RonanLana (HeavenMS)\n+\n+    This program is free software: you can redistribute it and/or modify\n+    it under the terms of the GNU Affero General Public License as\n+    published by the Free Software Foundation version 3 as published by\n+    the Free Software Foundation. You may not use, modify or distribute\n+    this program under any other version of the GNU Affero General Public\n+    License.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU Affero General Public License for more details.\n+\n+    You should have received a copy of the GNU Affero General Public License\n+    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+*/\n+package client.processor;\n+\n+import client.MapleCharacter;\n+import client.MapleClient;\n+import client.MapleStat;\n+import client.Skill;\n+import client.SkillFactory;\n+import client.autoban.AutobanFactory;\n+import constants.GameConstants;\n+import constants.skills.Aran;\n+import tools.FilePrinter;\n+import tools.MaplePacketCreator;\n+\n+/**\n+ *\n+ * @author RonanLana (synchronization of SP transaction modules)\n+ */\n+public class AssignSPProcessor {\n+    \n+    public static void SPAssignAction(MapleClient c, int skillid) {\n+        c.lockClient();\n+        try {\n+            if (skillid == Aran.HIDDEN_FULL_DOUBLE || skillid == Aran.HIDDEN_FULL_TRIPLE || skillid == Aran.HIDDEN_OVER_DOUBLE || skillid == Aran.HIDDEN_OVER_TRIPLE) {\n+                c.getSession().write(MaplePacketCreator.enableActions());\n+                return;\n+            }\n+\n+            MapleCharacter player = c.getPlayer();\n+            int remainingSp = player.getRemainingSpBySkill(GameConstants.getSkillBook(skillid/10000));\n+            boolean isBeginnerSkill = false;\n+            if ((!GameConstants.isPqSkillMap(player.getMapId()) && GameConstants.isPqSkill(skillid)) || (!player.isGM() && GameConstants.isGMSkills(skillid)) || (!GameConstants.isInJobTree(skillid, player.getJob().getId()) && !player.isGM())) {\n+                AutobanFactory.PACKET_EDIT.alert(player, \"tried to packet edit in distributing sp.\");\n+                FilePrinter.printError(FilePrinter.EXPLOITS + c.getPlayer().getName() + \".txt\", c.getPlayer().getName() + \" tried to use skill \" + skillid + \" without it being in their job.\\r\\n\");\n+                \n+                final MapleClient client = c;\n+                Thread t = new Thread(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        client.disconnect(true, false);\n+                    }\n+                });\n+                t.start();\n+                \n+                return;\n+            }\n+            if (skillid % 10000000 > 999 && skillid % 10000000 < 1003) {\n+                int total = 0;\n+                for (int i = 0; i < 3; i++) {\n+                    total += player.getSkillLevel(SkillFactory.getSkill(player.getJobType() * 10000000 + 1000 + i));\n+                }\n+                remainingSp = Math.min((player.getLevel() - 1), 6) - total;\n+                isBeginnerSkill = true;\n+            }  \t\t\n+            Skill skill = SkillFactory.getSkill(skillid);\n+            int curLevel = player.getSkillLevel(skill);\n+            if ((remainingSp > 0 && curLevel + 1 <= (skill.isFourthJob() ? player.getMasterLevel(skill) : skill.getMaxLevel()))) {\n+                if (!isBeginnerSkill) {\n+                    player.setRemainingSp(player.getRemainingSpBySkill(GameConstants.getSkillBook(skillid/10000)) - 1, GameConstants.getSkillBook(skillid/10000));\n+                }       \t\n+                player.updateSingleStat(MapleStat.AVAILABLESP, player.getRemainingSpBySkill(GameConstants.getSkillBook(skillid/10000)));\n+                if (skill.getId() == Aran.FULL_SWING) {\n+                    player.changeSkillLevel(skill, (byte) (curLevel + 1), player.getMasterLevel(skill), player.getSkillExpiration(skill));\n+                    player.changeSkillLevel(SkillFactory.getSkill(Aran.HIDDEN_FULL_DOUBLE), (byte) player.getSkillLevel(skill), player.getMasterLevel(skill),  player.getSkillExpiration(skill));\n+                    player.changeSkillLevel(SkillFactory.getSkill(Aran.HIDDEN_FULL_TRIPLE), (byte) player.getSkillLevel(skill), player.getMasterLevel(skill),  player.getSkillExpiration(skill));            \n+                } else if (skill.getId() == Aran.OVER_SWING) {\n+                    player.changeSkillLevel(skill, (byte) (curLevel + 1), player.getMasterLevel(skill), player.getSkillExpiration(skill));\n+                    player.changeSkillLevel(SkillFactory.getSkill(Aran.HIDDEN_OVER_DOUBLE), (byte) player.getSkillLevel(skill), player.getMasterLevel(skill),  player.getSkillExpiration(skill));\n+                    player.changeSkillLevel(SkillFactory.getSkill(Aran.HIDDEN_OVER_TRIPLE), (byte) player.getSkillLevel(skill), player.getMasterLevel(skill),  player.getSkillExpiration(skill));\n+                } else {\n+                    player.changeSkillLevel(skill, (byte) (curLevel + 1), player.getMasterLevel(skill), player.getSkillExpiration(skill));\n+                }\n+            }\n+        } finally {\n+            c.unlockClient();\n+        }\n+    }\n+}"}, {"sha": "3a03da5e77b084783a35204836260d91a81c7600", "filename": "src/client/processor/DueyProcessor.java", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/client/processor/DueyProcessor.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/client/processor/DueyProcessor.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/client/processor/DueyProcessor.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -149,6 +149,8 @@ private static DueyPackages getItemByPID(ResultSet rs) {\n                 Equip eq = new Equip(rs.getInt(\"itemid\"), (byte) 0, -1);\n                 eq.setUpgradeSlots((byte) rs.getInt(\"upgradeslots\"));\n                 eq.setLevel((byte) rs.getInt(\"level\"));\n+                eq.setItemLevel((byte) rs.getInt(\"itemlevel\"));\n+                eq.setItemExp(rs.getInt(\"itemexp\"));\n                 eq.setStr((short) rs.getInt(\"str\"));\n                 eq.setDex((short) rs.getInt(\"dex\"));\n                 eq.setInt((short) rs.getInt(\"int\"));\n@@ -271,29 +273,31 @@ public static void addItemToDB(Item item, int quantity, int mesos, String sName,\n                         rs.next();\n                         PreparedStatement ps2;\n                         if (item.getInventoryType().equals(MapleInventoryType.EQUIP)) {\n-                            ps2 = con.prepareStatement(\"INSERT INTO dueyitems (PackageId, itemid, quantity, upgradeslots, level, str, dex, `int`, luk, hp, mp, watk, matk, wdef, mdef, acc, avoid, hands, speed, jump, flag, owner) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\");\n+                            ps2 = con.prepareStatement(\"INSERT INTO dueyitems (PackageId, itemid, quantity, upgradeslots, level, itemlevel, itemexp, str, dex, `int`, luk, hp, mp, watk, matk, wdef, mdef, acc, avoid, hands, speed, jump, flag, owner) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\");\n                             Equip eq = (Equip) item;\n                             ps2.setInt(2, eq.getItemId());\n                             ps2.setInt(3, 1);\n                             ps2.setInt(4, eq.getUpgradeSlots());\n                             ps2.setInt(5, eq.getLevel());\n-                            ps2.setInt(6, eq.getStr());\n-                            ps2.setInt(7, eq.getDex());\n-                            ps2.setInt(8, eq.getInt());\n-                            ps2.setInt(9, eq.getLuk());\n-                            ps2.setInt(10, eq.getHp());\n-                            ps2.setInt(11, eq.getMp());\n-                            ps2.setInt(12, eq.getWatk());\n-                            ps2.setInt(13, eq.getMatk());\n-                            ps2.setInt(14, eq.getWdef());\n-                            ps2.setInt(15, eq.getMdef());\n-                            ps2.setInt(16, eq.getAcc());\n-                            ps2.setInt(17, eq.getAvoid());\n-                            ps2.setInt(18, eq.getHands());\n-                            ps2.setInt(19, eq.getSpeed());\n-                            ps2.setInt(20, eq.getJump());\n-                            ps2.setInt(21, eq.getFlag());\n-                            ps2.setString(22, eq.getOwner());\n+                            ps2.setInt(6, eq.getItemLevel());\n+                            ps2.setInt(7, eq.getItemExp());\n+                            ps2.setInt(8, eq.getStr());\n+                            ps2.setInt(9, eq.getDex());\n+                            ps2.setInt(10, eq.getInt());\n+                            ps2.setInt(11, eq.getLuk());\n+                            ps2.setInt(12, eq.getHp());\n+                            ps2.setInt(13, eq.getMp());\n+                            ps2.setInt(14, eq.getWatk());\n+                            ps2.setInt(15, eq.getMatk());\n+                            ps2.setInt(16, eq.getWdef());\n+                            ps2.setInt(17, eq.getMdef());\n+                            ps2.setInt(18, eq.getAcc());\n+                            ps2.setInt(19, eq.getAvoid());\n+                            ps2.setInt(20, eq.getHands());\n+                            ps2.setInt(21, eq.getSpeed());\n+                            ps2.setInt(22, eq.getJump());\n+                            ps2.setInt(23, eq.getFlag());\n+                            ps2.setString(24, eq.getOwner());\n                         } else {\n                             ps2 = con.prepareStatement(\"INSERT INTO dueyitems (PackageId, itemid, quantity, flag, owner) VALUES (?, ?, ?, ?, ?)\");\n                             ps2.setInt(2, item.getItemId());"}, {"sha": "61f686c598ecff69fcf51a5a09b3529cc0373344", "filename": "src/constants/ServerConstants.java", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/constants/ServerConstants.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/constants/ServerConstants.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/constants/ServerConstants.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -46,8 +46,8 @@\n     public static final boolean USE_DEBUG_SHOW_INFO_EQPEXP = false; //Prints on the cmd all equip exp gain info.\n     public static       boolean USE_DEBUG_SHOW_RCVD_PACKET = false; //Prints on the cmd all received packet ids.\n     \n-    public static final boolean USE_MAXRANGE_ECHO_OF_HERO = true;\n     public static final boolean USE_MAXRANGE = true;                //Will send and receive packets from all events on a map, rather than those of only view range.\n+    public static final boolean USE_MAXRANGE_ECHO_OF_HERO = true;\n     public static final boolean USE_MTS = false;\n     public static final boolean USE_AUTOHIDE_GM = false;            //When enabled, GMs are automatically hidden when joining. Thanks to Steven Deblois (steven1152).\n     public static final boolean USE_BUYBACK_SYSTEM = true;          //Enables the HeavenMS-builtin buyback system, to be used by dead players when clicking the MTS button.\n@@ -80,6 +80,8 @@\n     public static final boolean USE_BANISHABLE_TOWN_SCROLL = true;  //Enables town scrolls to act as if it's a \"player banish\", rendering the antibanish scroll effect available.\n     public static final boolean USE_OLD_GMS_STYLED_PQ_NPCS = true;  //Enables PQ NPCs with similar behaviour to old GMS style, that skips info about the PQs and immediately tries to register the party in.\n     public static final boolean USE_ENABLE_SOLO_EXPEDITIONS = true; //Enables start expeditions with any number of players. This will also bypass all the Zakum prequest.\n+    public static final boolean USE_ENABLE_FULL_RESPAWN = true;    //At respawn task, always respawn missing mobs when they're available. Spawn count doesn't depend on how many players are currently there.\n+    public static final boolean USE_SPAWN_LOOT_ON_ANIMATION = false;//Makes loot appear some time after the mob has been killed (following the mob death animation, instead of instantly).\n     \n     //Announcement Configuration\n     public static final boolean USE_ANNOUNCE_SHOPITEMSOLD = false;  //Automatic message sent to owner when an item from the Player Shop or Hired Merchant is sold.\n@@ -122,10 +124,12 @@\n     public static final int ITEM_EXPIRE_TIME  = 3 * 60 * 1000;  //Time before items start disappearing. Recommended to be set up to 3 minutes.\n     public static final int KITE_EXPIRE_TIME  = 60 * 60 * 1000; //Time before kites (cash item) disappears.\n     public static final int ITEM_MONITOR_TIME = 5 * 60 * 1000;  //Interval between item monitoring tasks on maps, which checks for dangling (null) item objects on the map item history.\n-    public static final int LOCK_MONITOR_TIME = 3 * 60 * 1000;      //Waiting time for a lock to be released. If it reaches timeout, a critical server deadlock has made present.\n+    public static final int LOCK_MONITOR_TIME = 30 * 1000;      //Waiting time for a lock to be released. If it reaches timeout, a critical server deadlock has made present.\n+    \n+    //Map Monitor Configuration\n     public static final int ITEM_EXPIRE_CHECK = 10 * 1000;      //Interval between item expiring tasks on maps, which checks and makes disappear expired items.\n     public static final int ITEM_LIMIT_ON_MAP = 200;            //Max number of items allowed on a map.\n-    public static final int MAP_VISITED_SIZE = 5;               //Max length for last mapids visited by a player. This is used to recover and update drops on these maps accordingly with player actions.\n+    public static final int MAP_VISITED_SIZE = 5;               //Max length for last mapids visited by a player. This is used to recover and update drops on these maps accordingly with player actions.    \n     \n     //Channel Mob Disease Monitor Configuration\n     public static final int MOB_STATUS_MONITOR_PROC = 200;     //Frequency in milliseconds between each proc on the mob disease monitor schedule."}, {"sha": "16eeac4ce81f2be4705054906810877df26dd74a", "filename": "src/net/MapleServerHandler.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/MapleServerHandler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/MapleServerHandler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/MapleServerHandler.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -29,7 +29,7 @@\n import java.util.concurrent.atomic.AtomicLong;\n \n import net.server.audit.locks.MonitoredLockType;\n-import net.server.audit.locks.MonitoredReentrantLock;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n import net.server.Server;\n \n import org.apache.mina.core.service.IoHandlerAdapter;\n@@ -63,8 +63,8 @@\n     private static final SimpleDateFormat sdf = new SimpleDateFormat(\"dd-MM-yyyy HH:mm\");\n     private static AtomicLong sessionId = new AtomicLong(7777);\n     \n-    private Lock idleLock = new MonitoredReentrantLock(MonitoredLockType.SRVHANDLER_IDLE, true);\n-    private Lock tempLock = new MonitoredReentrantLock(MonitoredLockType.SRVHANDLER_TEMP, true);\n+    private Lock idleLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.SRVHANDLER_IDLE, true);\n+    private Lock tempLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.SRVHANDLER_TEMP, true);\n     private Map<MapleClient, Long> idleSessions = new HashMap<>(100);\n     private Map<MapleClient, Long> tempIdleSessions = new HashMap<>();\n     private ScheduledFuture<?> idleManager = null;"}, {"sha": "2786d6f7a4897a3a59fd41b043b0466b643c09c5", "filename": "src/net/opcodes/SendOpcode.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/opcodes/SendOpcode.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/opcodes/SendOpcode.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/opcodes/SendOpcode.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -169,7 +169,7 @@\n     \n     FIELD_EFFECT(0x8A),\n     FIELD_OBSTACLE_ONOFF(0x8B),\n-    FIELD_OBSTACLE_ONOFF_STATUS(0x8C),\n+    FIELD_OBSTACLE_ONOFF_LIST(0x8C),\n     FIELD_OBSTACLE_ALL_RESET(0x8D),\n     BLOW_WEATHER(0x8E),\n     PLAY_JUKEBOX(0x8F),"}, {"sha": "c936c988986726d00317572f0775984b1f67855d", "filename": "src/net/server/PlayerBuffStorage.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/PlayerBuffStorage.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/PlayerBuffStorage.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/PlayerBuffStorage.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -29,7 +29,7 @@\n import server.life.MobSkill;\n import tools.Pair;\n import net.server.audit.locks.MonitoredLockType;\n-import net.server.audit.locks.MonitoredReentrantLock;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n \n /**\n  *\n@@ -38,7 +38,7 @@\n  */\n public class PlayerBuffStorage {\n     private int id = (int) (Math.random() * 100);\n-    private final Lock lock = new MonitoredReentrantLock(MonitoredLockType.BUFF_STORAGE, true);    \n+    private final Lock lock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.BUFF_STORAGE, true);    \n     private Map<Integer, List<PlayerBuffValueHolder>> buffs = new HashMap<>();\n     private Map<Integer, Map<MapleDisease, Pair<Long, MobSkill>>> diseases = new HashMap<>();\n "}, {"sha": "9bd6d1647d5af2efeb5a00897acf289ec0d5f990", "filename": "src/net/server/PlayerStorage.java", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/PlayerStorage.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/PlayerStorage.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/PlayerStorage.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -23,8 +23,9 @@\n \n import client.MapleClient;\n import client.MapleCharacter;\n+import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.Iterator;\n+import java.util.List;\n import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n@@ -35,10 +36,10 @@\n \n public class PlayerStorage {\n     private final ReentrantReadWriteLock locks = new MonitoredReentrantReadWriteLock(MonitoredLockType.PLAYER_STORAGE, true);\n-    private final ReadLock rlock = locks.readLock();\n-    private final WriteLock wlock = locks.writeLock();\n     private final Map<Integer, MapleCharacter> storage = new LinkedHashMap<>();\n     private final Map<String, MapleCharacter> nameStorage = new LinkedHashMap<>();\n+    private ReadLock rlock = locks.readLock();\n+    private WriteLock wlock = locks.writeLock();\n \n     public void addPlayer(MapleCharacter chr) {\n         wlock.lock();\n@@ -90,17 +91,24 @@ public MapleCharacter getCharacterById(int id) {\n     }\n \n     public final void disconnectAll() {\n-\twlock.lock();\n-\ttry {\t    \n-            final Iterator<MapleCharacter> chrit = storage.values().iterator();\n-\t    while (chrit.hasNext()) {\n-                MapleClient client = chrit.next().getClient();\n-                if(client != null) {\n-                    client.disconnect(true, false);\n-                }\n-                \n-                chrit.remove();\n+        List<MapleCharacter> chrList;\n+\trlock.lock();\n+\ttry {\n+            chrList = new ArrayList<>(storage.values());\n+\t} finally {\n+\t    rlock.unlock();\n+\t}\n+        \n+        for(MapleCharacter mc : chrList) {\n+            MapleClient client = mc.getClient();\n+            if(client != null) {\n+                client.disconnect(true, false);\n             }\n+        }\n+        \n+        wlock.lock();\n+\ttry {\n+            storage.clear();\n \t} finally {\n \t    wlock.unlock();\n \t}"}, {"sha": "45d189aca4717b53048512be1d32a55d3ab618e4", "filename": "src/net/server/Server.java", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/Server.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/Server.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/Server.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -48,8 +48,8 @@\n \n import net.server.audit.ThreadTracker;\n import net.server.audit.locks.MonitoredLockType;\n-import net.server.audit.locks.MonitoredReentrantLock;\n import net.server.audit.locks.MonitoredReentrantReadWriteLock;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n \n import net.MapleServerHandler;\n import net.mina.MapleCodecFactory;\n@@ -111,8 +111,8 @@\n     private final List<MapleClient> processDiseaseAnnouncePlayers = new LinkedList<>();\n     private final List<MapleClient> registeredDiseaseAnnouncePlayers = new LinkedList<>();\n     \n-    private final Lock srvLock = new MonitoredReentrantLock(MonitoredLockType.SERVER);\n-    private final Lock disLock = new MonitoredReentrantLock(MonitoredLockType.SERVER_DISEASES);\n+    private final Lock srvLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.SERVER);\n+    private final Lock disLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.SERVER_DISEASES);\n     \n     private final ReentrantReadWriteLock wldLock = new MonitoredReentrantReadWriteLock(MonitoredLockType.SERVER_WORLDS, true);\n     private final ReadLock wldRLock = wldLock.readLock();\n@@ -412,7 +412,7 @@ public boolean removeWorld() {   //lol don't!\n             wldRLock.unlock();\n         }\n         \n-        if(w == null || w.getPlayerStorage().getSize() > 0) {\n+        if(w == null || !w.canUninstall()) {\n             return false;\n         }\n         \n@@ -1414,12 +1414,11 @@ public void run() {\n                         }\n                     }*/\n                     \n+                    List<Channel> allChannels = getAllChannels();\n+                    \n                     if(ServerConstants.USE_THREAD_TRACKER) ThreadTracker.getInstance().cancelThreadTrackerTask();\n-\n-                    TimerManager.getInstance().purge();\n-                    TimerManager.getInstance().stop();\n-\n-                    for (Channel ch : getAllChannels()) {\n+                    \n+                    for (Channel ch : allChannels) {\n                         while (!ch.finishedShutdown()) {\n                             try {\n                                 Thread.sleep(1000);\n@@ -1431,6 +1430,9 @@ public void run() {\n                     }\n                     \n                     resetServerWorlds();\n+                    \n+                    TimerManager.getInstance().purge();\n+                    TimerManager.getInstance().stop();\n \n                     System.out.println(\"Worlds + Channels are offline.\");\n                     acceptor.unbind();"}, {"sha": "dc916553c4a7613878461dc713a5d12b33ebee87", "filename": "src/net/server/audit/ThreadTracker.java", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/ThreadTracker.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/ThreadTracker.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/audit/ThreadTracker.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -142,12 +142,15 @@ public void accessThreadTracker(boolean update, boolean lock, MonitoredLockType\n                             if(tt.isEmpty()) {\n                                 toRemove.add(l);\n                             } else {\n-                                DateFormat dateFormat = new SimpleDateFormat(\"dd-MM-yyyy HH:mm:ss\");\n-                                dateFormat.setTimeZone(TimeZone.getTimeZone(ServerConstants.TIMEZONE));\n-                                String df = dateFormat.format(new Date());\n-\n-                                FilePrinter.print(FilePrinter.DEADLOCK_LOCKS, printThreadLog(tt, df));\n-                                FilePrinter.print(FilePrinter.DEADLOCK_STACK, printThreadStack(threads.get(l).getStackTrace(), df));\n+                                StackTraceElement[] ste = threads.get(l).getStackTrace();\n+                                if(ste.length > 0) {\n+                                    DateFormat dateFormat = new SimpleDateFormat(\"dd-MM-yyyy HH:mm:ss\");\n+                                    dateFormat.setTimeZone(TimeZone.getTimeZone(ServerConstants.TIMEZONE));\n+                                    String df = dateFormat.format(new Date());\n+                                    \n+                                    FilePrinter.print(FilePrinter.DEADLOCK_LOCKS, printThreadLog(tt, df));\n+                                    FilePrinter.print(FilePrinter.DEADLOCK_STACK, printThreadStack(ste, df));\n+                                }\n                             }\n                         }\n "}, {"sha": "ad26cea77b4c1fe42e4c0c9d54258b1b6e8537d8", "filename": "src/net/server/audit/locks/MonitoredLockType.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/MonitoredLockType.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/MonitoredLockType.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/audit/locks/MonitoredLockType.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -87,6 +87,7 @@\n     MAP_OBJS,\n     MAP_FACTORY,\n     MAP_ITEM,\n+    MAP_LOOT,\n     MAP_BOUNDS,\n     MINIDUNGEON,\n     REACTOR,"}, {"sha": "b60599dd709b274f988ee58f81061a154a651ee3", "filename": "src/net/server/audit/locks/MonitoredReadLock.java", "status": "modified", "additions": 6, "deletions": 131, "changes": 137, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/MonitoredReadLock.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/MonitoredReadLock.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/audit/locks/MonitoredReadLock.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -1,6 +1,6 @@\n /*\n     This file is part of the HeavenMS MapleStory Server\n-    Copyleft (L) 2016 - 2018 RonanLana\n+    Copyleft 2016 - 2018 RonanLana\n \n     This program is free software: you can redistribute it and/or modify\n     it under the terms of the GNU Affero General Public License as\n@@ -19,143 +19,18 @@\n */\n package net.server.audit.locks;\n \n-import constants.ServerConstants;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.Date;\n-import java.util.TimeZone;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import java.util.concurrent.locks.Lock;\n-import java.util.concurrent.locks.ReentrantLock;\n-import java.util.concurrent.ScheduledFuture;\n-import server.TimerManager;\n-import net.server.Server;\n-import net.server.audit.ThreadTracker;\n-\n-import tools.FilePrinter;\n-\n /**\n  *\n  * @author RonanLana\n  */\n-public class MonitoredReadLock extends ReentrantReadWriteLock.ReadLock {\n-    private ScheduledFuture<?> timeoutSchedule = null;\n-    private StackTraceElement[] deadlockedState = null;\n-    private final MonitoredLockType id;\n-    private final int hashcode;\n-    private final Lock state = new ReentrantLock(true);\n-    private final AtomicInteger reentrantCount = new AtomicInteger(0);\n-    \n-    public MonitoredReadLock(MonitoredReentrantReadWriteLock lock) {\n-        super(lock);\n-        this.id = lock.id;\n-        hashcode = this.hashCode();\n-    }\n-    \n-    @Override\n-    public void lock() {\n-        if(ServerConstants.USE_THREAD_TRACKER) {\n-            if(deadlockedState != null) {\n-                DateFormat dateFormat = new SimpleDateFormat(\"dd-MM-yyyy HH:mm:ss\");\n-                dateFormat.setTimeZone(TimeZone.getTimeZone(ServerConstants.TIMEZONE));\n-\n-                //FilePrinter.printError(FilePrinter.DEADLOCK_ERROR, \"[CRITICAL] \" + dateFormat.format(new Date()) + \" Deadlock occurred when trying to use the '\" + id.name() + \"' lock resources:\\r\\n\" + printStackTrace(deadlockedState) + \"\\r\\n\\r\\n\");\n-                ThreadTracker.getInstance().accessThreadTracker(true, true, id, hashcode);\n-                deadlockedState = null;\n-            }\n-\n-            registerLocking();\n-        }\n-        \n-        super.lock();\n-    }\n-    \n-    @Override\n-    public void unlock() {\n-        if(ServerConstants.USE_THREAD_TRACKER) {\n-            unregisterLocking();\n-        }\n-        \n-        super.unlock();\n-    }\n-    \n-    @Override\n-    public boolean tryLock() {\n-        if(super.tryLock()) {\n-            if(ServerConstants.USE_THREAD_TRACKER) {\n-                if(deadlockedState != null) {\n-                    //FilePrinter.printError(FilePrinter.DEADLOCK_ERROR, \"Deadlock occurred when trying to use the '\" + id.name() + \"' lock resources:\\r\\n\" + printStackTrace(deadlockedState) + \"\\r\\n\\r\\n\");\n-                    ThreadTracker.getInstance().accessThreadTracker(true, true, id, hashcode);\n-                    deadlockedState = null;\n-                }\n-\n-                registerLocking();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n+public interface MonitoredReadLock {\n     \n-    private void registerLocking() {\n-        state.lock();\n-        try {\n-            ThreadTracker.getInstance().accessThreadTracker(false, true, id, hashcode);\n-        \n-            if(reentrantCount.incrementAndGet() == 1) {\n-                final Thread t = Thread.currentThread();\n-                timeoutSchedule = TimerManager.getInstance().schedule(new Runnable() {\n-                    @Override\n-                    public void run() {\n-                        issueDeadlock(t);\n-                    }\n-                }, ServerConstants.LOCK_MONITOR_TIME);\n-            }\n-        } finally {\n-            state.unlock();\n-        }\n-    }\n+    public void lock();\n     \n-    private void unregisterLocking() {\n-        state.lock();\n-        try {\n-            if(reentrantCount.decrementAndGet() == 0) {\n-                if(timeoutSchedule != null) {\n-                    timeoutSchedule.cancel(false);\n-                    timeoutSchedule = null;\n-                }\n-            }\n-            \n-            ThreadTracker.getInstance().accessThreadTracker(false, false, id, hashcode);\n-        } finally {\n-            state.unlock();\n-        }\n-    }\n+    public void unlock();\n     \n-    private void issueDeadlock(Thread t) {\n-        deadlockedState = t.getStackTrace();\n-        //super.unlock();\n-    }\n+    public boolean tryLock();\n     \n-    private static String printStackTrace(StackTraceElement[] list) {\n-        String s = \"\";\n-        for(int i = 0; i < list.length; i++) {\n-            s += (\"    \" + list[i].toString() + \"\\r\\n\");\n-        }\n-        \n-        return s;\n-    }\n+    public MonitoredReadLock dispose();\n     \n-    public void dispose() {\n-        state.lock();\n-        try {\n-            if(timeoutSchedule != null) {\n-                timeoutSchedule.cancel(false);\n-                timeoutSchedule = null;\n-            }\n-        } finally {\n-            state.unlock();\n-        }\n-    }\n }"}, {"sha": "ad8af31fe729120481a58af1c63fa4fddd18941b", "filename": "src/net/server/audit/locks/MonitoredReentrantLock.java", "status": "modified", "additions": 6, "deletions": 135, "changes": 141, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/MonitoredReentrantLock.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/MonitoredReentrantLock.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/audit/locks/MonitoredReentrantLock.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -1,6 +1,6 @@\n /*\n     This file is part of the HeavenMS MapleStory Server\n-    Copyleft (L) 2016 - 2018 RonanLana\n+    Copyleft 2016 - 2018 RonanLana\n \n     This program is free software: you can redistribute it and/or modify\n     it under the terms of the GNU Affero General Public License as\n@@ -19,147 +19,18 @@\n */\n package net.server.audit.locks;\n \n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.locks.Lock;\n-import java.util.concurrent.locks.ReentrantLock;\n-import java.util.concurrent.ScheduledFuture;\n-import constants.ServerConstants;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.Date;\n-import java.util.TimeZone;\n-import server.TimerManager;\n-import net.server.Server;\n-import net.server.audit.ThreadTracker;\n-import tools.FilePrinter;\n-\n /**\n  *\n  * @author RonanLana\n  */\n-public class MonitoredReentrantLock extends ReentrantLock {\n-    private ScheduledFuture<?> timeoutSchedule = null;\n-    private StackTraceElement[] deadlockedState = null;\n-    private final MonitoredLockType id;\n-    private final int hashcode;\n-    private final Lock state = new ReentrantLock(true);\n-    private final AtomicInteger reentrantCount = new AtomicInteger(0);\n-   \n-    public MonitoredReentrantLock(MonitoredLockType id) {\n-        super();\n-        this.id = id;\n-        hashcode = this.hashCode();\n-    }\n-            \n-    public MonitoredReentrantLock(MonitoredLockType id, boolean fair) {\n-        super(fair);\n-        this.id = id;\n-        hashcode = this.hashCode();\n-    }\n-    \n-    @Override\n-    public void lock() {\n-        if(ServerConstants.USE_THREAD_TRACKER) {\n-            if(deadlockedState != null) {\n-                DateFormat dateFormat = new SimpleDateFormat(\"dd-MM-yyyy HH:mm:ss\");\n-                dateFormat.setTimeZone(TimeZone.getTimeZone(ServerConstants.TIMEZONE));\n-\n-                //FilePrinter.printError(FilePrinter.DEADLOCK_ERROR, \"[CRITICAL] \" + dateFormat.format(new Date()) + \" Deadlock occurred when trying to use the '\" + id.name() + \"' lock resources:\\r\\n\" + printStackTrace(deadlockedState) + \"\\r\\n\\r\\n\");\n-                ThreadTracker.getInstance().accessThreadTracker(true, true, id, hashcode);\n-                deadlockedState = null;\n-            }\n-\n-            registerLocking();\n-        }\n-        \n-        super.lock();\n-    }\n-    \n-    @Override\n-    public void unlock() {\n-        if(ServerConstants.USE_THREAD_TRACKER) {\n-            unregisterLocking();\n-        }\n-        \n-        super.unlock();\n-    }\n-    \n-    @Override\n-    public boolean tryLock() {\n-        if(super.tryLock()) {\n-            if(ServerConstants.USE_THREAD_TRACKER) {\n-                if(deadlockedState != null) {\n-                    //FilePrinter.printError(FilePrinter.DEADLOCK_ERROR, \"Deadlock occurred when trying to use the '\" + id.name() + \"' lock resources:\\r\\n\" + printStackTrace(deadlockedState) + \"\\r\\n\\r\\n\");\n-                    ThreadTracker.getInstance().accessThreadTracker(true, true, id, hashcode);\n-                    deadlockedState = null;\n-                }\n-\n-                registerLocking();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n+public interface MonitoredReentrantLock {\n     \n-    private void registerLocking() {\n-        state.lock();\n-        try {\n-            ThreadTracker.getInstance().accessThreadTracker(false, true, id, hashcode);\n-        \n-            if(reentrantCount.incrementAndGet() == 1) {\n-                final Thread t = Thread.currentThread();\n-                timeoutSchedule = TimerManager.getInstance().schedule(new Runnable() {\n-                    @Override\n-                    public void run() {\n-                        issueDeadlock(t);\n-                    }\n-                }, ServerConstants.LOCK_MONITOR_TIME);\n-            }\n-        } finally {\n-            state.unlock();\n-        }\n-    }\n+    public void lock();\n     \n-    private void unregisterLocking() {\n-        state.lock();\n-        try {\n-            if(reentrantCount.decrementAndGet() == 0) {\n-                if(timeoutSchedule != null) {\n-                    timeoutSchedule.cancel(false);\n-                    timeoutSchedule = null;\n-                }\n-            }\n-            \n-            ThreadTracker.getInstance().accessThreadTracker(false, false, id, hashcode);\n-        } finally {\n-            state.unlock();\n-        }\n-    }\n+    public void unlock();\n     \n-    private void issueDeadlock(Thread t) {\n-        deadlockedState = t.getStackTrace();\n-        //super.unlock();\n-    }\n+    public boolean tryLock();\n     \n-    private static String printStackTrace(StackTraceElement[] list) {\n-        String s = \"\";\n-        for(int i = 0; i < list.length; i++) {\n-            s += (\"    \" + list[i].toString() + \"\\r\\n\");\n-        }\n-        \n-        return s;\n-    }\n+    public MonitoredReentrantLock dispose();\n     \n-    public void dispose() {\n-        state.lock();\n-        try {\n-            if(timeoutSchedule != null) {\n-                timeoutSchedule.cancel(false);\n-                timeoutSchedule = null;\n-            }\n-        } finally {\n-            state.unlock();\n-        }\n-    }\n }"}, {"sha": "bef3ef3ba63ccfd740b64234f3c8fb7f51a71fee", "filename": "src/net/server/audit/locks/MonitoredWriteLock.java", "status": "modified", "additions": 6, "deletions": 130, "changes": 136, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/MonitoredWriteLock.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/MonitoredWriteLock.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/audit/locks/MonitoredWriteLock.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -1,6 +1,6 @@\n /*\n     This file is part of the HeavenMS MapleStory Server\n-    Copyleft (L) 2016 - 2018 RonanLana\n+    Copyleft 2016 - 2018 RonanLana\n \n     This program is free software: you can redistribute it and/or modify\n     it under the terms of the GNU Affero General Public License as\n@@ -19,142 +19,18 @@\n */\n package net.server.audit.locks;\n \n-import constants.ServerConstants;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.Date;\n-import java.util.TimeZone;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import java.util.concurrent.locks.Lock;\n-import java.util.concurrent.locks.ReentrantLock;\n-import java.util.concurrent.ScheduledFuture;\n-import server.TimerManager;\n-import net.server.Server;\n-import net.server.audit.ThreadTracker;\n-import tools.FilePrinter;\n-\n /**\n  *\n  * @author RonanLana\n  */\n-public class MonitoredWriteLock extends ReentrantReadWriteLock.WriteLock {\n-    private ScheduledFuture<?> timeoutSchedule = null;\n-    private StackTraceElement[] deadlockedState = null;\n-    private final MonitoredLockType id;\n-    private final int hashcode;\n-    private final Lock state = new ReentrantLock(true);\n-    private final AtomicInteger reentrantCount = new AtomicInteger(0);\n-\n-    public MonitoredWriteLock(MonitoredReentrantReadWriteLock lock) {\n-        super(lock);\n-        this.id = lock.id;\n-        hashcode = this.hashCode();\n-    }\n-    \n-    @Override\n-    public void lock() {\n-        if(ServerConstants.USE_THREAD_TRACKER) {\n-            if(deadlockedState != null) {\n-                DateFormat dateFormat = new SimpleDateFormat(\"dd-MM-yyyy HH:mm:ss\");\n-                dateFormat.setTimeZone(TimeZone.getTimeZone(ServerConstants.TIMEZONE));\n-\n-                //FilePrinter.printError(FilePrinter.DEADLOCK_ERROR, \"[CRITICAL] \" + dateFormat.format(new Date()) + \" Deadlock occurred when trying to use the '\" + id.name() + \"' lock resources:\\r\\n\" + printStackTrace(deadlockedState) + \"\\r\\n\\r\\n\");\n-                ThreadTracker.getInstance().accessThreadTracker(true, true, id, hashcode);\n-                deadlockedState = null;\n-            }\n-\n-            registerLocking();\n-        }\n-        \n-        super.lock();\n-    }\n-    \n-    @Override\n-    public void unlock() {\n-        if(ServerConstants.USE_THREAD_TRACKER) {\n-            unregisterLocking();\n-        }\n-        \n-        super.unlock();\n-    }\n-    \n-    @Override\n-    public boolean tryLock() {\n-        if(super.tryLock()) {\n-            if(ServerConstants.USE_THREAD_TRACKER) {\n-                if(deadlockedState != null) {\n-                    //FilePrinter.printError(FilePrinter.DEADLOCK_ERROR, \"Deadlock occurred when trying to use the '\" + id.name() + \"' lock resources:\\r\\n\" + printStackTrace(deadlockedState) + \"\\r\\n\\r\\n\");\n-                    ThreadTracker.getInstance().accessThreadTracker(true, true, id, hashcode);\n-                    deadlockedState = null;\n-                }\n-\n-                registerLocking();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n+public interface MonitoredWriteLock {\n     \n-    private void registerLocking() {\n-        state.lock();\n-        try {\n-            ThreadTracker.getInstance().accessThreadTracker(false, true, id, hashcode);\n-        \n-            if(reentrantCount.incrementAndGet() == 1) {\n-                final Thread t = Thread.currentThread();\n-                timeoutSchedule = TimerManager.getInstance().schedule(new Runnable() {\n-                    @Override\n-                    public void run() {\n-                        issueDeadlock(t);\n-                    }\n-                }, ServerConstants.LOCK_MONITOR_TIME);\n-            }\n-        } finally {\n-            state.unlock();\n-        }\n-    }\n+    public void lock();\n     \n-    private void unregisterLocking() {\n-        state.lock();\n-        try {\n-            if(reentrantCount.decrementAndGet() == 0) {\n-                if(timeoutSchedule != null) {\n-                    timeoutSchedule.cancel(false);\n-                    timeoutSchedule = null;\n-                }\n-            }\n-            \n-            ThreadTracker.getInstance().accessThreadTracker(false, false, id, hashcode);\n-        } finally {\n-            state.unlock();\n-        }\n-    }\n+    public void unlock();\n     \n-    private void issueDeadlock(Thread t) {\n-        deadlockedState = t.getStackTrace();\n-        //super.unlock();\n-    }\n+    public boolean tryLock();\n     \n-    private static String printStackTrace(StackTraceElement[] list) {\n-        String s = \"\";\n-        for(int i = 0; i < list.length; i++) {\n-            s += (\"    \" + list[i].toString() + \"\\r\\n\");\n-        }\n-        \n-        return s;\n-    }\n+    public MonitoredWriteLock dispose();\n     \n-    public void dispose() {\n-        state.lock();\n-        try {\n-            if(timeoutSchedule != null) {\n-                timeoutSchedule.cancel(false);\n-                timeoutSchedule = null;\n-            }\n-        } finally {\n-            state.unlock();\n-        }\n-    }\n }"}, {"sha": "77f1723480c4b9a05699332dae53ab9ea9ecf4cc", "filename": "src/net/server/audit/locks/active/TrackerReadLock.java", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/active/TrackerReadLock.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/active/TrackerReadLock.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/audit/locks/active/TrackerReadLock.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -0,0 +1,169 @@\n+/*\n+    This file is part of the HeavenMS MapleStory Server\n+    Copyleft (L) 2016 - 2018 RonanLana\n+\n+    This program is free software: you can redistribute it and/or modify\n+    it under the terms of the GNU Affero General Public License as\n+    published by the Free Software Foundation version 3 as published by\n+    the Free Software Foundation. You may not use, modify or distribute\n+    this program under any other version of the GNU Affero General Public\n+    License.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU Affero General Public License for more details.\n+\n+    You should have received a copy of the GNU Affero General Public License\n+    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+*/\n+package net.server.audit.locks.active;\n+\n+import constants.ServerConstants;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.TimeZone;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.concurrent.ScheduledFuture;\n+import server.TimerManager;\n+\n+import net.server.audit.ThreadTracker;\n+import net.server.audit.locks.MonitoredLockType;\n+import net.server.audit.locks.MonitoredReadLock;\n+import net.server.audit.locks.MonitoredReentrantReadWriteLock;\n+import net.server.audit.locks.empty.EmptyReadLock;\n+\n+import tools.FilePrinter;\n+\n+/**\n+ *\n+ * @author RonanLana\n+ */\n+public class TrackerReadLock extends ReentrantReadWriteLock.ReadLock implements MonitoredReadLock {\n+    private ScheduledFuture<?> timeoutSchedule = null;\n+    private StackTraceElement[] deadlockedState = null;\n+    private final MonitoredLockType id;\n+    private final int hashcode;\n+    private final Lock state = new ReentrantLock(true);\n+    private final AtomicInteger reentrantCount = new AtomicInteger(0);\n+    \n+    public TrackerReadLock(MonitoredReentrantReadWriteLock lock) {\n+        super(lock);\n+        this.id = lock.id;\n+        hashcode = this.hashCode();\n+    }\n+    \n+    @Override\n+    public void lock() {\n+        if(ServerConstants.USE_THREAD_TRACKER) {\n+            if(deadlockedState != null) {\n+                DateFormat dateFormat = new SimpleDateFormat(\"dd-MM-yyyy HH:mm:ss\");\n+                dateFormat.setTimeZone(TimeZone.getTimeZone(ServerConstants.TIMEZONE));\n+\n+                //FilePrinter.printError(FilePrinter.DEADLOCK_ERROR, \"[CRITICAL] \" + dateFormat.format(new Date()) + \" Deadlock occurred when trying to use the '\" + id.name() + \"' lock resources:\\r\\n\" + printStackTrace(deadlockedState) + \"\\r\\n\\r\\n\");\n+                ThreadTracker.getInstance().accessThreadTracker(true, true, id, hashcode);\n+                deadlockedState = null;\n+            }\n+\n+            registerLocking();\n+        }\n+        \n+        super.lock();\n+    }\n+    \n+    @Override\n+    public void unlock() {\n+        if(ServerConstants.USE_THREAD_TRACKER) {\n+            unregisterLocking();\n+        }\n+        \n+        super.unlock();\n+    }\n+    \n+    @Override\n+    public boolean tryLock() {\n+        if(super.tryLock()) {\n+            if(ServerConstants.USE_THREAD_TRACKER) {\n+                if(deadlockedState != null) {\n+                    //FilePrinter.printError(FilePrinter.DEADLOCK_ERROR, \"Deadlock occurred when trying to use the '\" + id.name() + \"' lock resources:\\r\\n\" + printStackTrace(deadlockedState) + \"\\r\\n\\r\\n\");\n+                    ThreadTracker.getInstance().accessThreadTracker(true, true, id, hashcode);\n+                    deadlockedState = null;\n+                }\n+\n+                registerLocking();\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+    \n+    private void registerLocking() {\n+        state.lock();\n+        try {\n+            ThreadTracker.getInstance().accessThreadTracker(false, true, id, hashcode);\n+        \n+            if(reentrantCount.incrementAndGet() == 1) {\n+                final Thread t = Thread.currentThread();\n+                timeoutSchedule = TimerManager.getInstance().schedule(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        issueDeadlock(t);\n+                    }\n+                }, ServerConstants.LOCK_MONITOR_TIME);\n+            }\n+        } finally {\n+            state.unlock();\n+        }\n+    }\n+    \n+    private void unregisterLocking() {\n+        state.lock();\n+        try {\n+            if(reentrantCount.decrementAndGet() == 0) {\n+                if(timeoutSchedule != null) {\n+                    timeoutSchedule.cancel(false);\n+                    timeoutSchedule = null;\n+                }\n+            }\n+            \n+            ThreadTracker.getInstance().accessThreadTracker(false, false, id, hashcode);\n+        } finally {\n+            state.unlock();\n+        }\n+    }\n+    \n+    private void issueDeadlock(Thread t) {\n+        deadlockedState = t.getStackTrace();\n+        //super.unlock();\n+    }\n+    \n+    private static String printStackTrace(StackTraceElement[] list) {\n+        String s = \"\";\n+        for(int i = 0; i < list.length; i++) {\n+            s += (\"    \" + list[i].toString() + \"\\r\\n\");\n+        }\n+        \n+        return s;\n+    }\n+    \n+    @Override\n+    public MonitoredReadLock dispose() {\n+        state.lock();\n+        try {\n+            if(timeoutSchedule != null) {\n+                timeoutSchedule.cancel(false);\n+                timeoutSchedule = null;\n+            }\n+        } finally {\n+            state.unlock();\n+        }\n+        \n+        //unlock();\n+        return new EmptyReadLock();\n+    }\n+}"}, {"sha": "6ee53881c243c07852ac7e8a3aff3a76cc21058f", "filename": "src/net/server/audit/locks/active/TrackerReentrantLock.java", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/active/TrackerReentrantLock.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/active/TrackerReentrantLock.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/audit/locks/active/TrackerReentrantLock.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -0,0 +1,171 @@\n+/*\n+    This file is part of the HeavenMS MapleStory Server\n+    Copyleft (L) 2016 - 2018 RonanLana\n+\n+    This program is free software: you can redistribute it and/or modify\n+    it under the terms of the GNU Affero General Public License as\n+    published by the Free Software Foundation version 3 as published by\n+    the Free Software Foundation. You may not use, modify or distribute\n+    this program under any other version of the GNU Affero General Public\n+    License.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU Affero General Public License for more details.\n+\n+    You should have received a copy of the GNU Affero General Public License\n+    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+*/\n+package net.server.audit.locks.active;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.concurrent.ScheduledFuture;\n+import constants.ServerConstants;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.TimeZone;\n+import server.TimerManager;\n+import net.server.audit.ThreadTracker;\n+import net.server.audit.locks.MonitoredLockType;\n+import net.server.audit.locks.MonitoredReentrantLock;\n+import net.server.audit.locks.empty.EmptyReentrantLock;\n+import tools.FilePrinter;\n+\n+/**\n+ *\n+ * @author RonanLana\n+ */\n+public class TrackerReentrantLock extends ReentrantLock implements MonitoredReentrantLock {\n+    private ScheduledFuture<?> timeoutSchedule = null;\n+    private StackTraceElement[] deadlockedState = null;\n+    private final MonitoredLockType id;\n+    private final int hashcode;\n+    private final Lock state = new ReentrantLock(true);\n+    private final AtomicInteger reentrantCount = new AtomicInteger(0);\n+   \n+    public TrackerReentrantLock(MonitoredLockType id) {\n+        super();\n+        this.id = id;\n+        hashcode = this.hashCode();\n+    }\n+            \n+    public TrackerReentrantLock(MonitoredLockType id, boolean fair) {\n+        super(fair);\n+        this.id = id;\n+        hashcode = this.hashCode();\n+    }\n+    \n+    @Override\n+    public void lock() {\n+        if(ServerConstants.USE_THREAD_TRACKER) {\n+            if(deadlockedState != null) {\n+                DateFormat dateFormat = new SimpleDateFormat(\"dd-MM-yyyy HH:mm:ss\");\n+                dateFormat.setTimeZone(TimeZone.getTimeZone(ServerConstants.TIMEZONE));\n+\n+                //FilePrinter.printError(FilePrinter.DEADLOCK_ERROR, \"[CRITICAL] \" + dateFormat.format(new Date()) + \" Deadlock occurred when trying to use the '\" + id.name() + \"' lock resources:\\r\\n\" + printStackTrace(deadlockedState) + \"\\r\\n\\r\\n\");\n+                ThreadTracker.getInstance().accessThreadTracker(true, true, id, hashcode);\n+                deadlockedState = null;\n+            }\n+\n+            registerLocking();\n+        }\n+        \n+        super.lock();\n+    }\n+    \n+    @Override\n+    public void unlock() {\n+        if(ServerConstants.USE_THREAD_TRACKER) {\n+            unregisterLocking();\n+        }\n+        \n+        super.unlock();\n+    }\n+    \n+    @Override\n+    public boolean tryLock() {\n+        if(super.tryLock()) {\n+            if(ServerConstants.USE_THREAD_TRACKER) {\n+                if(deadlockedState != null) {\n+                    //FilePrinter.printError(FilePrinter.DEADLOCK_ERROR, \"Deadlock occurred when trying to use the '\" + id.name() + \"' lock resources:\\r\\n\" + printStackTrace(deadlockedState) + \"\\r\\n\\r\\n\");\n+                    ThreadTracker.getInstance().accessThreadTracker(true, true, id, hashcode);\n+                    deadlockedState = null;\n+                }\n+\n+                registerLocking();\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+    \n+    private void registerLocking() {\n+        state.lock();\n+        try {\n+            ThreadTracker.getInstance().accessThreadTracker(false, true, id, hashcode);\n+        \n+            if(reentrantCount.incrementAndGet() == 1) {\n+                final Thread t = Thread.currentThread();\n+                timeoutSchedule = TimerManager.getInstance().schedule(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        issueDeadlock(t);\n+                    }\n+                }, ServerConstants.LOCK_MONITOR_TIME);\n+            }\n+        } finally {\n+            state.unlock();\n+        }\n+    }\n+    \n+    private void unregisterLocking() {\n+        state.lock();\n+        try {\n+            if(reentrantCount.decrementAndGet() == 0) {\n+                if(timeoutSchedule != null) {\n+                    timeoutSchedule.cancel(false);\n+                    timeoutSchedule = null;\n+                }\n+            }\n+            \n+            ThreadTracker.getInstance().accessThreadTracker(false, false, id, hashcode);\n+        } finally {\n+            state.unlock();\n+        }\n+    }\n+    \n+    private void issueDeadlock(Thread t) {\n+        deadlockedState = t.getStackTrace();\n+        //super.unlock();\n+    }\n+    \n+    private static String printStackTrace(StackTraceElement[] list) {\n+        String s = \"\";\n+        for(int i = 0; i < list.length; i++) {\n+            s += (\"    \" + list[i].toString() + \"\\r\\n\");\n+        }\n+        \n+        return s;\n+    }\n+    \n+    @Override\n+    public MonitoredReentrantLock dispose() {\n+        state.lock();\n+        try {\n+            if(timeoutSchedule != null) {\n+                timeoutSchedule.cancel(false);\n+                timeoutSchedule = null;\n+            }\n+        } finally {\n+            state.unlock();\n+        }\n+        \n+        //unlock();\n+        return new EmptyReentrantLock();\n+    }\n+}"}, {"sha": "8262a6d3ff4fc5e3386a1fa56647376dc985c902", "filename": "src/net/server/audit/locks/active/TrackerWriteLock.java", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/active/TrackerWriteLock.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/active/TrackerWriteLock.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/audit/locks/active/TrackerWriteLock.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -0,0 +1,167 @@\n+/*\n+    This file is part of the HeavenMS MapleStory Server\n+    Copyleft (L) 2016 - 2018 RonanLana\n+\n+    This program is free software: you can redistribute it and/or modify\n+    it under the terms of the GNU Affero General Public License as\n+    published by the Free Software Foundation version 3 as published by\n+    the Free Software Foundation. You may not use, modify or distribute\n+    this program under any other version of the GNU Affero General Public\n+    License.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU Affero General Public License for more details.\n+\n+    You should have received a copy of the GNU Affero General Public License\n+    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+*/\n+package net.server.audit.locks.active;\n+\n+import constants.ServerConstants;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.TimeZone;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.concurrent.ScheduledFuture;\n+import server.TimerManager;\n+import net.server.audit.ThreadTracker;\n+import net.server.audit.locks.MonitoredLockType;\n+import net.server.audit.locks.MonitoredReentrantReadWriteLock;\n+import net.server.audit.locks.MonitoredWriteLock;\n+import net.server.audit.locks.empty.EmptyWriteLock;\n+import tools.FilePrinter;\n+\n+/**\n+ *\n+ * @author RonanLana\n+ */\n+public class TrackerWriteLock extends ReentrantReadWriteLock.WriteLock implements MonitoredWriteLock {\n+    private ScheduledFuture<?> timeoutSchedule = null;\n+    private StackTraceElement[] deadlockedState = null;\n+    private final MonitoredLockType id;\n+    private final int hashcode;\n+    private final Lock state = new ReentrantLock(true);\n+    private final AtomicInteger reentrantCount = new AtomicInteger(0);\n+\n+    public TrackerWriteLock(MonitoredReentrantReadWriteLock lock) {\n+        super(lock);\n+        this.id = lock.id;\n+        hashcode = this.hashCode();\n+    }\n+    \n+    @Override\n+    public void lock() {\n+        if(ServerConstants.USE_THREAD_TRACKER) {\n+            if(deadlockedState != null) {\n+                DateFormat dateFormat = new SimpleDateFormat(\"dd-MM-yyyy HH:mm:ss\");\n+                dateFormat.setTimeZone(TimeZone.getTimeZone(ServerConstants.TIMEZONE));\n+\n+                //FilePrinter.printError(FilePrinter.DEADLOCK_ERROR, \"[CRITICAL] \" + dateFormat.format(new Date()) + \" Deadlock occurred when trying to use the '\" + id.name() + \"' lock resources:\\r\\n\" + printStackTrace(deadlockedState) + \"\\r\\n\\r\\n\");\n+                ThreadTracker.getInstance().accessThreadTracker(true, true, id, hashcode);\n+                deadlockedState = null;\n+            }\n+\n+            registerLocking();\n+        }\n+        \n+        super.lock();\n+    }\n+    \n+    @Override\n+    public void unlock() {\n+        if(ServerConstants.USE_THREAD_TRACKER) {\n+            unregisterLocking();\n+        }\n+        \n+        super.unlock();\n+    }\n+    \n+    @Override\n+    public boolean tryLock() {\n+        if(super.tryLock()) {\n+            if(ServerConstants.USE_THREAD_TRACKER) {\n+                if(deadlockedState != null) {\n+                    //FilePrinter.printError(FilePrinter.DEADLOCK_ERROR, \"Deadlock occurred when trying to use the '\" + id.name() + \"' lock resources:\\r\\n\" + printStackTrace(deadlockedState) + \"\\r\\n\\r\\n\");\n+                    ThreadTracker.getInstance().accessThreadTracker(true, true, id, hashcode);\n+                    deadlockedState = null;\n+                }\n+\n+                registerLocking();\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+    \n+    private void registerLocking() {\n+        state.lock();\n+        try {\n+            ThreadTracker.getInstance().accessThreadTracker(false, true, id, hashcode);\n+        \n+            if(reentrantCount.incrementAndGet() == 1) {\n+                final Thread t = Thread.currentThread();\n+                timeoutSchedule = TimerManager.getInstance().schedule(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        issueDeadlock(t);\n+                    }\n+                }, ServerConstants.LOCK_MONITOR_TIME);\n+            }\n+        } finally {\n+            state.unlock();\n+        }\n+    }\n+    \n+    private void unregisterLocking() {\n+        state.lock();\n+        try {\n+            if(reentrantCount.decrementAndGet() == 0) {\n+                if(timeoutSchedule != null) {\n+                    timeoutSchedule.cancel(false);\n+                    timeoutSchedule = null;\n+                }\n+            }\n+            \n+            ThreadTracker.getInstance().accessThreadTracker(false, false, id, hashcode);\n+        } finally {\n+            state.unlock();\n+        }\n+    }\n+    \n+    private void issueDeadlock(Thread t) {\n+        deadlockedState = t.getStackTrace();\n+        //super.unlock();\n+    }\n+    \n+    private static String printStackTrace(StackTraceElement[] list) {\n+        String s = \"\";\n+        for(int i = 0; i < list.length; i++) {\n+            s += (\"    \" + list[i].toString() + \"\\r\\n\");\n+        }\n+        \n+        return s;\n+    }\n+    \n+    @Override\n+    public MonitoredWriteLock dispose() {\n+        state.lock();\n+        try {\n+            if(timeoutSchedule != null) {\n+                timeoutSchedule.cancel(false);\n+                timeoutSchedule = null;\n+            }\n+        } finally {\n+            state.unlock();\n+        }\n+        \n+        //unlock();\n+        return new EmptyWriteLock();\n+    }\n+}"}, {"sha": "a94dfadb26d05dfd2682169ef80c55262c548a79", "filename": "src/net/server/audit/locks/empty/EmptyReadLock.java", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/empty/EmptyReadLock.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/empty/EmptyReadLock.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/audit/locks/empty/EmptyReadLock.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -0,0 +1,44 @@\n+/*\n+    This file is part of the HeavenMS MapleStory Server\n+    Copyleft 2016 - 2018 RonanLana\n+\n+    This program is free software: you can redistribute it and/or modify\n+    it under the terms of the GNU Affero General Public License as\n+    published by the Free Software Foundation version 3 as published by\n+    the Free Software Foundation. You may not use, modify or distribute\n+    this program under any other version of the GNU Affero General Public\n+    License.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU Affero General Public License for more details.\n+\n+    You should have received a copy of the GNU Affero General Public License\n+    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+*/\n+package net.server.audit.locks.empty;\n+\n+import net.server.audit.locks.MonitoredReadLock;\n+\n+/**\n+ *\n+ * @author RonanLana\n+ */\n+public class EmptyReadLock implements MonitoredReadLock {\n+    @Override\n+    public void lock() {}\n+    \n+    @Override\n+    public void unlock() {}\n+    \n+    @Override\n+    public boolean tryLock() {\n+        return false;\n+    }\n+    \n+    @Override\n+    public MonitoredReadLock dispose() {\n+        return null;\n+    }\n+}"}, {"sha": "1ccd1087951cebf13ebc1e57eb87e9911a973e98", "filename": "src/net/server/audit/locks/empty/EmptyReentrantLock.java", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/empty/EmptyReentrantLock.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/empty/EmptyReentrantLock.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/audit/locks/empty/EmptyReentrantLock.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -0,0 +1,44 @@\n+/*\n+    This file is part of the HeavenMS MapleStory Server\n+    Copyleft 2016 - 2018 RonanLana\n+\n+    This program is free software: you can redistribute it and/or modify\n+    it under the terms of the GNU Affero General Public License as\n+    published by the Free Software Foundation version 3 as published by\n+    the Free Software Foundation. You may not use, modify or distribute\n+    this program under any other version of the GNU Affero General Public\n+    License.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU Affero General Public License for more details.\n+\n+    You should have received a copy of the GNU Affero General Public License\n+    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+*/\n+package net.server.audit.locks.empty;\n+\n+import net.server.audit.locks.MonitoredReentrantLock;\n+\n+/**\n+ *\n+ * @author RonanLana\n+ */\n+public class EmptyReentrantLock implements MonitoredReentrantLock {\n+    @Override\n+    public void lock() {}\n+    \n+    @Override\n+    public void unlock() {}\n+    \n+    @Override\n+    public boolean tryLock() {\n+        return false;\n+    }\n+    \n+    @Override\n+    public MonitoredReentrantLock dispose() {\n+        return null;\n+    }\n+}"}, {"sha": "cff88f441b1314c529b02a6ea925a43295a8ce75", "filename": "src/net/server/audit/locks/empty/EmptyWriteLock.java", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/empty/EmptyWriteLock.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/empty/EmptyWriteLock.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/audit/locks/empty/EmptyWriteLock.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -0,0 +1,44 @@\n+/*\n+    This file is part of the HeavenMS MapleStory Server\n+    Copyleft 2016 - 2018 RonanLana\n+\n+    This program is free software: you can redistribute it and/or modify\n+    it under the terms of the GNU Affero General Public License as\n+    published by the Free Software Foundation version 3 as published by\n+    the Free Software Foundation. You may not use, modify or distribute\n+    this program under any other version of the GNU Affero General Public\n+    License.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU Affero General Public License for more details.\n+\n+    You should have received a copy of the GNU Affero General Public License\n+    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+*/\n+package net.server.audit.locks.empty;\n+\n+import net.server.audit.locks.MonitoredWriteLock;\n+\n+/**\n+ *\n+ * @author RonanLana\n+ */\n+public class EmptyWriteLock implements MonitoredWriteLock {\n+    @Override\n+    public void lock() {}\n+    \n+    @Override\n+    public void unlock() {}\n+    \n+    @Override\n+    public boolean tryLock() {\n+        return false;\n+    }\n+    \n+    @Override\n+    public MonitoredWriteLock dispose() {\n+        return null;\n+    }\n+}"}, {"sha": "728e8fa94b6aa736e8bb58aaf177602760f7c348", "filename": "src/net/server/audit/locks/factory/MonitoredReadLockFactory.java", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/factory/MonitoredReadLockFactory.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/factory/MonitoredReadLockFactory.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/audit/locks/factory/MonitoredReadLockFactory.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -0,0 +1,33 @@\n+/*\n+    This file is part of the HeavenMS MapleStory Server\n+    Copyleft 2016 - 2018 RonanLana\n+\n+    This program is free software: you can redistribute it and/or modify\n+    it under the terms of the GNU Affero General Public License as\n+    published by the Free Software Foundation version 3 as published by\n+    the Free Software Foundation. You may not use, modify or distribute\n+    this program under any other version of the GNU Affero General Public\n+    License.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU Affero General Public License for more details.\n+\n+    You should have received a copy of the GNU Affero General Public License\n+    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+*/\n+package net.server.audit.locks.factory;\n+\n+import net.server.audit.locks.MonitoredReentrantReadWriteLock;\n+import net.server.audit.locks.active.TrackerReadLock;\n+\n+/**\n+ *\n+ * @author RonanLana\n+ */\n+public class MonitoredReadLockFactory {\n+    public static TrackerReadLock createLock(MonitoredReentrantReadWriteLock lock) {\n+        return new TrackerReadLock(lock);\n+    }\n+}"}, {"sha": "6275fa24ec18b8c3ddec24df80ccb1f895c089d3", "filename": "src/net/server/audit/locks/factory/MonitoredReentrantLockFactory.java", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/factory/MonitoredReentrantLockFactory.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/factory/MonitoredReentrantLockFactory.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/audit/locks/factory/MonitoredReentrantLockFactory.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -0,0 +1,37 @@\n+/*\n+    This file is part of the HeavenMS MapleStory Server\n+    Copyleft 2016 - 2018 RonanLana\n+\n+    This program is free software: you can redistribute it and/or modify\n+    it under the terms of the GNU Affero General Public License as\n+    published by the Free Software Foundation version 3 as published by\n+    the Free Software Foundation. You may not use, modify or distribute\n+    this program under any other version of the GNU Affero General Public\n+    License.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU Affero General Public License for more details.\n+\n+    You should have received a copy of the GNU Affero General Public License\n+    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+*/\n+package net.server.audit.locks.factory;\n+\n+import net.server.audit.locks.MonitoredLockType;\n+import net.server.audit.locks.active.TrackerReentrantLock;\n+\n+/**\n+ *\n+ * @author RonanLana\n+ */\n+public class MonitoredReentrantLockFactory {\n+    public static TrackerReentrantLock createLock(MonitoredLockType id) {\n+        return new TrackerReentrantLock(id);\n+    }\n+    \n+    public static TrackerReentrantLock createLock(MonitoredLockType id, boolean fair) {\n+        return new TrackerReentrantLock(id, fair);\n+    }\n+}"}, {"sha": "682983082d901dd0b43b3fd606b05224f664aeab", "filename": "src/net/server/audit/locks/factory/MonitoredWriteLockFactory.java", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/factory/MonitoredWriteLockFactory.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/audit/locks/factory/MonitoredWriteLockFactory.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/audit/locks/factory/MonitoredWriteLockFactory.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -0,0 +1,33 @@\n+/*\n+    This file is part of the HeavenMS MapleStory Server\n+    Copyleft 2016 - 2018 RonanLana\n+\n+    This program is free software: you can redistribute it and/or modify\n+    it under the terms of the GNU Affero General Public License as\n+    published by the Free Software Foundation version 3 as published by\n+    the Free Software Foundation. You may not use, modify or distribute\n+    this program under any other version of the GNU Affero General Public\n+    License.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU Affero General Public License for more details.\n+\n+    You should have received a copy of the GNU Affero General Public License\n+    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+*/\n+package net.server.audit.locks.factory;\n+\n+import net.server.audit.locks.MonitoredReentrantReadWriteLock;\n+import net.server.audit.locks.active.TrackerWriteLock;\n+\n+/**\n+ *\n+ * @author RonanLana\n+ */\n+public class MonitoredWriteLockFactory {\n+    public static TrackerWriteLock createLock(MonitoredReentrantReadWriteLock lock) {\n+        return new TrackerWriteLock(lock);\n+    }\n+}"}, {"sha": "7a51af868521f2639fa716f667f8e718ec8a5f3f", "filename": "src/net/server/channel/Channel.java", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/Channel.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/Channel.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/Channel.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -29,6 +29,7 @@\n import java.util.Iterator;\n import java.util.List;\n import java.util.Collections;\n+import java.util.HashSet;\n import java.util.Map;\n import java.util.Map.Entry;\n import java.util.Set;\n@@ -39,6 +40,7 @@\n import net.server.audit.locks.MonitoredLockType;\n import net.server.audit.locks.MonitoredReentrantLock;\n import net.server.audit.locks.MonitoredReentrantReadWriteLock;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n \n import net.MapleServerHandler;\n import net.mina.MapleCodecFactory;\n@@ -95,6 +97,7 @@\n     private OverallScheduler channelSchedulers[] = new OverallScheduler[4];\n     private Map<Integer, MapleHiredMerchant> hiredMerchants = new HashMap<>();\n     private final Map<Integer, Integer> storedVars = new HashMap<>();\n+    private Set<Integer> playersAway = new HashSet<>();\n     private List<MapleExpedition> expeditions = new ArrayList<>();\n     private List<MapleExpeditionType> expedType = new ArrayList<>();\n     private MapleEvent event;\n@@ -128,7 +131,7 @@\n     \n     private MonitoredReentrantLock faceLock[] = new MonitoredReentrantLock[4];\n     \n-    private MonitoredReentrantLock lock = new MonitoredReentrantLock(MonitoredLockType.CHANNEL, true);\n+    private MonitoredReentrantLock lock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.CHANNEL, true);\n     \n     public Channel(final int world, final int channel, long startTime) {\n         this.world = world;\n@@ -165,7 +168,7 @@ public Channel(final int world, final int channel, long startTime) {\n             }\n             \n             for(int i = 0; i < 4; i++) {\n-                faceLock[i] = new MonitoredReentrantLock(MonitoredLockType.CHANNEL_FACEEXPRS, true);\n+                faceLock[i] = MonitoredReentrantLockFactory.createLock(MonitoredLockType.CHANNEL_FACEEXPRS, true);\n                 \n                 mobStatusSchedulers[i] = new MobStatusScheduler();\n                 mobAnimationSchedulers[i] = new MobAnimationScheduler();\n@@ -208,6 +211,7 @@ public final void shutdown() {\n             eventSM = null;\n             \n             closeChannelSchedules();\n+            players = null;\n             \n             acceptor.unbind();\n             \n@@ -263,10 +267,10 @@ private void closeChannelSchedules() {\n                 channelSchedulers[i] = null;\n             }\n             \n-            faceLock[i].dispose();\n+            faceLock[i] = faceLock[i].dispose();\n         }\n         \n-        lock.dispose();\n+        lock = lock.dispose();\n     }\n     \n     private void closeAllMerchants() {\n@@ -291,7 +295,7 @@ public MapleMapFactory getMapFactory() {\n     public int getWorld() {\n         return world;\n     }\n-\n+    \n     public void addPlayer(MapleCharacter chr) {\n         players.addPlayer(chr);\n         chr.announce(MaplePacketCreator.serverMessage(serverMessage));\n@@ -355,6 +359,18 @@ public void broadcastGMPacket(final byte[] data) {\n         }\n         return partym;\n     }\n+    \n+    public void insertPlayerAway(int chrId) {   // either they in CS or MTS\n+        playersAway.add(chrId);\n+    }\n+    \n+    public void removePlayerAway(int chrId) {\n+        playersAway.remove(chrId);\n+    }\n+    \n+    public boolean canUninstall() {\n+        return players.getSize() == 0 && playersAway.isEmpty();\n+    }\n         \n     public class respawnMaps implements Runnable {\n "}, {"sha": "3ab45935e14a3ae2c18ba90df5a77c9c95b19357", "filename": "src/net/server/channel/handlers/AbstractDealDamageHandler.java", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/handlers/AbstractDealDamageHandler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/handlers/AbstractDealDamageHandler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/handlers/AbstractDealDamageHandler.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -152,26 +152,27 @@ protected synchronized void applyAttack(AttackInfo attack, final MapleCharacter\n                     AutobanFactory.MPCON.addPoint(player.getAutobanManager(), \"Skill: \" + attack.skill + \"; Player MP: \" + player.getMp() + \"; MP Needed: \" + attackEffect.getMpCon());\n                 }\n \n+                int mobCount = attackEffect.getMobCount();\n                 if (attack.skill != Cleric.HEAL) {\n                     if (player.isAlive()) {\n-                        if(attack.skill == NightWalker.POISON_BOMB) // Poison Bomb\n+                        if(attack.skill == NightWalker.POISON_BOMB) {// Poison Bomb\n                             attackEffect.applyTo(player, new Point(attack.position.x, attack.position.y));\n-                        else if(attack.skill != Aran.BODY_PRESSURE) // prevent BP refreshing\n+                        } else if(attack.skill != Aran.BODY_PRESSURE) {// prevent BP refreshing\n                             attackEffect.applyTo(player);\n+                            \n+                            if (attack.skill == DawnWarrior.FINAL_ATTACK || attack.skill == Page.FINAL_ATTACK_BW || attack.skill == Page.FINAL_ATTACK_SWORD || attack.skill == Fighter.FINAL_ATTACK_SWORD\n+                                    || attack.skill == Fighter.FINAL_ATTACK_AXE || attack.skill == Spearman.FINAL_ATTACK_SPEAR || attack.skill == Spearman.FINAL_ATTACK_POLEARM || attack.skill == WindArcher.FINAL_ATTACK\n+                                    || attack.skill == DawnWarrior.FINAL_ATTACK || attack.skill == Hunter.FINAL_ATTACK || attack.skill == Crossbowman.FINAL_ATTACK) {\n+                                \n+                                mobCount = 15;//:(\n+                            } else if (attack.skill == Aran.HIDDEN_FULL_DOUBLE || attack.skill == Aran.HIDDEN_FULL_TRIPLE || attack.skill == Aran.HIDDEN_OVER_DOUBLE || attack.skill == Aran.HIDDEN_OVER_TRIPLE) {\n+                                mobCount = 12;\n+                            }\n+                        }\n                     } else {\n                         player.getClient().announce(MaplePacketCreator.enableActions());\n                     }\n                 }\n-                int mobCount = attackEffect.getMobCount();\n-                if (attack.skill == DawnWarrior.FINAL_ATTACK || attack.skill == Page.FINAL_ATTACK_BW || attack.skill == Page.FINAL_ATTACK_SWORD || attack.skill == Fighter.FINAL_ATTACK_SWORD\n-                        || attack.skill == Fighter.FINAL_ATTACK_AXE || attack.skill == Spearman.FINAL_ATTACK_SPEAR || attack.skill == Spearman.FINAL_ATTACK_POLEARM || attack.skill == WindArcher.FINAL_ATTACK\n-                        || attack.skill == DawnWarrior.FINAL_ATTACK || attack.skill == Hunter.FINAL_ATTACK || attack.skill == Crossbowman.FINAL_ATTACK) {\n-                    mobCount = 15;//:(\n-                }\n-                \n-                if (attack.skill == Aran.HIDDEN_FULL_DOUBLE || attack.skill == Aran.HIDDEN_FULL_TRIPLE || attack.skill == Aran.HIDDEN_OVER_DOUBLE || attack.skill == Aran.HIDDEN_OVER_TRIPLE) {\n-                \tmobCount = 12;\n-                }\n                 \n                 if (attack.numAttacked > mobCount) {\n                     AutobanFactory.MOB_COUNT.autoban(player, \"Skill: \" + attack.skill + \"; Count: \" + attack.numAttacked + \" Max: \" + attackEffect.getMobCount());"}, {"sha": "b9e2717c4fb8e81a1e319784974891a061304c5a", "filename": "src/net/server/channel/handlers/AutoAssignHandler.java", "status": "modified", "additions": 2, "deletions": 389, "changes": 391, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/handlers/AutoAssignHandler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/handlers/AutoAssignHandler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/handlers/AutoAssignHandler.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -21,22 +21,9 @@\n  */\n package net.server.channel.handlers;\n \n-import constants.ServerConstants;\n-import client.MapleCharacter;\n import client.MapleClient;\n-import client.MapleJob;\n-import client.MapleStat;\n-import client.autoban.AutobanFactory;\n-import client.inventory.Equip;\n-import client.inventory.Item;\n-import client.inventory.MapleInventory;\n-import client.inventory.MapleInventoryType;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.ArrayList;\n+import client.processor.AssignAPProcessor;\n import net.AbstractMaplePacketHandler;\n-import tools.MaplePacketCreator;\n import tools.data.input.SeekableLittleEndianAccessor;\n \n /**\n@@ -45,382 +32,8 @@\n  */\n public class AutoAssignHandler extends AbstractMaplePacketHandler {\n     \n-    private static int getNthHighestStat(List<Short> statList, short rank) {    // ranks from 0\n-        return(statList.size() <= rank ? 0 : statList.get(rank));\n-    }\n-    \n     @Override\n     public void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c) {\n-        MapleCharacter chr = c.getPlayer();\n-        if (chr.getRemainingAp() < 1) return;\n-        \n-        int[] statGain = new int[4];\n-        int[] statEqpd = new int[4];\n-        statGain[0] = 0; statGain[1] = 0; statGain[2] = 0; statGain[3] = 0;\n-        \n-        slea.skip(8);\n-        \n-        if(ServerConstants.USE_SERVER_AUTOASSIGNER) {\n-            // --------- Ronan Lana's AUTOASSIGNER ---------\n-            // This method excels for assigning APs in such a way to cover all equipments AP requirements.\n-            byte opt = slea.readByte();     // useful for pirate autoassigning\n-            \n-            int str = 0, dex = 0, luk = 0, int_ = 0;\n-            List<Short> eqpStrList = new ArrayList<>();\n-            List<Short> eqpDexList = new ArrayList<>();\n-            List<Short> eqpLukList = new ArrayList<>();\n-            \n-            MapleInventory iv = chr.getInventory(MapleInventoryType.EQUIPPED);\n-            Collection<Item> equippedC = iv.list();\n-            Equip nEquip;\n-\n-            for (Item item : equippedC) {   //selecting the biggest AP value of each stat from each equipped item.\n-            \tnEquip = (Equip)item;\n-                if(nEquip.getStr() > 0) eqpStrList.add(nEquip.getStr());\n-                str += nEquip.getStr();\n-                \n-                if(nEquip.getDex() > 0) eqpDexList.add(nEquip.getDex());\n-                dex += nEquip.getDex();\n-                \n-                if(nEquip.getLuk() > 0) eqpLukList.add(nEquip.getLuk());\n-                luk += nEquip.getLuk();\n-                \n-                //if(nEquip.getInt() > 0) eqpIntList.add(nEquip.getInt()); //not needed...\n-                int_ += nEquip.getInt();\n-            }\n-            \n-            statEqpd[0] = str;\n-            statEqpd[1] = dex;\n-            statEqpd[2] = luk;\n-            statEqpd[3] = int_;\n-            \n-            Collections.sort(eqpStrList, Collections.reverseOrder());\n-            Collections.sort(eqpDexList, Collections.reverseOrder());\n-            Collections.sort(eqpLukList, Collections.reverseOrder());\n-            \n-            //Autoassigner looks up the 1st/2nd placed equips for their stats to calculate the optimal upgrade.\n-            int eqpStr = getNthHighestStat(eqpStrList, (short) 0) + getNthHighestStat(eqpStrList, (short) 1);\n-            int eqpDex = getNthHighestStat(eqpDexList, (short) 0) + getNthHighestStat(eqpDexList, (short) 1);\n-            int eqpLuk = getNthHighestStat(eqpLukList, (short) 0) + getNthHighestStat(eqpLukList, (short) 1);\n-\n-            //c.getPlayer().message(\"----------------------------------------\");\n-            //c.getPlayer().message(\"SDL: s\" + eqpStr + \" d\" + eqpDex + \" l\" + eqpLuk + \" BASE STATS --> STR: \" + chr.getStr() + \" DEX: \" + chr.getDex() + \" INT: \" + chr.getInt() + \" LUK: \" + chr.getLuk());\n-            //c.getPlayer().message(\"SUM EQUIP STATS -> STR: \" + str + \" DEX: \" + dex + \" LUK: \" + luk + \" INT: \" + int_);\n-            \n-            MapleJob stance = c.getPlayer().getJobStyle(opt);\n-            int prStat = 0, scStat = 0, trStat = 0, temp, tempAp = chr.getRemainingAp(), CAP;\n-            \n-            MapleStat primary, secondary, tertiary = MapleStat.LUK;\n-            switch(stance) {\n-                case MAGICIAN:\n-                    CAP = 165;\n-                    scStat = (chr.getLevel() + 3) - (chr.getLuk() + luk - eqpLuk);\n-                    if(scStat < 0) scStat = 0;\n-                    scStat = Math.min(scStat, tempAp);\n-                    \n-                    if(tempAp > scStat) tempAp -= scStat;\n-                    else tempAp = 0;\n-                    \n-                    prStat = tempAp;\n-                    int_ = prStat;\n-                    luk = scStat;\n-                    str = 0; dex = 0;\n-                    \n-                    if(luk + chr.getLuk() > CAP) {\n-                        temp = luk + chr.getLuk() - CAP;\n-                        luk -= temp;\n-                        int_ += temp;\n-                    }\n-                    \n-                    primary = MapleStat.INT;\n-                    secondary = MapleStat.LUK;\n-                    tertiary = MapleStat.DEX;\n-                    \n-                    break;\n-                \n-                case BOWMAN:\n-                    CAP = 125;\n-                    scStat = (chr.getLevel() + 5) - (chr.getStr() + str - eqpStr);\n-                    if(scStat < 0) scStat = 0;\n-                    scStat = Math.min(scStat, tempAp);\n-                    \n-                    if(tempAp > scStat) tempAp -= scStat;\n-                    else tempAp = 0;\n-                    \n-                    prStat = tempAp;\n-                    dex = prStat;\n-                    str = scStat;\n-                    int_ = 0; luk = 0;\n-                    \n-                    if(str + chr.getStr() > CAP) {\n-                        temp = str + chr.getStr() - CAP;\n-                        str -= temp;\n-                        dex += temp;\n-                    }\n-                    \n-                    primary = MapleStat.DEX;\n-                    secondary = MapleStat.STR;\n-                    \n-                    break;\n-                    \n-                case GUNSLINGER:\n-                case CROSSBOWMAN:\n-                    CAP = 120;\n-                    scStat = chr.getLevel() - (chr.getStr() + str - eqpStr);\n-                    if(scStat < 0) scStat = 0;\n-                    scStat = Math.min(scStat, tempAp);\n-                    \n-                    if(tempAp > scStat) tempAp -= scStat;\n-                    else tempAp = 0;\n-                    \n-                    prStat = tempAp;\n-                    dex = prStat;\n-                    str = scStat;\n-                    int_ = 0; luk = 0;\n-                    \n-                    if(str + chr.getStr() > CAP) {\n-                        temp = str + chr.getStr() - CAP;\n-                        str -= temp;\n-                        dex += temp;\n-                    }\n-                    \n-                    primary = MapleStat.DEX;\n-                    secondary = MapleStat.STR;\n-                    \n-                    break;\n-                    \n-                case THIEF:\n-                    CAP = 160;\n-                    \n-                    scStat = 0;\n-                    if(chr.getDex() < 80) {\n-                        scStat = (2 * chr.getLevel()) - (chr.getDex() + dex - eqpDex);\n-                        if(scStat < 0) scStat = 0;\n-                            \n-                        scStat = Math.min(80 - chr.getDex(), scStat);\n-                        scStat = Math.min(tempAp, scStat);\n-                        tempAp -= scStat;\n-                    }\n-                    \n-                    temp = (chr.getLevel() + 40) - Math.max(80, scStat + chr.getDex() + dex - eqpDex);\n-                    if(temp < 0) temp = 0;\n-                    temp = Math.min(tempAp, temp);\n-                    scStat += temp;\n-                    tempAp -= temp;\n-                    \n-                    // thieves will upgrade STR as well only if a level-based threshold is reached.\n-                    if(chr.getStr() >= Math.max(13, (int)(0.4 * chr.getLevel()))) {\n-                        if(chr.getStr() < 50) {\n-                            trStat = (chr.getLevel() - 10) - (chr.getStr() + str - eqpStr);\n-                            if(trStat < 0) trStat = 0;\n-\n-                            trStat = Math.min(50 - chr.getStr(), trStat);\n-                            trStat = Math.min(tempAp, trStat);\n-                            tempAp -= trStat;\n-                        }\n-                    \n-                        temp = (20 + (chr.getLevel() / 2)) - Math.max(50, trStat + chr.getStr() + str - eqpStr);\n-                        if(temp < 0) temp = 0;\n-                        temp = Math.min(tempAp, temp);\n-                        trStat += temp;\n-                        tempAp -= temp;\n-                    }\n-                    \n-                    prStat = tempAp;\n-                    luk = prStat;\n-                    dex = scStat;\n-                    str = trStat;\n-                    int_ = 0;\n-                    \n-                    if(dex + chr.getDex() > CAP) {\n-                        temp = dex + chr.getDex() - CAP;\n-                        dex -= temp;\n-                        luk += temp;\n-                    }\n-                    if(str + chr.getStr() > CAP) {\n-                        temp = str + chr.getStr() - CAP;\n-                        str -= temp;\n-                        luk += temp;\n-                    }\n-                    \n-                    primary = MapleStat.LUK;\n-                    secondary = MapleStat.DEX;\n-                    tertiary = MapleStat.STR;\n-                    \n-                    break;\n-                    \n-                case BRAWLER:\n-                    CAP = 120;\n-                    \n-                    scStat = chr.getLevel() - (chr.getDex() + dex - eqpDex);\n-                    if(scStat < 0) scStat = 0;\n-                    scStat = Math.min(scStat, tempAp);\n-                    \n-                    if(tempAp > scStat) tempAp -= scStat;\n-                    else tempAp = 0;\n-                    \n-                    prStat = tempAp;\n-                    str = prStat;\n-                    dex = scStat;\n-                    int_ = 0; luk = 0;\n-                    \n-                    if(dex + chr.getDex() > CAP) {\n-                        temp = dex + chr.getDex() - CAP;\n-                        dex -= temp;\n-                        str += temp;\n-                    }\n-                    \n-                    primary = MapleStat.STR;\n-                    secondary = MapleStat.DEX;\n-                    \n-                    break;\n-                    \n-                default:    //warrior, beginner, ...\n-                    CAP = 80;\n-                    \n-                    scStat = ((2 * chr.getLevel()) / 3) - (chr.getDex() + dex - eqpDex);\n-                    if(scStat < 0) scStat = 0;\n-                    scStat = Math.min(scStat, tempAp);\n-                    \n-                    if(tempAp > scStat) tempAp -= scStat;\n-                    else tempAp = 0;\n-                    \n-                    prStat = tempAp;\n-                    str = prStat;\n-                    dex = scStat;\n-                    int_ = 0; luk = 0;\n-                    \n-                    if(dex + chr.getDex() > CAP) {\n-                        temp = dex + chr.getDex() - CAP;\n-                        dex -= temp;\n-                        str += temp;\n-                    }\n-                    \n-                    primary = MapleStat.STR;\n-                    secondary = MapleStat.DEX;\n-            }\n-            \n-            //-------------------------------------------------------------------------------------\n-            \n-            int extras = 0;\n-            \n-            extras = gainStatByType(chr, primary, statGain, prStat + extras);\n-            extras = gainStatByType(chr, secondary, statGain, scStat + extras);\n-            extras = gainStatByType(chr, tertiary, statGain, trStat + extras);\n-                        \n-            if(extras > 0) {    //redistribute surplus in priority order\n-                extras = gainStatByType(chr, primary, statGain, extras);\n-                extras = gainStatByType(chr, secondary, statGain, extras);\n-                extras = gainStatByType(chr, tertiary, statGain, extras);\n-                gainStatByType(chr, getQuaternaryStat(stance), statGain, extras);\n-            }\n-            \n-            int remainingAp = (chr.getRemainingAp() - getAccumulatedStatGain(statGain));\n-            chr.setRemainingAp(remainingAp);\n-            chr.updateSingleStat(MapleStat.AVAILABLEAP, remainingAp);\n-            c.announce(MaplePacketCreator.enableActions());\n-            \n-            //----------------------------------------------------------------------------------------\n-            \n-            c.announce(MaplePacketCreator.serverNotice(1, \"Better AP applications detected:\\r\\nSTR: +\" + statGain[0] + \"\\r\\nDEX: +\" + statGain[1] + \"\\r\\nINT: +\" + statGain[3] + \"\\r\\nLUK: +\" + statGain[2]));\n-        } else {\n-            if(slea.available() < 16) {\n-                AutobanFactory.PACKET_EDIT.alert(chr, \"Didn't send full packet for Auto Assign.\");\n-                c.disconnect(false, false);\n-                return;\n-            }\n-\n-            MapleInventory iv = chr.getInventory(MapleInventoryType.EQUIPPED);\n-            Collection<Item> equippedC = iv.list();\n-            for (Item item : equippedC) {   //selecting the biggest AP value of each stat from each equipped item.\n-            \tEquip nEquip = (Equip)item;\n-                \n-                statEqpd[0] += nEquip.getStr();\n-                statEqpd[1] += nEquip.getDex();\n-                statEqpd[2] += nEquip.getLuk();\n-                statEqpd[3] += nEquip.getInt();\n-            }\n-            \n-            int total = 0;\n-            int extras = 0;\n-            for (int i = 0; i < 2; i++) {\n-                int type = slea.readInt();\n-                int tempVal = slea.readInt();\n-                if (tempVal < 0 || tempVal > c.getPlayer().getRemainingAp()) {\n-                    return;\n-                }\n-                total += tempVal;\n-                extras += gainStatByType(chr, MapleStat.getBy5ByteEncoding(type), statGain, tempVal);\n-            }\n-            int remainingAp = (chr.getRemainingAp() - total) + extras;\n-            chr.setRemainingAp(remainingAp);\n-            chr.updateSingleStat(MapleStat.AVAILABLEAP, remainingAp);\n-            c.announce(MaplePacketCreator.enableActions());\n-        }\n-    }\n-\n-    private int gainStatByType(MapleCharacter chr, MapleStat type, int[] statGain, int gain) {\n-        if(gain <= 0) return 0;\n-        \n-        int newVal = 0;\n-        if (type.equals(MapleStat.STR)) {\n-            newVal = chr.getStr() + gain;\n-            if (newVal > ServerConstants.MAX_AP) {\n-                statGain[0] += (gain - (newVal - ServerConstants.MAX_AP));\n-                chr.setStr(ServerConstants.MAX_AP);\n-            } else {\n-                statGain[0] += gain;\n-                chr.setStr(newVal);\n-            }\n-        } else if (type.equals(MapleStat.INT)) {\n-            newVal = chr.getInt() + gain;\n-            if (newVal > ServerConstants.MAX_AP) {\n-                statGain[3] += (gain - (newVal - ServerConstants.MAX_AP));\n-                chr.setInt(ServerConstants.MAX_AP);\n-            } else {\n-                statGain[3] += gain;\n-                chr.setInt(newVal);\n-            }\n-        } else if (type.equals(MapleStat.LUK)) {\n-            newVal = chr.getLuk() + gain;\n-            if (newVal > ServerConstants.MAX_AP) {\n-                statGain[2] += (gain - (newVal - ServerConstants.MAX_AP));\n-                chr.setLuk(ServerConstants.MAX_AP);\n-            } else {\n-                statGain[2] += gain;\n-                chr.setLuk(newVal);\n-            }\n-        } else if (type.equals(MapleStat.DEX)) {\n-            newVal = chr.getDex() + gain;\n-            if (newVal > ServerConstants.MAX_AP) {\n-                statGain[1] += (gain - (newVal - ServerConstants.MAX_AP));\n-                chr.setDex(ServerConstants.MAX_AP);\n-            } else {\n-                statGain[1] += gain;\n-                chr.setDex(newVal);\n-            }\n-        }\n-        \n-        if (newVal > ServerConstants.MAX_AP) {\n-            chr.updateSingleStat(type, ServerConstants.MAX_AP);\n-            return newVal - ServerConstants.MAX_AP;\n-        }\n-        chr.updateSingleStat(type, newVal);\n-        return 0;\n-    }\n-    \n-    private MapleStat getQuaternaryStat(MapleJob stance) {\n-        if(stance != MapleJob.MAGICIAN) return MapleStat.INT;\n-        return MapleStat.STR;\n-    }\n-    \n-    private int getAccumulatedStatGain(int[] statGain) {\n-        int acc = 0;\n-        \n-        for(byte i = 0; i < statGain.length; i++) {\n-            acc += statGain[i];\n-        }\n-        \n-        return acc;\n+        AssignAPProcessor.APAutoAssignAction(slea, c);\n     }\n }"}, {"sha": "0f343fe5d16ccc8b40eda8f1b81ba784c9a08dee", "filename": "src/net/server/channel/handlers/ChangeChannelHandler.java", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/handlers/ChangeChannelHandler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/handlers/ChangeChannelHandler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/handlers/ChangeChannelHandler.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -37,12 +37,13 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n         int channel = slea.readByte() + 1;\n         c.getPlayer().getAutobanManager().setTimestamp(6, slea.readInt(), 2);\n         if(c.getChannel() == channel) {\n-        \tAutobanFactory.GENERAL.alert(c.getPlayer(), \"CCing to same channel.\");\n-            c.disconnect(false, false);\n-            return;\n+                AutobanFactory.GENERAL.alert(c.getPlayer(), \"CCing to same channel.\");\n+                c.disconnect(false, false);\n+                return;\n         } else if (c.getPlayer().getCashShop().isOpened() || c.getPlayer().getMiniGame() != null || c.getPlayer().getPlayerShop() != null) {\n     \t\treturn;\n     \t}\n+        \n         c.changeChannel(channel);\n     }\n }\n\\ No newline at end of file"}, {"sha": "3831a15e5d01bd1a707515604236a36cd9e65f1a", "filename": "src/net/server/channel/handlers/DistributeAPHandler.java", "status": "modified", "additions": 4, "deletions": 305, "changes": 309, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/handlers/DistributeAPHandler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/handlers/DistributeAPHandler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/handlers/DistributeAPHandler.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -21,319 +21,18 @@\n */\n package net.server.channel.handlers;\n \n-import client.MapleCharacter;\n import client.MapleClient;\n-import client.MapleJob;\n-import client.MapleStat;\n-import client.Skill;\n-import client.SkillFactory;\n-import constants.ServerConstants;\n-import constants.skills.BlazeWizard;\n-import constants.skills.Brawler;\n-import constants.skills.DawnWarrior;\n-import constants.skills.Magician;\n-import constants.skills.Warrior;\n+import client.processor.AssignAPProcessor;\n import net.AbstractMaplePacketHandler;\n-import tools.MaplePacketCreator;\n-import tools.Randomizer;\n import tools.data.input.SeekableLittleEndianAccessor;\n \n public final class DistributeAPHandler extends AbstractMaplePacketHandler {\n-    private static final int max = 32767;\n-\n+    \n     @Override\n     public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c) {\n         slea.readInt();\n         int num = slea.readInt();\n-        if (c.getPlayer().getRemainingAp() > 0) {\n-            if (addStat(c, num, false)) {\n-                c.getPlayer().setRemainingAp(c.getPlayer().getRemainingAp() - 1);\n-                c.getPlayer().updateSingleStat(MapleStat.AVAILABLEAP, c.getPlayer().getRemainingAp());\n-            }\n-        }\n-        c.announce(MaplePacketCreator.enableActions());\n-    }\n-\n-    public static boolean addStat(MapleClient c, int apTo, boolean usedAPReset) {\n-        switch (apTo) {\n-            case 64: // Str\n-                if (c.getPlayer().getStr() >= max) {\n-                    return false;\n-                }\n-                c.getPlayer().addStat(1, 1);\n-                break;\n-            case 128: // Dex\n-                if (c.getPlayer().getDex() >= max) {\n-                    return false;\n-                }\n-                c.getPlayer().addStat(2, 1);\n-                break;\n-            case 256: // Int\n-                if (c.getPlayer().getInt() >= max) {\n-                    return false;\n-                }\n-                c.getPlayer().addStat(3, 1);\n-                break;\n-            case 512: // Luk\n-                if (c.getPlayer().getLuk() >= max) {\n-                    return false;\n-                }\n-                c.getPlayer().addStat(4, 1);\n-                break;\n-            case 2048: // HP\n-                addHP(c.getPlayer(), addHP(c, usedAPReset));\n-                break;\n-            case 8192: // MP\n-                addMP(c.getPlayer(), addMP(c, usedAPReset));\n-                break;\n-            default:\n-                c.announce(MaplePacketCreator.updatePlayerStats(MaplePacketCreator.EMPTY_STATUPDATE, true, c.getPlayer()));\n-                return false;\n-        }\n-        return true;\n-    }\n-\n-    private static int addHP(MapleClient c, boolean usedAPReset) {\n-        MapleCharacter player = c.getPlayer();\n-        MapleJob job = player.getJob();\n-        int MaxHP = player.getMaxHp();\n-        if (player.getHpMpApUsed() > 9999 || MaxHP >= 30000) {\n-            return MaxHP;\n-        }\n-        \n-        return MaxHP + calcHpChange(player, job, usedAPReset);\n-    }\n-    \n-    private static int calcHpChange(MapleCharacter player, MapleJob job, boolean usedAPReset) {\n-        int MaxHP = 0;\n-        \n-        if (job.isA(MapleJob.WARRIOR) || job.isA(MapleJob.DAWNWARRIOR1)) {\n-            if(!usedAPReset) {\n-                Skill increaseHP = SkillFactory.getSkill(job.isA(MapleJob.DAWNWARRIOR1) ? DawnWarrior.MAX_HP_INCREASE : Warrior.IMPROVED_MAXHP);\n-                int sLvl = player.getSkillLevel(increaseHP);\n-\n-                if(sLvl > 0)\n-                    MaxHP += increaseHP.getEffect(sLvl).getY();\n-            }\n-            \n-            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n-                if (usedAPReset) {\n-                    MaxHP += 20;\n-                } else {\n-                    MaxHP += Randomizer.rand(18, 22);\n-                }\n-            } else {\n-                MaxHP += 20;\n-            }\n-        } else if(job.isA(MapleJob.ARAN1)) {\n-            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n-                if (usedAPReset) {\n-                    MaxHP += 20;\n-                } else {\n-                    MaxHP += Randomizer.rand(26, 30);\n-                }\n-            } else {\n-                MaxHP += 28;\n-            }\n-        } else if (job.isA(MapleJob.MAGICIAN) || job.isA(MapleJob.BLAZEWIZARD1)) {\n-            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n-                if (usedAPReset) {\n-                    MaxHP += 6;\n-                } else {\n-                    MaxHP += Randomizer.rand(5, 9);\n-                }\n-            } else {\n-                MaxHP += 6;\n-            }\n-        } else if (job.isA(MapleJob.THIEF) || job.isA(MapleJob.NIGHTWALKER1)) {\n-            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n-                if (usedAPReset) {\n-                    MaxHP += 16;\n-                } else {\n-                    MaxHP += Randomizer.rand(14, 18);\n-                }\n-            } else {\n-                MaxHP += 16;\n-            }\n-        } else if(job.isA(MapleJob.BOWMAN) || job.isA(MapleJob.WINDARCHER1)) {\n-            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n-                if (usedAPReset) {\n-                    MaxHP += 16;\n-                } else {\n-                    MaxHP += Randomizer.rand(14, 18);\n-                }\n-            } else {\n-                MaxHP += 16;\n-            }\n-        } else if (job.isA(MapleJob.PIRATE) || job.isA(MapleJob.THUNDERBREAKER1)) {\n-            if(!usedAPReset) {\n-                Skill increaseHP = SkillFactory.getSkill(Brawler.IMPROVE_MAX_HP);\n-                int sLvl = player.getSkillLevel(increaseHP);\n-\n-                if(sLvl > 0)\n-                    MaxHP += increaseHP.getEffect(sLvl).getY();\n-            }\n-            \n-            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n-                if (usedAPReset) {\n-                    MaxHP += 18;\n-                } else {\n-                    MaxHP += Randomizer.rand(16, 20);\n-                }\n-            } else {\n-                MaxHP += 18;\n-            }\n-        } else if (usedAPReset) {\n-            MaxHP += 8;\n-        } else {\n-            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n-                MaxHP += Randomizer.rand(8, 12);\n-            } else {\n-                MaxHP += 10;\n-            }\n-        }\n-        \n-        return MaxHP;\n-    }\n-\n-    private static int addMP(MapleClient c, boolean usedAPReset) {\n-        MapleCharacter player = c.getPlayer();\n-        int MaxMP = player.getMaxMp();\n-        MapleJob job = player.getJob();\n-        if (player.getHpMpApUsed() > 9999 || player.getMaxMp() >= 30000) {\n-            return MaxMP;\n-        }\n-        \n-        return MaxMP + calcMpChange(player, job, usedAPReset);\n-    }\n-    \n-    private static int calcMpChange(MapleCharacter player, MapleJob job, boolean usedAPReset) {\n-        int MaxMP = 0;\n-        \n-        if (job.isA(MapleJob.WARRIOR) || job.isA(MapleJob.DAWNWARRIOR1) || job.isA(MapleJob.ARAN1)) {\n-            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n-                if(!usedAPReset) {\n-                    MaxMP += (Randomizer.rand(2, 4) + (player.getInt() / 10));\n-                } else {\n-                    MaxMP += 2;\n-                }\n-            } else {\n-                MaxMP += 3;\n-            }\n-        } else if (job.isA(MapleJob.MAGICIAN) || job.isA(MapleJob.BLAZEWIZARD1)) {\n-            if(!usedAPReset) {\n-                Skill increaseMP = SkillFactory.getSkill(job.isA(MapleJob.BLAZEWIZARD1) ? BlazeWizard.INCREASING_MAX_MP : Magician.IMPROVED_MAX_MP_INCREASE);\n-                int sLvl = player.getSkillLevel(increaseMP);\n-\n-                if(sLvl > 0)\n-                    MaxMP += increaseMP.getEffect(sLvl).getY();\n-            }\n-            \n-            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n-                if(!usedAPReset) {\n-                    MaxMP += (Randomizer.rand(12, 16) + (player.getInt() / 20));\n-                } else {\n-                    MaxMP += 18;\n-                }\n-            } else {\n-                MaxMP += 18;\n-            }\n-        } else if (job.isA(MapleJob.BOWMAN) || job.isA(MapleJob.WINDARCHER1)) {\n-            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n-                if(!usedAPReset) {\n-                    MaxMP += (Randomizer.rand(6, 8) + (player.getInt() / 10));\n-                } else {\n-                    MaxMP += 10;\n-                }\n-            } else {\n-                MaxMP += 10;\n-            }\n-        } else if(job.isA(MapleJob.THIEF) || job.isA(MapleJob.NIGHTWALKER1)) {\n-            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n-                if(!usedAPReset) {\n-                    MaxMP += (Randomizer.rand(6, 8) + (player.getInt() / 10));\n-                } else {\n-                    MaxMP += 10;\n-                }\n-            } else {\n-                MaxMP += 10;\n-            }\n-        } else if (job.isA(MapleJob.PIRATE) || job.isA(MapleJob.THUNDERBREAKER1)) {\n-            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n-                if(!usedAPReset) {\n-                    MaxMP += (Randomizer.rand(7, 9) + (player.getInt() / 10));\n-                } else {\n-                    MaxMP += 14;\n-                }\n-            } else {\n-                MaxMP += 14;\n-            }\n-        } else {\n-            if(ServerConstants.USE_RANDOMIZE_HPMP_GAIN) {\n-                if(!usedAPReset) {\n-                    MaxMP += (Randomizer.rand(4, 6) + (player.getInt() / 10));\n-                } else {\n-                    MaxMP += 6;\n-                }\n-            } else {\n-                MaxMP += 6;\n-            }\n-        }\n-        \n-        return MaxMP;\n-    }\n-\n-    private static void addHP(MapleCharacter player, int MaxHP) {\n-        MaxHP = Math.min(30000, MaxHP);\n-        player.setHpMpApUsed(player.getHpMpApUsed() + 1);\n-        player.setMaxHp(MaxHP);\n-        player.updateSingleStat(MapleStat.MAXHP, MaxHP);\n-    }\n-\n-    private static void addMP(MapleCharacter player, int MaxMP) {\n-        MaxMP = Math.min(30000, MaxMP);\n-        player.setHpMpApUsed(player.getHpMpApUsed() + 1);\n-        player.setMaxMp(MaxMP);\n-        player.updateSingleStat(MapleStat.MAXMP, MaxMP);\n-    }\n-    \n-    public static int takeHp(MapleCharacter player, MapleJob job) {\n-        int MaxHP = 0;\n-        \n-        if (job.isA(MapleJob.WARRIOR) || job.isA(MapleJob.DAWNWARRIOR1) || job.isA(MapleJob.ARAN1)) {\n-            MaxHP += 54;\n-        } else if (job.isA(MapleJob.MAGICIAN) || job.isA(MapleJob.BLAZEWIZARD1)) {\n-            MaxHP += 10;\n-        } else if (job.isA(MapleJob.THIEF) || job.isA(MapleJob.NIGHTWALKER1)) {\n-            MaxHP += 20;\n-        } else if(job.isA(MapleJob.BOWMAN) || job.isA(MapleJob.WINDARCHER1)) {\n-            MaxHP += 20;\n-        } else if (job.isA(MapleJob.PIRATE) || job.isA(MapleJob.THUNDERBREAKER1)) {\n-            MaxHP += 42;\n-        } else {\n-            MaxHP += 12;\n-        }\n-        \n-        return MaxHP;\n-    }\n-    \n-    public static int takeMp(MapleCharacter player, MapleJob job) {\n-        int MaxMP = 0;\n-        \n-        if (job.isA(MapleJob.WARRIOR) || job.isA(MapleJob.DAWNWARRIOR1) || job.isA(MapleJob.ARAN1)) {\n-            MaxMP += 4;\n-        } else if (job.isA(MapleJob.MAGICIAN) || job.isA(MapleJob.BLAZEWIZARD1)) {\n-            MaxMP += 31;\n-        } else if (job.isA(MapleJob.BOWMAN) || job.isA(MapleJob.WINDARCHER1)) {\n-            MaxMP += 12;\n-        } else if(job.isA(MapleJob.THIEF) || job.isA(MapleJob.NIGHTWALKER1)) {\n-            MaxMP += 12;\n-        } else if (job.isA(MapleJob.PIRATE) || job.isA(MapleJob.THUNDERBREAKER1)) {\n-            MaxMP += 16;\n-        } else {\n-            MaxMP += 8;\n-        }\n         \n-        return MaxMP;\n-    }\n+        AssignAPProcessor.APAssignAction(c, num);\n+    }    \n }"}, {"sha": "8e1e570c03a94de7664bbbb9b2e56f66bb5bf214", "filename": "src/net/server/channel/handlers/DistributeSPHandler.java", "status": "modified", "additions": 3, "deletions": 50, "changes": 53, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/handlers/DistributeSPHandler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/handlers/DistributeSPHandler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/handlers/DistributeSPHandler.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -21,64 +21,17 @@\n */\n package net.server.channel.handlers;\n \n+import client.MapleClient;\n+import client.processor.AssignSPProcessor;\n import net.AbstractMaplePacketHandler;\n-import tools.FilePrinter;\n-import tools.MaplePacketCreator;\n import tools.data.input.SeekableLittleEndianAccessor;\n-import client.MapleCharacter;\n-import client.MapleClient;\n-import client.MapleStat;\n-import client.Skill;\n-import client.SkillFactory;\n-import client.autoban.AutobanFactory;\n-import constants.GameConstants;\n-import constants.skills.Aran;\n \n public final class DistributeSPHandler extends AbstractMaplePacketHandler {\n     @Override\n     public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c) {\n         slea.readInt();\n         int skillid = slea.readInt();\n-        if (skillid == Aran.HIDDEN_FULL_DOUBLE || skillid == Aran.HIDDEN_FULL_TRIPLE || skillid == Aran.HIDDEN_OVER_DOUBLE || skillid == Aran.HIDDEN_OVER_TRIPLE) {\n-            c.getSession().write(MaplePacketCreator.enableActions());\n-            return;\n-        }\n         \n-        MapleCharacter player = c.getPlayer();\n-        int remainingSp = player.getRemainingSpBySkill(GameConstants.getSkillBook(skillid/10000));\n-        boolean isBeginnerSkill = false;\n-        if ((!GameConstants.isPqSkillMap(player.getMapId()) && GameConstants.isPqSkill(skillid)) || (!player.isGM() && GameConstants.isGMSkills(skillid)) || (!GameConstants.isInJobTree(skillid, player.getJob().getId()) && !player.isGM())) {\n-            AutobanFactory.PACKET_EDIT.alert(player, \"tried to packet edit in distributing sp.\");\n-            FilePrinter.printError(FilePrinter.EXPLOITS + c.getPlayer().getName() + \".txt\", c.getPlayer().getName() + \" tried to use skill \" + skillid + \" without it being in their job.\\r\\n\");\n-            c.disconnect(true, false);\n-            return;\n-        }\n-        if (skillid % 10000000 > 999 && skillid % 10000000 < 1003) {\n-            int total = 0;\n-            for (int i = 0; i < 3; i++) {\n-                total += player.getSkillLevel(SkillFactory.getSkill(player.getJobType() * 10000000 + 1000 + i));\n-            }\n-            remainingSp = Math.min((player.getLevel() - 1), 6) - total;\n-            isBeginnerSkill = true;\n-        }  \t\t\n-        Skill skill = SkillFactory.getSkill(skillid);\n-        int curLevel = player.getSkillLevel(skill);\n-        if ((remainingSp > 0 && curLevel + 1 <= (skill.isFourthJob() ? player.getMasterLevel(skill) : skill.getMaxLevel()))) {\n-            if (!isBeginnerSkill) {\n-                player.setRemainingSp(player.getRemainingSpBySkill(GameConstants.getSkillBook(skillid/10000)) - 1, GameConstants.getSkillBook(skillid/10000));\n-            }       \t\n-            player.updateSingleStat(MapleStat.AVAILABLESP, player.getRemainingSpBySkill(GameConstants.getSkillBook(skillid/10000)));\n-            if (skill.getId() == Aran.FULL_SWING) {\n-            \tplayer.changeSkillLevel(skill, (byte) (curLevel + 1), player.getMasterLevel(skill), player.getSkillExpiration(skill));\n-            \tplayer.changeSkillLevel(SkillFactory.getSkill(Aran.HIDDEN_FULL_DOUBLE), (byte) player.getSkillLevel(skill), player.getMasterLevel(skill),  player.getSkillExpiration(skill));\n-            \tplayer.changeSkillLevel(SkillFactory.getSkill(Aran.HIDDEN_FULL_TRIPLE), (byte) player.getSkillLevel(skill), player.getMasterLevel(skill),  player.getSkillExpiration(skill));            \n-            } else if (skill.getId() == Aran.OVER_SWING) {\n-            \tplayer.changeSkillLevel(skill, (byte) (curLevel + 1), player.getMasterLevel(skill), player.getSkillExpiration(skill));\n-            \tplayer.changeSkillLevel(SkillFactory.getSkill(Aran.HIDDEN_OVER_DOUBLE), (byte) player.getSkillLevel(skill), player.getMasterLevel(skill),  player.getSkillExpiration(skill));\n-            \tplayer.changeSkillLevel(SkillFactory.getSkill(Aran.HIDDEN_OVER_TRIPLE), (byte) player.getSkillLevel(skill), player.getMasterLevel(skill),  player.getSkillExpiration(skill));\n-            } else {\n-            \tplayer.changeSkillLevel(skill, (byte) (curLevel + 1), player.getMasterLevel(skill), player.getSkillExpiration(skill));\n-            }\n-        }\n+        AssignSPProcessor.SPAssignAction(c, skillid);\n     }\n }\n\\ No newline at end of file"}, {"sha": "4d6c044de8566a90789c3e8fb0129e58a186c9f6", "filename": "src/net/server/channel/handlers/EnterCashShopHandler.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/handlers/EnterCashShopHandler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/handlers/EnterCashShopHandler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/handlers/EnterCashShopHandler.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -60,7 +60,7 @@ public void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c) {\n             mc.unregisterChairBuff();\n             Server.getInstance().getPlayerBuffStorage().addBuffsToStorage(mc.getId(), mc.getAllBuffs());\n             Server.getInstance().getPlayerBuffStorage().addDiseasesToStorage(mc.getId(), mc.getAllDiseases());\n-            mc.setAwayFromWorld(true);\n+            mc.setAwayFromChannelWorld();\n             mc.notifyMapTransferToPartner(-1);\n             mc.cancelAllBuffs(true);\n             mc.cancelAllDebuffs();"}, {"sha": "c2833ba12d1005bb83d317730fef4486b5ab6dc3", "filename": "src/net/server/channel/handlers/EnterMTSHandler.java", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/handlers/EnterMTSHandler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/handlers/EnterMTSHandler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/handlers/EnterMTSHandler.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -83,7 +83,7 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n             chr.unregisterChairBuff();\n             Server.getInstance().getPlayerBuffStorage().addBuffsToStorage(chr.getId(), chr.getAllBuffs());\n             Server.getInstance().getPlayerBuffStorage().addDiseasesToStorage(chr.getId(), chr.getAllDiseases());\n-            chr.setAwayFromWorld(true);\n+            chr.setAwayFromChannelWorld();\n             chr.notifyMapTransferToPartner(-1);\n             chr.cancelAllBuffs(true);\n             chr.cancelAllDebuffs();\n@@ -96,6 +96,8 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n             chr.cancelQuestExpirationTask();\n \n             chr.saveCharToDB();\n+            \n+            c.getChannelServer().removePlayer(chr);\n             chr.getMap().removePlayer(c.getPlayer());\n             try {\n                 c.announce(MaplePacketCreator.openCashShop(c, true));"}, {"sha": "72d8ee7abf5b36a1cb315489019db1fd12fa431a", "filename": "src/net/server/channel/handlers/HealOvertimeHandler.java", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/handlers/HealOvertimeHandler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/handlers/HealOvertimeHandler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/handlers/HealOvertimeHandler.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -26,13 +26,16 @@\n import client.autoban.AutobanFactory;\n import client.autoban.AutobanManager;\n import net.AbstractMaplePacketHandler;\n+import server.maps.MapleMapFactory;\n import tools.data.input.SeekableLittleEndianAccessor;\n import tools.MaplePacketCreator;\n \n public final class HealOvertimeHandler extends AbstractMaplePacketHandler {\n     @Override\n     public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c) {\n         MapleCharacter chr = c.getPlayer();\n+        if(!chr.isLoggedinWorld()) return;\n+        \n         AutobanManager abm = chr.getAutobanManager();\n         int timestamp = slea.readInt();\n         abm.setTimestamp(0, timestamp, 3);\n@@ -41,8 +44,7 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n         if (healHP != 0) {\n             if ((abm.getLastSpam(0) + 1500) > timestamp) AutobanFactory.FAST_HP_HEALING.addPoint(abm, \"Fast hp healing\");\n             \n-            int abHeal = 140;\n-            if(chr.getMapId() == 105040401 || chr.getMapId() == 105040402 || chr.getMapId() == 809000101 || chr.getMapId() == 809000201) abHeal += 40; // Sleepywood sauna and showa spa...\n+            int abHeal = 120 + (int)(20 * MapleMapFactory.getMapRecoveryRate(chr.getMapId())); // Sleepywood sauna and showa spa...\n             if (healHP > abHeal) {\n                 AutobanFactory.HIGH_HP_HEALING.autoban(chr, \"Healing: \" + healHP + \"; Max is \" + abHeal + \".\");\n                 return;"}, {"sha": "0560264ec54bcc65ccf37ae2b72c21ea84278bef", "filename": "src/net/server/channel/handlers/PlayerLoggedinHandler.java", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/handlers/PlayerLoggedinHandler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/handlers/PlayerLoggedinHandler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/handlers/PlayerLoggedinHandler.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -42,6 +42,7 @@\n import tools.MaplePacketCreator;\n import tools.Pair;\n import tools.data.input.SeekableLittleEndianAccessor;\n+import client.BuddyList;\n import client.BuddylistEntry;\n import client.CharacterNameAndId;\n import client.MapleCharacter;\n@@ -101,7 +102,17 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n         \n         int state = c.getLoginState();\n         boolean allowLogin = true;\n+        \n         Channel cserv = c.getChannelServer();\n+        if(cserv == null) {\n+            c.setChannel(1);\n+            cserv = c.getChannelServer();\n+            \n+            if(cserv == null) {  // world server is out\n+                c.disconnect(true, false);\n+                return;\n+            }\n+        }\n \n         /*  is this check really necessary?\n         if (state == MapleClient.LOGIN_SERVER_TRANSITION || state == MapleClient.LOGIN_NOTLOGGEDIN) {\n@@ -126,7 +137,11 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n         }\n         c.updateLoginState(MapleClient.LOGIN_LOGGEDIN);\n \n+        World world = server.getWorld(c.getWorld());\n+        \n         cserv.addPlayer(player);\n+        world.addPlayer(player);\n+        player.setEnteredChannelWorld();\n         \n         List<PlayerBuffValueHolder> buffs = server.getPlayerBuffStorage().getBuffsFromStorage(cid);\n         if (buffs != null) {\n@@ -156,19 +171,16 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n         player.getMap().addPlayer(player);\n         player.visitMap(player.getMap());\n         \n-        World world = server.getWorld(c.getWorld());\n-        world.getPlayerStorage().addPlayer(player);\n-        \n-        player.setAwayFromWorld(false);\n-            \n-        int buddyIds[] = player.getBuddylist().getBuddyIds();\n+        BuddyList bl = player.getBuddylist();\n+        int buddyIds[] = bl.getBuddyIds();\n         world.loggedOn(player.getName(), player.getId(), c.getChannel(), buddyIds);\n-        for (CharacterIdChannelPair onlineBuddy : server.getWorld(c.getWorld()).multiBuddyFind(player.getId(), buddyIds)) {\n-            BuddylistEntry ble = player.getBuddylist().get(onlineBuddy.getCharacterId());\n+        for (CharacterIdChannelPair onlineBuddy : world.multiBuddyFind(player.getId(), buddyIds)) {\n+            BuddylistEntry ble = bl.get(onlineBuddy.getCharacterId());\n             ble.setChannel(onlineBuddy.getChannel());\n-            player.getBuddylist().put(ble);\n+            bl.put(ble);\n         }\n-        c.announce(MaplePacketCreator.updateBuddylist(player.getBuddylist().getBuddies()));\n+        c.announce(MaplePacketCreator.updateBuddylist(bl.getBuddies()));\n+        \n         c.announce(MaplePacketCreator.loadFamily(player));\n         if (player.getFamilyId() > 0) {\n             MapleFamily f = world.getFamily(player.getFamilyId());"}, {"sha": "d0f4e489bea4d150342c02954d4b132298592437", "filename": "src/net/server/channel/handlers/UseCashItemHandler.java", "status": "modified", "additions": 27, "deletions": 147, "changes": 174, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/handlers/UseCashItemHandler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/handlers/UseCashItemHandler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/handlers/UseCashItemHandler.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -23,8 +23,6 @@\n \n import client.MapleCharacter;\n import client.MapleClient;\n-import client.MapleJob;\n-import client.MapleStat;\n import client.Skill;\n import client.SkillFactory;\n import client.creator.veteran.*;\n@@ -36,6 +34,7 @@\n import client.inventory.ModifyInventory;\n import client.inventory.manipulator.MapleInventoryManipulator;\n import client.inventory.manipulator.MapleKarmaManipulator;\n+import client.processor.AssignAPProcessor;\n import constants.GameConstants;\n import constants.ItemConstants;\n import constants.ServerConstants;\n@@ -79,9 +78,9 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n         slea.readShort();\n         int itemId = slea.readInt();\n         int itemType = itemId / 10000;\n-        Item toUse = c.getPlayer().getInventory(MapleInventoryType.CASH).getItem(c.getPlayer().getInventory(MapleInventoryType.CASH).findById(itemId).getPosition());\n+        Item toUse = player.getInventory(MapleInventoryType.CASH).getItem(player.getInventory(MapleInventoryType.CASH).findById(itemId).getPosition());\n         String medal = \"\";\n-        Item medalItem = c.getPlayer().getInventory(MapleInventoryType.EQUIPPED).getItem((short) -49);\n+        Item medalItem = player.getInventory(MapleInventoryType.EQUIPPED).getItem((short) -49);\n         if (medalItem != null) {\n             medal = \"<\" + ii.getName(medalItem.getItemId()) + \"> \";\n         }\n@@ -100,7 +99,7 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n                 \tplayer.changeMap(c.getChannelServer().getMapFactory().getMap(mapId));\n                 } else {\n                     MapleInventoryManipulator.addById(c, itemId, (short) 1);\n-                    c.getPlayer().dropMessage(1, error1);\n+                    player.dropMessage(1, error1);\n                     c.announce(MaplePacketCreator.enableActions());\n                 }\n             } else {\n@@ -149,131 +148,12 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n                     player.changeSkillLevel(skillSPTo, (byte) (curLevel + 1), player.getMasterLevel(skillSPTo), -1);\n                 }\n             } else {\n-                List<Pair<MapleStat, Integer>> statupdate = new ArrayList<>(2);\n                 int APTo = slea.readInt();\n                 int APFrom = slea.readInt();\n-                switch (APFrom) {\n-                    case 64: // str\n-                        if (player.getStr() < 5) {\n-                            c.getPlayer().message(\"You don't have the minimum STR required to swap.\");\n-                            c.announce(MaplePacketCreator.enableActions());\n-                            return;\n-                        }\n-                        player.addStat(1, -1);\n-                        break;\n-                    case 128: // dex\n-                        if (player.getDex() < 5) {\n-                            c.getPlayer().message(\"You don't have the minimum DEX required to swap.\");\n-                            c.announce(MaplePacketCreator.enableActions());\n-                            return;\n-                        }\n-                        player.addStat(2, -1);\n-                        break;\n-                    case 256: // int\n-                        if (player.getInt() < 5) {\n-                            c.getPlayer().message(\"You don't have the minimum INT required to swap.\");\n-                            c.announce(MaplePacketCreator.enableActions());\n-                            return;\n-                        }\n-                        player.addStat(3, -1);\n-                        break;\n-                    case 512: // luk\n-                        if (player.getLuk() < 5) {\n-                            c.getPlayer().message(\"You don't have the minimum LUK required to swap.\");\n-                            c.announce(MaplePacketCreator.enableActions());\n-                            return;\n-                        }\n-                        player.addStat(4, -1);\n-                        break;\n-                    case 2048: // HP\n-                        if(ServerConstants.USE_ENFORCE_HPMP_SWAP) {\n-                            if (APTo != 8192) {\n-                                c.getPlayer().message(\"You can only swap HP ability points to MP.\");\n-                                c.announce(MaplePacketCreator.enableActions());\n-                                return;\n-                            }\n-                        }\n-                        if (player.getHpMpApUsed() < 1) {\n-                            c.getPlayer().message(\"You don't have enough HPMP stat points to spend on AP Reset.\");\n-                            c.announce(MaplePacketCreator.enableActions());\n-                            return;\n-                    \t}\n-                        \n-                        int hp = player.getMaxHp();\n-                        int level_ = player.getLevel();\n-                        \n-                        boolean canWash_ = true;\n-                        if (hp < level_ * 14 + 148) {\n-                            canWash_ = false;\n-                        }\n-                        \n-                        if (!canWash_) {\n-                            c.getPlayer().message(\"You don't have the minimum HP pool required to swap.\");\n-                            c.announce(MaplePacketCreator.enableActions());\n-                            return;\n-                        }\n-                        \n-                        player.setHpMpApUsed(player.getHpMpApUsed() - 1);\n-                        int hplose = -DistributeAPHandler.takeHp(player, player.getJob());\n-                        int nextHp = Math.max(1, player.getHp() + hplose), nextMaxHp = Math.max(50, player.getMaxHp() + hplose);\n-\n-                        player.setHp(nextHp);\n-                        player.setMaxHp(nextMaxHp);\n-                        statupdate.add(new Pair<>(MapleStat.HP, nextHp));\n-                        statupdate.add(new Pair<>(MapleStat.MAXHP, nextMaxHp));\n-                        \n-                        break;\n-                    case 8192: // MP\n-                        if(ServerConstants.USE_ENFORCE_HPMP_SWAP) {\n-                            if (APTo != 2048) {\n-                                c.getPlayer().message(\"You can only swap MP ability points to HP.\");\n-                                c.announce(MaplePacketCreator.enableActions());\n-                                return;\n-                            }\n-                        }\n-                        if (player.getHpMpApUsed() < 1) {\n-                            c.getPlayer().message(\"You don't have enough HPMP stat points to spend on AP Reset.\");\n-                            c.announce(MaplePacketCreator.enableActions());\n-                            return;\n-                    \t}\n-                        \n-                        int mp = player.getMaxMp();\n-                        int level = player.getLevel();\n-                        MapleJob job = player.getJob();\n-                        \n-                        boolean canWash = true;\n-                        if (job.isA(MapleJob.SPEARMAN) && mp < 4 * level + 156) {\n-                            canWash = false;\n-                        } else if (job.isA(MapleJob.FIGHTER) && mp < 4 * level + 56) {\n-                            canWash = false;\n-                        } else if (job.isA(MapleJob.THIEF) && job.getId() % 100 > 0 && mp < level * 14 - 4) {\n-                            canWash = false;\n-                        } else if (mp < level * 14 + 148) {\n-                            canWash = false;\n-                        }\n-                        \n-                        if (!canWash) {\n-                            c.getPlayer().message(\"You don't have the minimum MP pool required to swap.\");\n-                            c.announce(MaplePacketCreator.enableActions());\n-                            return;\n-                        }\n-                        \n-                        player.setHpMpApUsed(player.getHpMpApUsed() - 1);\n-                        int mplose = -DistributeAPHandler.takeMp(player, job);\n-                        int nextMp = Math.max(0, player.getMp() + mplose), nextMaxMp = Math.max(5, player.getMaxMp() + mplose);\n-\n-                        player.setMp(nextMp);\n-                        player.setMaxMp(nextMaxMp);\n-                        statupdate.add(new Pair<>(MapleStat.MP, nextMp));\n-                        statupdate.add(new Pair<>(MapleStat.MAXMP, nextMaxMp));\n-                        \n-                        break;\n-                    default:\n-                        c.announce(MaplePacketCreator.updatePlayerStats(MaplePacketCreator.EMPTY_STATUPDATE, true, c.getPlayer()));\n-                        return;\n+                \n+                if(!AssignAPProcessor.APResetAction(c, APFrom, APTo)) {\n+                    return;\n                 }\n-                DistributeAPHandler.addStat(c, APTo, true);\n-                c.announce(MaplePacketCreator.updatePlayerStats(statupdate, true, c.getPlayer()));\n             }\n             remove(c, itemId);\n         } else if (itemType == 506) {\n@@ -287,7 +167,7 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n                 eq.setOwner(player.getName());\n             } else if (itemId == 5060001 || itemId == 5061000 || itemId == 5061001 || itemId == 5061002 || itemId == 5061003) { // Sealing lock\n                 MapleInventoryType type = MapleInventoryType.getByType((byte) slea.readInt());\n-                eq = c.getPlayer().getInventory(type).getItem((short) slea.readInt());\n+                eq = player.getInventory(type).getItem((short) slea.readInt());\n                 if (eq == null) { //Check if the type is EQUIPMENT?\n                     return;\n                 }\n@@ -317,7 +197,7 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n             } else if (itemId == 5060002) { // Incubator\n                 byte inventory2 = (byte) slea.readInt();\n                 short slot2 = (short) slea.readInt();\n-                Item item2 = c.getPlayer().getInventory(MapleInventoryType.getByType(inventory2)).getItem(slot2);\n+                Item item2 = player.getInventory(MapleInventoryType.getByType(inventory2)).getItem(slot2);\n                 if (item2 == null) // hacking\n                 {\n                     return;\n@@ -388,11 +268,11 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n                     \n                     break;\n                 case 6: //item megaphone\n-                    String msg = medal + c.getPlayer().getName() + \" : \" + slea.readMapleAsciiString();\n+                    String msg = medal + player.getName() + \" : \" + slea.readMapleAsciiString();\n                     whisper = slea.readByte() == 1;\n                     Item item = null;\n                     if (slea.readByte() == 1) { //item\n-                        item = c.getPlayer().getInventory(MapleInventoryType.getByType((byte) slea.readInt())).getItem((short) slea.readInt());\n+                        item = player.getInventory(MapleInventoryType.getByType((byte) slea.readInt())).getItem((short) slea.readInt());\n                         if (item == null) //hack\n                         {\n                             return;\n@@ -412,18 +292,18 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n                     }\n                     String[] msg2 = new String[lines];\n                     for (int i = 0; i < lines; i++) {\n-                        msg2[i] = medal + c.getPlayer().getName() + \" : \" + slea.readMapleAsciiString();\n+                        msg2[i] = medal + player.getName() + \" : \" + slea.readMapleAsciiString();\n                     }\n                     whisper = slea.readByte() == 1;\n                     Server.getInstance().broadcastMessage(c.getWorld(), MaplePacketCreator.getMultiMegaphone(msg2, c.getChannel(), whisper));\n                     break;\n             }\n             remove(c, itemId);\n         } else if (itemType == 508) {   // graduation banner, thanks to tmskdl12\n-            MapleKite kite = new MapleKite(c.getPlayer(), slea.readMapleAsciiString(), itemId);\n+            MapleKite kite = new MapleKite(player, slea.readMapleAsciiString(), itemId);\n             \n-            if (!GameConstants.isFreeMarketRoom(c.getPlayer().getMapId())) {\n-                c.getPlayer().getMap().spawnKite(kite);\n+            if (!GameConstants.isFreeMarketRoom(player.getMapId())) {\n+                player.getMap().spawnKite(kite);\n                 remove(c, itemId);\n             } else {\n                 c.announce(MaplePacketCreator.sendCannotSpawnKite());\n@@ -442,11 +322,11 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n             remove(c, itemId);\n         } else if (itemType == 512) {\n             if (ii.getStateChangeItem(itemId) != 0) {\n-                for (MapleCharacter mChar : c.getPlayer().getMap().getCharacters()) {\n+                for (MapleCharacter mChar : player.getMap().getCharacters()) {\n                     ii.getItemEffect(ii.getStateChangeItem(itemId)).applyTo(mChar);\n                 }\n             }\n-            player.getMap().startMapEffect(ii.getMsg(itemId).replaceFirst(\"%s\", c.getPlayer().getName()).replaceFirst(\"%s\", slea.readMapleAsciiString()), itemId);\n+            player.getMap().startMapEffect(ii.getMsg(itemId).replaceFirst(\"%s\", player.getName()).replaceFirst(\"%s\", slea.readMapleAsciiString()), itemId);\n             remove(c, itemId);\n         } else if (itemType == 517) {\n             MaplePet pet = player.getPet(0);\n@@ -512,7 +392,7 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n             }\n             \n             final int world = c.getWorld();\n-            Server.getInstance().broadcastMessage(world, MaplePacketCreator.getAvatarMega(c.getPlayer(), medal, c.getChannel(), itemId, strLines, (slea.readByte() != 0)));\n+            Server.getInstance().broadcastMessage(world, MaplePacketCreator.getAvatarMega(player, medal, c.getChannel(), itemId, strLines, (slea.readByte() != 0)));\n             TimerManager.getInstance().schedule(new Runnable() {\n             \t@Override\n             \tpublic void run() {\n@@ -585,20 +465,20 @@ public void run() {\n         } else if (itemType == 552) {\n             MapleInventoryType type = MapleInventoryType.getByType((byte) slea.readInt());\n             short slot = (short) slea.readInt();\n-            Item item = c.getPlayer().getInventory(type).getItem(slot);\n+            Item item = player.getInventory(type).getItem(slot);\n             if (item == null || item.getQuantity() <= 0 || MapleKarmaManipulator.hasKarmaFlag(item) || !ii.isKarmaAble(item.getItemId())) {\n                 c.announce(MaplePacketCreator.enableActions());\n                 return;\n             }\n             \n             if(MapleKarmaManipulator.hasUsedKarmaFlag(item)) {\n-                c.getPlayer().dropMessage(6, \"Scissors of Karma was already used on this item.\");\n+                player.dropMessage(6, \"Scissors of Karma was already used on this item.\");\n                 c.announce(MaplePacketCreator.enableActions());\n                 return;\n             }\n             \n             MapleKarmaManipulator.setKarmaFlag(item);\n-            c.getPlayer().forceUpdateItem(item);\n+            player.forceUpdateItem(item);\n             remove(c, itemId);\n             c.announce(MaplePacketCreator.enableActions());\n         } else if (itemType == 552) { //DS EGG THING\n@@ -607,8 +487,8 @@ public void run() {\n             slea.readInt();\n             int itemSlot = slea.readInt();\n             slea.readInt();\n-            final Equip equip = (Equip) c.getPlayer().getInventory(MapleInventoryType.EQUIP).getItem((short) itemSlot);\n-            if (equip.getVicious() == 2 || c.getPlayer().getInventory(MapleInventoryType.CASH).findById(5570000) == null) {\n+            final Equip equip = (Equip) player.getInventory(MapleInventoryType.EQUIP).getItem((short) itemSlot);\n+            if (equip.getVicious() == 2 || player.getInventory(MapleInventoryType.CASH).findById(5570000) == null) {\n                 return;\n             }\n             equip.setVicious(equip.getVicious() + 1);\n@@ -623,14 +503,14 @@ public void run() {\n             }\n             \n             final byte eSlot = (byte) slea.readInt();\n-            final Item eitem = c.getPlayer().getInventory(MapleInventoryType.EQUIP).getItem(eSlot);\n+            final Item eitem = player.getInventory(MapleInventoryType.EQUIP).getItem(eSlot);\n             \n             if (slea.readInt() != 2) {\n                 return;\n             }\n             \n             final byte uSlot = (byte) slea.readInt();\n-            final Item uitem = c.getPlayer().getInventory(MapleInventoryType.USE).getItem(uSlot);\n+            final Item uitem = player.getInventory(MapleInventoryType.USE).getItem(uSlot);\n             if (eitem == null || uitem == null) {\n                 return;\n             }\n@@ -644,12 +524,12 @@ public void run() {\n             //should have a check here against PE hacks\n             if(itemId / 1000000 != 5) itemId = 0;\n             \n-            c.getPlayer().toggleBlockCashShop();\n+            player.toggleBlockCashShop();\n             \n             final int curlevel = toScroll.getLevel();\n             c.getSession().write(MaplePacketCreator.sendVegaScroll(0x40));\n             \n-            final Equip scrolled = (Equip) ii.scrollEquipWithId(toScroll, uitem.getItemId(), false, itemId, c.getPlayer().isGM());\n+            final Equip scrolled = (Equip) ii.scrollEquipWithId(toScroll, uitem.getItemId(), false, itemId, player.isGM());\n             c.getSession().write(MaplePacketCreator.sendVegaScroll(scrolled.getLevel() > curlevel ? 0x41 : 0x43));\n             //opcodes 0x42, 0x44: \"this item cannot be used\"; 0x39, 0x45: crashes\n             "}, {"sha": "a95abdf053063ecd618864f38c5506744a4eb06b", "filename": "src/net/server/channel/worker/BaseScheduler.java", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/worker/BaseScheduler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/worker/BaseScheduler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/worker/BaseScheduler.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -27,11 +27,11 @@\n import java.util.Map;\n import java.util.Map.Entry;\n import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.locks.Lock;\n \n import net.server.Server;\n import net.server.audit.locks.MonitoredLockType;\n import net.server.audit.locks.MonitoredReentrantLock;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n import server.TimerManager;\n import tools.Pair;\n \n@@ -42,7 +42,7 @@\n public abstract class BaseScheduler {\n     private int idleProcs = 0;\n     private List<SchedulerListener> listeners = new LinkedList<>();\n-    private final List<Lock> externalLocks = new LinkedList<>();\n+    private final List<MonitoredReentrantLock> externalLocks = new LinkedList<>();\n     private Map<Object, Pair<Runnable, Long>> registeredEntries = new HashMap<>();\n     \n     private ScheduledFuture<?> schedulerTask = null;\n@@ -55,14 +55,14 @@ public void run() {\n                                     };\n     \n     protected BaseScheduler(MonitoredLockType lockType) {\n-        schedulerLock = new MonitoredReentrantLock(lockType, true);\n+        schedulerLock = MonitoredReentrantLockFactory.createLock(lockType, true);\n     }\n     \n     // NOTE: practice EXTREME caution when adding external locks to the scheduler system, if you don't know what you're doing DON'T USE THIS.\n-    protected BaseScheduler(MonitoredLockType lockType, List<Lock> extLocks) {\n-        schedulerLock = new MonitoredReentrantLock(lockType, true);\n+    protected BaseScheduler(MonitoredLockType lockType, List<MonitoredReentrantLock> extLocks) {\n+        schedulerLock = MonitoredReentrantLockFactory.createLock(lockType, true);\n         \n-        for(Lock lock : extLocks) {\n+        for(MonitoredReentrantLock lock : extLocks) {\n             externalLocks.add(lock);\n         }\n     }\n@@ -73,7 +73,7 @@ protected void addListener(SchedulerListener listener) {\n     \n     private void lockScheduler() {\n         if(!externalLocks.isEmpty()) {\n-            for(Lock l : externalLocks) {\n+            for(MonitoredReentrantLock l : externalLocks) {\n                 l.lock();\n             }\n         }\n@@ -83,7 +83,7 @@ private void lockScheduler() {\n     \n     private void unlockScheduler() {\n         if(!externalLocks.isEmpty()) {\n-            for(Lock l : externalLocks) {\n+            for(MonitoredReentrantLock l : externalLocks) {\n                 l.unlock();\n             }\n         }\n@@ -190,12 +190,12 @@ public void dispose() {\n             }\n             \n             listeners.clear();\n-            externalLocks.clear();\n             registeredEntries.clear();\n         } finally {\n             unlockScheduler();\n+            externalLocks.clear();\n         }\n         \n-        schedulerLock.dispose();\n+        schedulerLock = schedulerLock.dispose();\n     }\n }"}, {"sha": "2cff3228b0dc0a7c10d3fc1b39ca78f6dc1a4f3b", "filename": "src/net/server/channel/worker/FaceExpressionScheduler.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/worker/FaceExpressionScheduler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/worker/FaceExpressionScheduler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/worker/FaceExpressionScheduler.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -20,15 +20,15 @@\n package net.server.channel.worker;\n \n import java.util.Collections;\n-import java.util.concurrent.locks.Lock;\n import net.server.audit.locks.MonitoredLockType;\n+import net.server.audit.locks.MonitoredReentrantLock;\n \n /**\n  *\n  * @author Ronan\n  */\n public class FaceExpressionScheduler extends BaseScheduler {\n-    public FaceExpressionScheduler(final Lock channelFaceLock) {\n+    public FaceExpressionScheduler(final MonitoredReentrantLock channelFaceLock) {\n         super(MonitoredLockType.CHANNEL_FACESCHDL, Collections.singletonList(channelFaceLock));\n     }\n     "}, {"sha": "cead942343cb2ce692c568017a216d3b37f0a335", "filename": "src/net/server/channel/worker/MobAnimationScheduler.java", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/worker/MobAnimationScheduler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/worker/MobAnimationScheduler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/worker/MobAnimationScheduler.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -25,14 +25,15 @@\n import java.util.List;\n import java.util.Set;\n import net.server.audit.locks.MonitoredReentrantLock;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n \n /**\n  *\n  * @author Ronan\n  */\n public class MobAnimationScheduler extends BaseScheduler {\n     Set<Integer> onAnimationMobs = new HashSet<>(1000);\n-    private MonitoredReentrantLock animationLock = new MonitoredReentrantLock(MonitoredLockType.CHANNEL_MOBANIMAT, true);\n+    private MonitoredReentrantLock animationLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.CHANNEL_MOBANIMAT, true);\n     \n     private static Runnable r = new Runnable() {\n         @Override\n@@ -75,7 +76,7 @@ public boolean registerAnimationMode(Integer mobHash, long animationTime) {\n     \n     @Override\n     public void dispose() {\n-        animationLock.dispose();\n+        animationLock = animationLock.dispose();\n         super.dispose();\n     }\n }"}, {"sha": "702370ebb3a6a832391b9fe969bcd62b3f1e6f56", "filename": "src/net/server/channel/worker/MobStatusScheduler.java", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/worker/MobStatusScheduler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/channel/worker/MobStatusScheduler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/worker/MobStatusScheduler.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -27,14 +27,15 @@\n import java.util.Map;\n import net.server.audit.locks.MonitoredLockType;\n import net.server.audit.locks.MonitoredReentrantLock;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n \n /**\n  *\n  * @author Ronan\n  */\n public class MobStatusScheduler extends BaseScheduler {\n     private Map<MonsterStatusEffect, MobStatusOvertimeEntry> registeredMobStatusOvertime = new HashMap<>();\n-    private MonitoredReentrantLock overtimeStatusLock = new MonitoredReentrantLock(MonitoredLockType.CHANNEL_OVTSTATUS, true);\n+    private MonitoredReentrantLock overtimeStatusLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.CHANNEL_OVTSTATUS, true);\n     \n     private class MobStatusOvertimeEntry {\n         private int procCount;\n@@ -110,7 +111,7 @@ public void interruptMobStatus(MonsterStatusEffect mse) {\n     \n     @Override\n     public void dispose() {\n-        overtimeStatusLock.dispose();\n+        overtimeStatusLock = overtimeStatusLock.dispose();\n         super.dispose();\n     }\n }"}, {"sha": "f5039a0438c528362f8af6d2c47760bdfa97118f", "filename": "src/net/server/guild/MapleGuild.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/guild/MapleGuild.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/guild/MapleGuild.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/guild/MapleGuild.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -36,7 +36,7 @@\n import java.util.Set;\n \n import java.util.concurrent.locks.Lock;\n-import net.server.audit.locks.MonitoredReentrantLock;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n \n import net.server.Server;\n import net.server.channel.Channel;\n@@ -51,7 +51,7 @@\n     }\n     \n     private final List<MapleGuildCharacter> members;\n-    private final Lock membersLock = new MonitoredReentrantLock(MonitoredLockType.GUILD, true);\n+    private final Lock membersLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.GUILD, true);\n     \n     private String rankTitles[] = new String[5]; // 1 = master, 2 = jr, 5 = lowest member\n     private String name, notice;"}, {"sha": "ac93f1452239a4e085f2d865e75fb11e21d5dee1", "filename": "src/net/server/world/MapleParty.java", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/world/MapleParty.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/world/MapleParty.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/world/MapleParty.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -32,6 +32,7 @@\n import java.util.Comparator;\n import net.server.audit.locks.MonitoredReentrantLock;\n import net.server.audit.locks.MonitoredLockType;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n \n public class MapleParty {\n     private int id;\n@@ -43,7 +44,7 @@\n     private Map<Integer, Integer> histMembers = new HashMap<>();\n     private int nextEntry = 0;\n     \n-    private MonitoredReentrantLock lock = new MonitoredReentrantLock(MonitoredLockType.PARTY, true);\n+    private MonitoredReentrantLock lock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.PARTY, true);\n     \n     public MapleParty(int id, MaplePartyCharacter chrfor) {\n         this.leaderId = chrfor.getId();\n@@ -215,7 +216,7 @@ public void assignNewLeader(MapleClient c) {\n     }\n     \n     public void disposeLocks() {\n-        lock.dispose();\n+        lock = lock.dispose();\n     }\n     \n     @Override"}, {"sha": "8583bde94252ef563977dd22624d0aa19bcd6b8b", "filename": "src/net/server/world/World.java", "status": "modified", "additions": 48, "deletions": 24, "changes": 72, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/world/World.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/net/server/world/World.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/world/World.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -47,11 +47,13 @@\n import java.util.SortedMap;\n import java.util.TreeMap;\n import java.util.concurrent.atomic.AtomicInteger;\n-import net.server.audit.locks.MonitoredReentrantLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;\n+\n import java.util.Set;\n import java.util.HashSet;\n import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n import scripting.event.EventInstanceManager;\n import server.TimerManager;\n@@ -76,7 +78,9 @@\n import tools.MaplePacketCreator;\n import tools.Pair;\n import net.server.audit.locks.MonitoredLockType;\n+import net.server.audit.locks.MonitoredReentrantLock;\n import net.server.audit.locks.MonitoredReentrantReadWriteLock;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n \n /**\n  *\n@@ -99,11 +103,11 @@\n     private PlayerStorage players = new PlayerStorage();\n     \n     private final ReentrantReadWriteLock chnLock = new MonitoredReentrantReadWriteLock(MonitoredLockType.WORLD_CHANNELS, true);\n-    private final ReentrantReadWriteLock.ReadLock chnRLock = chnLock.readLock();\n-    private final ReentrantReadWriteLock.WriteLock chnWLock = chnLock.writeLock();\n+    private ReadLock chnRLock = chnLock.readLock();\n+    private WriteLock chnWLock = chnLock.writeLock();\n     \n     private Map<Integer, SortedMap<Integer, MapleCharacter>> accountChars = new HashMap<>();\n-    private MonitoredReentrantLock accountCharsLock = new MonitoredReentrantLock(MonitoredLockType.WORLD_CHARS, true);\n+    private MonitoredReentrantLock accountCharsLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.WORLD_CHARS, true);\n     \n     private Set<Integer> queuedGuilds = new HashSet<>();\n     private Map<Integer, Pair<Pair<Boolean, Boolean>, Pair<Integer, Integer>>> queuedMarriages = new HashMap<>();\n@@ -112,31 +116,31 @@\n     private Map<Integer, Integer> partyChars = new HashMap<>();\n     private Map<Integer, MapleParty> parties = new HashMap<>();\n     private AtomicInteger runningPartyId = new AtomicInteger();\n-    private MonitoredReentrantLock partyLock = new MonitoredReentrantLock(MonitoredLockType.WORLD_PARTY, true);\n+    private MonitoredReentrantLock partyLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.WORLD_PARTY, true);\n     \n     private Map<Integer, Integer> owlSearched = new LinkedHashMap<>();\n-    private MonitoredReentrantLock owlLock = new MonitoredReentrantLock(MonitoredLockType.WORLD_OWL);\n+    private MonitoredReentrantLock owlLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.WORLD_OWL);\n     \n-    private MonitoredReentrantLock activePetsLock = new MonitoredReentrantLock(MonitoredLockType.WORLD_PETS, true);\n+    private MonitoredReentrantLock activePetsLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.WORLD_PETS, true);\n     private Map<Integer, Byte> activePets = new LinkedHashMap<>();\n     private ScheduledFuture<?> petsSchedule;\n     private long petUpdate;\n     \n-    private MonitoredReentrantLock activeMountsLock = new MonitoredReentrantLock(MonitoredLockType.WORLD_MOUNTS, true);\n+    private MonitoredReentrantLock activeMountsLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.WORLD_MOUNTS, true);\n     private Map<Integer, Byte> activeMounts = new LinkedHashMap<>();\n     private ScheduledFuture<?> mountsSchedule;\n     private long mountUpdate;\n     \n-    private MonitoredReentrantLock activePlayerShopsLock = new MonitoredReentrantLock(MonitoredLockType.WORLD_PSHOPS, true);\n+    private MonitoredReentrantLock activePlayerShopsLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.WORLD_PSHOPS, true);\n     private Map<Integer, MaplePlayerShop> activePlayerShops = new LinkedHashMap<>();\n     \n-    private MonitoredReentrantLock activeMerchantsLock = new MonitoredReentrantLock(MonitoredLockType.WORLD_MERCHS, true);\n+    private MonitoredReentrantLock activeMerchantsLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.WORLD_MERCHS, true);\n     private Map<Integer, Pair<MapleHiredMerchant, Byte>> activeMerchants = new LinkedHashMap<>();\n     private long merchantUpdate;\n     \n     private Map<Runnable, Long> registeredTimedMapObjects = new LinkedHashMap<>();\n     private ScheduledFuture<?> timedMapObjectsSchedule;\n-    private MonitoredReentrantLock timedMapObjectLock = new MonitoredReentrantLock(MonitoredLockType.WORLD_MAPOBJS, true);\n+    private MonitoredReentrantLock timedMapObjectLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.WORLD_MAPOBJS, true);\n     \n     private ScheduledFuture<?> charactersSchedule;\n     private ScheduledFuture<?> marriagesSchedule;\n@@ -216,7 +220,7 @@ public int removeChannel() {\n             chnRLock.unlock();\n         }\n         \n-        if(ch == null || ch.getPlayerStorage().getSize() > 0) {\n+        if(ch == null || !ch.canUninstall()) {\n             return -1;\n         }\n         \n@@ -235,6 +239,18 @@ public int removeChannel() {\n         return ch.getId();\n     }\n \n+    public boolean canUninstall() {\n+        if(players.getSize() > 0) return false;\n+        \n+        for(Channel ch : this.getChannels()) {\n+            if(!ch.canUninstall()) {\n+                return false;\n+            }\n+        }\n+        \n+        return true;\n+    }\n+    \n     public void setFlag(byte b) {\n         this.flag = b;\n     }\n@@ -401,11 +417,17 @@ public PlayerStorage getPlayerStorage() {\n         return players;\n     }\n \n+    public void addPlayer(MapleCharacter chr) {\n+        players.addPlayer(chr);\n+    }\n+    \n     public void removePlayer(MapleCharacter chr) {\n-        if(!getChannel(chr.getClient().getChannel()).removePlayer(chr)) {\n-            if(!chr.getClient().getChannelServer().removePlayer(chr)) {\n+        Channel cserv = chr.getClient().getChannelServer();\n+        \n+        if(cserv != null) {\n+            if(!cserv.removePlayer(chr)) {\n                 // oy the player is not where it should be, find this mf\n-                \n+\n                 for(Channel ch : getChannels()) {\n                     if(ch.removePlayer(chr)) {\n                         break;\n@@ -1661,14 +1683,14 @@ private void disposeLocks() {\n             p.disposeLocks();\n         }\n         \n-        accountCharsLock.dispose();\n-        partyLock.dispose();\n-        owlLock.dispose();\n-        activePetsLock.dispose();\n-        activeMountsLock.dispose();\n-        activePlayerShopsLock.dispose();\n-        activeMerchantsLock.dispose();\n-        timedMapObjectLock.dispose();\n+        accountCharsLock = accountCharsLock.dispose();\n+        partyLock = partyLock.dispose();\n+        owlLock = owlLock.dispose();\n+        activePetsLock = activePetsLock.dispose();\n+        activeMountsLock = activeMountsLock.dispose();\n+        activePlayerShopsLock = activePlayerShopsLock.dispose();\n+        activeMerchantsLock = activeMerchantsLock.dispose();\n+        timedMapObjectLock = timedMapObjectLock.dispose();\n     }\n     \n     public final void shutdown() {\n@@ -1702,6 +1724,8 @@ public final void shutdown() {\n         }\n         \n         players.disconnectAll();\n+        players = null;\n+        \n         disposeLocks();\n     }\n }"}, {"sha": "4bde63d2432be1d3c1c216511b1f6239b3397ea0", "filename": "src/scripting/event/EventInstanceManager.java", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/scripting/event/EventInstanceManager.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/scripting/event/EventInstanceManager.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/scripting/event/EventInstanceManager.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -34,13 +34,11 @@\n import java.util.Set;\n import java.util.Iterator;\n import java.util.Properties;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;\n import javax.script.ScriptException;\n import net.server.audit.locks.MonitoredLockType;\n import net.server.audit.locks.MonitoredReentrantLock;\n import net.server.audit.locks.MonitoredReentrantReadWriteLock;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n import net.server.world.MapleParty;\n import net.server.world.MaplePartyCharacter;\n import provider.MapleDataProviderFactory;\n@@ -61,6 +59,9 @@\n import java.awt.Point;\n import java.sql.Connection;\n import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n import scripting.AbstractPlayerInteraction;\n@@ -89,11 +90,11 @@\n         private List<Integer> mapIds = new LinkedList<>();\n         \n         private final ReentrantReadWriteLock lock = new MonitoredReentrantReadWriteLock(MonitoredLockType.EIM, true);\n-        private final ReadLock rL = lock.readLock();\n-        private final WriteLock wL = lock.writeLock();\n+        private ReadLock rL = lock.readLock();\n+        private WriteLock wL = lock.writeLock();\n         \n-        private final MonitoredReentrantLock pL = new MonitoredReentrantLock(MonitoredLockType.EIM_PARTY, true);\n-        private final MonitoredReentrantLock sL = new MonitoredReentrantLock(MonitoredLockType.EIM_SCRIPT, true);\n+        private MonitoredReentrantLock pL = MonitoredReentrantLockFactory.createLock(MonitoredLockType.EIM_PARTY, true);\n+        private MonitoredReentrantLock sL = MonitoredReentrantLockFactory.createLock(MonitoredLockType.EIM_SCRIPT, true);\n         \n         private ScheduledFuture<?> event_schedule = null;\n         private boolean disposed = false;\n@@ -467,26 +468,26 @@ public void movePlayer(MapleCharacter chr) {\n \t\t}\n \t}\n         \n-        public void changedMap(MapleCharacter chr, int mapId) {     // optional\n+        public void changedMap(MapleCharacter chr, int mapId) {\n \t\ttry {\n                         sL.lock();\n                         try {\n                                 em.getIv().invokeFunction(\"changedMap\", this, chr, mapId);\n                         } finally {\n                                 sL.unlock();\n                         }\n-\t\t} catch (ScriptException | NoSuchMethodException ex) {}\n+\t\t} catch (ScriptException | NoSuchMethodException ex) {} // optional\n \t}\n         \n-        public void afterChangedMap(MapleCharacter chr, int mapId) {     // optional\n+        public void afterChangedMap(MapleCharacter chr, int mapId) {\n \t\ttry {\n                         sL.lock();\n                         try {\n                                 em.getIv().invokeFunction(\"afterChangedMap\", this, chr, mapId);\n                         } finally {\n                                 sL.unlock();\n                         }\n-\t\t} catch (ScriptException | NoSuchMethodException ex) {}\n+\t\t} catch (ScriptException | NoSuchMethodException ex) {} // optional\n \t}\n         \n         public void changedLeader(MapleCharacter ldr) {\n@@ -537,9 +538,7 @@ public void friendlyKilled(MapleMonster mob, boolean hasKiller) {\n                         } finally {\n                                 sL.unlock();\n                         }\n-                } catch (ScriptException | NoSuchMethodException ex) {\n-                        //optional\n-                }\n+                } catch (ScriptException | NoSuchMethodException ex) {} //optional\n \t}\n \n \tpublic void playerKilled(MapleCharacter chr) {\n@@ -563,9 +562,7 @@ public void reviveMonster(MapleMonster mob) {\n                         } finally {\n                                 sL.unlock();\n                         }\n-\t\t} catch (ScriptException | NoSuchMethodException ex) {\n-\t\t\tex.printStackTrace();\n-\t\t}\n+\t\t} catch (ScriptException | NoSuchMethodException ex) {} // optional\n \t}\n         \n \tpublic boolean revivePlayer(MapleCharacter chr) {\n@@ -637,7 +634,18 @@ public int getKillCount(MapleCharacter chr) {\n \t\treturn (kc == null) ? 0 : kc;\n \t}\n         \n-\tpublic synchronized void dispose() {\n+        public void dispose() {\n+                Thread t = new Thread( new Runnable() {\n+                        @Override\n+                        public void run() {\n+                                dispose(false);\n+                        }\n+                });\n+                \n+                t.start();\n+        }\n+        \n+        public synchronized void dispose(boolean shutdown) {\n                 if(disposed) return;\n                 \n                 disposed = true;\n@@ -688,8 +696,8 @@ public synchronized void dispose() {\n \t}\n         \n         private void disposeLocks() {\n-                pL.dispose();\n-                sL.dispose();\n+                pL = pL.dispose();\n+                sL = sL.dispose();\n         }\n \n \tpublic MapleMapFactory getMapFactory() {"}, {"sha": "efa760bea4947eaa558166ac8dfd4cc2f8834f77", "filename": "src/scripting/event/EventManager.java", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/scripting/event/EventManager.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/scripting/event/EventManager.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/scripting/event/EventManager.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -54,6 +54,7 @@\n import java.util.Queue;\n import net.server.audit.locks.MonitoredLockType;\n import net.server.audit.locks.MonitoredReentrantLock;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n \n /**\n  *\n@@ -75,8 +76,8 @@\n     private Integer readyId = 0;\n     private Properties props = new Properties();\n     private String name;\n-    private MonitoredReentrantLock lobbyLock = new MonitoredReentrantLock(MonitoredLockType.EM_LOBBY);\n-    private MonitoredReentrantLock queueLock = new MonitoredReentrantLock(MonitoredLockType.EM_QUEUE);\n+    private MonitoredReentrantLock lobbyLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.EM_LOBBY);\n+    private MonitoredReentrantLock queueLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.EM_QUEUE);\n \n     private static final int maxLobbys = 8;     // an event manager holds up to this amount of concurrent lobbys\n     \n@@ -102,7 +103,7 @@ public void cancel() {  // make sure to only call this when there are NO PLAYERS\n         \n         synchronized(instances) {\n             for(EventInstanceManager eim : instances.values()) {\n-                eim.dispose();\n+                eim.dispose(true);\n             }\n             instances.clear();\n         }\n@@ -117,7 +118,7 @@ public void cancel() {  // make sure to only call this when there are NO PLAYERS\n         }\n         \n         for(EventInstanceManager eim : readyEims) {\n-            eim.dispose();\n+            eim.dispose(true);\n         }\n         \n         props.clear();\n@@ -130,8 +131,8 @@ public void cancel() {  // make sure to only call this when there are NO PLAYERS\n     }\n     \n     private void disposeLocks() {\n-        lobbyLock.dispose();\n-        queueLock.dispose();\n+        lobbyLock = lobbyLock.dispose();\n+        queueLock = queueLock.dispose();\n     }\n     \n     private static List<Integer> convertToIntegerArray(List<Double> list) {"}, {"sha": "974be7c5935c30b7a6c43333c5efb27e70cab449", "filename": "src/scripting/event/worker/EventScriptScheduler.java", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/scripting/event/worker/EventScriptScheduler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/scripting/event/worker/EventScriptScheduler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/scripting/event/worker/EventScriptScheduler.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -30,6 +30,7 @@\n import net.server.Server;\n import net.server.audit.locks.MonitoredLockType;\n import net.server.audit.locks.MonitoredReentrantLock;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n \n /**\n  *\n@@ -50,7 +51,7 @@ public void run() {\n                                     };\n     \n     public EventScriptScheduler() {\n-        schedulerLock = new MonitoredReentrantLock(MonitoredLockType.EM_SCHDL, true);\n+        schedulerLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.EM_SCHDL, true);\n     }\n     \n     private void runBaseSchedule() {\n@@ -160,7 +161,7 @@ public void run() {\n                                 schedulerLock.unlock();\n                             }\n                             \n-                            schedulerLock.dispose();\n+                            schedulerLock = schedulerLock.dispose();\n                         }\n                     });\n         "}, {"sha": "de1e8a2ab8bb47794b8850f2ea21f455be87634c", "filename": "src/server/CashShop.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/server/CashShop.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/server/CashShop.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/CashShop.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -32,7 +32,7 @@\n import java.util.Map;\n import java.util.Map.Entry;\n import java.util.concurrent.locks.Lock;\n-import net.server.audit.locks.MonitoredReentrantLock;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n \n import provider.MapleData;\n import provider.MapleDataProvider;\n@@ -269,7 +269,7 @@ public static void reloadSpecialCashItems() {//Yay?\n     private List<Item> inventory = new ArrayList<>();\n     private List<Integer> wishList = new ArrayList<>();\n     private int notes = 0;\n-    private Lock lock = new MonitoredReentrantLock(MonitoredLockType.CASHSHOP);\n+    private Lock lock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.CASHSHOP);\n \n     public CashShop(int accountId, int characterId, int jobType) throws SQLException {\n         this.accountId = accountId;"}, {"sha": "18d8c0edbb516017b22e0f6a0deec12cca5ead52", "filename": "src/server/MapleStorage.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/server/MapleStorage.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/server/MapleStorage.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/MapleStorage.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -39,7 +39,7 @@\n import provider.MapleDataProvider;\n import provider.MapleDataProviderFactory;\n import provider.MapleDataTool;\n-import net.server.audit.locks.MonitoredReentrantLock;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n import tools.DatabaseConnection;\n import tools.MaplePacketCreator;\n import tools.Pair;\n@@ -59,7 +59,7 @@\n     private byte slots;\n     private Map<MapleInventoryType, List<Item>> typeItems = new HashMap<>();\n     private List<Item> items;\n-    private Lock lock = new MonitoredReentrantLock(MonitoredLockType.STORAGE, true);\n+    private Lock lock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.STORAGE, true);\n \n     private MapleStorage(int id, byte slots, int meso) {\n         this.id = id;"}, {"sha": "d6b01116290c9dfd9b3b7378d6797298cec2ddb6", "filename": "src/server/life/MapleMonster.java", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/server/life/MapleMonster.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/server/life/MapleMonster.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/life/MapleMonster.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -70,6 +70,7 @@\n import tools.Pair;\n import tools.Randomizer;\n import net.server.audit.locks.MonitoredLockType;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n \n public class MapleMonster extends AbstractLoadedMapleLife {\n     private ChangeableStats ostats = null;  //unused, v83 WZs offers no support for changeable stats.\n@@ -94,10 +95,10 @@\n     private int parentMobOid = 0;\n     private final HashMap<Integer, AtomicInteger> takenDamage = new HashMap<>();\n \n-    private MonitoredReentrantLock externalLock = new MonitoredReentrantLock(MonitoredLockType.MOB_EXT);\n-    private MonitoredReentrantLock monsterLock = new MonitoredReentrantLock(MonitoredLockType.MOB, true);\n-    private MonitoredReentrantLock statiLock = new MonitoredReentrantLock(MonitoredLockType.MOB_STATI);\n-    private MonitoredReentrantLock animationLock = new MonitoredReentrantLock(MonitoredLockType.MOB_ANI);\n+    private MonitoredReentrantLock externalLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.MOB_EXT);\n+    private MonitoredReentrantLock monsterLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.MOB, true);\n+    private MonitoredReentrantLock statiLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.MOB_STATI);\n+    private MonitoredReentrantLock animationLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.MOB_ANI);\n \n     public MapleMonster(int id, MapleMonsterStats stats) {\n         super(id);\n@@ -1477,9 +1478,9 @@ public final void changeDifficulty(final int difficulty, boolean pqMob) {\n     }\n     \n     public final void disposeLocks() {\n-        externalLock.dispose();\n-        monsterLock.dispose();\n-        statiLock.dispose();\n-        animationLock.dispose();\n+        externalLock = externalLock.dispose();\n+        monsterLock = monsterLock.dispose();\n+        statiLock = statiLock.dispose();\n+        animationLock = animationLock.dispose();\n     }\n }"}, {"sha": "7ba6fe6b9d1dd8a84fb615931ff0de8b2007c342", "filename": "src/server/maps/MapleGenericPortal.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/server/maps/MapleGenericPortal.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/server/maps/MapleGenericPortal.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/maps/MapleGenericPortal.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -26,9 +26,9 @@\n import scripting.portal.PortalScriptManager;\n import server.MaplePortal;\n import tools.MaplePacketCreator;\n-import java.util.concurrent.locks.Lock;\n import net.server.audit.locks.MonitoredLockType;\n import net.server.audit.locks.MonitoredReentrantLock;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n \n public class MapleGenericPortal implements MaplePortal {\n \n@@ -41,7 +41,7 @@\n     private int id;\n     private String scriptName;\n     private boolean portalState;\n-    private Lock scriptLock = null;\n+    private MonitoredReentrantLock scriptLock = null;\n     \n     public MapleGenericPortal(int type) {\n         this.type = type;\n@@ -118,7 +118,7 @@ public void setScriptName(String scriptName) {\n         \n         if(scriptName != null) {\n             if(scriptLock == null) {\n-                scriptLock = new MonitoredReentrantLock(MonitoredLockType.PORTAL, true);\n+                scriptLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.PORTAL, true);\n             }\n         } else {\n             scriptLock = null;"}, {"sha": "dd0819f966ba3b56d3d6279ac2c4f086c2bf9fcd", "filename": "src/server/maps/MapleHiredMerchant.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/server/maps/MapleHiredMerchant.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/server/maps/MapleHiredMerchant.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/maps/MapleHiredMerchant.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -40,7 +40,7 @@\n import java.util.List;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.locks.Lock;\n-import net.server.audit.locks.MonitoredReentrantLock;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n import net.server.Server;\n import server.MapleItemInformationProvider;\n import tools.DatabaseConnection;\n@@ -65,7 +65,7 @@\n     private List<SoldItem> sold = new LinkedList<>();\n     private AtomicBoolean open = new AtomicBoolean();\n     private MapleMap map;\n-    private Lock visitorLock = new MonitoredReentrantLock(MonitoredLockType.VISITOR_MERCH, true);\n+    private Lock visitorLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.VISITOR_MERCH, true);\n \n     public MapleHiredMerchant(final MapleCharacter owner, String desc, int itemId) {\n         this.setPosition(owner.getPosition());"}, {"sha": "6677269ee9c65878fc002882939abeae087e7adb", "filename": "src/server/maps/MapleMap.java", "status": "modified", "additions": 239, "deletions": 81, "changes": 320, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/server/maps/MapleMap.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/server/maps/MapleMap.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/maps/MapleMap.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -43,6 +43,7 @@\n import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.LinkedHashSet;\n+import java.util.HashSet;\n import java.util.Set;\n import java.util.LinkedList;\n import java.util.List;\n@@ -53,12 +54,12 @@\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.locks.Lock;\n-import net.server.audit.locks.MonitoredLockType;\n-import net.server.audit.locks.MonitoredReentrantLock;\n-import net.server.audit.locks.MonitoredReentrantReadWriteLock;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;\n import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;\n+import net.server.audit.locks.MonitoredLockType;\n+import net.server.audit.locks.MonitoredReentrantReadWriteLock;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n import java.lang.ref.WeakReference;\n import net.server.Server;\n import net.server.channel.Channel;\n@@ -108,6 +109,7 @@\n     private Map<String, Integer> environment = new LinkedHashMap<>();\n     private Map<MapleMapItem, Long> droppedItems = new LinkedHashMap<>();\n     private LinkedList<WeakReference<MapleMapObject>> registeredDrops = new LinkedList<>();\n+    private Map<MobLootEntry, Long> mobLootEntries = new HashMap(20);\n     private List<Rectangle> areas = new ArrayList<>();\n     private MapleFootholdTree footholds = null;\n     private Pair<Integer, Integer> xLimits;  // caches the min and max x's with available footholds\n@@ -141,11 +143,11 @@\n     private ScheduledFuture<?> mapMonitor = null;\n     private ScheduledFuture<?> itemMonitor = null;\n     private ScheduledFuture<?> expireItemsTask = null;\n+    private ScheduledFuture<?> mobSpawnLootTask = null;\n     private short itemMonitorTimeout;\n     private Pair<Integer, String> timeMob = null;\n     private short mobInterval = 5000;\n     private boolean allowSummons = true; // All maps should have this true at the beginning\n-    private int lastDoorOwner = -1;\n     \n     // HPQ\n     private int riceCakes = 0;\n@@ -157,13 +159,15 @@\n     private MapleCoconut coconut;\n     \n     //locks\n-    private final ReadLock chrRLock;\n-    private final WriteLock chrWLock;\n-    private final ReadLock objectRLock;\n-    private final WriteLock objectWLock;\n+    private ReadLock chrRLock;\n+    private WriteLock chrWLock;\n+    private ReadLock objectRLock;\n+    private WriteLock objectWLock;\n \n+    private Lock lootLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.MAP_LOOT, true);\n+    \n     // due to the nature of loadMapFromWz (synchronized), sole function that calls 'generateMapDropRangeCache', this lock remains optional.\n-    private static final Lock bndLock = new MonitoredReentrantLock(MonitoredLockType.MAP_BOUNDS, true);\n+    private static final Lock bndLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.MAP_BOUNDS, true);\n     \n     public MapleMap(int mapid, int world, int channel, int returnMapId, float monsterRate) {\n         this.mapid = mapid;\n@@ -695,22 +699,14 @@ private void dropFromMonster(final MapleCharacter chr, final MapleMonster mob, f\n         if(useBaseRate) chRate = 1;\n \n         final MapleMonsterInformationProvider mi = MapleMonsterInformationProvider.getInstance();\n+        final List<MonsterGlobalDropEntry> globalEntry = mi.getGlobalDrop();\n         \n         final List<MonsterDropEntry>  dropEntry = new ArrayList<>();\n         final List<MonsterDropEntry> visibleQuestEntry = new ArrayList<>();\n         final List<MonsterDropEntry> otherQuestEntry = new ArrayList<>();\n         sortDropEntries(mi.retrieveEffectiveDrop(mob.getId()), dropEntry, visibleQuestEntry, otherQuestEntry, chr);\n         \n-        // Normal Drops\n-        d = dropItemsFromMonsterOnMap(dropEntry, pos, d, chRate, droptype, mobpos, chr, mob);\n-        \n-        // Global Drops\n-        final List<MonsterGlobalDropEntry> globalEntry = mi.getGlobalDrop();\n-        d = dropGlobalItemsFromMonsterOnMap(globalEntry, pos, d, droptype, mobpos, chr, mob);\n-        \n-        // Quest Drops\n-        d = dropItemsFromMonsterOnMap(visibleQuestEntry, pos, d, chRate, droptype, mobpos, chr, mob);\n-        dropItemsFromMonsterOnMap(otherQuestEntry, pos, d, chRate, droptype, mobpos, chr, mob);\n+        registerMobItemDrops(droptype, mobpos, chRate, pos, dropEntry, visibleQuestEntry, otherQuestEntry, globalEntry, chr, mob);\n     }\n     \n     public void dropItemsFromMonster(List<MonsterDropEntry> list, final MapleCharacter chr, final MapleMonster mob) {\n@@ -736,15 +732,15 @@ public void dropFromReactor(final MapleCharacter chr, final MapleReactor reactor\n     }\n \n     private void stopItemMonitor() {\n-        chrWLock.lock();\n-        try {\n-            itemMonitor.cancel(false);\n-            itemMonitor = null;\n-            \n-            expireItemsTask.cancel(false);\n-            expireItemsTask = null;\n-        } finally {\n-            chrWLock.unlock();\n+        itemMonitor.cancel(false);\n+        itemMonitor = null;\n+\n+        expireItemsTask.cancel(false);\n+        expireItemsTask = null;\n+\n+        if(ServerConstants.USE_SPAWN_LOOT_ON_ANIMATION) {\n+            mobSpawnLootTask.cancel(false);\n+            mobSpawnLootTask = null;\n         }\n     }\n     \n@@ -765,18 +761,34 @@ private void startItemMonitor() {\n             itemMonitor = TimerManager.getInstance().register(new Runnable() {\n                 @Override\n                 public void run() {\n-                    if (getCharacters().isEmpty()) {\n-                        if(itemMonitorTimeout == 0) {\n-                            stopItemMonitor();\n-                            return;\n+                    chrWLock.lock();\n+                    try {\n+                        if (characters.isEmpty()) {\n+                            if(itemMonitorTimeout == 0) {\n+                                if(itemMonitor != null) {\n+                                    stopItemMonitor();\n+                                }\n+                                \n+                                return;\n+                            } else {\n+                                itemMonitorTimeout--;\n+                            }\n                         } else {\n-                            itemMonitorTimeout--;\n+                            itemMonitorTimeout = 1;\n                         }\n-                    } else {\n-                        itemMonitorTimeout = 1;\n+                    } finally {\n+                        chrWLock.unlock();\n+                    }\n+                    \n+                    boolean tryClean;\n+                    objectRLock.lock();\n+                    try {\n+                        tryClean = registeredDrops.size() > 70;\n+                    } finally {\n+                        objectRLock.unlock();\n                     }\n                     \n-                    if(!registeredDrops.isEmpty()) cleanItemMonitor();\n+                    if(tryClean) cleanItemMonitor();\n                 }\n             }, ServerConstants.ITEM_MONITOR_TIME, ServerConstants.ITEM_MONITOR_TIME);\n             \n@@ -786,6 +798,22 @@ public void run() {\n                     makeDisappearExpiredItemDrops();\n                 }\n             }, ServerConstants.ITEM_EXPIRE_CHECK, ServerConstants.ITEM_EXPIRE_CHECK);\n+            \n+            if(ServerConstants.USE_SPAWN_LOOT_ON_ANIMATION) {\n+                lootLock.lock();\n+                try {\n+                    mobLootEntries.clear();\n+                } finally {\n+                    lootLock.unlock();\n+                }\n+\n+                mobSpawnLootTask = TimerManager.getInstance().register(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        spawnMobItemDrops();\n+                    }\n+                }, 200, 200);\n+            }\n                     \n             itemMonitorTimeout = 1;\n         } finally {\n@@ -878,6 +906,63 @@ private void makeDisappearExpiredItemDrops() {\n         }\n     }\n     \n+    private void registerMobItemDrops(byte droptype, int mobpos, int chRate, Point pos, List<MonsterDropEntry> dropEntry, List<MonsterDropEntry> visibleQuestEntry, List<MonsterDropEntry> otherQuestEntry, List<MonsterGlobalDropEntry> globalEntry, MapleCharacter chr, MapleMonster mob) {\n+        MobLootEntry mle = new MobLootEntry(droptype, mobpos, chRate, pos, dropEntry, visibleQuestEntry, otherQuestEntry, globalEntry, chr, mob);\n+        \n+        if(ServerConstants.USE_SPAWN_LOOT_ON_ANIMATION) {\n+            int animationTime = mob.getAnimationTime(\"die1\");\n+\n+            lootLock.lock();\n+            try {\n+                long timeNow = Server.getInstance().getCurrentTime();\n+                mobLootEntries.put(mle, timeNow + ((long)(0.42 * animationTime)));\n+            } finally {\n+                lootLock.unlock();\n+            }\n+        } else {\n+            mle.run();\n+        }\n+    }\n+    \n+    private void spawnMobItemDrops() {\n+        Set<Entry<MobLootEntry, Long>> mleList;\n+        \n+        lootLock.lock();\n+        try {\n+            mleList = new HashSet<>(mobLootEntries.entrySet());\n+        } finally {\n+            lootLock.unlock();\n+        }\n+        \n+        long timeNow = Server.getInstance().getCurrentTime();\n+        List<MobLootEntry> toRemove = new LinkedList<>();\n+        for(Entry<MobLootEntry, Long> mlee : mleList) {\n+            if(mlee.getValue() < timeNow) {\n+                toRemove.add(mlee.getKey());\n+            }\n+        }\n+        \n+        if(!toRemove.isEmpty()) {\n+            List<MobLootEntry> toSpawnLoot = new LinkedList<>();\n+            \n+            lootLock.lock();\n+            try {\n+                for(MobLootEntry mle : toRemove) {\n+                    Long mler = mobLootEntries.remove(mle);\n+                    if(mler != null) {\n+                        toSpawnLoot.add(mle);\n+                    }\n+                }\n+            } finally {\n+                lootLock.unlock();\n+            }\n+            \n+            for(MobLootEntry mle : toSpawnLoot) {\n+                mle.run();\n+            }\n+        }\n+    }\n+    \n     private List<MapleMapItem> getDroppedItems() {\n         objectRLock.lock();\n         try {\n@@ -1748,6 +1833,7 @@ public Point getPointBelow(Point pos) {\n \n     public void spawnRevives(final MapleMonster monster) {\n         monster.setMap(this);\n+        if(getEventInstance() != null) getEventInstance().registerMonster(monster);\n \n         spawnAndAddRangedMapObject(monster, new DelayedPacketCreation() {\n             @Override\n@@ -1756,8 +1842,36 @@ public void sendPackets(MapleClient c) {\n                 c.announce(MaplePacketCreator.spawnMonster(monster, false));\n             }\n         });\n+        \n         updateMonsterController(monster);\n+        \n+        if (monster.hasBossHPBar()) {\n+            broadcastBossHpMessage(monster, monster.hashCode(), monster.makeBossHPBarPacket(), monster.getPosition());\n+        }\n+        \n         spawnedMonstersOnMap.incrementAndGet();\n+        applyRemoveAfter(monster);\n+    }\n+    \n+    private void applyRemoveAfter(final MapleMonster monster) {\n+        final selfDestruction selfDestruction = monster.getStats().selfDestruction();\n+        if (monster.getStats().removeAfter() > 0 || selfDestruction != null && selfDestruction.getHp() < 0) {\n+            if (selfDestruction == null) {\n+                TimerManager.getInstance().schedule(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        killMonster(monster, null, false);\n+                    }\n+                }, monster.getStats().removeAfter() * 1000);\n+            } else {\n+                TimerManager.getInstance().schedule(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        killMonster(monster, null, false, selfDestruction.getAction());\n+                    }\n+                }, selfDestruction.removeAfter() * 1000);\n+            }\n+        }\n     }\n     \n     public void spawnAllMonsterIdFromMapSpawnList(int id) {\n@@ -1781,7 +1895,7 @@ public void spawnAllMonstersFromMapSpawnList(int difficulty, boolean isPq) {\n             spawnMonster(sp.getMonster(), difficulty, isPq);\n         }\n     }\n-\n+    \n     public void spawnMonster(final MapleMonster monster) {\n         spawnMonster(monster, 1, false);\n     }\n@@ -1804,6 +1918,10 @@ public void sendPackets(MapleClient c) {\n         }, null);\n         \n         updateMonsterController(monster);\n+        \n+        if (monster.hasBossHPBar()) {\n+            broadcastBossHpMessage(monster, monster.hashCode(), monster.makeBossHPBarPacket(), monster.getPosition());\n+        }\n \n         if (monster.getDropPeriodTime() > 0) { //9300102 - Watchhog, 9300061 - Moon Bunny (HPQ), 9300093 - Tylus\n             if (monster.getId() == 9300102) {\n@@ -1818,25 +1936,9 @@ public void sendPackets(MapleClient c) {\n                 FilePrinter.printError(FilePrinter.UNHANDLED_EVENT, \"UNCODED TIMED MOB DETECTED: \" + monster.getId() + \"\\r\\n\");\n             }\n         }\n+        \n         spawnedMonstersOnMap.incrementAndGet();\n-        final selfDestruction selfDestruction = monster.getStats().selfDestruction();\n-        if (monster.getStats().removeAfter() > 0 || selfDestruction != null && selfDestruction.getHp() < 0) {\n-            if (selfDestruction == null) {\n-                TimerManager.getInstance().schedule(new Runnable() {\n-                    @Override\n-                    public void run() {\n-                        killMonster(monster, null, false);\n-                    }\n-                }, monster.getStats().removeAfter() * 1000);\n-            } else {\n-                TimerManager.getInstance().schedule(new Runnable() {\n-                    @Override\n-                    public void run() {\n-                        killMonster(monster, null, false, selfDestruction.getAction());\n-                    }\n-                }, selfDestruction.removeAfter() * 1000);\n-            }\n-        }\n+        applyRemoveAfter(monster);\n     }\n \n     public void spawnDojoMonster(final MapleMonster monster) {\n@@ -1850,6 +1952,8 @@ public void spawnMonsterWithEffect(final MapleMonster monster, final int effect,\n         spos = calcPointBelow(spos);\n         if(spos == null) return;\n         \n+        if(getEventInstance() != null) getEventInstance().registerMonster(monster);\n+        \n         spos.y--;\n         monster.setPosition(spos);\n         spawnAndAddRangedMapObject(monster, new DelayedPacketCreation() {\n@@ -1858,12 +1962,14 @@ public void sendPackets(MapleClient c) {\n                 c.announce(MaplePacketCreator.spawnMonster(monster, true, effect));\n             }\n         });\n+        updateMonsterController(monster);\n+        \n         if (monster.hasBossHPBar()) {\n             broadcastBossHpMessage(monster, monster.hashCode(), monster.makeBossHPBarPacket(), monster.getPosition());\n         }\n-        updateMonsterController(monster);\n \n         spawnedMonstersOnMap.incrementAndGet();\n+        applyRemoveAfter(monster);\n     }\n \n     public void spawnFakeMonster(final MapleMonster monster) {\n@@ -1929,21 +2035,19 @@ public boolean canSpawn(MapleCharacter chr) {\n                 return chr.getMapId() == door.getFrom().getId();\n             }\n         });\n-        \n-        if(!door.inTown()) setLastDoorOwner(door.getOwnerId());\n     }\n     \n     public List<MaplePortal> getAvailableDoorPortals() {\n         objectRLock.lock();\n         try {\n             List<MaplePortal> availablePortals = new ArrayList<>();\n-            \n+\n             for (MaplePortal port : portals.values()) {\n                 if (port.getType() == MaplePortal.DOOR_PORTAL) {\n                     availablePortals.add(port);\n                 }\n             }\n-            \n+\n             return availablePortals;\n         } finally {\n             objectRLock.unlock();\n@@ -2270,12 +2374,12 @@ public void addPlayer(final MapleCharacter chr) {\n             chrSize = characters.size();\n                     \n             addPartyMemberInternal(chr);\n+            itemMonitorTimeout = 1;\n         } finally {\n             chrWLock.unlock();\n         }\n         chr.setMapId(mapid);\n-            \n-        itemMonitorTimeout = 1;\n+        \n         if (chrSize == 1) {\n             if(!hasItemMonitor()) startItemMonitor();\n             \n@@ -3143,6 +3247,47 @@ public boolean makeDisappearItemFromMap(MapleMapItem mapitem) {\n         return false;\n     }\n \n+    private class MobLootEntry implements Runnable {\n+        private byte droptype;\n+        private int mobpos;\n+        private int chRate;\n+        private Point pos;\n+        private List<MonsterDropEntry> dropEntry;\n+        private List<MonsterDropEntry> visibleQuestEntry;\n+        private List<MonsterDropEntry> otherQuestEntry;\n+        private List<MonsterGlobalDropEntry> globalEntry;\n+        private MapleCharacter chr;\n+        private MapleMonster mob;\n+\n+        protected MobLootEntry(byte droptype, int mobpos, int chRate, Point pos, List<MonsterDropEntry> dropEntry, List<MonsterDropEntry> visibleQuestEntry, List<MonsterDropEntry> otherQuestEntry, List<MonsterGlobalDropEntry> globalEntry, MapleCharacter chr, MapleMonster mob) {\n+            this.droptype = droptype;\n+            this.mobpos = mobpos;\n+            this.chRate = chRate;\n+            this.pos = pos;\n+            this.dropEntry = dropEntry;\n+            this.visibleQuestEntry = visibleQuestEntry;\n+            this.otherQuestEntry = otherQuestEntry;\n+            this.globalEntry = globalEntry;\n+            this.chr = chr;\n+            this.mob = mob;\n+        }\n+\n+        @Override\n+        public void run() {\n+            byte d = 1;\n+            \n+            // Normal Drops\n+            d = dropItemsFromMonsterOnMap(dropEntry, pos, d, chRate, droptype, mobpos, chr, mob);\n+\n+            // Global Drops\n+            d = dropGlobalItemsFromMonsterOnMap(globalEntry, pos, d, droptype, mobpos, chr, mob);\n+\n+            // Quest Drops\n+            d = dropItemsFromMonsterOnMap(visibleQuestEntry, pos, d, chRate, droptype, mobpos, chr, mob);\n+            dropItemsFromMonsterOnMap(otherQuestEntry, pos, d, chRate, droptype, mobpos, chr, mob);\n+        }\n+    }\n+    \n     private class ActivateItemReactor implements Runnable {\n \n         private MapleMapItem mapitem;\n@@ -3292,28 +3437,44 @@ public SpawnPoint findClosestSpawnpoint(Point from) {\n         return closest;\n     }\n \n+    private static double getCurrentSpawnRate(int numPlayers) {\n+        return 0.550 + (0.075 * Math.min(6, numPlayers));\n+    }\n+    \n+    private int getNumShouldSpawn(int numPlayers) {\n+        /*\n+        System.out.println(\"----------------------------------\");\n+        for (SpawnPoint spawnPoint : monsterSpawn) {\n+            System.out.println(\"sp \" + spawnPoint.getPosition().getX() + \", \" + spawnPoint.getPosition().getY() + \": \" + spawnPoint.getDenySpawn());\n+        }\n+        System.out.println(\"try \" + monsterSpawn.size() + \" - \" + spawnedMonstersOnMap.get());\n+        System.out.println(\"----------------------------------\");\n+        */\n+        \n+        if(ServerConstants.USE_ENABLE_FULL_RESPAWN) {\n+            return (monsterSpawn.size() - spawnedMonstersOnMap.get());\n+        }\n+        \n+        int maxNumShouldSpawn = (int) Math.ceil(getCurrentSpawnRate(numPlayers) * monsterSpawn.size());\n+        return maxNumShouldSpawn - spawnedMonstersOnMap.get();\n+    }\n+    \n     public void respawn() {\n         if(!allowSummons) return;\n         \n+        int numPlayers;\n         chrRLock.lock();\n         try {\n-            if(characters.isEmpty()) {\n+            numPlayers = characters.size();\n+            \n+            if(numPlayers == 0) {\n                 return;\n             }\n         } finally {\n             chrRLock.unlock();\n         }\n         \n-        /*\n-        System.out.println(\"----------------------------------\");\n-        for (SpawnPoint spawnPoint : monsterSpawn) {\n-            System.out.println(\"sp \" + spawnPoint.getPosition().getX() + \", \" + spawnPoint.getPosition().getY() + \": \" + spawnPoint.getDenySpawn());\n-        }\n-        System.out.println(\"try \" + monsterSpawn.size() + \" - \" + spawnedMonstersOnMap.get());\n-        System.out.println(\"----------------------------------\");\n-        */\n-        \n-        short numShouldSpawn = (short) ((monsterSpawn.size() - spawnedMonstersOnMap.get()));//Fking lol'd\n+        int numShouldSpawn = getNumShouldSpawn(numPlayers);\n         if(numShouldSpawn > 0) {\n             List<SpawnPoint> randomSpawn = new ArrayList<>(monsterSpawn);\n             Collections.shuffle(randomSpawn);\n@@ -3745,14 +3906,6 @@ public void broadcastEnemyShip(final boolean state) {\n         this.setDocked(state);\n     }\n     \n-    public boolean isLastDoorOwner(int cid) {\n-        return lastDoorOwner == cid;\n-    }\n-    \n-    public void setLastDoorOwner(int cid) {\n-        lastDoorOwner = cid;\n-    }\n-    \n     public boolean isDojoMap() {\n         return mapid >= 925020000 && mapid < 925040000;\n     }\n@@ -3843,6 +3996,11 @@ public void dispose() {\n                 expireItemsTask.cancel(false);\n                 expireItemsTask = null;\n             }\n+            \n+            if(mobSpawnLootTask != null) {\n+                mobSpawnLootTask.cancel(false);\n+                mobSpawnLootTask = null;\n+            }\n         } finally {\n             chrWLock.unlock();\n         }"}, {"sha": "9702f58cce20e6574c67f814519185ab16758bd9", "filename": "src/server/maps/MapleMapFactory.java", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/server/maps/MapleMapFactory.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/server/maps/MapleMapFactory.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/maps/MapleMapFactory.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -51,9 +51,9 @@\n import tools.DatabaseConnection;\n import tools.StringUtil;\n \n-\n public class MapleMapFactory {\n-\n+    private static Map<Integer, Float> mapRecoveryRate = new HashMap<>();\n+    \n     private MapleDataProvider source;\n     private MapleData nameData;\n     private EventInstanceManager event;\n@@ -278,7 +278,13 @@ private synchronized MapleMap loadMapFromWz(int mapid, Integer omapid) {\n         map.setTimeLimit(MapleDataTool.getIntConvert(\"timeLimit\", infoData, -1));\n         map.setFieldType(MapleDataTool.getIntConvert(\"fieldType\", infoData, 0));\n         map.setMobCapacity(MapleDataTool.getIntConvert(\"fixedMobCapacity\", infoData, 500));//Is there a map that contains more than 500 mobs?\n-\n+        \n+        MapleData recData = infoData.getChildByPath(\"recovery\");\n+        if(recData != null) {\n+            float recoveryRate = MapleDataTool.getFloat(recData);\n+            mapRecoveryRate.put(mapid, recoveryRate);\n+        }\n+        \n         HashMap<Integer, Integer> backTypes = new HashMap<>();\n         try {\n             for (MapleData layer : mapData.getChildByPath(\"back\")) { // yolo\n@@ -443,4 +449,9 @@ public void dispose() {\n         \n         this.event = null;\n     }\n+    \n+    public static float getMapRecoveryRate(int mapid) {\n+        Float recRate = mapRecoveryRate.get(mapid);\n+        return recRate != null ? recRate : 1.0f;\n+    }\n }"}, {"sha": "3d883a94d270d87878740ad7f31cf103de86ffd4", "filename": "src/server/maps/MapleMapItem.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/server/maps/MapleMapItem.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/server/maps/MapleMapItem.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/maps/MapleMapItem.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -25,9 +25,9 @@\n import client.inventory.Item;\n import java.awt.Point;\n import java.util.concurrent.locks.Lock;\n-import net.server.audit.locks.MonitoredReentrantLock;\n import tools.MaplePacketCreator;\n import net.server.audit.locks.MonitoredLockType;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n \n public class MapleMapItem extends AbstractMapleMapObject {\n     protected MapleClient ownerClient;\n@@ -37,7 +37,7 @@\n     protected byte type;\n     protected boolean pickedUp = false, playerDrop;\n     protected long dropTime;\n-    private Lock itemLock = new MonitoredReentrantLock(MonitoredLockType.MAP_ITEM);\n+    private Lock itemLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.MAP_ITEM);\n \n     public MapleMapItem(Item item, Point position, MapleMapObject dropper, MapleCharacter owner, MapleClient ownerClient, byte type, boolean playerDrop) {\n \tsetPosition(position);"}, {"sha": "ce2d386ffb6d9675cbd685cde59b2077ba771def", "filename": "src/server/maps/MapleMiniDungeon.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/server/maps/MapleMiniDungeon.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/server/maps/MapleMiniDungeon.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/maps/MapleMiniDungeon.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -26,9 +26,9 @@\n import java.util.ArrayList;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.locks.Lock;\n-import net.server.audit.locks.MonitoredReentrantLock;\n import tools.MaplePacketCreator;\n import net.server.audit.locks.MonitoredLockType;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n \n /**\n  *\n@@ -37,7 +37,7 @@\n public class MapleMiniDungeon {\n     List<MapleCharacter> players = new ArrayList<>();\n     ScheduledFuture<?> timeoutTask = null;\n-    Lock lock = new MonitoredReentrantLock(MonitoredLockType.MINIDUNGEON, true);\n+    Lock lock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.MINIDUNGEON, true);\n     \n     int baseMap;\n     long expireTime;"}, {"sha": "32c8544da7b65c561c8b49675ed5b768e86de144", "filename": "src/server/maps/MaplePlayerShop.java", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/server/maps/MaplePlayerShop.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/server/maps/MaplePlayerShop.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/maps/MaplePlayerShop.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -28,7 +28,6 @@\n import client.inventory.MapleInventoryType;\n import client.inventory.manipulator.MapleInventoryManipulator;\n import client.inventory.manipulator.MapleKarmaManipulator;\n-import constants.ServerConstants;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.LinkedList;\n@@ -37,12 +36,12 @@\n import java.util.Map;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.locks.Lock;\n-import net.server.audit.locks.MonitoredReentrantLock;\n import net.opcodes.SendOpcode;\n import tools.MaplePacketCreator;\n import tools.Pair;\n import tools.data.output.MaplePacketLittleEndianWriter;\n import net.server.audit.locks.MonitoredLockType;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n \n /**\n  *\n@@ -62,7 +61,7 @@\n     private List<String> bannedList = new ArrayList<>();\n     private List<Pair<MapleCharacter, String>> chatLog = new LinkedList<>();\n     private Map<Integer, Byte> chatSlot = new LinkedHashMap<>();\n-    private Lock visitorLock = new MonitoredReentrantLock(MonitoredLockType.VISITOR_PSHOP, true);\n+    private Lock visitorLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.VISITOR_PSHOP, true);\n \n     public MaplePlayerShop(MapleCharacter owner, String description, int itemid) {\n         this.setPosition(owner.getPosition());"}, {"sha": "72df5fcfbcc80dac197e35aef60a5198215d4ce0", "filename": "src/server/maps/MapleReactor.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/server/maps/MapleReactor.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/server/maps/MapleReactor.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/maps/MapleReactor.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -29,7 +29,7 @@\n \n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.locks.Lock;\n-import net.server.audit.locks.MonitoredReentrantLock;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n \n import scripting.reactor.ReactorScriptManager;\n import server.TimerManager;\n@@ -54,8 +54,8 @@\n     private boolean shouldCollect;\n     private boolean attackHit;\n     private ScheduledFuture<?> timeoutTask = null;\n-    private Lock reactorLock = new MonitoredReentrantLock(MonitoredLockType.REACTOR, true);\n-    private Lock hitLock = new MonitoredReentrantLock(MonitoredLockType.REACTOR_HIT, true);\n+    private Lock reactorLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.REACTOR, true);\n+    private Lock hitLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.REACTOR_HIT, true);\n \n     public MapleReactor(MapleReactorStats stats, int rid) {\n         this.evstate = (byte)0;"}, {"sha": "da14024165c1e7c8e3a67246eced94a9b78ea5a7", "filename": "src/tools/MaplePacketCreator.java", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/src/tools/MaplePacketCreator.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/src/tools/MaplePacketCreator.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/tools/MaplePacketCreator.java?ref=cc541f39d571673c813ce1bed180f1575caacd60", "patch": "@@ -957,6 +957,7 @@ private static void addMonsterBookInfo(final MaplePacketLittleEndianWriter mplew\n          * Gets an update for specified stats.\n          *\n          * @param stats The stats to update.\n+         * @param chr The update target.\n          * @return The stat update packet.\n          */\n         public static byte[] updatePlayerStats(List<Pair<MapleStat, Integer>> stats, MapleCharacter chr) {\n@@ -968,6 +969,7 @@ private static void addMonsterBookInfo(final MaplePacketLittleEndianWriter mplew\n          *\n          * @param stats The list of stats to update.\n          * @param itemReaction Result of an item reaction(?)\n+         * @param chr The update target.\n          * @return The stat update packet.\n          */\n         public static byte[] updatePlayerStats(List<Pair<MapleStat, Integer>> stats, boolean itemReaction, MapleCharacter chr) {\n@@ -2189,7 +2191,7 @@ private static void updateHiredMerchantBoxInfo(MaplePacketLittleEndianWriter mpl\n                 mplew.writeInt(hm.getObjectId());\n                 mplew.writeMapleAsciiString(hm.getDescription());\n                 mplew.write(hm.getItemId() % 100);\n-                mplew.write(roomInfo);\n+                mplew.write(roomInfo);    // visitor capacity here, thanks GabrielSin!\n         }\n         \n         public static byte[] updateHiredMerchantBox(MapleHiredMerchant hm) {\n@@ -4204,11 +4206,30 @@ private static void writeIntMask(final MaplePacketLittleEndianWriter mplew, Map<\n \n                 mplew.writeShort(SendOpcode.FIELD_OBSTACLE_ONOFF.getValue());\n                 mplew.writeMapleAsciiString(env);\n-                mplew.writeInt(mode);\n+                mplew.writeInt(mode);   // 0: stop and back to start, 1: move\n                 \n                 return mplew.getPacket();\n         }\n-\n+        \n+        public static byte[] environmentMoveList(Set<Entry<String, Integer>> envList) {\n+                MaplePacketLittleEndianWriter mplew = new MaplePacketLittleEndianWriter();\n+                mplew.writeShort(SendOpcode.FIELD_OBSTACLE_ONOFF_LIST.getValue());\n+                mplew.writeInt(envList.size());\n+                \n+                for(Entry<String, Integer> envMove : envList) {\n+                        mplew.writeMapleAsciiString(envMove.getKey());\n+                        mplew.writeInt(envMove.getValue());\n+                }\n+                \n+                return mplew.getPacket();\n+        }\n+        \n+        public static byte[] environmentMoveReset() {\n+                MaplePacketLittleEndianWriter mplew = new MaplePacketLittleEndianWriter();\n+                mplew.writeShort(SendOpcode.FIELD_OBSTACLE_ALL_RESET.getValue());\n+                return mplew.getPacket();\n+        }\n+        \n         public static byte[] startMapEffect(String msg, int itemid, boolean active) {\n                 final MaplePacketLittleEndianWriter mplew = new MaplePacketLittleEndianWriter();\n                 mplew.writeShort(SendOpcode.BLOW_WEATHER.getValue());"}, {"sha": "1d73c07c0cf1b58f94693adfe54bfea6787de989", "filename": "wz/Map.wz/Map/Map5/540000000.img.xml", "status": "modified", "additions": 7126, "deletions": 7153, "changes": 14279, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/wz/Map.wz/Map/Map5/540000000.img.xml", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/wz/Map.wz/Map/Map5/540000000.img.xml", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/wz/Map.wz/Map/Map5/540000000.img.xml?ref=cc541f39d571673c813ce1bed180f1575caacd60"}, {"sha": "ddd1c5aac8f5f967ef46113c7a35ee950fdc1570", "filename": "wz/Map.wz/Map/Map5/550000000.img.xml", "status": "modified", "additions": 5431, "deletions": 5455, "changes": 10886, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/wz/Map.wz/Map/Map5/550000000.img.xml", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/wz/Map.wz/Map/Map5/550000000.img.xml", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/wz/Map.wz/Map/Map5/550000000.img.xml?ref=cc541f39d571673c813ce1bed180f1575caacd60"}, {"sha": "2939dd4307bea28126f705c0681fd49c0db1c922", "filename": "wz/Map.wz/Map/Map5/550000400.img.xml", "status": "modified", "additions": 2950, "deletions": 2944, "changes": 5894, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/wz/Map.wz/Map/Map5/550000400.img.xml", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/wz/Map.wz/Map/Map5/550000400.img.xml", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/wz/Map.wz/Map/Map5/550000400.img.xml?ref=cc541f39d571673c813ce1bed180f1575caacd60"}, {"sha": "fbf3514bccb05a8a77c9da3cbbd02d6ca62be90b", "filename": "wz/Map.wz/Map/Map5/551000000.img.xml", "status": "modified", "additions": 3993, "deletions": 4000, "changes": 7993, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/wz/Map.wz/Map/Map5/551000000.img.xml", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/wz/Map.wz/Map/Map5/551000000.img.xml", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/wz/Map.wz/Map/Map5/551000000.img.xml?ref=cc541f39d571673c813ce1bed180f1575caacd60"}, {"sha": "1fb138a5c67c3913e816f7a5593bda2f0a0cba2c", "filename": "wz/Map.wz/Map/Map5/551000200.img.xml", "status": "modified", "additions": 3330, "deletions": 3374, "changes": 6704, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/cc541f39d571673c813ce1bed180f1575caacd60/wz/Map.wz/Map/Map5/551000200.img.xml", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/cc541f39d571673c813ce1bed180f1575caacd60/wz/Map.wz/Map/Map5/551000200.img.xml", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/wz/Map.wz/Map/Map5/551000200.img.xml?ref=cc541f39d571673c813ce1bed180f1575caacd60"}]}]},
