{"fetchDate": "2019-12-19", "content": [{"sha": "a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "node_id": "MDY6Q29tbWl0NDUwODIwMjM6YTM5YTIxMGMxZjY5OTNhODc0N2JhNDNmMTYwYzViOGRiZmU3NjFmMg==", "commit": {"author": {"name": "ronancpl", "email": "rcpl2010@gmail.com", "date": "2019-06-15T18:10:56Z"}, "committer": {"name": "ronancpl", "email": "rcpl2010@gmail.com", "date": "2019-06-15T18:10:56Z"}, "message": "Conditional Buffs & M. Magnet & Loot Patch + Exp Split + Duey Rework\n\nFixed Monster Magnet skill when used on bosses disconnecting the caster.\nImproved conditional buff system, no longer updating buffs that are not supposed to toggle.\nAdded party hunting in the conditional buffs system.\nRefactored usage of DB by Duey. Registered Duey items now make use of the same table as the other inventory items.\nFixed non-encapsulated unlocking in reactor class.\nFixed stylish NPCs disconnecting players when trying to display empty styles list.\nFixed a deadlock case within recently implemented update buff effects (conditional buffs mechanic).\nFixed AOE mobskills not behaving well for fixed mobs (those shouldn't take into account attribute \"facingLeft\").\nFixed non-flipping mobs having attribute \"facingLeft\" updated according to controller position.\nRevised aggro system no longer having bosses expire player chase.\nFixed chalkboard being depleted upon use.\nRefactored MapleMapFactory, looking for normalization of the Factory design pattern the class was intended to make use at its conception.\nAdded MP replenishing system for mobs, gains based on its level.\nFixed indisponibility of one-of-a-kind loots due to the killer's team already having one sample each.\nReworked the EXP split system within the source. New behavior is expected to be GMS-like.\nAdjusted interaction within the NPC Nein Spirit's Baby Dragon area. Only players who interacts with quests within can access the area now. One player at a time, with a timeout timer.\nFixed check of level requisites for expeditions.", "tree": {"sha": "35c9a26c445402800653490284493b58d96a9642", "url": "https://api.github.com/repos/ronancpl/HeavenMS/git/trees/35c9a26c445402800653490284493b58d96a9642"}, "url": "https://api.github.com/repos/ronancpl/HeavenMS/git/commits/a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/ronancpl/HeavenMS/commits/a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "html_url": "https://github.com/ronancpl/HeavenMS/commit/a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "comments_url": "https://api.github.com/repos/ronancpl/HeavenMS/commits/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/comments", "author": {"login": "ronancpl", "id": 9257761, "node_id": "MDQ6VXNlcjkyNTc3NjE=", "avatar_url": "https://avatars2.githubusercontent.com/u/9257761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ronancpl", "html_url": "https://github.com/ronancpl", "followers_url": "https://api.github.com/users/ronancpl/followers", "following_url": "https://api.github.com/users/ronancpl/following{/other_user}", "gists_url": "https://api.github.com/users/ronancpl/gists{/gist_id}", "starred_url": "https://api.github.com/users/ronancpl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ronancpl/subscriptions", "organizations_url": "https://api.github.com/users/ronancpl/orgs", "repos_url": "https://api.github.com/users/ronancpl/repos", "events_url": "https://api.github.com/users/ronancpl/events{/privacy}", "received_events_url": "https://api.github.com/users/ronancpl/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ronancpl", "id": 9257761, "node_id": "MDQ6VXNlcjkyNTc3NjE=", "avatar_url": "https://avatars2.githubusercontent.com/u/9257761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ronancpl", "html_url": "https://github.com/ronancpl", "followers_url": "https://api.github.com/users/ronancpl/followers", "following_url": "https://api.github.com/users/ronancpl/following{/other_user}", "gists_url": "https://api.github.com/users/ronancpl/gists{/gist_id}", "starred_url": "https://api.github.com/users/ronancpl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ronancpl/subscriptions", "organizations_url": "https://api.github.com/users/ronancpl/orgs", "repos_url": "https://api.github.com/users/ronancpl/repos", "events_url": "https://api.github.com/users/ronancpl/events{/privacy}", "received_events_url": "https://api.github.com/users/ronancpl/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04b11e251815c02a5c7a14dd37bc0677d77f37e7", "url": "https://api.github.com/repos/ronancpl/HeavenMS/commits/04b11e251815c02a5c7a14dd37bc0677d77f37e7", "html_url": "https://github.com/ronancpl/HeavenMS/commit/04b11e251815c02a5c7a14dd37bc0677d77f37e7"}], "stats": {"total": 2063, "additions": 1207, "deletions": 856}, "files": [{"sha": "e3411185f37552f3850dea0f28d4e3e6dec3eb93", "filename": "README.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/README.md", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/README.md", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/README.md?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -23,13 +23,15 @@ Java7 SDK: https://www.oracle.com/technetwork/java/javase/downloads/java-archive\n \n **Important note about localhosts**: these executables are red-flagged by antivirus tools as __potentially malicious softwares__, this happens due to the reverse engineering methods that were applied onto these software artifacts. Those depicted here have been put to use for years already and posed no harm so far, so they are soundly assumed to be safe.\n \n-  Latest localhost: https://hostr.co/tsYsQzzV6xT0\n+  Latest localhost: https://hostr.co/itrvrHapvtEg\n \n   The following list, in bottom-up chronological order, holds information regarding all changes that were applied from the starting localhost used in this development. Some lines have a link attached, that will lead you to a snapshot of the localhost at that version of the artifact. Naturally, later versions holds all previous changes along with the proposed changes.\n \n **Change log:**\n \n-  * Fixed some 'rn' problems with quest icons & removed \"tab\" from party leader changed message.\n+  * Fixed Monster Magnet crashing the caster when trying to pull-in bosses.\n+\n+  * Fixed some 'rn' problems with quest icons & removed \"tab\" from party leader changed message. https://hostr.co/tsYsQzzV6xT0\n \n   * Removed block on applying attack-based strengthening gems on non-weapon equipments. https://hostr.co/m2bVtnizCtmD\n "}, {"sha": "ccff9e18d82f130b37540aab2c339d9ba57ff0c0", "filename": "docs/issues.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/docs/issues.txt", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/docs/issues.txt", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/docs/issues.txt?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -15,6 +15,7 @@ Known issues:\n - On low-end connections, things such as command summoning a player that is currently logging in (already visible to other players) may cause the player to freeze, consequently freezing the account as well since the server-side disconnection doesn't happen.\n - Reportedly, there are cases where mob positions fail to sync between player's client-view.\n - Visual equip EXP watch value will present stuttering for early levels requirement (EXP needed less than 100), and requirement at level 200 will not progress at all due to the level cap in client.\n+- Monster Magnet will crash the player when trying to pull fixed monsters.\n ---------------------------\n \n ---------------------------"}, {"sha": "05f5a035f82c1e81ff2d21a52a0df6167ba1e148", "filename": "docs/mychanges_ptbr.txt", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/docs/mychanges_ptbr.txt", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/docs/mychanges_ptbr.txt", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/docs/mychanges_ptbr.txt?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -1907,4 +1907,45 @@ Corrigido m\u00e9todos de chegagem por espa\u00e7o de invent\u00e1rios n\u00e3o avaliando corret\n Corrigido minigames n\u00e3o retirando refer\u00eancias dos jogadores devidamente, problema que veio a ocorrer ap\u00f3s atualiza\u00e7\u00f5es recentes.\n Implementado requisi\u00e7\u00e3o de sa\u00edda de minigames ap\u00f3s fim de partida.\n Corrigido possibilidade de minigames entregando mais de um resultado cada partida (jogadores podem decidir desistir em conjunto, somando pontos).\n-Corrigido nega\u00e7\u00e3o de empate em minigame pelo outro jogador n\u00e3o permitindo o mesmo lan\u00e7ar um pedido de empate em sequ\u00eancia.\n\\ No newline at end of file\n+Corrigido nega\u00e7\u00e3o de empate em minigame pelo outro jogador n\u00e3o permitindo o mesmo lan\u00e7ar um pedido de empate em sequ\u00eancia.\n+\n+02 - 03 Junho 2019,\n+Tentativa de corre\u00e7\u00e3o de mais casos de skill \"Monster Magnet\" desconectando jogadores ao utiliz\u00e1-la (tentativa n\u00e3o foi bem-sucedida, mas apresenta resultados para bosses ou mobs fixos, mutuamente exclusivos).\n+\n+04 Junho 2019,\n+Aprimorado sistema de update de buffs condicionais, n\u00e3o mais atualizando todos os buffs ao mudar de mapas.\n+\n+05 Junho 2019,\n+Refatorado uso da DB pelo Duey. Itens registrados pelo Duey agora compartilham da mesma tabela de itens e equipamentos que os demais.\n+Revisado levemente transa\u00e7\u00e3o de itens pelas diversas intera\u00e7\u00f5es dispon\u00edveis (trades, shops, Duey, at\u00e9 checagem de item ao anunciar pelo megafone), adotando uso das server flags.\n+Corrigido caso de unlock n\u00e3o-encapsulado no hitLock de reatores.\n+\n+07 - 08 Junho 2019,\n+Corrigido NPCs de cosm\u00e9ticos desconectando jogadores ao tentar mostrar ao jogador uma lista sem op\u00e7\u00f5es.\n+Corrigido caso de deadlock ao realizar update de buffs durante transi\u00e7\u00e3o de mapas.\n+\n+09 Junho 2019,\n+Corrigido falhas na detec\u00e7\u00e3o de objetos dentro do alcan\u00e7e de mob skills, c\u00f3digo anterior levava em conta atributo \"facingLeft\" desnecess\u00e1rio para c\u00e1lculo da \u00e1rea de efeito.\n+Revisado sistema de aggro n\u00e3o mais retirando persegui\u00e7\u00e3o de boss sobre jogadores ap\u00f3s expirar contagem de aggro.\n+Refatorado checagem desnecess\u00e1ria por mapas onde itens n\u00e3o expiram (n\u00e3o havia efeito na checagem, itens expir\u00e1veis s\u00e3o determinados mais \u00e0 frente com tempo de expira\u00e7\u00e3o m\u00e1ximo).\n+Corrigido chalkboard removendo unidade do invent\u00e1rio ao usar (usa-se \u00e0 vontade, por um curto per\u00edodo).\n+Corrigido detec\u00e7\u00e3o de \"mob virado para um lado\" atuando incorretamente para mobs fixos n\u00e3o-vir\u00e1veis (resultado deveria ser sempre a mesma orienta\u00e7\u00e3o para esse caso).\n+\n+10 Junho 2019,\n+Refatorado MapleMapFactory, buscando normalizar o padr\u00e3o de design \"Factory\" que fora implementado inicialmente. Com a adi\u00e7\u00e3o de novas funcionalidades o padr\u00e3o implementado perdeu um pouco de sua coes\u00e3o, agora revisado.\n+Adicionado sistema de recupera\u00e7\u00e3o de MP para mobs, evitando assim possibilidade de mobs faltarem com MP em lutas muito longas.\n+Adicionado no sistema de buff condicionais suporte para condicional de \"ca\u00e7ando em grupo\" (dois ou mais membros de grupo no mesmo mapa).\n+Corrigido indisponibilidade de certos loots de mobs para jogadores que poderiam obter o mesmo mas que n\u00e3o fazem parte do grupo que lidou o golpe final (somente o grupo citado era levado em considera\u00e7\u00e3o).\n+Corrigido loots one-of-a-kind se tornando indispon\u00edvel uma vez que o jogador possui o mesmo em seu invent\u00e1rio.\n+\n+11 - 12 Junho 2019,\n+Refatorado objeto construtor de intervalos para fora da classe encarregada com \"Party Search\", agora servindo como objeto de prop\u00f3sito-geral.\n+Revisado sistema de distribui\u00e7\u00e3o de EXP, agora seguindo c\u00e1lculos mais chegados ao GMS-like.\n+\n+13 Junho 2019,\n+Ajustado novamente portal que acessa \u00e1rea do NPC Nein Spirit's Baby Dragon. Somente acessa a \u00e1rea quem completou a quest inicial do NPC.\n+Ajustado intera\u00e7\u00e3o com mapa do NPC Nein Spirit's Baby Dragon. Acesso \u00e0 \u00e1rea \u00e9 restrita para um jogador por vez, tempo limitado, e somente se o mesmo pode/j\u00e1 interagiu com o NPC.\n+Normalizado uso de lobbyids em in\u00edcio de eventos nos scripts.\n+\n+15 Junho 2019,\n+Corrigido limites de requisitos de n\u00edvel para acessar expedi\u00e7\u00f5es nos scripts de NPCs que as gerenciam.\n\\ No newline at end of file"}, {"sha": "2b47f24e13d036a1c6810c154717dc3afe7bd905", "filename": "scripts/event/NineSpirit.js", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/event/NineSpirit.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/event/NineSpirit.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/event/NineSpirit.js?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -0,0 +1,105 @@\n+var minPlayers = 1;\n+var timeLimit = 5; //5 minutes\n+var eventTimer = 1000 * 60 * timeLimit;\n+var exitMap = 240040610;\n+var eventMap = 240040611;\n+\n+var minMapId = 240040611;\n+var maxMapId = 240040611;\n+\n+function init(){}\n+\n+function setup(difficulty, lobbyId){\n+\tvar eim = em.newInstance(\"NineSpirit_\" +lobbyId);\n+\teim.getInstanceMap(eventMap).resetFully();\n+\teim.getInstanceMap(eventMap).allowSummonState(false);\n+\trespawn(eim);\n+\teim.startEventTimer(eventTimer);\n+\treturn eim;\n+}\n+\n+function afterSetup(eim){}\n+\n+function respawn(eim){}\n+\n+function playerEntry(eim, player){\n+\tvar nest = eim.getMapInstance(eventMap);\n+        if (!player.haveItem(4001094)) {\n+            eim.spawnNpc(2081008, nest.getReactorById(2406000).getPosition(), nest);\n+        }\n+        \n+\tplayer.changeMap(nest, 1);\n+}\n+\n+function scheduledTimeout(eim){\n+\tvar party = eim.getPlayers();\n+\n+\tfor(var i = 0; i < party.size(); i++)\n+\t\tplayerExit(eim, party.get(i));\n+\n+\teim.dispose();\n+}\n+\n+function playerRevive(eim, player){\n+\tplayer.respawn(eim, exitMap);\n+\treturn false;\n+}\n+\n+function playerDead(eim, player){}\n+\n+function playerDisconnected(eim, player){\n+\tvar party = eim.getPlayers();\n+\n+\tfor(var i = 0; i < party.size(); i++){\n+\t\tif(party.get(i).equals(player))\n+\t\t\tremovePlayer(eim, player);\n+\t\telse\n+\t\t\tplayerExit(eim, party.get(i));\n+\t}\n+\teim.dispose();\n+}\n+\n+function monsterValue(eim, mobId){\n+\treturn -1;\n+}\n+\n+function leftParty(eim, player){}\n+\n+function disbandParty(eim){}\n+\n+function playerUnregistered(eim, player){}\n+\n+function playerExit(eim, player){\n+\teim.unregisterPlayer(player);\n+\tplayer.changeMap(exitMap);\n+}\n+\n+function changedMap(eim, chr, mapid){\n+\tif(mapid < minMapId || mapid > maxMapId){\n+\t\tremovePlayer(eim, chr);\n+\t\teim.stopEventTimer();\n+\t\teim.setEventCleared();\n+\t\teim.dispose();\n+\t}\n+}\n+\n+function removePlayer(eim, player){\n+\teim.unregisterPlayer(player);\n+\tplayer.getMap().removePlayer(player);\n+\tplayer.setMap(exitMap);\n+}\n+\n+function cancelSchedule(){}\n+\n+function dispose(){}\n+\n+function clearPQ(eim){}\n+\n+function monsterKilled(mob, eim){}\n+\n+function allMonstersDead(eim){}\n+\n+// ---------- FILLER FUNCTIONS ----------\n+\n+function changedLeader(eim, leader) {}\n+"}, {"sha": "35baa8c0dcd9dd0905ba1c86b7f320f5c64f2bb6", "filename": "scripts/event/Puppeteer.js", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/event/Puppeteer.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/event/Puppeteer.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/event/Puppeteer.js?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -4,6 +4,9 @@ var eventTimer = 1000 * 60 * timeLimit;\n var exitMap = 105070300;\n var eventMap = 910510000;\n \n+var minMapId = 910510000;\n+var maxMapId = 910510000;\n+\n function init(){}\n \n function setup(difficulty, lobbyId){\n@@ -67,9 +70,9 @@ function playerExit(eim, player){\n \tplayer.changeMap(exitMap);\n }\n \n-function changedMap(eim, player){\n-\tif(player.getMap().getId() < eventMap || player.getMap().getId() > next){\n-\t\tremovePlayer(eim, player);\n+function changedMap(eim, chr, mapid){\n+\tif(mapid < minMapId || mapid > maxMapId){\n+\t\tremovePlayer(eim, chr);\n \t\teim.stopEventTimer();\n \t\teim.setEventCleared();\n \t\teim.dispose();"}, {"sha": "545218e1e172f9540d16fbcd92577c015b37e7b8", "filename": "scripts/npc/1061014.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/npc/1061014.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/npc/1061014.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/1061014.js?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -58,7 +58,7 @@ function action(mode, type, selection) {\n         }\n \n         if (status == 0) {\n-            if (player.getLevel() < exped.getMinLevel() && player.getLevel() > exped.getMaxLevel()) { //Don't fit requirement\n+            if (player.getLevel() < exped.getMinLevel() || player.getLevel() > exped.getMaxLevel()) { //Don't fit requirement, thanks Conrad\n                 cm.sendOk(\"You do not meet the criteria to battle \" + expedBoss + \"!\");\n                 cm.dispose();\n             } else if (expedition == null) { //Start an expedition"}, {"sha": "29bd5ec7c84a1be22d0cd7e151868e5a6487e8f8", "filename": "scripts/npc/1300013.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/npc/1300013.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/npc/1300013.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/1300013.js?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -48,7 +48,7 @@ function action(mode, type, selection){\n                                 \n                                 var party = cm.getPlayer().getParty();\n                                 if (party != null) {\n-                                    if (!em.startInstance(party, cm.getMap())) {\n+                                    if (!em.startInstance(party, cm.getMap(), 1)) {\n                                         cm.sendOk(\"Another party is already challenging the boss in this channel.\");\n                                     }\n                                 } else {"}, {"sha": "d62e8f1ee2249dc21a0e26d85d75c226f9946904", "filename": "scripts/npc/2030013.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/npc/2030013.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/npc/2030013.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/2030013.js?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -59,7 +59,7 @@ function action(mode, type, selection) {\n         }\n \n         if (status == 0) {\n-            if (player.getLevel() < exped.getMinLevel() && player.getLevel() > exped.getMaxLevel()) { //Don't fit requirement\n+            if (player.getLevel() < exped.getMinLevel() || player.getLevel() > exped.getMaxLevel()) { //Don't fit requirement, thanks Conrad\n                 cm.sendOk(\"You do not meet the criteria to battle \" + expedBoss + \"!\");\n                 cm.dispose();\n             } else if (expedition == null) { //Start an expedition"}, {"sha": "b0501ee64d221685f844217e0fafb2d6e8e33902", "filename": "scripts/npc/2083004.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/npc/2083004.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/npc/2083004.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/2083004.js?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -57,7 +57,7 @@ function action(mode, type, selection) {\n         }\n \n         if (status == 0) {\n-            if (player.getLevel() < exped.getMinLevel() && player.getLevel() > exped.getMaxLevel()) { //Don't fit requirement\n+            if (player.getLevel() < exped.getMinLevel() || player.getLevel() > exped.getMaxLevel()) { //Don't fit requirement, thanks Conrad\n                 cm.sendOk(\"You do not meet the criteria to battle \" + expedBoss + \"!\");\n                 cm.dispose();\n             } else if (expedition == null) { //Start an expedition"}, {"sha": "12bdba353ab993808f1850d2ac3d8398c21c8d03", "filename": "scripts/npc/2141001.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/npc/2141001.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/npc/2141001.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/2141001.js?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -60,7 +60,7 @@ function action(mode, type, selection) {\n         }\n \n         if (status == 0) {\n-            if (player.getLevel() < exped.getMinLevel() && player.getLevel() > exped.getMaxLevel()) { //Don't fit requirement\n+            if (player.getLevel() < exped.getMinLevel() || player.getLevel() > exped.getMaxLevel()) { //Don't fit requirement, thanks Conrad\n                 cm.sendOk(\"You do not meet the criteria to battle \" + expedBoss + \"!\");\n                 cm.dispose();\n             } else if (expedition == null) { //Start an expedition"}, {"sha": "fd201e1de3875467b174321ee555b7839d2d05f0", "filename": "scripts/npc/9120201.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/npc/9120201.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/npc/9120201.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/9120201.js?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -58,7 +58,7 @@ function action(mode, type, selection) {\n         }\n \n         if (status == 0) {\n-            if (player.getLevel() < exped.getMinLevel() && player.getLevel() > exped.getMaxLevel()) { //Don't fit requirement\n+            if (player.getLevel() < exped.getMinLevel() || player.getLevel() > exped.getMaxLevel()) { //Don't fit requirement, thanks Conrad\n                 cm.sendOk(\"You do not meet the criteria to battle \" + expedBoss + \"!\");\n                 cm.dispose();\n             } else if (expedition == null) { //Start an expedition"}, {"sha": "fa7b31b74361a2febbfe28e90521ad03d5b8ca9e", "filename": "scripts/npc/9201113.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/npc/9201113.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/npc/9201113.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/9201113.js?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -54,7 +54,7 @@ function action(mode, type, selection) {\n         }\n \n         if (status == 0) {\n-            if (player.getLevel() < cwkpq.getMinLevel() && player.getLevel() > cwkpq.getMaxLevel()) { //Don't fit requirement\n+            if (player.getLevel() < cwkpq.getMinLevel() || player.getLevel() > cwkpq.getMaxLevel()) { //Don't fit requirement, thanks Conrad\n                 cm.sendOk(\"You do not meet the criteria to take attempt Crimsonwood Keep Party Quest!\");\n                 cm.dispose();\n             } else if (expedition == null) { //Start an expedition"}, {"sha": "a660524100aa6b0f61b350b1e5142c2d64ca2c1e", "filename": "scripts/npc/9270047.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/npc/9270047.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/npc/9270047.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/9270047.js?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -59,7 +59,7 @@ function action(mode, type, selection) {\n         }\n \n         if (status == 0) {\n-            if (player.getLevel() < exped.getMinLevel() && player.getLevel() > exped.getMaxLevel()) { //Don't fit requirement\n+            if (player.getLevel() < exped.getMinLevel() || player.getLevel() > exped.getMaxLevel()) { //Don't fit requirement, thanks Conrad\n                 cm.sendOk(\"You do not meet the criteria to battle \" + expedBoss + \"!\");\n                 cm.dispose();\n             } else if (expedition == null) { //Start an expedition"}, {"sha": "de76ba2802b3995526de8476cbd375c901fc8b18", "filename": "scripts/portal/TD_MC_enterboss2.js", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/portal/TD_MC_enterboss2.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/portal/TD_MC_enterboss2.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/portal/TD_MC_enterboss2.js?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -29,7 +29,7 @@ function enter(pi) {\n         if (party != null) {\n             var eli = em.getEligibleParty(pi.getParty());   // thanks Conrad for pointing out missing eligible party declaration here\n             if(eli.size() > 0) {\n-                if (em.startInstance(party, pi.getMap())) {\n+                if (em.startInstance(party, pi.getMap(), 1)) {\n                     pi.playPortalSound();\n                     return true;\n                 } else {\n@@ -54,7 +54,7 @@ function enter(pi) {\n         if (party != null) {\n             var eli = em.getEligibleParty(pi.getParty());\n             if(eli.size() > 0) {\n-                if (em.startInstance(1, party, pi.getMap())) {\n+                if (em.startInstance(party, pi.getMap(), 1)) {\n                     pi.playPortalSound();\n                     return true;\n                 } else {"}, {"sha": "db3f4b75bd6710b3546afb83252a15fa5e252160", "filename": "scripts/portal/dragonNest.js", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/portal/dragonNest.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/portal/dragonNest.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/portal/dragonNest.js?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -20,11 +20,20 @@\n     along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n function enter(pi) {\n-        if (!pi.isQuestStarted(100203)) { // thanks Conrad for suggesting grant players access to area with Nein Spirit's Baby Dragon after hatching egg\n-            pi.playPortalSound(); pi.warp(240040611, \"out00\");\n+    if (pi.isQuestCompleted(3706)) {\n+        pi.playPortalSound(); pi.warp(240040612, \"out00\");\n+        return true;\n+    } else if (pi.isQuestStarted(100203) || pi.getPlayer().haveItem(4001094)) {\n+        var em = pi.getEventManager(\"NineSpirit\");\n+        if (!em.startInstance(pi.getPlayer())) {\n+            pi.message(\"There is currently someone in this map, come back later.\");\n+            return false;\n         } else {\n-            pi.playPortalSound(); pi.warp(240040612, \"out00\");\n+            pi.playPortalSound();\n+            return true;\n         }\n-    \n-\treturn true;\n+    } else {\n+        pi.message(\"A strange force is blocking you from entering.\");\n+        return false;\n+    }\n }\n\\ No newline at end of file"}, {"sha": "2297187d0492a262c4949811654cccd8983a4a23", "filename": "scripts/reactor/2406000.js", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/reactor/2406000.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/scripts/reactor/2406000.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/reactor/2406000.js?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -3,9 +3,9 @@ Dragon nest\n */\n \n function sendToHeaven() {\n-    rm.destroyNpc(2081008);\n-    rm.mapMessage(6, \"In a flicker of light, Nine Spirit's Little Dragon returns to the place it belongs, high above the skies.\");\n-    rm.getReactor().getMap().resetReactors();\n+    rm.spawnNpc(2081008);\n+    rm.startQuest(100203);\n+    rm.mapMessage(6, \"In a flicker of light the egg has matured and cracked, thus born a radiant baby dragon.\");\n }\n \n function touch() {\n@@ -18,9 +18,5 @@ function touch() {\n function untouch() {}\n \n function act() {\n-    rm.message(\"With your latest efforts the egg has matured and cracked, thus born a radiant baby dragon.\");\n-    rm.startQuest(100203);\n-    \n-    rm.spawnNpc(2081008);\n-    rm.schedule(\"sendToHeaven\", 12 * 1000);\n+    sendToHeaven();     // thanks Conrad for pointing out the GMS-like way of Nine Spirit's Nest\n }\n\\ No newline at end of file"}, {"sha": "857857152ed09d104619b4a99444e3dba5710614", "filename": "sql/db_database.sql", "status": "modified", "additions": 3, "deletions": 51, "changes": 54, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/sql/db_database.sql", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/sql/db_database.sql", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/sql/db_database.sql?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -12800,30 +12800,9 @@ INSERT INTO `drop_data_global` (`id`, `continent`, `itemid`, `minimum_quantity`,\n CREATE TABLE IF NOT EXISTS `dueyitems` (\n   `id` int(10) unsigned NOT NULL AUTO_INCREMENT,\n   `PackageId` int(10) unsigned NOT NULL DEFAULT '0',\n-  `itemid` int(10) unsigned NOT NULL DEFAULT '0',\n-  `quantity` int(10) unsigned NOT NULL DEFAULT '0',\n-  `upgradeslots` int(11) DEFAULT '0',\n-  `level` int(11) DEFAULT '0',\n-  `itemlevel` int(11) DEFAULT '0',\n-  `itemexp` int(11) DEFAULT '0',\n-  `str` int(11) DEFAULT '0',\n-  `dex` int(11) DEFAULT '0',\n-  `int` int(11) DEFAULT '0',\n-  `luk` int(11) DEFAULT '0',\n-  `hp` int(11) DEFAULT '0',\n-  `mp` int(11) DEFAULT '0',\n-  `watk` int(11) DEFAULT '0',\n-  `matk` int(11) DEFAULT '0',\n-  `wdef` int(11) DEFAULT '0',\n-  `mdef` int(11) DEFAULT '0',\n-  `acc` int(11) DEFAULT '0',\n-  `avoid` int(11) DEFAULT '0',\n-  `hands` int(11) DEFAULT '0',\n-  `speed` int(11) DEFAULT '0',\n-  `jump` int(11) DEFAULT '0',\n-  `flag` int(11) DEFAULT '0',\n-  `owner` varchar(13) DEFAULT NULL,\n+  `inventoryitemid` int(10) unsigned NOT NULL DEFAULT '0',\n   PRIMARY KEY (`id`),\n+  KEY `INVENTORYITEMID` (`inventoryitemid`),\n   KEY `PackageId` (`PackageId`)\n ) ENGINE=InnoDB DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;\n \n@@ -12833,8 +12812,8 @@ CREATE TABLE IF NOT EXISTS `dueypackages` (\n   `SenderName` varchar(13) NOT NULL,\n   `Mesos` int(10) unsigned DEFAULT '0',\n   `TimeStamp` varchar(10) NOT NULL,\n+  `Message` varchar(200) NOT NULL DEFAULT \"\",\n   `Checked` tinyint(1) unsigned DEFAULT '1',\n-  `Type` tinyint(1) unsigned NOT NULL,\n   PRIMARY KEY (`PackageId`)\n ) ENGINE=InnoDB DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;\n \n@@ -12909,33 +12888,6 @@ CREATE TABLE IF NOT EXISTS `guilds` (\n   INDEX (guildid, name)\n ) ENGINE=InnoDB DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;\n \n-CREATE TABLE IF NOT EXISTS `hiredmerchant` (\n-  `id` int(11) NOT NULL AUTO_INCREMENT,\n-  `ownerid` int(11) DEFAULT '0',\n-  `itemid` int(10) unsigned NOT NULL DEFAULT '0',\n-  `quantity` int(10) unsigned NOT NULL DEFAULT '0',\n-  `upgradeslots` int(11) DEFAULT '0',\n-  `level` int(11) DEFAULT '0',\n-  `str` int(11) DEFAULT '0',\n-  `dex` int(11) DEFAULT '0',\n-  `int` int(11) DEFAULT '0',\n-  `luk` int(11) DEFAULT '0',\n-  `hp` int(11) DEFAULT '0',\n-  `mp` int(11) DEFAULT '0',\n-  `watk` int(11) DEFAULT '0',\n-  `matk` int(11) DEFAULT '0',\n-  `wdef` int(11) DEFAULT '0',\n-  `mdef` int(11) DEFAULT '0',\n-  `acc` int(11) DEFAULT '0',\n-  `avoid` int(11) DEFAULT '0',\n-  `hands` int(11) DEFAULT '0',\n-  `speed` int(11) DEFAULT '0',\n-  `jump` int(11) DEFAULT '0',\n-  `owner` varchar(13) DEFAULT '',\n-  `type` tinyint(1) unsigned NOT NULL,\n-  PRIMARY KEY (`id`)\n-) ENGINE=InnoDB DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;\n-\n CREATE TABLE IF NOT EXISTS `hwidaccounts` (\n   `accountid` int(11) NOT NULL DEFAULT '0',\n   `hwid` varchar(40) NOT NULL DEFAULT '',"}, {"sha": "d2a3d304021e7bf152221597465c5f67f0db5b30", "filename": "src/client/MapleCharacter.java", "status": "modified", "additions": 60, "deletions": 27, "changes": 87, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/client/MapleCharacter.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/client/MapleCharacter.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/client/MapleCharacter.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -84,13 +84,12 @@\n import server.events.gm.MapleOla;\n import server.life.MapleMonster;\n import server.life.MobSkill;\n-import server.loot.MapleLootManager;\n import server.maps.MapleHiredMerchant;\n import server.maps.MapleDoor;\n import server.maps.MapleDragon;\n import server.maps.MapleMap;\n import server.maps.MapleMapEffect;\n-import server.maps.MapleMapFactory;\n+import server.maps.MapleMapManager;\n import server.maps.MapleMapObject;\n import server.maps.MapleMapObjectType;\n import server.maps.MapleMiniGame;\n@@ -3489,7 +3488,7 @@ private MapleBuffStatValueHolder fetchBestEffectFromItemEffectHolder(MapleBuffSt\n         for(Entry<Integer, Map<MapleBuffStat, MapleBuffStatValueHolder>> bpl: buffEffects.entrySet()) {\n             MapleBuffStatValueHolder mbsvhi = bpl.getValue().get(mbs);\n             if(mbsvhi != null) {\n-                if(!mbsvhi.effect.isActive(mapid)) {\n+                if(!mbsvhi.effect.isActive(this)) {\n                     continue;\n                 }\n                 \n@@ -3714,17 +3713,57 @@ public boolean cancelEffect(MapleStatEffect effect, boolean overwrite, long star\n         }\n     }\n     \n+    private static MapleStatEffect getEffectFromBuffSource(Map<MapleBuffStat, MapleBuffStatValueHolder> buffSource) {\n+        try {\n+            return buffSource.entrySet().iterator().next().getValue().effect;\n+        } catch (Exception e) {\n+            return null;\n+        }\n+    }\n+    \n+    private boolean isUpdatingEffect(Set<MapleStatEffect> activeEffects, MapleStatEffect mse) {\n+        if (mse == null) return false;\n+        \n+        // thanks xinyifly for noticing \"Speed Infusion\" crashing game when updating buffs during map transition\n+        boolean active = mse.isActive(this);\n+        if (active) {\n+            return !activeEffects.contains(mse);\n+        } else {\n+            return activeEffects.contains(mse);\n+        }\n+    }\n+    \n     public void updateActiveEffects() {\n-        chrLock.lock();\n+        effLock.lock();     // thanks davidlafriniere, maple006, RedHat for pointing a deadlock occurring here\n         try {\n-            effects.clear();\n-            updateEffects(buffEffectsCount.keySet());\n+            Set<MapleBuffStat> updatedBuffs = new LinkedHashSet<>();\n+            Set<MapleStatEffect> activeEffects = new LinkedHashSet<>();\n+            \n+            for (MapleBuffStatValueHolder mse : effects.values()) {\n+                activeEffects.add(mse.effect);\n+            }\n+            \n+            for (Map<MapleBuffStat, MapleBuffStatValueHolder> buff : buffEffects.values()) {\n+                MapleStatEffect mse = getEffectFromBuffSource(buff);\n+                if (isUpdatingEffect(activeEffects, mse)) {\n+                    for (Pair<MapleBuffStat, Integer> p : mse.getStatups()) {\n+                        updatedBuffs.add(p.getLeft());\n+                    }\n+                }\n+            }\n+            \n+            for (MapleBuffStat mbs : updatedBuffs) {\n+                effects.remove(mbs);\n+            }\n+            \n+            updateEffects(updatedBuffs);\n         } finally {\n-            chrLock.unlock();\n+            effLock.unlock();\n         }\n     }\n     \n     private void updateEffects(Set<MapleBuffStat> removedStats) {\n+        effLock.lock();\n         chrLock.lock();\n         try {\n             Set<MapleBuffStat> retrievedStats = new LinkedHashSet<>();\n@@ -3743,6 +3782,7 @@ private void updateEffects(Set<MapleBuffStat> removedStats) {\n             propagateBuffEffectUpdates(new LinkedHashMap<Integer, Pair<MapleStatEffect, Long>>(), retrievedStats, removedStats);\n         } finally {\n             chrLock.unlock();\n+            effLock.unlock();\n         }\n     }\n     \n@@ -4169,6 +4209,12 @@ private static boolean isSingletonStatup(MapleBuffStat mbs) {\n             case COUPON_DRP1:\n             case COUPON_DRP2:\n             case COUPON_DRP3:\n+            case MESO_UP_BY_ITEM:\n+            case ITEM_UP_BY_ITEM:\n+            case RESPECT_PIMMUNE:\n+            case RESPECT_MIMMUNE:\n+            case DEFENSE_ATT:\n+            case DEFENSE_STATE:\n             case WATK:\n             case WDEF:\n             case MATK:\n@@ -4314,7 +4360,7 @@ public void run() {\n                 appliedStatups.put(ps.getLeft(), new MapleBuffStatValueHolder(effect, starttime, ps.getRight()));\n             }\n             \n-            boolean active = effect.isActive(mapid);\n+            boolean active = effect.isActive(this);\n             if(ServerConstants.USE_BUFF_MOST_SIGNIFICANT) {\n                 toDeploy = new LinkedHashMap<>();\n                 Map<Integer, Pair<MapleStatEffect, Long>> retrievedEffects = new LinkedHashMap<>();\n@@ -5289,20 +5335,6 @@ public boolean isPartyMember(int cid) {\n         return false;\n     }\n     \n-    public List<MonsterDropEntry> retrieveRelevantDrops(int monsterId) {\n-        List<MapleCharacter> pchars = new LinkedList<>();\n-        for (MapleCharacter chr : getPartyMembers()) {\n-            if (chr.isLoggedinWorld()) {\n-                pchars.add(chr);\n-            }\n-        }\n-        \n-        if (pchars.isEmpty()) {\n-            pchars.add(this);\n-        }\n-        return MapleLootManager.retrieveRelevantDrops(monsterId, pchars);\n-    }\n-\n     public MaplePlayerShop getPlayerShop() {\n         return playerShop;\n     }\n@@ -6507,9 +6539,10 @@ private void revertCouponRates() {\n     }\n     \n     public void updateCouponRates() {\n+        MapleInventory cashInv = this.getInventory(MapleInventoryType.CASH);\n+        if (cashInv == null) return;\n+        \n         if (cpnLock.tryLock()) {\n-            MapleInventory cashInv = this.getInventory(MapleInventoryType.CASH);\n-            \n             effLock.lock();\n             chrLock.lock();\n             cashInv.lockInventory();\n@@ -6944,11 +6977,11 @@ public static MapleCharacter loadCharFromDB(int charid, MapleClient client, bool\n             ret.commitExcludedItems();\n             \n             if (channelserver) {\n-                MapleMapFactory mapFactory = client.getChannelServer().getMapFactory();\n-                ret.map = mapFactory.getMap(ret.mapid);\n+                MapleMapManager mapManager = client.getChannelServer().getMapFactory();\n+                ret.map = mapManager.getMap(ret.mapid);\n                 \n                 if (ret.map == null) {\n-                    ret.map = mapFactory.getMap(100000000);\n+                    ret.map = mapManager.getMap(100000000);\n                 }\n                 MaplePortal portal = ret.map.getPortal(ret.initialSpawnPoint);\n                 if (portal == null) {"}, {"sha": "e97f41c7de76491dac8a0873315cd32cbd77cc0a", "filename": "src/client/command/commands/gm1/GotoCommand.java", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/client/command/commands/gm1/GotoCommand.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/client/command/commands/gm1/GotoCommand.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/client/command/commands/gm1/GotoCommand.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -33,7 +33,7 @@\n import server.MaplePortal;\n import server.maps.FieldLimit;\n import server.maps.MapleMap;\n-import server.maps.MapleMapFactory;\n+import server.maps.MapleMapManager;\n import server.maps.MapleMiniDungeonInfo;\n \n import java.util.Comparator;\n@@ -47,18 +47,18 @@\n     {\n         setDescription(\"\");\n         \n-        MapleMapFactory mapFactory = Server.getInstance().getWorlds().get(0).getChannels().get(0).getMapFactory();\n+        MapleMapManager mapManager = Server.getInstance().getWorlds().get(0).getChannels().get(0).getMapFactory();\n         \n         List<Entry<String, Integer>> towns = new ArrayList<>(GameConstants.GOTO_TOWNS.entrySet());\n         sortGotoEntries(towns);\n         for (Map.Entry<String, Integer> e : towns) {\n-            GOTO_TOWNS_INFO += (\"'\" + e.getKey() + \"' - #b\" + (mapFactory.getMap(e.getValue()).getMapName()) + \"#k\\r\\n\");\n+            GOTO_TOWNS_INFO += (\"'\" + e.getKey() + \"' - #b\" + (mapManager.getMap(e.getValue()).getMapName()) + \"#k\\r\\n\");\n         }\n         \n         List<Entry<String, Integer>> areas = new ArrayList<>(GameConstants.GOTO_AREAS.entrySet());\n         sortGotoEntries(areas);\n         for (Map.Entry<String, Integer> e : areas) {\n-            GOTO_AREAS_INFO += (\"'\" + e.getKey() + \"' - #b\" + (mapFactory.getMap(e.getValue()).getMapName()) + \"#k\\r\\n\");\n+            GOTO_AREAS_INFO += (\"'\" + e.getKey() + \"' - #b\" + (mapManager.getMap(e.getValue()).getMapName()) + \"#k\\r\\n\");\n         }\n     }\n     \n@@ -103,6 +103,7 @@ public void execute(MapleClient c, String[] params) {\n         HashMap<String, Integer> gotomaps;\n         if (player.isGM()) {\n             gotomaps = new HashMap<>(GameConstants.GOTO_AREAS);     // distinct map registry for GM/users suggested thanks to Vcoc\n+            gotomaps.putAll(GameConstants.GOTO_TOWNS);  // thanks Halcyon for pointing out duplicates on listed entries functionality\n         } else {\n             gotomaps = new HashMap<>(GameConstants.GOTO_TOWNS);\n         }"}, {"sha": "4dab3c2a7b01b94407fc9fc990227c05c7b25f70", "filename": "src/client/inventory/ItemFactory.java", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/client/inventory/ItemFactory.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/client/inventory/ItemFactory.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/client/inventory/ItemFactory.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -46,13 +46,16 @@\n     CASH_ARAN(5, true),\n     MERCHANT(6, false),\n     CASH_OVERALL(7, true),\n-    MARRIAGE_GIFTS(8, false);\n+    MARRIAGE_GIFTS(8, false),\n+    DUEY(9, false);\n     private final int value;\n     private final boolean account;\n-    private static final Lock locks[] = new Lock[200];  // thanks Masterrulax for pointing out a bottleneck issue here\n+    \n+    private static final int lockCount = 400;\n+    private static final Lock locks[] = new Lock[lockCount];  // thanks Masterrulax for pointing out a bottleneck issue here\n     \n     static {\n-        for (int i = 0; i < 200; i++) {\n+        for (int i = 0; i < lockCount; i++) {\n             locks[i] = MonitoredReentrantLockFactory.createLock(MonitoredLockType.ITEM, true);\n         }\n     }\n@@ -75,7 +78,9 @@ public void saveItems(List<Pair<Item, MapleInventoryType>> items, int id, Connec\n         saveItems(items, null, id, con);\n     }\n     \n-    public synchronized void saveItems(List<Pair<Item, MapleInventoryType>> items, List<Short> bundlesList, int id, Connection con) throws SQLException {\n+    public void saveItems(List<Pair<Item, MapleInventoryType>> items, List<Short> bundlesList, int id, Connection con) throws SQLException {\n+        // thanks Arufonsu, MedicOP, BHB for pointing a \"synchronized\" bottleneck here\n+        \n         if(value != 6) saveItemsCommon(items, id, con);\n         else saveItemsMerchant(items, bundlesList, id, con);\n     }\n@@ -199,7 +204,7 @@ private void saveItemsCommon(List<Pair<Item, MapleInventoryType>> items, int id,\n         PreparedStatement pse = null;\n         ResultSet rs = null;\n \n-        Lock lock = locks[id % 200];\n+        Lock lock = locks[id % lockCount];\n         lock.lock();\n         try {\n             StringBuilder query = new StringBuilder();\n@@ -365,7 +370,7 @@ private void saveItemsMerchant(List<Pair<Item, MapleInventoryType>> items, List<\n         PreparedStatement pse = null;\n         ResultSet rs = null;\n \n-        Lock lock = locks[id % 200];\n+        Lock lock = locks[id % lockCount];\n         lock.lock();\n         try {\n             ps = con.prepareStatement(\"DELETE FROM `inventorymerchant` WHERE `characterid` = ?\");"}, {"sha": "579dddb25f7b3cc119428fdeda7b1e51999d1ac4", "filename": "src/client/inventory/manipulator/MapleInventoryManipulator.java", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/client/inventory/manipulator/MapleInventoryManipulator.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/client/inventory/manipulator/MapleInventoryManipulator.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/client/inventory/manipulator/MapleInventoryManipulator.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -713,7 +713,7 @@ public static void drop(MapleClient c, MapleInventoryType type, short src, short\n             source.setQuantity((short) (source.getQuantity() - quantity));\n             c.announce(MaplePacketCreator.modifyInventory(true, Collections.singletonList(new ModifyInventory(1, source))));\n             \n-            if(ItemConstants.isNewYearCardEtc(itemId)) {\n+            if (ItemConstants.isNewYearCardEtc(itemId)) {\n                 if(itemId == 4300000) {\n                     NewYearCardRecord.removeAllNewYearCard(true, chr);\n                     c.getAbstractPlayerInteraction().removeAll(4300000);\n@@ -723,13 +723,9 @@ public static void drop(MapleClient c, MapleInventoryType type, short src, short\n                 }\n             } else if (ItemConstants.isWeddingRing(source.getItemId())) {\n                 map.disappearingItemDrop(chr, chr, target, dropPos);\n-            } else if (map.getEverlast()) {\n-                if (ii.isDropRestricted(target.getItemId()) || ii.isCash(target.getItemId()) || isDroppedItemRestricted(target)) {\n-                    map.disappearingItemDrop(chr, chr, target, dropPos);\n-                } else {\n-                    map.spawnItemDrop(chr, chr, target, dropPos, true, true);\n-                }\n-            } else if (ii.isDropRestricted(target.getItemId()) || ii.isCash(target.getItemId()) || isDroppedItemRestricted(target)) {\n+            }\n+            \n+            if (ii.isDropRestricted(target.getItemId()) || ii.isCash(target.getItemId()) || isDroppedItemRestricted(target)) {\n                 map.disappearingItemDrop(chr, chr, target, dropPos);\n             } else {\n                 map.spawnItemDrop(chr, chr, target, dropPos, true, true);\n@@ -750,24 +746,20 @@ public static void drop(MapleClient c, MapleInventoryType type, short src, short\n             c.announce(MaplePacketCreator.modifyInventory(true, Collections.singletonList(new ModifyInventory(3, source))));\n             if (src < 0) {\n                 chr.equipChanged();\n-            } else if(ItemConstants.isNewYearCardEtc(itemId)) {\n-                if(itemId == 4300000) {\n+            } else if (ItemConstants.isNewYearCardEtc(itemId)) {\n+                if (itemId == 4300000) {\n                     NewYearCardRecord.removeAllNewYearCard(true, chr);\n                     c.getAbstractPlayerInteraction().removeAll(4300000);\n                 } else {\n                     NewYearCardRecord.removeAllNewYearCard(false, chr);\n                     c.getAbstractPlayerInteraction().removeAll(4301000);\n                 }\n+            } else if (ItemConstants.isWeddingRing(source.getItemId())) {\n+                map.disappearingItemDrop(chr, chr, source, dropPos);\n             }\n             \n-            if (map.getEverlast()) {\n-                if (ii.isDropRestricted(itemId) || ii.isCash(itemId) || isDroppedItemRestricted(source)) {\n-                    map.disappearingItemDrop(chr, chr, source, dropPos);\n-                } else {\n-                    map.spawnItemDrop(chr, chr, source, dropPos, true, true);\n-                }\n-            } else if (ii.isDropRestricted(itemId) || ii.isCash(itemId) || isDroppedItemRestricted(source)) {\n-                map.disappearingItemDrop(chr, chr, source, dropPos);           \n+            if (ii.isDropRestricted(itemId) || ii.isCash(itemId) || isDroppedItemRestricted(source)) {\n+                map.disappearingItemDrop(chr, chr, source, dropPos);\n             } else {\n                 map.spawnItemDrop(chr, chr, source, dropPos, true, true);\n             }"}, {"sha": "441580918408e3b44285e58d6716cd407359cd4f", "filename": "src/client/processor/DueyProcessor.java", "status": "modified", "additions": 234, "deletions": 223, "changes": 457, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/client/processor/DueyProcessor.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/client/processor/DueyProcessor.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/client/processor/DueyProcessor.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -26,26 +26,31 @@\n import client.MapleCharacter;\n import client.MapleClient;\n import client.autoban.AutobanFactory;\n-import client.inventory.Equip;\n import client.inventory.Item;\n+import client.inventory.ItemFactory;\n+import client.inventory.MapleInventory;\n import client.inventory.MapleInventoryType;\n import client.inventory.manipulator.MapleInventoryManipulator;\n import client.inventory.manipulator.MapleKarmaManipulator;\n import constants.ItemConstants;\n+import constants.ServerConstants;\n import java.sql.Connection;\n import java.sql.PreparedStatement;\n import java.sql.ResultSet;\n import java.sql.SQLException;\n+import java.sql.Statement;\n import java.util.Calendar;\n+import java.util.Collections;\n import java.util.LinkedList;\n import java.util.List;\n import net.server.channel.Channel;\n-import server.DueyPackages;\n+import server.DueyPackage;\n import server.MapleItemInformationProvider;\n import server.MapleTrade;\n import tools.DatabaseConnection;\n import tools.FilePrinter;\n import tools.MaplePacketCreator;\n+import tools.Pair;\n \n /**\n  *\n@@ -86,29 +91,25 @@ public byte getCode() {\n         }\n     }\n     \n-    private static int getAccIdFromCNAME(String name, boolean accountid) {\n+    private static Pair<Integer, Integer> getAccountCharacterIdFromCNAME(String name) {\n         try {\n-            PreparedStatement ps;\n-            String text = \"SELECT id,accountid FROM characters WHERE name = ?\";\n             Connection con = DatabaseConnection.getConnection();\n-            ps = con.prepareStatement(text);\n+            PreparedStatement ps = con.prepareStatement(\"SELECT id,accountid FROM characters WHERE name = ?\");\n             ps.setString(1, name);\n-            int id_;\n+            \n+            Pair<Integer, Integer> id_ = null;\n             try (ResultSet rs = ps.executeQuery()) {\n-                if (!rs.next()) {\n-                    rs.close();\n-                    ps.close();\n-                    return -1;\n+                if (rs.next()) {\n+                    id_ = new Pair<>(rs.getInt(\"accountid\"), rs.getInt(\"id\"));\n                 }\n-                id_ = accountid ? rs.getInt(\"accountid\") : rs.getInt(\"id\");\n             }\n             ps.close();\n             con.close();\n             return id_;\n         } catch (SQLException e) {\n             e.printStackTrace();\n         }\n-        return -1;\n+        return null;\n     }\n     \n     private static String getCurrentDate() {\n@@ -123,67 +124,6 @@ private static String getCurrentDate() {\n         \n         return date;\n     }\n-\n-    private static void removeItemFromDB(int packageid) {\n-        Connection con = null;\n-        try {\n-            con = DatabaseConnection.getConnection();\n-            \n-            PreparedStatement ps = con.prepareStatement(\"DELETE FROM dueypackages WHERE PackageId = ?\");\n-            ps.setInt(1, packageid);\n-            ps.executeUpdate();\n-            ps.close();\n-            ps = con.prepareStatement(\"DELETE FROM dueyitems WHERE PackageId = ?\");\n-            ps.setInt(1, packageid);\n-            ps.executeUpdate();\n-            ps.close();\n-            con.close();\n-        } catch (SQLException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    private static DueyPackages getItemByPID(ResultSet rs) {\n-        try {\n-            DueyPackages dueypack;\n-            if (rs.getInt(\"type\") == 1) {\n-                Equip eq = new Equip(rs.getInt(\"itemid\"), (byte) 0, -1);\n-                eq.setUpgradeSlots((byte) rs.getInt(\"upgradeslots\"));\n-                eq.setLevel((byte) rs.getInt(\"level\"));\n-                eq.setItemLevel((byte) rs.getInt(\"itemlevel\"));\n-                eq.setItemExp(rs.getInt(\"itemexp\"));\n-                eq.setStr((short) rs.getInt(\"str\"));\n-                eq.setDex((short) rs.getInt(\"dex\"));\n-                eq.setInt((short) rs.getInt(\"int\"));\n-                eq.setLuk((short) rs.getInt(\"luk\"));\n-                eq.setHp((short) rs.getInt(\"hp\"));\n-                eq.setMp((short) rs.getInt(\"mp\"));\n-                eq.setWatk((short) rs.getInt(\"watk\"));\n-                eq.setMatk((short) rs.getInt(\"matk\"));\n-                eq.setWdef((short) rs.getInt(\"wdef\"));\n-                eq.setMdef((short) rs.getInt(\"mdef\"));\n-                eq.setAcc((short) rs.getInt(\"acc\"));\n-                eq.setAvoid((short) rs.getInt(\"avoid\"));\n-                eq.setHands((short) rs.getInt(\"hands\"));\n-                eq.setSpeed((short) rs.getInt(\"speed\"));\n-                eq.setJump((short) rs.getInt(\"jump\"));\n-                eq.setFlag((byte) rs.getInt(\"flag\"));\n-                eq.setOwner(rs.getString(\"owner\"));\n-                dueypack = new DueyPackages(rs.getInt(\"PackageId\"), eq);\n-            } else if (rs.getInt(\"type\") == 2) {\n-                Item newItem = new Item(rs.getInt(\"itemid\"), (short) 0, (short) rs.getInt(\"quantity\"));\n-                newItem.setFlag((byte) rs.getInt(\"flag\"));\n-                newItem.setOwner(rs.getString(\"owner\"));\n-                dueypack = new DueyPackages(rs.getInt(\"PackageId\"), newItem);\n-            } else {\n-                dueypack = new DueyPackages(rs.getInt(\"PackageId\"));\n-            }\n-            return dueypack;\n-        } catch (SQLException se) {\n-            se.printStackTrace();\n-            return null;\n-        }\n-    }\n     \n     private static void showDueyNotification(MapleClient c, MapleCharacter player) {\n         Connection con = null;\n@@ -230,120 +170,203 @@ private static void showDueyNotification(MapleClient c, MapleCharacter player) {\n             }\n         }\n     }\n-    \n-    private static void addMesoToDB(int mesos, String sName, int recipientID) {\n-        addItemToDB(null, 1, mesos, sName, recipientID);\n-    }\n \n-    public static void addItemToDB(Item item, int quantity, int mesos, String sName, int recipientID) {\n-        Connection con = null;\n+    private static void deletePackageFromInventoryDB(Connection con, int packageId) throws SQLException {\n+        ItemFactory.DUEY.saveItems(new LinkedList<Pair<Item, MapleInventoryType>>(), packageId, con);\n+    }\n+    \n+    private static void removePackageFromDB(int packageId) {\n         try {\n-            con = DatabaseConnection.getConnection();\n-            try (PreparedStatement ps = con.prepareStatement(\"INSERT INTO dueypackages (ReceiverId, SenderName, Mesos, TimeStamp, Checked, Type) VALUES (?, ?, ?, ?, ?, ?)\")) {\n-                ps.setInt(1, recipientID);\n-                ps.setString(2, sName);\n-                ps.setInt(3, mesos);\n-                ps.setString(4, getCurrentDate());\n-                ps.setInt(5, 1);\n-                if (item == null) {\n-                    ps.setInt(6, 3);\n-                    ps.executeUpdate();\n-                } else {\n-                    ps.setInt(6, item.getItemType());\n-                    \n-                    ps.executeUpdate();\n-                    try (ResultSet rs = ps.getGeneratedKeys()) {\n-                        rs.next();\n-                        PreparedStatement ps2;\n-                        if (item.getInventoryType().equals(MapleInventoryType.EQUIP)) {\n-                            ps2 = con.prepareStatement(\"INSERT INTO dueyitems (PackageId, itemid, quantity, upgradeslots, level, itemlevel, itemexp, str, dex, `int`, luk, hp, mp, watk, matk, wdef, mdef, acc, avoid, hands, speed, jump, flag, owner) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\");\n-                            Equip eq = (Equip) item;\n-                            ps2.setInt(2, eq.getItemId());\n-                            ps2.setInt(3, 1);\n-                            ps2.setInt(4, eq.getUpgradeSlots());\n-                            ps2.setInt(5, eq.getLevel());\n-                            ps2.setInt(6, eq.getItemLevel());\n-                            ps2.setInt(7, eq.getItemExp());\n-                            ps2.setInt(8, eq.getStr());\n-                            ps2.setInt(9, eq.getDex());\n-                            ps2.setInt(10, eq.getInt());\n-                            ps2.setInt(11, eq.getLuk());\n-                            ps2.setInt(12, eq.getHp());\n-                            ps2.setInt(13, eq.getMp());\n-                            ps2.setInt(14, eq.getWatk());\n-                            ps2.setInt(15, eq.getMatk());\n-                            ps2.setInt(16, eq.getWdef());\n-                            ps2.setInt(17, eq.getMdef());\n-                            ps2.setInt(18, eq.getAcc());\n-                            ps2.setInt(19, eq.getAvoid());\n-                            ps2.setInt(20, eq.getHands());\n-                            ps2.setInt(21, eq.getSpeed());\n-                            ps2.setInt(22, eq.getJump());\n-                            ps2.setInt(23, eq.getFlag());\n-                            ps2.setString(24, eq.getOwner());\n-                        } else {\n-                            ps2 = con.prepareStatement(\"INSERT INTO dueyitems (PackageId, itemid, quantity, flag, owner) VALUES (?, ?, ?, ?, ?)\");\n-                            ps2.setInt(2, item.getItemId());\n-                            ps2.setInt(3, quantity);\n-                            ps2.setInt(4, item.getFlag());\n-                            ps2.setString(5, item.getOwner());\n-                        }\n-                        ps2.setInt(1, rs.getInt(1));\n-                        ps2.executeUpdate();\n-                        ps2.close();\n-                    }\n-                }\n-            }\n+            Connection con = DatabaseConnection.getConnection();\n+            \n+            PreparedStatement ps = con.prepareStatement(\"DELETE FROM dueypackages WHERE PackageId = ?\");\n+            ps.setInt(1, packageId);\n+            ps.executeUpdate();\n+            ps.close();\n+            \n+            deletePackageFromInventoryDB(con, packageId);\n             \n             con.close();\n         } catch (SQLException e) {\n             e.printStackTrace();\n         }\n     }\n \n-    private static List<DueyPackages> loadItems(MapleCharacter chr) {\n-        List<DueyPackages> packages = new LinkedList<>();\n-        Connection con = null;\n+    private static DueyPackage getPackageFromDB(ResultSet rs) {\n         try {\n-            con = DatabaseConnection.getConnection();\n-            try (PreparedStatement ps = con.prepareStatement(\"SELECT * FROM dueypackages dp LEFT JOIN dueyitems di ON dp.PackageId=di.PackageId WHERE ReceiverId = ?\")) {\n+            int packageId = rs.getInt(\"PackageId\");\n+            \n+            List<Pair<Item, MapleInventoryType>> dueyItems = ItemFactory.DUEY.loadItems(packageId, false);\n+            DueyPackage dueypack;\n+            \n+            if (!dueyItems.isEmpty()) {     // in a duey package there's only one item\n+                dueypack = new DueyPackage(packageId, dueyItems.get(0).getLeft());\n+            } else {\n+                dueypack = new DueyPackage(packageId);\n+            }\n+            \n+            dueypack.setSender(rs.getString(\"SenderName\"));\n+            dueypack.setMesos(rs.getInt(\"Mesos\"));\n+            dueypack.setSentTime(rs.getString(\"TimeStamp\"));\n+            dueypack.setMessage(rs.getString(\"Message\"));\n+            \n+            return dueypack;\n+        } catch (SQLException sqle) {\n+            sqle.printStackTrace();\n+            return null;\n+        }\n+    }\n+    \n+    private static List<DueyPackage> loadPackages(MapleCharacter chr) {\n+        List<DueyPackage> packages = new LinkedList<>();\n+        try {\n+            Connection con = DatabaseConnection.getConnection();\n+            try (PreparedStatement ps = con.prepareStatement(\"SELECT * FROM dueypackages dp WHERE ReceiverId = ?\")) {\n                 ps.setInt(1, chr.getId());\n                 try (ResultSet rs = ps.executeQuery()) {\n                     while (rs.next()) {\n-                        DueyPackages dueypack = getItemByPID(rs);\n-                        dueypack.setSender(rs.getString(\"SenderName\"));\n-                        dueypack.setMesos(rs.getInt(\"Mesos\"));\n-                        dueypack.setSentTime(rs.getString(\"TimeStamp\"));\n+                        DueyPackage dueypack = getPackageFromDB(rs);\n+                        if (dueypack == null) continue;\n+                        \n                         packages.add(dueypack);\n                     }\n                 }\n             }\n             \n             con.close();\n-            return packages;\n         } catch (SQLException e) {\n             e.printStackTrace();\n-            return null;\n         }\n+        \n+        return packages;\n+    }\n+    \n+    private static int createPackage(int mesos, String message, String sender, int toCid) {\n+        try {\n+            Connection con = null;\n+            PreparedStatement ps = null;\n+            ResultSet rs = null;\n+        \n+            try {\n+                con = DatabaseConnection.getConnection();\n+                ps = con.prepareStatement(\"INSERT INTO `dueypackages` (ReceiverId, SenderName, Mesos, TimeStamp, Message, Checked) VALUES (?, ?, ?, ?, ?, 1)\", Statement.RETURN_GENERATED_KEYS);\n+                ps.setInt(1, toCid);\n+                ps.setString(2, sender);\n+                ps.setInt(3, mesos);\n+                ps.setString(4, getCurrentDate());\n+                ps.setString(5, message);\n+\n+                int updateRows = ps.executeUpdate();\n+                if (updateRows < 1) {\n+                    FilePrinter.printError(FilePrinter.INSERT_CHAR, \"Error trying to create package [mesos: \" + mesos + \", \" + sender + \", to CharacterId: \" + toCid + \"]\");\n+                    return -1;\n+                }\n+                \n+                int packageId;\n+                rs = ps.getGeneratedKeys();\n+                if (rs.next()) {\n+                    packageId = rs.getInt(1);\n+                } else {\n+                    FilePrinter.printError(FilePrinter.INSERT_CHAR, \"Failed inserting package [mesos: \" + mesos + \", \" + sender + \", to CharacterId: \" + toCid + \"]\");\n+                    return -1;\n+                }\n+                \n+                return packageId;\n+            } finally {\n+                if (rs != null && !rs.isClosed()) {\n+                    rs.close();\n+                }\n+                \n+                if (ps != null && !ps.isClosed()) {\n+                    ps.close();\n+                }\n+                \n+                if (con != null && !con.isClosed()) {\n+                    con.close();\n+                }\n+            }\n+        } catch (SQLException sqle) {\n+            sqle.printStackTrace();\n+        }\n+        \n+        return -1;\n+    }\n+    \n+    private static boolean insertPackageItem(int packageId, Item item) {\n+        try {\n+            Pair<Item, MapleInventoryType> dueyItem = new Pair<>(item, MapleInventoryType.getByType(item.getItemType()));\n+            Connection con = DatabaseConnection.getConnection();\n+            ItemFactory.DUEY.saveItems(Collections.singletonList(dueyItem), packageId, con);\n+            con.close();\n+            \n+            return true;\n+        } catch (SQLException sqle) {\n+            sqle.printStackTrace();\n+            \n+            return false;\n+        }\n+    }\n+    \n+    private static int addPackageItemFromInventory(int packageId, MapleClient c, byte invTypeId, short itemPos, short amount) {\n+        if (invTypeId > 0) {\n+            MapleItemInformationProvider ii = MapleItemInformationProvider.getInstance();\n+            \n+            MapleInventoryType invType = MapleInventoryType.getByType(invTypeId);\n+            MapleInventory inv = c.getPlayer().getInventory(invType);\n+\n+            Item item;\n+            inv.lockInventory();\n+            try {\n+                item = inv.getItem(itemPos);\n+                if (item != null && item.getQuantity() >= amount) {\n+                    if (item.isUntradeable() || ii.isUnmerchable(item.getItemId())) {\n+                        return -1;\n+                    }\n+\n+                    if (ItemConstants.isRechargeable(item.getItemId())) {\n+                        MapleInventoryManipulator.removeFromSlot(c, invType, itemPos, item.getQuantity(), true);\n+                    } else {\n+                        MapleInventoryManipulator.removeFromSlot(c, invType, itemPos, amount, true, false);\n+                    }\n+\n+                    item = item.copy();\n+                } else {\n+                    return -2;\n+                }\n+            } finally {\n+                inv.unlockInventory();\n+            }\n+            \n+            MapleKarmaManipulator.toggleKarmaFlagToUntradeable(item);\n+            item.setQuantity(amount);\n+            \n+            if (!insertPackageItem(packageId, item)) {\n+                return 1;\n+            }\n+        }\n+        \n+        return 0;\n     }\n     \n-    public static void dueySendItem(MapleClient c, byte inventId, short itemPos, short amount, int mesos, String recipient) {\n+    public static void dueySendItem(MapleClient c, byte invTypeId, short itemPos, short amount, int sendMesos, String sendMessage, String recipient) {\n         if (c.tryacquireClient()) {\n             try {\n-                final int fee = 5000;\n-                final long sendMesos = (long) mesos + fee;\n-                if (mesos < 0 || sendMesos > Integer.MAX_VALUE || (amount < 1 && mesos == 0)) {\n+                final int fee = 5000 + MapleTrade.getFee(sendMesos);\n+                \n+                long finalcost = (long) sendMesos + fee;\n+                if (finalcost < 0 || finalcost > Integer.MAX_VALUE || (amount < 1 && sendMesos == 0)) {\n                     AutobanFactory.PACKET_EDIT.alert(c.getPlayer(), c.getPlayer().getName() + \" tried to packet edit with duey.\");\n-                    FilePrinter.printError(FilePrinter.EXPLOITS + c.getPlayer().getName() + \".txt\", c.getPlayer().getName() + \" tried to use duey with mesos \" + mesos + \" and amount \" + amount);\n+                    FilePrinter.printError(FilePrinter.EXPLOITS + c.getPlayer().getName() + \".txt\", c.getPlayer().getName() + \" tried to use duey with mesos \" + sendMesos + \" and amount \" + amount);\n                     c.disconnect(true, false);\n                     return;\n                 }\n-\n-                int finalcost = mesos + fee;\n+                \n+                Pair<Integer, Integer> accIdCid;\n                 if (c.getPlayer().getMeso() >= finalcost) {\n-                    int accid = getAccIdFromCNAME(recipient, true);\n-                    if (accid != -1) {\n-                        if (accid == c.getAccID()) {\n+                    accIdCid = getAccountCharacterIdFromCNAME(recipient);\n+                    int recipientAccId = accIdCid.getLeft();\n+                    if (recipientAccId != -1) {\n+                        if (recipientAccId == c.getAccID()) {\n                             c.announce(MaplePacketCreator.sendDueyMSG(DueyProcessor.Actions.TOCLIENT_SEND_SAMEACC_ERROR.getCode()));\n                             return;\n                         }\n@@ -355,7 +378,29 @@ public static void dueySendItem(MapleClient c, byte inventId, short itemPos, sho\n                     c.announce(MaplePacketCreator.sendDueyMSG(DueyProcessor.Actions.TOCLIENT_SEND_NOT_ENOUGH_MESOS.getCode()));\n                     return;\n                 }\n-\n+                \n+                int recipientCid = accIdCid.getRight();\n+                if (recipientCid == -1) {\n+                    c.announce(MaplePacketCreator.sendDueyMSG(DueyProcessor.Actions.TOCLIENT_SEND_NAME_DOES_NOT_EXIST.getCode()));\n+                    return;\n+                }\n+                \n+                int packageId = createPackage(sendMesos, sendMessage, c.getPlayer().getName(), recipientCid);\n+                if (packageId == -1) {\n+                    c.announce(MaplePacketCreator.sendDueyMSG(DueyProcessor.Actions.TOCLIENT_SEND_ENABLE_ACTIONS.getCode()));\n+                    return;\n+                }\n+                c.getPlayer().gainMeso((int) -finalcost, false);\n+                \n+                int res = addPackageItemFromInventory(packageId, c, invTypeId, itemPos, amount);\n+                if (res == 0) {\n+                    c.announce(MaplePacketCreator.sendDueyMSG(DueyProcessor.Actions.TOCLIENT_SEND_SUCCESSFULLY_SENT.getCode()));\n+                } else if (res > 0) {\n+                    c.announce(MaplePacketCreator.sendDueyMSG(DueyProcessor.Actions.TOCLIENT_SEND_ENABLE_ACTIONS.getCode()));\n+                } else {\n+                    c.announce(MaplePacketCreator.sendDueyMSG(DueyProcessor.Actions.TOCLIENT_SEND_INCORRECT_REQUEST.getCode()));\n+                }\n+                \n                 MapleClient rClient = null;\n                 int channel = c.getWorldServer().find(recipient);\n                 if (channel > -1) {\n@@ -367,40 +412,7 @@ public static void dueySendItem(MapleClient c, byte inventId, short itemPos, sho\n                         }\n                     }\n                 }\n-\n-                if (inventId > 0) {\n-                    MapleInventoryType inv = MapleInventoryType.getByType(inventId);\n-                    Item item = c.getPlayer().getInventory(inv).getItem(itemPos);\n-                    if (item != null && c.getPlayer().getItemQuantity(item.getItemId(), false) >= amount) {\n-                        if (item.isUntradeable()) {\n-                            c.announce(MaplePacketCreator.sendDueyMSG(DueyProcessor.Actions.TOCLIENT_SEND_INCORRECT_REQUEST.getCode()));\n-                            return;\n-                        }\n-                        \n-                        c.getPlayer().gainMeso(-finalcost, false);\n-                        c.announce(MaplePacketCreator.sendDueyMSG(DueyProcessor.Actions.TOCLIENT_SEND_SUCCESSFULLY_SENT.getCode()));\n-\n-                        if (ItemConstants.isRechargeable(item.getItemId())) {\n-                            MapleInventoryManipulator.removeFromSlot(c, inv, itemPos, item.getQuantity(), true);\n-                        } else {\n-                            MapleInventoryManipulator.removeFromSlot(c, inv, itemPos, amount, true, false);\n-                        }\n-\n-                        MapleKarmaManipulator.toggleKarmaFlagToUntradeable(item);\n-                        addItemToDB(item, amount, mesos - MapleTrade.getFee(mesos), c.getPlayer().getName(), getAccIdFromCNAME(recipient, false));\n-                    } else {\n-                        if (item != null) {\n-                            c.announce(MaplePacketCreator.sendDueyMSG(DueyProcessor.Actions.TOCLIENT_SEND_INCORRECT_REQUEST.getCode()));\n-                        }\n-                        return;\n-                    }\n-                } else {\n-                    c.getPlayer().gainMeso(-finalcost, false);\n-                    c.announce(MaplePacketCreator.sendDueyMSG(DueyProcessor.Actions.TOCLIENT_SEND_SUCCESSFULLY_SENT.getCode()));    \n-\n-                    addMesoToDB(mesos - MapleTrade.getFee(mesos), c.getPlayer().getName(), getAccIdFromCNAME(recipient, false));\n-                }\n-\n+                \n                 if (rClient != null && rClient.isLoggedIn() && !rClient.getPlayer().isAwayFromWorld()) {\n                     showDueyNotification(rClient, rClient.getPlayer());\n                 }\n@@ -410,55 +422,50 @@ public static void dueySendItem(MapleClient c, byte inventId, short itemPos, sho\n         }\n     }\n     \n-    public static void dueyRemovePackage(MapleClient c, int packageid) {\n+    public static void dueyRemovePackage(MapleClient c, int packageid, boolean playerRemove) {\n         if (c.tryacquireClient()) {\n             try {\n-                removeItemFromDB(packageid);\n-                c.announce(MaplePacketCreator.removeItemFromDuey(true, packageid));\n+                removePackageFromDB(packageid);\n+                c.announce(MaplePacketCreator.removeItemFromDuey(playerRemove, packageid));\n             } finally {\n                 c.releaseClient();\n             }\n         }\n     }\n     \n-    public static void dueyClaimPackage(MapleClient c, int packageid) {\n+    public static void dueyClaimPackage(MapleClient c, int packageId) {\n         if (c.tryacquireClient()) {\n             try {\n-                List<DueyPackages> packages = new LinkedList<>();\n-                DueyPackages dp = null;\n-                Connection con = null;\n                 try {\n-                    con = DatabaseConnection.getConnection();\n-                    DueyPackages dueypack;\n-                    try (PreparedStatement ps = con.prepareStatement(\"SELECT * FROM dueypackages LEFT JOIN dueyitems USING (PackageId) WHERE PackageId = ?\")) {\n-                        ps.setInt(1, packageid);\n+                    DueyPackage dp = null;\n+                    \n+                    Connection con = DatabaseConnection.getConnection();\n+                    try (PreparedStatement ps = con.prepareStatement(\"SELECT * FROM dueypackages dp WHERE PackageId = ?\")) {\n+                        ps.setInt(1, packageId);\n+                        \n                         try (ResultSet rs = ps.executeQuery()) {\n-                            dueypack = null;\n                             if (rs.next()) {\n-                                dueypack = getItemByPID(rs);\n-                                dueypack.setSender(rs.getString(\"SenderName\"));\n-                                dueypack.setMesos(rs.getInt(\"Mesos\"));\n-                                dueypack.setSentTime(rs.getString(\"TimeStamp\"));\n-\n-                                packages.add(dueypack);\n+                                dp = getPackageFromDB(rs);\n                             }\n                         }\n                     }\n-                    dp = dueypack;\n+                    con.close();\n+                    \n                     if(dp == null) {\n                         c.announce(MaplePacketCreator.sendDueyMSG(Actions.TOCLIENT_RECV_UNKNOWN_ERROR.getCode()));\n-                        FilePrinter.printError(FilePrinter.EXPLOITS + c.getPlayer().getName() + \".txt\", c.getPlayer().getName() + \" tried to receive package from duey with id \" + packageid);\n+                        FilePrinter.printError(FilePrinter.EXPLOITS + c.getPlayer().getName() + \".txt\", c.getPlayer().getName() + \" tried to receive package from duey with id \" + packageId);\n                         return;\n                     }\n \n-                    if (dp.getItem() != null) {\n+                    Item dpItem = dp.getItem();\n+                    if (dpItem != null) {\n                         if (!c.getPlayer().canHoldMeso(dp.getMesos())) {\n                             c.announce(MaplePacketCreator.sendDueyMSG(Actions.TOCLIENT_RECV_UNKNOWN_ERROR.getCode()));\n                             return;\n                         }\n                         \n-                        if (!MapleInventoryManipulator.checkSpace(c, dp.getItem().getItemId(), dp.getItem().getQuantity(), dp.getItem().getOwner())) {\n-                            int itemid = dp.getItem().getItemId();\n+                        if (!MapleInventoryManipulator.checkSpace(c, dpItem.getItemId(), dpItem.getQuantity(), dpItem.getOwner())) {\n+                            int itemid = dpItem.getItemId();\n                             if(MapleItemInformationProvider.getInstance().isPickupRestricted(itemid) && c.getPlayer().getInventory(ItemConstants.getInventoryType(itemid)).findById(itemid) != null) {\n                                 c.announce(MaplePacketCreator.sendDueyMSG(Actions.TOCLIENT_RECV_RECEIVER_WITH_UNIQUE.getCode()));\n                             } else {\n@@ -467,16 +474,13 @@ public static void dueyClaimPackage(MapleClient c, int packageid) {\n \n                             return;\n                         } else {\n-                            MapleInventoryManipulator.addFromDrop(c, dp.getItem(), false);\n+                            MapleInventoryManipulator.addFromDrop(c, dpItem, false);\n                         }\n                     }\n-\n+                    \n                     c.getPlayer().gainMeso(dp.getMesos(), false);\n-\n-                    removeItemFromDB(packageid);\n-                    c.announce(MaplePacketCreator.removeItemFromDuey(false, packageid));\n-\n-                    con.close();\n+                    \n+                    dueyRemovePackage(c, packageId, false);\n                 } catch (SQLException e) {\n                     e.printStackTrace();\n                 }\n@@ -489,10 +493,17 @@ public static void dueyClaimPackage(MapleClient c, int packageid) {\n     public static void dueySendTalk(MapleClient c) {\n         if (c.tryacquireClient()) {\n             try {\n-                c.announce(MaplePacketCreator.sendDuey((byte) 8, loadItems(c.getPlayer())));\n+                c.announce(MaplePacketCreator.sendDuey((byte) 8, loadPackages(c.getPlayer())));\n             } finally {\n                 c.releaseClient();\n             }\n         }\n     }\n+    \n+    public static void dueyCreatePackage(Item item, int mesos, String sender, int recipientCid) {\n+        int packageId = createPackage(mesos, \"\", sender, recipientCid);\n+        if (packageId != -1) {\n+            insertPackageItem(packageId, item);\n+        }\n+    }\n }"}, {"sha": "b2f5f4aa0e5ec7b287562959ddd4a90d5800b320", "filename": "src/client/processor/StorageProcessor.java", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/client/processor/StorageProcessor.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/client/processor/StorageProcessor.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/client/processor/StorageProcessor.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -147,7 +147,6 @@ public static void storageAction(SeekableLittleEndianAccessor slea, MapleClient\n                                                 \n                                                 chr.gainMeso(-storeFee, false, true, false);\n                                                 \n-                                                item = item.copy(); // thanks Robin Schulz for pointing out an issue with stored items\n                                                 MapleKarmaManipulator.toggleKarmaFlagToUntradeable(item);\n                                                 item.setQuantity(quantity);\n                                                 storage.store(item);"}, {"sha": "b7e64813d46a727c3e00faf3caa3d6f6ee7b362d", "filename": "src/constants/GameConstants.java", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/constants/GameConstants.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/constants/GameConstants.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/constants/GameConstants.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -92,8 +92,6 @@ public static int getPlayerBonusExpRate(int slot) {\n     \n     // used by the \"goto\" command for only-GMs\n     public static final HashMap<String, Integer> GOTO_AREAS = new HashMap<String, Integer>() {{\n-        putAll(GOTO_TOWNS);\n-        \n         put(\"gmmap\", 180000000);\n         put(\"excavation\", 990000000);\n         put(\"mushmom\", 100000005);"}, {"sha": "1e9085b3269d11ffc8cd4196aa5bba3aa37c2f2e", "filename": "src/constants/ServerConstants.java", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/constants/ServerConstants.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/constants/ServerConstants.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/constants/ServerConstants.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -150,15 +150,18 @@\n     public static final int TRAVEL_RATE = 10;                       //Means of transportation rides/departs using 1/N of the default time.\n     \n     public static final double EQUIP_EXP_RATE = 1.0;                //Rate for equipment exp gain, grows linearly. Set 1.0 for default (about 100~200 same-level range mobs killed to pass equip from level 1 to 2).\n-    public static final float PARTY_BONUS_EXP_RATE = 1.0f;          //Rate for the party exp bonus reward.\n     public static final double PQ_BONUS_EXP_RATE = 0.5;             //Rate for the PQ exp reward.\n     \n+    public static final byte EXP_SPLIT_LEVEL_INTERVAL = 5;          //Non-contributing players must be within N level between the mob to receive EXP.\n+    public static final byte EXP_SPLIT_LEECH_INTERVAL = 5;          //Non-contributing players must be within N level between any contributing party member to receive EXP.\n+    public static final float EXP_SPLIT_MVP_MOD = 0.2f;\n+    public static final float EXP_SPLIT_COMMON_MOD = 0.8f;\n+    public static final float PARTY_BONUS_EXP_RATE = 1.0f;          //Rate for the party exp bonus reward.\n+    \n     //Miscellaneous Configuration\n     public static String TIMEZONE = \"GMT-3\";\n     public static boolean USE_DISPLAY_NUMBERS_WITH_COMMA = true;        //Enforce comma on displayed strings (use this when USE_UNITPRICE_WITH_COMMA is active and you still want to display comma-separated values).\n     public static boolean USE_UNITPRICE_WITH_COMMA = true;              //Set this accordingly with the layout of the unitPrices on Item.wz XML's, whether it's using commas or dots to represent fractions.\n-    public static final byte MIN_UNDERLEVEL_TO_EXP_GAIN = 20;           //Characters are unable to get EXP from a mob if their level are under this threshold, only if \"USE_ENFORCE_MOB_LEVEL_RANGE\" is enabled. For bosses, this attribute is doubled.\n-    public static final byte MIN_RANGELEVEL_TO_EXP_LEECH = 40;          //Characters are unable to leech EXP from party member kills whose level difference are past this limit.\n     public static final byte MAX_MONITORED_BUFFSTATS = 5;               //Limits accounting for \"dormant\" buff effects, that should take place when stronger stat buffs expires.\n     public static final int MAX_AP = 32767;                             //Max AP allotted on the auto-assigner.\n     public static final int MAX_EVENT_LEVELS = 8;                       //Event has different levels of rewarding system."}, {"sha": "98780b18d3c44696fd3fb1fcb2a6b1f34ac8d70c", "filename": "src/net/server/audit/ThreadTracker.java", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/net/server/audit/ThreadTracker.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/net/server/audit/ThreadTracker.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/audit/ThreadTracker.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -239,7 +239,10 @@ public void accessThreadTracker(boolean update, boolean lock, MonitoredLockType\n                 }\n                 else {\n                     AtomicInteger c = lockCount.get(lockOid);\n-                    c.decrementAndGet();\n+                    if (c != null) {    // thanks BHB for detecting an NPE here\n+                        c.decrementAndGet();\n+                    }\n+                    \n                     lockUpdate.put(lockOid, 0);\n \n                     List<MonitoredLockType> list = threadTracker.get(tid);"}, {"sha": "4d0a8bd7e6718fe7a6c4a0b9f640b8e913b573d1", "filename": "src/net/server/audit/locks/MonitoredLockType.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/net/server/audit/locks/MonitoredLockType.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/net/server/audit/locks/MonitoredLockType.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/audit/locks/MonitoredLockType.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -26,6 +26,7 @@\n \n public enum MonitoredLockType {\n     UNDEFINED,\n+    INTERVAL,\n     CHARACTER_CHR,\n     CHARACTER_CPN,\n     CHARACTER_EFF,\n@@ -96,7 +97,7 @@\n     VISITOR_MERCH,\n     MAP_CHRS,\n     MAP_OBJS,\n-    MAP_FACTORY,\n+    MAP_MANAGER,\n     MAP_ITEM,\n     MAP_LOOT,\n     MAP_BOUNDS,"}, {"sha": "17ffdc03a729c7e89abf66b66f8cf0c3ea697e69", "filename": "src/net/server/channel/Channel.java", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/net/server/channel/Channel.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/net/server/channel/Channel.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/Channel.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -26,7 +26,6 @@\n import java.util.ArrayList;\n import java.util.LinkedList;\n import java.util.HashMap;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.Collections;\n import java.util.HashSet;\n@@ -64,15 +63,14 @@\n import org.apache.mina.transport.socket.SocketSessionConfig;\n import org.apache.mina.transport.socket.nio.NioSocketAcceptor;\n \n-import provider.MapleDataProviderFactory;\n import scripting.event.EventScriptManager;\n import server.TimerManager;\n import server.events.gm.MapleEvent;\n import server.expeditions.MapleExpedition;\n import server.expeditions.MapleExpeditionType;\n import server.maps.MapleHiredMerchant;\n import server.maps.MapleMap;\n-import server.maps.MapleMapFactory;\n+import server.maps.MapleMapManager;\n import server.maps.MapleMiniDungeon;\n import tools.MaplePacketCreator;\n import tools.Pair;\n@@ -88,7 +86,7 @@\n     private int world, channel;\n     private IoAcceptor acceptor;\n     private String ip, serverMessage;\n-    private MapleMapFactory mapFactory;\n+    private MapleMapManager mapManager;\n     private EventScriptManager eventSM;\n     private MobStatusScheduler mobStatusSchedulers[] = new MobStatusScheduler[ServerConstants.CHANNEL_LOCKS];\n     private MobAnimationScheduler mobAnimationSchedulers[] = new MobAnimationScheduler[ServerConstants.CHANNEL_LOCKS];\n@@ -108,8 +106,6 @@\n     private int usedDojo = 0;\n     private Set<Integer> usedMC = new HashSet<>();\n     \n-    private ScheduledFuture<?> respawnTask;\n-    \n     private int[] dojoStage;\n     private long[] dojoFinishTime;\n     private ScheduledFuture<?>[] dojoTask;\n@@ -142,7 +138,7 @@ public Channel(final int world, final int channel, long startTime) {\n         this.channel = channel;\n         \n         this.ongoingStartTime = startTime + 10000;  // rude approach to a world's last channel boot time, placeholder for the 1st wedding reservation ever\n-        this.mapFactory = new MapleMapFactory(null, MapleDataProviderFactory.getDataProvider(new File(System.getProperty(\"wzpath\") + \"/Map.wz\")), MapleDataProviderFactory.getDataProvider(new File(System.getProperty(\"wzpath\") + \"/String.wz\")), world, channel);\n+        this.mapManager = new MapleMapManager(null, world, channel);\n         try {\n             eventSM = new EventScriptManager(this, getEvents());\n             port = 7575 + this.channel - 1;\n@@ -151,7 +147,6 @@ public Channel(final int world, final int channel, long startTime) {\n             IoBuffer.setUseDirectBuffer(false);\n             IoBuffer.setAllocator(new SimpleBufferAllocator());\n             acceptor = new NioSocketAcceptor();\n-            respawnTask = TimerManager.getInstance().register(new respawnMaps(), ServerConstants.RESPAWN_INTERVAL);\n             acceptor.setHandler(new MapleServerHandler(world, channel));\n             acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 30);\n             acceptor.getFilterChain().addLast(\"codec\", (IoFilter) new ProtocolCodecFilter(new MapleCodecFactory()));\n@@ -204,13 +199,8 @@ public final void shutdown() {\n             disconnectAwayPlayers();\n             players.disconnectAll();\n             \n-            if(respawnTask != null) {\n-                respawnTask.cancel(false);\n-                respawnTask = null;\n-            }\n-            \n-            mapFactory.dispose();\n-            mapFactory = null;\n+            mapManager.dispose();\n+            mapManager = null;\n             \n             eventSM.cancel();\n             eventSM = null;\n@@ -315,8 +305,8 @@ private void closeAllMerchants() {\n         }\n     }\n     \n-    public MapleMapFactory getMapFactory() {\n-        return mapFactory;\n+    public MapleMapManager getMapFactory() {\n+        return mapManager;\n     }\n \n     public int getWorld() {\n@@ -417,16 +407,6 @@ private void disconnectAwayPlayers() {\n         }\n     }\n         \n-    public class respawnMaps implements Runnable {\n-\n-        @Override\n-        public void run() {\n-            for (MapleMap map : mapFactory.getMaps().values()) {\n-                map.respawn();\n-            }\n-        }\n-    }\n-\n     public Map<Integer, MapleHiredMerchant> getHiredMerchants() {\n         merchRlock.lock();\n         try {"}, {"sha": "ae2fc17a6eb13a63d5ab6efabee113bcff1cb0b8", "filename": "src/net/server/channel/handlers/DueyHandler.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/net/server/channel/handlers/DueyHandler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/net/server/channel/handlers/DueyHandler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/handlers/DueyHandler.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -45,12 +45,12 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n             short amount = slea.readShort();\n             int mesos = slea.readInt();\n             String recipient = slea.readMapleAsciiString();\n-            \n-            DueyProcessor.dueySendItem(c, inventId, itemPos, amount, mesos, recipient);\n+            String message = slea.readByte() != 0 ? slea.readMapleAsciiString() : \"\";\n+            DueyProcessor.dueySendItem(c, inventId, itemPos, amount, mesos, message, recipient);\n         } else if (operation == DueyProcessor.Actions.TOSERVER_REMOVE_PACKAGE.getCode()) {\n             int packageid = slea.readInt();\n             \n-            DueyProcessor.dueyRemovePackage(c, packageid);\n+            DueyProcessor.dueyRemovePackage(c, packageid, true);\n         } else if (operation == DueyProcessor.Actions.TOSERVER_CLAIM_PACKAGE.getCode()) {\n             int packageid = slea.readInt();\n             "}, {"sha": "bd38fa41e7c5502c9fd8e1ce463c7c396513b681", "filename": "src/net/server/channel/handlers/PlayerInteractionHandler.java", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/net/server/channel/handlers/PlayerInteractionHandler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/net/server/channel/handlers/PlayerInteractionHandler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/handlers/PlayerInteractionHandler.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -495,13 +495,14 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n                     return;\n                 }\n                 \n-                if(ServerConstants.USE_ENFORCE_UNMERCHABLE_CASH && ii.isCash(item.getItemId())) {\n-                    c.announce(MaplePacketCreator.serverNotice(1, \"Cash items are not allowed to be traded.\"));\n-                    return;\n-                }\n-                \n-                if (ServerConstants.USE_ENFORCE_UNMERCHABLE_PET && ItemConstants.isPet(item.getItemId())) {\n-                    c.announce(MaplePacketCreator.serverNotice(1, \"Pets are not allowed to be traded.\"));\n+                if (ii.isUnmerchable(item.getItemId())) {\n+                    if (ItemConstants.isPet(item.getItemId())) {\n+                        c.announce(MaplePacketCreator.serverNotice(1, \"Pets are not allowed to be traded.\"));\n+                    } else {\n+                        c.announce(MaplePacketCreator.serverNotice(1, \"Cash items are not allowed to be traded.\"));\n+                    }\n+                    \n+                    c.announce(MaplePacketCreator.enableActions());\n                     return;\n                 }\n                 \n@@ -567,6 +568,15 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n \n                 if (ivItem == null || ivItem.isUntradeable()) {\n                     c.announce(MaplePacketCreator.serverNotice(1, \"Could not perform shop operation with that item.\"));\n+                    c.announce(MaplePacketCreator.enableActions());\n+                    return;\n+                } else if (MapleItemInformationProvider.getInstance().isUnmerchable(ivItem.getItemId())) {\n+                    if (ItemConstants.isPet(ivItem.getItemId())) {\n+                        c.announce(MaplePacketCreator.serverNotice(1, \"Pets are not allowed to be sold on the Player Store.\"));\n+                    } else {\n+                        c.announce(MaplePacketCreator.serverNotice(1, \"Cash items are not allowed to be sold on the Player Store.\"));\n+                    }\n+                    \n                     c.announce(MaplePacketCreator.enableActions());\n                     return;\n                 }\n@@ -588,17 +598,7 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n                     FilePrinter.printError(FilePrinter.EXPLOITS + chr.getName() + \".txt\", chr.getName() + \" might of possibly packet edited Hired Merchants\\nperBundle: \" + perBundle + \"\\nperBundle * bundles (This multiplied cannot be greater than 2000): \" + perBundle * bundles + \"\\nbundles: \" + bundles + \"\\nprice: \" + price);\n                     return;\n                 }\n-\n-                if(ServerConstants.USE_ENFORCE_UNMERCHABLE_CASH && MapleItemInformationProvider.getInstance().isCash(ivItem.getItemId())) {\n-                    c.announce(MaplePacketCreator.serverNotice(1, \"Cash items are not allowed to be sold on the Player Store.\"));\n-                    return;\n-                }\n                 \n-                if (ServerConstants.USE_ENFORCE_UNMERCHABLE_PET && ItemConstants.isPet(ivItem.getItemId())) {\n-                    c.announce(MaplePacketCreator.serverNotice(1, \"Pets are not allowed to be sold on the Player Store.\"));\n-                    return;\n-                }\n-\n                 Item sellItem = ivItem.copy();\n                 if(!ItemConstants.isRechargeable(ivItem.getItemId())) {\n                     sellItem.setQuantity(perBundle);"}, {"sha": "3f2290119c945b360cbe5221578d5ea19978c57c", "filename": "src/net/server/channel/handlers/RingActionHandler.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/net/server/channel/handlers/RingActionHandler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/net/server/channel/handlers/RingActionHandler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/handlers/RingActionHandler.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -422,8 +422,8 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n                                     \n                                     Item weddingTicket = new Item(newItemId, (short) 0, (short) 1);\n                                     weddingTicket.setExpiration(expiration);\n-\n-                                    DueyProcessor.addItemToDB(weddingTicket, 1, 0, groom, guest);\n+                                    \n+                                    DueyProcessor.dueyCreatePackage(weddingTicket, 0, groom, guest);\n                                 }\n                             } else {\n                                 c.getPlayer().dropMessage(5, \"Wedding is already under way. You cannot invite any more guests for the event.\");"}, {"sha": "2ee9dcac3c158e9d25eef5ffd3b75e466ecc1d97", "filename": "src/net/server/channel/handlers/UseCashItemHandler.java", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/net/server/channel/handlers/UseCashItemHandler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/net/server/channel/handlers/UseCashItemHandler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/handlers/UseCashItemHandler.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -36,6 +36,7 @@\n import client.inventory.manipulator.MapleInventoryManipulator;\n import client.inventory.manipulator.MapleKarmaManipulator;\n import client.processor.AssignAPProcessor;\n+import client.processor.DueyProcessor;\n import constants.GameConstants;\n import constants.ItemConstants;\n import constants.ServerConstants;\n@@ -47,7 +48,6 @@\n \n import net.AbstractMaplePacketHandler;\n import net.server.Server;\n-import scripting.npc.NPCScriptManager;\n import server.MapleItemInformationProvider;\n import server.MapleShop;\n import server.MapleShopFactory;\n@@ -294,7 +294,7 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n                         if (item == null) //hack\n                         {\n                             return;\n-                        } else if (item.isUntradeable()) {\n+                        } else if (item.isUntradeable() || ii.isUnmerchable(item.getItemId())) {\n                             player.dropMessage(1, \"You cannot trade this item.\");\n                             c.announce(MaplePacketCreator.enableActions());\n                             return;\n@@ -398,7 +398,7 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n             ii.getItemEffect(itemId).applyTo(player);\n             remove(c, position, itemId);\n         } else if (itemType == 533) {\n-            NPCScriptManager.getInstance().start(c, 9010009, null);\n+            DueyProcessor.dueySendTalk(c);\n         } else if (itemType == 537) {\n             if (GameConstants.isFreeMarketRoom(player.getMapId())) {\n                 player.dropMessage(5, \"You cannot use the chalkboard here.\");\n@@ -409,7 +409,7 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n             player.setChalkboard(slea.readMapleAsciiString());\n             player.getMap().broadcastMessage(MaplePacketCreator.useChalkboard(player, false));\n             player.getClient().announce(MaplePacketCreator.enableActions());\n-            remove(c, position, itemId);\n+            //remove(c, position, itemId);  thanks Conrad for noticing chalkboards shouldn't be depleted upon use\n         } else if (itemType == 539) {\n             List<String> strLines = new LinkedList<>();\n             for (int i = 0; i < 4; i++) {"}, {"sha": "dd45a073393b869a0a359da050cb00e1237d2c24", "filename": "src/net/server/coordinator/MapleMonsterAggroCoordinator.java", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/net/server/coordinator/MapleMonsterAggroCoordinator.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/net/server/coordinator/MapleMonsterAggroCoordinator.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/coordinator/MapleMonsterAggroCoordinator.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -237,7 +237,9 @@ private void runAggroUpdate(int deltaTime) {\n                             }\n                             \n                             if (mobAggro.isEmpty()) {   // all aggro on this mob expired\n-                                am.getLeft().aggroResetAggro();\n+                                if (!am.getLeft().isBoss()) {\n+                                    am.getLeft().aggroResetAggro();\n+                                }\n                             }\n                         }\n "}, {"sha": "75b77d4700920b938eb84349c6bfb4000b860a47", "filename": "src/net/server/coordinator/partysearch/PartySearchStorage.java", "status": "modified", "additions": 5, "deletions": 83, "changes": 88, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/net/server/coordinator/partysearch/PartySearchStorage.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/net/server/coordinator/partysearch/PartySearchStorage.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/coordinator/partysearch/PartySearchStorage.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -34,8 +34,7 @@\n import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;\n import net.server.audit.locks.MonitoredLockType;\n import net.server.audit.locks.MonitoredReentrantReadWriteLock;\n-\n-import java.awt.geom.Line2D;\n+import tools.IntervalBuilder;\n \n /**\n  *\n@@ -44,84 +43,7 @@\n public class PartySearchStorage {\n     \n     private List<PartySearchCharacter> storage = new ArrayList<>(20);\n-    private PartySearchEmptyIntervals emptyManager = new PartySearchEmptyIntervals();\n-    \n-    private class PartySearchEmptyIntervals {\n-        \n-        private List<Line2D> emptyLimits = new ArrayList<>();\n-        \n-        private void refitEmptyIntervals(int st, int en, int minLevel, int maxLevel) {\n-            List<Line2D> checkLimits = new ArrayList<>(emptyLimits.subList(st, en));\n-            \n-            float newLimitX1, newLimitX2;\n-            if (!checkLimits.isEmpty()) {\n-                Line2D firstLimit = checkLimits.get(0);\n-                Line2D lastLimit = checkLimits.get(checkLimits.size() - 1);\n-\n-                newLimitX1 = (float) ((minLevel < firstLimit.getX1()) ? minLevel : firstLimit.getX1());\n-                newLimitX2 = (float) ((maxLevel > lastLimit.getX2()) ? maxLevel : lastLimit.getX2());\n-\n-                for (Line2D limit : checkLimits) {\n-                    emptyLimits.remove(st);\n-                }\n-            } else {\n-                newLimitX1 = minLevel;\n-                newLimitX2 = maxLevel;\n-            }\n-            \n-            emptyLimits.add(st, new Line2D.Float((float) newLimitX1, 0, (float) newLimitX2, 0));\n-        }\n-        \n-        private int bsearchInterval(int level) {\n-            int st = 0, en = emptyLimits.size() - 1;\n-\n-            int mid, idx;\n-            while (en >= st) {\n-                idx = (st + en) / 2;\n-                mid = (int) emptyLimits.get(idx).getX1();\n-\n-                if (mid == level) {\n-                    return idx;\n-                } else if (mid < level) {\n-                    st = idx + 1;\n-                } else {\n-                    en = idx - 1;\n-                }\n-            }\n-\n-            return en;\n-        }\n-        \n-        public void addEmptyInterval(int fromLevel, int toLevel) {\n-            synchronized (emptyLimits) {    // adding intervals occurs on a same-thread process, so this is actually not performance grinding\n-                int st = bsearchInterval(fromLevel);\n-                if (st < 0) {\n-                    st = 0;\n-                } else if (emptyLimits.get(st).getX2() < fromLevel) {\n-                    st += 1;\n-                }\n-\n-                int en = bsearchInterval(toLevel);\n-                if (en < st) en = st - 1;\n-\n-                refitEmptyIntervals(st, en + 1, fromLevel, toLevel);\n-            }\n-        }\n-        \n-        public boolean isInEmptyInterval(int minLevel, int maxLevel) {\n-            synchronized (emptyLimits) {\n-                int idx = bsearchInterval(minLevel);\n-                return idx >= 0 && maxLevel <= emptyLimits.get(idx).getX2();\n-            }\n-        }\n-        \n-        public void clearEmptyInterval() {\n-            synchronized (emptyLimits) {\n-                emptyLimits.clear();\n-            }\n-        }\n-        \n-    }\n+    private IntervalBuilder emptyIntervals = new IntervalBuilder();\n     \n     private final ReentrantReadWriteLock psLock = new MonitoredReentrantReadWriteLock(MonitoredLockType.WORLD_PARTY_SEARCH_STORAGE, true);\n     private final ReadLock psRLock = psLock.readLock();\n@@ -183,7 +105,7 @@ public int compare(PartySearchCharacter c1, PartySearchCharacter c2)\n             psWLock.unlock();\n         }\n         \n-        emptyManager.clearEmptyInterval();\n+        emptyIntervals.clear();\n     }\n     \n     private static int bsearchStorage(List<PartySearchCharacter> storage, int level) {\n@@ -207,7 +129,7 @@ private static int bsearchStorage(List<PartySearchCharacter> storage, int level)\n     }\n     \n     public MapleCharacter callPlayer(int callerCid, int callerMapid, int minLevel, int maxLevel) {\n-        if (emptyManager.isInEmptyInterval(minLevel, maxLevel)) {\n+        if (emptyIntervals.inInterval(minLevel, maxLevel)) {\n             return null;\n         }\n         \n@@ -230,7 +152,7 @@ public MapleCharacter callPlayer(int callerCid, int callerMapid, int minLevel, i\n             }\n         }\n         \n-        emptyManager.addEmptyInterval(minLevel, maxLevel);\n+        emptyIntervals.addInterval(minLevel, maxLevel);\n         return null;\n     }\n     "}, {"sha": "c710dc1f711c0afe22408438d298419995d5b56f", "filename": "src/scripting/event/EventInstanceManager.java", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/scripting/event/EventInstanceManager.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/scripting/event/EventInstanceManager.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/scripting/event/EventInstanceManager.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -21,7 +21,6 @@\n  */\n package scripting.event;\n \n-import java.io.File;\n import tools.Pair;\n import java.util.ArrayList;\n import java.util.LinkedList;\n@@ -40,14 +39,13 @@\n import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n import net.server.world.MapleParty;\n import net.server.world.MaplePartyCharacter;\n-import provider.MapleDataProviderFactory;\n import server.MaplePortal;\n import server.TimerManager;\n import server.MapleStatEffect;\n import server.expeditions.MapleExpedition;\n import server.life.MapleMonster;\n import server.maps.MapleMap;\n-import server.maps.MapleMapFactory;\n+import server.maps.MapleMapManager;\n import server.maps.MapleReactor;\n import client.MapleCharacter;\n import client.SkillFactory;\n@@ -82,7 +80,7 @@\n \tprivate Map<MapleCharacter, Integer> killCount = new HashMap<>();\n \tprivate EventManager em;\n         private EventScriptScheduler ess;\n-\tprivate MapleMapFactory mapFactory;\n+\tprivate MapleMapManager mapManager;\n \tprivate String name;\n \tprivate Properties props = new Properties();\n         private Map<String, Object> objectProps = new HashMap<>();\n@@ -125,8 +123,7 @@ public EventInstanceManager(EventManager em, String name) {\n \t\tthis.em = em;\n \t\tthis.name = name;\n                 this.ess = new EventScriptScheduler();\n-\t\tmapFactory = new MapleMapFactory(this, MapleDataProviderFactory.getDataProvider(new File(System.getProperty(\"wzpath\") + \"/Map.wz\")), MapleDataProviderFactory.getDataProvider(new File(System.getProperty(\"wzpath\") + \"/String.wz\")), (byte) 0, (byte) 1);//Fk this\n-\t\tmapFactory.setChannel(em.getChannelServer().getId());\n+\t\tthis.mapManager = new MapleMapManager(this, em.getWorldServer().getId(), em.getChannelServer().getId());\n \t}\n         \n         public void setName(String name) {\n@@ -647,10 +644,10 @@ public synchronized void dispose(boolean shutdown) {    // should not trigger an\n                 TimerManager.getInstance().schedule(new Runnable() {\n                         @Override\n                         public void run() {\n-                                mapFactory.dispose();   // issues from instantly disposing some event objects found thanks to MedicOP\n+                                mapManager.dispose();   // issues from instantly disposing some event objects found thanks to MedicOP\n                                 wL.lock();\n                                 try {\n-                                        mapFactory = null;\n+                                        mapManager = null;\n                                         em = null;\n                                 } finally {\n                                         wL.unlock();\n@@ -675,8 +672,8 @@ private void emptyLocks() {\n                 sL = sL.dispose();\n         }\n \n-\tpublic MapleMapFactory getMapFactory() {\n-\t\treturn mapFactory;\n+\tpublic MapleMapManager getMapFactory() {\n+\t\treturn mapManager;\n \t}\n \n \tpublic void schedule(final String methodName, long delay) {\n@@ -706,10 +703,10 @@ public String getName() {\n \t}\n \n \tpublic MapleMap getMapInstance(int mapId) {\n-\t\tMapleMap map = mapFactory.getMap(mapId);\n+\t\tMapleMap map = mapManager.getMap(mapId);\n                 map.setEventInstance(this);\n \n-\t\tif (!mapFactory.isMapLoaded(mapId)) {\n+\t\tif (!mapManager.isMapLoaded(mapId)) {\n                         sL.lock();\n                         try {\n                                 if (em.getProperty(\"shuffleReactors\") != null && em.getProperty(\"shuffleReactors\").equals(\"true\")) {"}, {"sha": "a561c2e97d749486c7ca8bd3f6bdcaab8699e15f", "filename": "src/scripting/npc/NPCConversationManager.java", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/scripting/npc/NPCConversationManager.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/scripting/npc/NPCConversationManager.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/scripting/npc/NPCConversationManager.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -41,10 +41,9 @@\n import server.gachapon.MapleGachapon.MapleGachaponItem;\n import server.life.MaplePlayerNPC;\n import server.maps.MapleMap;\n-import server.maps.MapleMapFactory;\n+import server.maps.MapleMapManager;\n import server.partyquest.Pyramid;\n import server.partyquest.Pyramid.PyramidMode;\n-import server.quest.MapleQuest;\n import tools.LogHelper;\n import tools.MaplePacketCreator;\n import client.MapleCharacter;\n@@ -215,7 +214,12 @@ public void sendSimple(String text, byte speaker) {\n \t}\n \n \tpublic void sendStyle(String text, int styles[]) {\n-\t\tgetClient().announce(MaplePacketCreator.getNPCTalkStyle(npc, text, styles));\n+                if (styles.length > 0) {\n+                        getClient().announce(MaplePacketCreator.getNPCTalkStyle(npc, text, styles));\n+                } else {    // thanks Conrad for noticing empty styles crashing players\n+                        sendOk(\"Sorry, there are no options of cosmetics available for you here at the moment.\");\n+                        dispose();\n+                }\n \t}\n \n \tpublic void sendGetNumber(String text, int def, int min, int max) {\n@@ -515,7 +519,7 @@ public boolean createPyramid(String mode, boolean party) {//lol\n \t\tPyramidMode mod = PyramidMode.valueOf(mode);\n \n \t\tMapleParty partyz = getPlayer().getParty();\n-\t\tMapleMapFactory mf = c.getChannelServer().getMapFactory();\n+\t\tMapleMapManager mapManager = c.getChannelServer().getMapFactory();\n \n \t\tMapleMap map = null;\n \t\tint mapid = 926010100;\n@@ -525,7 +529,7 @@ public boolean createPyramid(String mode, boolean party) {//lol\n \t\tmapid += (mod.getMode() * 1000);\n \n \t\tfor (byte b = 0; b < 5; b++) {//They cannot warp to the next map before the timer ends (:\n-\t\t\tmap = mf.getMap(mapid + b);\n+\t\t\tmap = mapManager.getMap(mapid + b);\n \t\t\tif (map.getCharacters().size() > 0) {\n \t\t\t\tcontinue;\n \t\t\t} else {"}, {"sha": "0aba4868f84f8144fc291455f7e49a59a504f50a", "filename": "src/server/DueyPackage.java", "status": "renamed", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/DueyPackage.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/DueyPackage.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/DueyPackage.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -24,21 +24,22 @@\n import client.inventory.Item;\n import java.util.Calendar;\n \n-public class DueyPackages {\n+public class DueyPackage {\n     private String sender = null;\n     private Item item = null;\n     private int mesos = 0;\n+    private String message = \"\";\n     private int day;\n     private int month;\n     private int year;\n     private int packageId = 0;\n \n-    public DueyPackages(int pId, Item item) {\n+    public DueyPackage(int pId, Item item) {\n         this.item = item;\n         packageId = pId;\n     }\n \n-    public DueyPackages(int pId) { // Meso only package.\n+    public DueyPackage(int pId) { // Meso only package.\n         this.packageId = pId;\n     }\n \n@@ -61,6 +62,14 @@ public int getMesos() {\n     public void setMesos(int set) {\n         mesos = set;\n     }\n+    \n+    public String getMessage() {\n+        return message;\n+    }\n+    \n+    public void setMessage(String m) {\n+        message = m;\n+    }\n \n     public int getPackageId() {\n         return packageId;", "previous_filename": "src/server/DueyPackages.java"}, {"sha": "9bd172329f08f8319a0caec3da37257222c1c10c", "filename": "src/server/MapleItemInformationProvider.java", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/MapleItemInformationProvider.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/MapleItemInformationProvider.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/MapleItemInformationProvider.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -1586,6 +1586,18 @@ public boolean isUpgradeable(int itemId) {\n                 eq.getWatk() > 0 || eq.getMatk() > 0 || eq.getWdef() > 0 || eq.getMdef() > 0 || eq.getAcc() > 0 ||\n                 eq.getAvoid() > 0 || eq.getSpeed() > 0 || eq.getJump() > 0 || eq.getHp() > 0 || eq.getMp() > 0);\n     }\n+    \n+    public boolean isUnmerchable(int itemId) {\n+        if(ServerConstants.USE_ENFORCE_UNMERCHABLE_CASH && isCash(itemId)) {\n+            return true;\n+        }\n+\n+        if (ServerConstants.USE_ENFORCE_UNMERCHABLE_PET && ItemConstants.isPet(itemId)) {\n+            return true;\n+        }\n+        \n+        return false;\n+    }\n \n     public Collection<Item> canWearEquipment(MapleCharacter chr, Collection<Item> items) {\n         MapleInventory inv = chr.getInventory(MapleInventoryType.EQUIPPED);"}, {"sha": "00affc1e20ea0401611aa21ce93abf953538b7cd", "filename": "src/server/MapleStatEffect.java", "status": "modified", "additions": 39, "deletions": 18, "changes": 57, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/MapleStatEffect.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/MapleStatEffect.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/MapleStatEffect.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -150,12 +150,14 @@\n     \n     private static class CardItemupStats {\n         protected int itemCode, prob;\n+        protected boolean party;\n         private List<Pair<Integer, Integer>> areas;\n         \n-        private CardItemupStats(int code, int prob, List<Pair<Integer, Integer>> areas) {\n+        private CardItemupStats(int code, int prob, List<Pair<Integer, Integer>> areas, boolean inParty) {\n             this.itemCode = code;\n             this.prob = prob;\n             this.areas = areas;\n+            this.party = inParty;\n         }\n         \n         private boolean isInArea(int mapid) {\n@@ -173,8 +175,22 @@ private boolean isInArea(int mapid) {\n         }\n     }\n     \n-    public boolean isActive(int mapid) {\n-        return cardStats == null || cardStats.isInArea(mapid);\n+    private boolean isEffectActive(int mapid, boolean partyHunting) {\n+        if (cardStats == null) return true;\n+        \n+        if (!cardStats.isInArea(mapid)) {\n+            return false;\n+        }\n+        \n+        if (cardStats.party && !partyHunting) {\n+            return false;\n+        }\n+        \n+        return true;\n+    }\n+    \n+    public boolean isActive(MapleCharacter applyto) {\n+        return isEffectActive(applyto.getMapId(), applyto.getPartyMembersOnSameMap().size() > 1);\n     }\n     \n     public int getCardRate(int mapid, int itemid) {\n@@ -354,16 +370,27 @@ private static MapleStatEffect loadFromData(MapleData source, int sourceid, bool\n                 } else if (isMonsterCard(sourceid)) {\n                     int prob = 0, itemupCode = Integer.MAX_VALUE;\n                     List<Pair<Integer, Integer>> areas = null;\n+                    boolean inParty = false;\n                     \n                     MapleData con = source.getChildByPath(\"con\");\n                     if (con != null) {\n                         areas = new ArrayList<>(3);\n \n                         for (MapleData conData : con.getChildren()) {\n-                            int startMap = MapleDataTool.getInt(\"sMap\", conData, 0);\n-                            int endMap = MapleDataTool.getInt(\"eMap\", conData, 0);\n-\n-                            areas.add(new Pair<>(startMap, endMap));\n+                            int type = MapleDataTool.getInt(\"type\", conData, -1);\n+                            \n+                            if (type == 0) {\n+                                int startMap = MapleDataTool.getInt(\"sMap\", conData, 0);\n+                                int endMap = MapleDataTool.getInt(\"eMap\", conData, 0);\n+\n+                                areas.add(new Pair<>(startMap, endMap));\n+                            } else if (type == 2) {\n+                                inParty = true;\n+                            }\n+                        }\n+                        \n+                        if (areas.isEmpty()) {\n+                            areas = null;\n                         }\n                     }\n                     \n@@ -409,7 +436,7 @@ private static MapleStatEffect loadFromData(MapleData source, int sourceid, bool\n                         addBuffStatPairToListIfNotZero(statups, MapleBuffStat.MAP_PROTECTION, thaw > 0 ? 1 : 2);\n                     }\n                     \n-                    ret.cardStats = new CardItemupStats(itemupCode, prob, areas);\n+                    ret.cardStats = new CardItemupStats(itemupCode, prob, areas, inParty);\n                 } else if (isExpIncrease(sourceid)) {\n                     addBuffStatPairToListIfNotZero(statups, MapleBuffStat.EXP_INCREASE, MapleDataTool.getInt(\"expinc\", source, 0));\n                 }\n@@ -1180,15 +1207,9 @@ private void applyMonsterBuff(MapleCharacter applyfrom) {\n     }\n \n     private Rectangle calculateBoundingBox(Point posFrom, boolean facingLeft) {\n-        Point mylt;\n-        Point myrb;\n-        if (facingLeft) {\n-            mylt = new Point(lt.x + posFrom.x, lt.y + posFrom.y);\n-            myrb = new Point(rb.x + posFrom.x, rb.y + posFrom.y);\n-        } else {\n-            myrb = new Point(-lt.x + posFrom.x, rb.y + posFrom.y);\n-            mylt = new Point(-rb.x + posFrom.x, lt.y + posFrom.y);\n-        }\n+        int multiplier = facingLeft ? 1 : -1;\n+        Point mylt = new Point(lt.x * multiplier + posFrom.x, lt.y + posFrom.y);\n+        Point myrb = new Point(rb.x * multiplier + posFrom.x, rb.y + posFrom.y);\n         Rectangle bounds = new Rectangle(mylt.x, mylt.y, myrb.x - mylt.x, myrb.y - mylt.y);\n         return bounds;\n     }\n@@ -1313,7 +1334,7 @@ private void applyBuffEffect(MapleCharacter applyfrom, MapleCharacter applyto, b\n         if (localstatups.size() > 0) {\n             byte[] buff = null;\n             byte[] mbuff = null;\n-            if (getSummonMovementType() == null && this.isActive(applyto.getMapId())) {\n+            if (getSummonMovementType() == null && this.isActive(applyto)) {\n                 buff = MaplePacketCreator.giveBuff((skill ? sourceid : -sourceid), localDuration, localstatups);\n             }\n             if (isDash()) {"}, {"sha": "b691581503bdeff09a59ad10982384505d0a759f", "filename": "src/server/life/MapleLifeFactory.java", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/life/MapleLifeFactory.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/life/MapleLifeFactory.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/life/MapleLifeFactory.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -21,6 +21,7 @@\n  */\n package server.life;\n \n+import java.awt.Point;\n import java.io.File;\n import java.util.ArrayList;\n import java.util.HashMap;\n@@ -216,6 +217,14 @@ private static void setMonsterAttackInfo(int mid, List<MobAttackInfoHolder> atta\n             stats.setBanishInfo(new BanishInfo(MapleDataTool.getString(\"banMsg\", banishData), MapleDataTool.getInt(\"banMap/0/field\", banishData, -1), MapleDataTool.getString(\"banMap/0/portal\", banishData, \"sp\")));\n         }\n         \n+        int noFlip = MapleDataTool.getInt(\"noFlip\", monsterInfoData, 0);\n+        if (noFlip > 0) {\n+            Point origin = MapleDataTool.getPoint(\"stand/0/origin\", monsterData, null);\n+            if (origin != null) {\n+                stats.setFixedStance(origin.getX() < 1 ? 5 : 4);    // fixed left/right\n+            }\n+        }\n+        \n         return new Pair<>(stats, attackInfos);\n     }\n     "}, {"sha": "26a389e8374e3fcaa3eb1e30fc23438ab36b7b25", "filename": "src/server/life/MapleMonster.java", "status": "modified", "additions": 162, "deletions": 143, "changes": 305, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/life/MapleMonster.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/life/MapleMonster.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/life/MapleMonster.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -56,14 +56,14 @@\n import java.util.concurrent.atomic.AtomicLong;\n import net.server.audit.locks.MonitoredReentrantLock;\n import net.server.channel.Channel;\n-import net.server.world.World;\n import net.server.world.MapleParty;\n import net.server.world.MaplePartyCharacter;\n import scripting.event.EventInstanceManager;\n import server.TimerManager;\n import server.life.MapleLifeFactory.BanishInfo;\n import server.maps.MapleMap;\n import server.maps.MapleMapObjectType;\n+import tools.IntervalBuilder;\n import tools.MaplePacketCreator;\n import tools.Pair;\n import tools.Randomizer;\n@@ -72,6 +72,7 @@\n import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n import net.server.coordinator.MapleMonsterAggroCoordinator;\n import server.MapleStatEffect;\n+import server.loot.MapleLootManager;\n import server.maps.MapleSummon;\n \n public class MapleMonster extends AbstractLoadedMapleLife {\n@@ -94,12 +95,11 @@\n     private Map<Pair<Integer, Integer>, Integer> skillsUsed = new HashMap<>();\n     private Set<Integer> usedAttacks = new HashSet<>();\n     private Set<Integer> calledMobOids = null;\n-    private int calledMobCount = 0;\n     private WeakReference<MapleMonster> callerMob = new WeakReference<>(null);\n     private List<Integer> stolenItems = new ArrayList<>();\n     private int team;\n     private int parentMobOid = 0;\n-    private final HashMap<Integer, AtomicInteger> takenDamage = new HashMap<>();\n+    private final HashMap<Integer, AtomicLong> takenDamage = new HashMap<>();\n     private Runnable removeAfterAction = null;\n     private boolean availablePuppetUpdate = true;\n \n@@ -160,13 +160,17 @@ public void setParentMobOid(int parentMobId) {\n         this.parentMobOid = parentMobId;\n     }\n     \n-    public int countAvailableMobSummons(int limit, int skillLimit) {    // limit prop for summons has another conotation, found thanks to MedicOP\n+    public int countAvailableMobSummons(int summonsSize, int skillLimit) {    // limit prop for summons has another conotation, found thanks to MedicOP\n+        int summonsCount;\n+        \n         Set<Integer> calledOids = this.calledMobOids;\n         if(calledOids != null) {\n-            limit -= calledOids.size();\n+            summonsCount = calledOids.size();\n+        } else {\n+            summonsCount = 0;\n         }\n         \n-        return Math.min(limit, skillLimit - this.calledMobCount);\n+        return Math.min(summonsSize, skillLimit - summonsCount);\n     }\n     \n     public void addSummonedMob(MapleMonster mob) {\n@@ -178,7 +182,6 @@ public void addSummonedMob(MapleMonster mob) {\n         \n         calledOids.add(mob.getObjectId());\n         mob.setSummonerMob(this);\n-        this.calledMobCount += 1;\n     }\n     \n     private void removeSummonedMob(int mobOid) {\n@@ -442,7 +445,7 @@ private void applyDamage(MapleCharacter from, int damage, boolean stayAlive) {\n         dispatchMonsterDamaged(from, trueDamage);\n \n         if (!takenDamage.containsKey(from.getId())) {\n-            takenDamage.put(from.getId(), new AtomicInteger(trueDamage));\n+            takenDamage.put(from.getId(), new AtomicLong(trueDamage));\n         } else {\n             takenDamage.get(from.getId()).addAndGet(trueDamage);\n         }\n@@ -475,98 +478,85 @@ public boolean isAttackedBy(MapleCharacter chr) {\n         return takenDamage.containsKey(chr.getId());\n     }\n     \n-    private void distributeExperienceToParty(int pid, float exp, int mostDamageCid, int minThresholdLevel, int killerLevel, Set<MapleCharacter> underleveled, Map<MapleCharacter, Float> partyExpReward, Set<MapleCharacter> participants) {\n-        MapleCharacter pchar = getMap().getAnyCharacterFromParty(pid);  // thanks G h o s t, Alfred, Vcoc, BHB for poiting out a bug in detecting party members after membership transactions in a party took place\n-        \n-        List<MapleCharacter> members;\n-        if (pchar != null) {\n-            members = pchar.getPartyMembersOnSameMap();\n-        } else {\n-            members = new LinkedList<>();\n-        }\n-        \n-        List<MapleCharacter> expSharers = new LinkedList<>();\n-        int expParticipantsMaxLevel = 1;\n-        boolean hasMostDamageCid = false;\n-        for (MapleCharacter mc : members) {\n-            if (mc.getId() == mostDamageCid) {\n-                hasMostDamageCid = true;\n-            }\n-            \n-            if (mc.getLevel() >= minThresholdLevel) {    //NO EXP WILL BE GIVEN for those who are underleveled!\n-                if (Math.abs(killerLevel - mc.getLevel()) < ServerConstants.MIN_RANGELEVEL_TO_EXP_LEECH) {\n-                    // thanks Thora for pointing out leech level limitation\n-                    \n-                    if (expParticipantsMaxLevel < mc.getLevel() && participants.contains(mc)) {\n-                        expParticipantsMaxLevel = mc.getLevel();\n-                    }\n-                    expSharers.add(mc);\n-                }\n-            } else {\n-                underleveled.add(mc);\n-            }\n+    private static boolean isWhiteExpGain(MapleCharacter chr, Map<Integer, Float> personalRatio, double sdevRatio) {\n+        Float pr = personalRatio.get(chr.getId());\n+        if (pr == null) {\n+            return false;\n         }\n         \n-        int numExpSharers = expSharers.size();\n-        \n-        // PARTY BONUS: 2p -> +5% , 3p -> +6.25% , 4p -> +7.5% , 5p -> +8.75% , 6p -> +10%\n-        // MOST DAMAGE BONUS: 1.5x bonus\n-        \n-        // thanks Crypter for reporting an insufficiency on party exp bonuses\n-        final float partyModifier = numExpSharers <= 1 ? 0.0f : 0.05f + (0.0125f * (numExpSharers - 1));\n-        final float mostDamageModifier = hasMostDamageCid ? 1.5f : 1.0f;\n-        final float partyExp = exp * partyModifier * mostDamageModifier;\n-        \n-        for (MapleCharacter mc : expSharers) {\n-            float levelPenaltyModifier = (float) Math.min(1.0, Math.sqrt(((float) mc.getLevel()) / expParticipantsMaxLevel));\n-            partyExpReward.put(mc, partyExp * levelPenaltyModifier);\n-        }\n-    }\n-\n-    private int calcThresholdLevel(boolean isPqMob) {\n-        if(!ServerConstants.USE_ENFORCE_MOB_LEVEL_RANGE) {\n-            return 0;\n-        } else if (isPqMob) {\n-            double thresholdLevel = getLevel();\n-            thresholdLevel /= 32.55916838;\n-            thresholdLevel = Math.log(thresholdLevel) / 0.02058204546;\n-            \n-            return (int) Math.ceil(thresholdLevel);\n-        } else {\n-            return getLevel() - (!isBoss() ? ServerConstants.MIN_UNDERLEVEL_TO_EXP_GAIN : 2 * ServerConstants.MIN_UNDERLEVEL_TO_EXP_GAIN);\n-        }\n+        return pr >= sdevRatio;\n     }\n     \n-    private static double calcExperienceStandDevThreshold(Map<MapleCharacter, Float> personalExpReward, float exp2) {\n+    private static double calcExperienceStandDevThreshold(List<Float> entryExpRatio, int totalEntries) {\n         float avgExpReward = 0.0f;\n-        for (Float exp : personalExpReward.values()) {\n+        for (Float exp : entryExpRatio) {\n             avgExpReward += exp;\n         }\n         \n         // thanks Simon for finding an issue with solo party player gaining yellow EXP when soloing mobs\n-        float realAvgExpReward = avgExpReward;\n-        avgExpReward -= exp2;   // clear out the 20% raw exp from last hitting\n-        avgExpReward /= personalExpReward.size();\n+        avgExpReward /= totalEntries;\n         \n         float varExpReward = 0.0f;\n-        for (Float exp : personalExpReward.values()) {\n-            varExpReward += Math.pow(exp - realAvgExpReward, 2);\n+        for (Float exp : entryExpRatio) {\n+            varExpReward += Math.pow(exp - avgExpReward, 2);\n         }\n-        varExpReward /= personalExpReward.size();\n+        varExpReward /= entryExpRatio.size();\n         \n         return avgExpReward + Math.sqrt(varExpReward);\n     }\n     \n-    private void propagateExperienceGains(Map<MapleCharacter, Float> personalExpReward, Map<MapleCharacter, Float> partyExpReward, float exp2) {\n-        Set<MapleCharacter> expRewardPlayers = new HashSet<>(personalExpReward.keySet());\n-        expRewardPlayers.addAll(partyExpReward.keySet());\n+    private void distributePlayerExperience(MapleCharacter chr, float exp, float partyBonusMod, int totalPartyLevel, boolean highestPartyDamager, boolean whiteExpGain) {\n+        float playerExp = (ServerConstants.EXP_SPLIT_COMMON_MOD * chr.getLevel()) / totalPartyLevel;\n+        if (highestPartyDamager) playerExp += ServerConstants.EXP_SPLIT_MVP_MOD;\n+        \n+        playerExp *= exp;\n+        float bonusExp = partyBonusMod * playerExp;\n+        \n+        this.giveExpToCharacter(chr, playerExp, bonusExp, whiteExpGain);\n+    }\n+    \n+    private void distributePartyExperience(Map<MapleCharacter, Long> partyParticipation, float expPerDmg, Set<MapleCharacter> underleveled, Map<Integer, Float> personalRatio, double sdevRatio) {\n+        IntervalBuilder leechInterval = new IntervalBuilder();\n+        leechInterval.addInterval(this.getLevel() - ServerConstants.EXP_SPLIT_LEVEL_INTERVAL, this.getLevel() + ServerConstants.EXP_SPLIT_LEVEL_INTERVAL);\n+        \n+        long maxDamage = 0, partyDamage = 0;\n+        MapleCharacter participationMvp = null;\n+        for (Entry<MapleCharacter, Long> e : partyParticipation.entrySet()) {\n+            long entryDamage = e.getValue();\n+            partyDamage += entryDamage;\n+            \n+            if (maxDamage < entryDamage) {\n+                maxDamage = entryDamage;\n+                participationMvp = e.getKey();\n+            }\n+            \n+            // thanks Thora for pointing out leech level limitation\n+            int chrLevel = e.getKey().getLevel();\n+            leechInterval.addInterval(chrLevel - ServerConstants.EXP_SPLIT_LEECH_INTERVAL, chrLevel + ServerConstants.EXP_SPLIT_LEECH_INTERVAL);\n+        }\n+        \n+        List<MapleCharacter> expMembers = new LinkedList<>();\n+        int totalPartyLevel = 0;\n         \n-        double sdevExp = calcExperienceStandDevThreshold(personalExpReward, exp2);\n-        for (MapleCharacter chr : expRewardPlayers) {\n-            Float personalExp = personalExpReward.get(chr);\n-            Float partyExp = partyExpReward.get(chr);\n+        // thanks G h o s t, Alfred, Vcoc, BHB for poiting out a bug in detecting party members after membership transactions in a party took place\n+        for (MapleCharacter member : partyParticipation.keySet().iterator().next().getPartyMembersOnSameMap()) {\n+            if (!leechInterval.inInterval(member.getLevel())) {\n+                underleveled.add(member);\n+                continue;\n+            }\n             \n-            this.giveExpToCharacter(chr, personalExp, partyExp, personalExp != null && personalExp >= sdevExp);\n+            totalPartyLevel += member.getLevel();\n+            expMembers.add(member);\n+        }\n+        \n+        int membersSize = expMembers.size();\n+        float participationExp = partyDamage * expPerDmg;\n+        \n+        // thanks Crypter for reporting an insufficiency on party exp bonuses\n+        float partyBonusMod = (membersSize > 1) ? 0.05f * membersSize : 0.0f;\n+        \n+        for (MapleCharacter mc : expMembers) {\n+            distributePlayerExperience(mc, participationExp, partyBonusMod, totalPartyLevel, mc == participationMvp, isWhiteExpGain(mc, personalRatio, sdevRatio));\n         }\n     }\n     \n@@ -575,84 +565,89 @@ private void distributeExperience(int killerId) {\n             return;\n         }\n         \n-        Map<MapleCharacter, Float> personalExpReward = new HashMap<>();\n-        Map<MapleCharacter, Float> partyExpReward = new HashMap<>();\n+        Map<MapleParty, Map<MapleCharacter, Long>> partyExpDist = new HashMap<>();\n+        Map<MapleCharacter, Long> soloExpDist = new HashMap<>();\n         \n-        EventInstanceManager eim = getMap().getEventInstance();\n-        int minThresholdLevel = calcThresholdLevel(eim != null), killerLevel = Integer.MAX_VALUE;\n-        int exp = getExp();\n-        long totalHealth = maxHpPlusHeal.get();\n-        Map<Integer, Float> expDist = new HashMap<>();\n-        Map<Integer, Float> partyExp = new HashMap<>();\n+        Map<Integer, MapleCharacter> mapPlayers = map.getMapAllPlayers();\n         \n-        float exp8perHp = (0.8f * exp) / totalHealth;   // 80% of pool is split amongst all the damagers\n-        float exp2 = (0.2f * exp);                      // 20% of pool goes to the killer or his/her party\n-        \n-        for (Entry<Integer, AtomicInteger> damage : takenDamage.entrySet()) {\n-            expDist.put(damage.getKey(), exp8perHp * damage.getValue().get());\n-        }\n-        \n-        Set<MapleCharacter> underleveled = new HashSet<>();\n-        Collection<MapleCharacter> mapChrs = map.getCharacters();\n-        for (MapleCharacter mc : mapChrs) {\n-            Float mcExp = expDist.remove(mc.getId());\n-            if (mcExp != null) {\n-                float xp = mcExp;\n-                boolean isKiller = (mc.getId() == killerId);\n-                if (isKiller) {\n-                    if (eim != null) {\n-                        eim.monsterKilled(mc, this);\n-                    }\n-                    \n-                    killerLevel = mc.getLevel();\n-                    xp += exp2;\n-                }\n+        int totalEntries = 0;   // counts \"participant parties\", players who no longer are available in the map is an \"independent party\"\n+        for (Entry<Integer, AtomicLong> e : takenDamage.entrySet()) {\n+            MapleCharacter chr = mapPlayers.get(e.getKey());\n+            if (chr != null) {\n+                long damage = e.getValue().longValue();\n                 \n-                if(mc.getLevel() >= minThresholdLevel) {\n-                    //NO EXP WILL BE GIVEN for those who are underleveled!\n-                    personalExpReward.put(mc, xp);\n-                    \n-                    MapleParty p = mc.getParty();\n-                    if (p != null) {    // for party bonus exp\n-                        int pID = p.getId();\n-                        float pXP = xp + (partyExp.containsKey(pID) ? partyExp.get(pID) : 0);\n-                        partyExp.put(pID, pXP);\n+                MapleParty p = chr.getParty();\n+                if (p != null) {\n+                    Map<MapleCharacter, Long> partyParticipation = partyExpDist.get(p);\n+                    if (partyParticipation == null) {\n+                        partyParticipation = new HashMap<>(6);\n+                        partyExpDist.put(p, partyParticipation);\n+                        \n+                        totalEntries += 1;\n                     }\n+                    \n+                    partyParticipation.put(chr, damage);\n                 } else {\n-                    underleveled.add(mc);\n+                    soloExpDist.put(chr, damage);\n+                    totalEntries += 1;\n                 }\n+            } else {\n+                totalEntries += 1;\n             }\n         }\n         \n-        if(!expDist.isEmpty()) {    // locate on world server the partyid of the missing characters\n-            World wserv = map.getWorldServer();\n+        long totalDamage = maxHpPlusHeal.get();\n+        int mobExp = getExp();\n+        float expPerDmg = ((float) mobExp) / totalDamage;\n+        \n+        Map<Integer, Float> personalRatio = new HashMap<>();\n+        List<Float> entryExpRatio = new LinkedList<>();\n+        for (Entry<MapleCharacter, Long> e : soloExpDist.entrySet()) {\n+            float ratio = ((float) e.getValue()) / totalDamage;\n             \n-            for (Entry<Integer, Float> ed : expDist.entrySet()) {\n-                boolean isKiller = (ed.getKey() == killerId);\n-                float xp = ed.getValue();\n-                if (isKiller) {\n-                    xp += exp2;\n-                }\n-\n-                Integer pID = wserv.getCharacterPartyid(ed.getKey());\n-                if (pID != null) {\n-                    float pXP = xp + (partyExp.containsKey(pID) ? partyExp.get(pID) : 0);\n-                    partyExp.put(pID, pXP);\n-                }\n+            personalRatio.put(e.getKey().getId(), ratio);\n+            entryExpRatio.add(ratio);\n+        }\n+        \n+        for (Map<MapleCharacter, Long> m : partyExpDist.values()) {\n+            float ratio = 0.0f;\n+            for (Entry<MapleCharacter, Long> e : m.entrySet()) {\n+                float chrRatio = ((float) e.getValue()) / totalDamage;\n+                \n+                personalRatio.put(e.getKey().getId(), chrRatio);\n+                ratio += chrRatio;\n             }\n+            \n+            entryExpRatio.add(ratio);\n+        }\n+        \n+        double sdevRatio = calcExperienceStandDevThreshold(entryExpRatio, totalEntries);\n+        \n+        // GMS-like player and party split calculations found thanks to Russt, KaidaTan, Dusk, AyumiLove. Src: https://ayumilovemaple.wordpress.com/maplestory_calculator_formula/\n+        Set<MapleCharacter> underleveled = new HashSet<>();\n+        for (Entry<MapleCharacter, Long> chrParticipation : soloExpDist.entrySet()) {\n+            float exp = chrParticipation.getValue() * expPerDmg;\n+            MapleCharacter chr = chrParticipation.getKey();\n+            \n+            distributePlayerExperience(chr, exp, 0.0f, chr.getLevel(), true, isWhiteExpGain(chr, personalRatio, sdevRatio));\n+        }\n+        \n+        for (Map<MapleCharacter, Long> partyParticipation : partyExpDist.values()) {\n+            distributePartyExperience(partyParticipation, expPerDmg, underleveled, personalRatio, sdevRatio);\n         }\n         \n-        Set<MapleCharacter> participants = personalExpReward.keySet();\n-        int mostDamageCid = this.getHighestDamagerId();\n-        for (Entry<Integer, Float> party : partyExp.entrySet()) {\n-            distributeExperienceToParty(party.getKey(), party.getValue(), mostDamageCid, minThresholdLevel, killerLevel, underleveled, partyExpReward, participants);\n+        EventInstanceManager eim = getMap().getEventInstance();\n+        if (eim != null) {\n+            MapleCharacter chr = mapPlayers.get(killerId);\n+            if (chr != null) {\n+                eim.monsterKilled(chr, this);\n+            }\n         }\n         \n         for(MapleCharacter mc : underleveled) {\n             mc.showUnderleveledInfo(this);\n         }\n         \n-        propagateExperienceGains(personalExpReward, partyExpReward, killerLevel != Integer.MAX_VALUE ? exp2 : 0.0f);\n     }\n     \n     private float getStatusExpMultiplier(MapleCharacter attacker) {\n@@ -718,6 +713,20 @@ private void giveExpToCharacter(MapleCharacter attacker, Float personalExp, Floa\n             attacker.updateQuestMobCount(getId());\n         }\n     }\n+    \n+    public List<MonsterDropEntry> retrieveRelevantDrops() {\n+        Map<Integer, MapleCharacter> pchars = map.getMapAllPlayers();\n+        \n+        List<MapleCharacter> lootChars = new LinkedList<>();\n+        for (Integer cid : takenDamage.keySet()) {\n+            MapleCharacter chr = pchars.get(cid);\n+            if (chr != null && chr.isLoggedinWorld()) {\n+                lootChars.add(chr);\n+            }\n+        }\n+        \n+        return MapleLootManager.retrieveRelevantDrops(this.getId(), lootChars);\n+    }\n \n     public MapleCharacter killBy(final MapleCharacter killer) {\n         distributeExperience(killer != null ? killer.getId() : 0);\n@@ -904,9 +913,9 @@ private void dispatchMonsterHealed(int trueHeal) {\n \n     public int getHighestDamagerId() {\n         int curId = 0;\n-        int curDmg = 0;\n+        long curDmg = 0;\n \n-        for (Entry<Integer, AtomicInteger> damage : takenDamage.entrySet()) {\n+        for (Entry<Integer, AtomicLong> damage : takenDamage.entrySet()) {\n             curId = damage.getValue().get() >= curDmg ? damage.getKey() : curId;\n             curDmg = damage.getKey() == curId ? damage.getValue().get() : curDmg;\n         }\n@@ -1012,6 +1021,16 @@ public boolean isMobile() {\n         return stats.isMobile();\n     }\n \n+    @Override\n+    public boolean isFacingLeft() {\n+        int fixedStance = stats.getFixedStance();    // thanks DimDiDima for noticing inconsistency on some AOE mobskills\n+        if (fixedStance != 0) {\n+            return Math.abs(fixedStance) % 2 == 1;\n+        }\n+        \n+        return super.isFacingLeft();\n+    }\n+    \n     public ElementalEffectiveness getElementalEffectiveness(Element e) {\n         statiLock.lock();\n         try {"}, {"sha": "94d3a07038e4503b1651f7bb27d0f4d757e5808a", "filename": "src/server/life/MapleMonsterStats.java", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/life/MapleMonsterStats.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/life/MapleMonsterStats.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/life/MapleMonsterStats.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -50,6 +50,7 @@\n     public BanishInfo banish = null;\n     public List<loseItem> loseItem = null;\n     public selfDestruction selfDestruction = null;\n+    public int fixedStance = 0;\n     public boolean friendly;\n \n     public void setChange(boolean change) {\n@@ -339,6 +340,14 @@ public void setMDDamage(int MDDamage) {\n         this.MDDamage = MDDamage;\n     } \n     \n+    public int getFixedStance() {\n+        return this.fixedStance;\n+    }\n+    \n+    public void setFixedStance(int stance) {\n+        this.fixedStance = stance;\n+    }\n+    \n     public MapleMonsterStats copy() {\n         MapleMonsterStats copy = new MapleMonsterStats();\n         try {"}, {"sha": "55c6e6436dc4c870db55f716d9239a38a64457f2", "filename": "src/server/life/MobSkill.java", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/life/MobSkill.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/life/MobSkill.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/life/MobSkill.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -197,7 +197,7 @@ public void applyEffect(MapleCharacter player, MapleMonster monster, boolean ski\n                 }\n                 break;\n             case 131: // Mist\n-                monster.getMap().spawnMist(new MapleMist(calculateBoundingBox(monster.getPosition(), true), monster, this), x * 100, false, false, false);\n+                monster.getMap().spawnMist(new MapleMist(calculateBoundingBox(monster.getPosition(), monster.isFacingLeft()), monster, this), x * 100, false, false, false);\n                 break;\n             case 132:\n                 disease = MapleDisease.CONFUSE;\n@@ -253,9 +253,9 @@ public void applyEffect(MapleCharacter player, MapleMonster monster, boolean ski\n                     List<Integer> summons = getSummons();\n                     int summonLimit = monster.countAvailableMobSummons(summons.size(), skillLimit);\n                     if (summonLimit >= 1) {\n-                        Collections.shuffle(summons);\n                         boolean bossRushMap = GameConstants.isBossRush(map.getId());\n-\n+                        \n+                        Collections.shuffle(summons);\n                         for (Integer mobId : summons.subList(0, summonLimit)) {\n                             MapleMonster toSpawn = MapleLifeFactory.getMonster(mobId);\n                             if (toSpawn != null) {\n@@ -412,12 +412,11 @@ private Rectangle calculateBoundingBox(Point posFrom, boolean facingLeft) {\n         int multiplier = facingLeft ? 1 : -1;\n         Point mylt = new Point(lt.x * multiplier + posFrom.x, lt.y + posFrom.y);\n         Point myrb = new Point(rb.x * multiplier + posFrom.x, rb.y + posFrom.y);\n-        return new Rectangle(mylt.x, mylt.y, myrb.x - mylt.x, myrb.y - mylt.y);\n+        Rectangle bounds = new Rectangle(mylt.x, mylt.y, myrb.x - mylt.x, myrb.y - mylt.y);\n+        return bounds;\n     }\n \n     private List<MapleMapObject> getObjectsInRange(MapleMonster monster, MapleMapObjectType objectType) {\n-        List<MapleMapObjectType> objectTypes = new ArrayList<MapleMapObjectType>();\n-        objectTypes.add(objectType);\n-        return monster.getMap().getMapObjectsInBox(calculateBoundingBox(monster.getPosition(), monster.isFacingLeft()), objectTypes);\n+        return monster.getMap().getMapObjectsInBox(calculateBoundingBox(monster.getPosition(), monster.isFacingLeft()), Collections.singletonList(objectType));\n     }\n }"}, {"sha": "bcfef5ee69d4b5bd8d01040e73ed5dd2229e0e64", "filename": "src/server/loot/MapleLootManager.java", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/loot/MapleLootManager.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/loot/MapleLootManager.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/loot/MapleLootManager.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -23,7 +23,7 @@\n import java.util.LinkedList;\n import java.util.List;\n \n-import server.MapleItemInformationProvider;\n+//import server.MapleItemInformationProvider;\n import server.life.MapleMonsterInformationProvider;\n import server.life.MonsterDropEntry;\n import server.quest.MapleQuest;\n@@ -34,20 +34,20 @@\n  */\n public class MapleLootManager {\n     \n-    private static boolean isRelevantDrop(MonsterDropEntry dropEntry, List<MapleCharacter> partyMembers, List<MapleLootInventory> partyInv) {\n+    private static boolean isRelevantDrop(MonsterDropEntry dropEntry, List<MapleCharacter> players, List<MapleLootInventory> playersInv) {\n         int qStartAmount = 0, qCompleteAmount = 0;\n         MapleQuest quest = MapleQuest.getInstance(dropEntry.questid);\n         if (quest != null) {\n             qStartAmount = quest.getStartItemAmountNeeded(dropEntry.itemId);\n             qCompleteAmount = quest.getCompleteItemAmountNeeded(dropEntry.itemId);\n         }\n         \n-        boolean restricted = MapleItemInformationProvider.getInstance().isPickupRestricted(dropEntry.itemId);\n-        for (int i = 0; i < partyMembers.size(); i++) {\n-            MapleLootInventory chrInv = partyInv.get(i);\n+        //boolean restricted = MapleItemInformationProvider.getInstance().isPickupRestricted(dropEntry.itemId);\n+        for (int i = 0; i < players.size(); i++) {\n+            MapleLootInventory chrInv = playersInv.get(i);\n             \n             if (dropEntry.questid > 0) {\n-                int qItemAmount, chrQuestStatus = partyMembers.get(i).getQuestStatus(dropEntry.questid);\n+                int qItemAmount, chrQuestStatus = players.get(i).getQuestStatus(dropEntry.questid);\n                 if (chrQuestStatus == 0) {\n                     qItemAmount = qStartAmount;\n                 } else if (chrQuestStatus != 1) {\n@@ -63,32 +63,32 @@ private static boolean isRelevantDrop(MonsterDropEntry dropEntry, List<MapleChar\n                 int qItemStatus = chrInv.hasItem(dropEntry.itemId, qItemAmount);\n                 if (qItemStatus == 2) {\n                     continue;\n-                } else if (restricted && qItemStatus == 1) {\n+                } /*else if (restricted && qItemStatus == 1) {\n                     continue;\n-                }\n-            } else if (restricted && chrInv.hasItem(dropEntry.itemId, 1) > 0) {\n+                }*/\n+            } /*else if (restricted && chrInv.hasItem(dropEntry.itemId, 1) > 0) {   // thanks Conrad, Legalize for noticing eligible loots not being available to drop for non-killer parties\n                 continue;\n-            }\n+            }*/\n             \n             return true;\n         }\n         \n         return false;\n     }\n     \n-    public static List<MonsterDropEntry> retrieveRelevantDrops(int monsterId, List<MapleCharacter> partyMembers) {\n+    public static List<MonsterDropEntry> retrieveRelevantDrops(int monsterId, List<MapleCharacter> players) {\n         List<MonsterDropEntry> loots = MapleMonsterInformationProvider.getInstance().retrieveEffectiveDrop(monsterId);\n         if(loots.isEmpty()) return loots;\n         \n-        List<MapleLootInventory> partyInv = new LinkedList<>();\n-        for(MapleCharacter chr : partyMembers) {\n+        List<MapleLootInventory> playersInv = new LinkedList<>();\n+        for(MapleCharacter chr : players) {\n             MapleLootInventory lootInv = new MapleLootInventory(chr);\n-            partyInv.add(lootInv);\n+            playersInv.add(lootInv);\n         }\n         \n         List<MonsterDropEntry> effectiveLoot = new LinkedList<>();\n         for(MonsterDropEntry mde : loots) {\n-            if(isRelevantDrop(mde, partyMembers, partyInv)) {\n+            if(isRelevantDrop(mde, players, playersInv)) {\n                 effectiveLoot.add(mde);\n             }\n         }"}, {"sha": "2bc9ca9a0cf61b68b19a4c712f53df46e844b5d7", "filename": "src/server/maps/MapleMap.java", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/maps/MapleMap.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/maps/MapleMap.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/maps/MapleMap.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -85,8 +85,6 @@\n import server.life.MonsterGlobalDropEntry;\n import server.life.SpawnPoint;\n import scripting.event.EventInstanceManager;\n-import server.expeditions.MapleExpedition;\n-import server.expeditions.MapleExpeditionType;\n import server.life.MaplePlayerNPC;\n import server.life.MonsterListener;\n import server.partyquest.GuardianSpawnPoint;\n@@ -744,7 +742,7 @@ private void dropFromMonster(final MapleCharacter chr, final MapleMonster mob, f\n         final List<MonsterDropEntry>  dropEntry = new ArrayList<>();\n         final List<MonsterDropEntry> visibleQuestEntry = new ArrayList<>();\n         final List<MonsterDropEntry> otherQuestEntry = new ArrayList<>();\n-        sortDropEntries(ServerConstants.USE_SPAWN_RELEVANT_LOOT ? chr.retrieveRelevantDrops(mob.getId()) : mi.retrieveEffectiveDrop(mob.getId()), dropEntry, visibleQuestEntry, otherQuestEntry, chr);\n+        sortDropEntries(ServerConstants.USE_SPAWN_RELEVANT_LOOT ? mob.retrieveRelevantDrops() : mi.retrieveEffectiveDrop(mob.getId()), dropEntry, visibleQuestEntry, otherQuestEntry, chr);\n         \n         registerMobItemDrops(droptype, mobpos, chRate, pos, dropEntry, visibleQuestEntry, otherQuestEntry, globalEntry, chr, mob);\n     }\n@@ -1281,6 +1279,15 @@ public int countPlayers() {\n         return character;\n     }\n     \n+    public Map<Integer, MapleCharacter> getMapAllPlayers() {\n+        Map<Integer, MapleCharacter> pchars = new HashMap<>();\n+        for (MapleCharacter chr : this.getAllPlayers()) {\n+            pchars.put(chr.getId(), chr);\n+        }\n+        \n+        return pchars;\n+    }\n+    \n     public List<MapleCharacter> getPlayersInRange(Rectangle box, List<MapleCharacter> targets) {\n         List<MapleCharacter> character = new LinkedList<>();\n         chrRLock.lock();\n@@ -3724,6 +3731,14 @@ public void respawn() {\n         }\n     }\n     \n+    public void mobMpRecovery() {\n+        for (MapleMonster mob : this.getAllMonsters()) {\n+            if (mob.isAlive()) {\n+                mob.heal(0, mob.getLevel());\n+            }\n+        }\n+    }\n+    \n     public final int getNumPlayersInArea(final int index) {\n         return getNumPlayersInRect(getArea(index));\n     }"}, {"sha": "e3c33db3fa7dbd6f9c5f4b3fe851941bad90dbcd", "filename": "src/server/maps/MapleMapFactory.java", "status": "modified", "additions": 30, "deletions": 134, "changes": 164, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/maps/MapleMapFactory.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/maps/MapleMapFactory.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/maps/MapleMapFactory.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -23,23 +23,18 @@\n \n import java.awt.Point;\n import java.awt.Rectangle;\n+import java.io.File;\n import java.sql.Connection;\n import java.sql.PreparedStatement;\n import java.sql.ResultSet;\n import java.sql.SQLException;\n-import java.util.Collection;\n-import java.util.Collections;\n import java.util.HashMap;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;\n-import net.server.audit.locks.MonitoredLockType;\n-import net.server.audit.locks.MonitoredReentrantReadWriteLock;\n import provider.MapleData;\n import provider.MapleDataProvider;\n+import provider.MapleDataProviderFactory;\n import provider.MapleDataTool;\n import server.PortalFactory;\n import server.life.AbstractLoadedMapleLife;\n@@ -54,40 +49,17 @@\n \n public class MapleMapFactory {\n \n-    private static Map<Integer, Float> mapRecoveryRate = new HashMap<>();\n-\n-    private MapleDataProvider source;\n-    private MapleData nameData;\n-    private EventInstanceManager event;\n-    private Map<Integer, MapleMap> maps = new HashMap<>();\n-    private ReadLock mapsRLock;\n-    private WriteLock mapsWLock;\n-    private int channel, world;\n-\n-    public MapleMapFactory(EventInstanceManager eim, MapleDataProvider source, MapleDataProvider stringSource, int world, int channel) {\n-        this.source = source;\n-        this.nameData = stringSource.getData(\"Map.img\");\n-        this.world = world;\n-        this.channel = channel;\n-        this.event = eim;\n-\n-        ReentrantReadWriteLock rrwl = new MonitoredReentrantReadWriteLock(MonitoredLockType.MAP_FACTORY);\n-        this.mapsRLock = rrwl.readLock();\n-        this.mapsWLock = rrwl.writeLock();\n-    }\n-\n-    public MapleMap resetMap(int mapid) {\n-        mapsWLock.lock();\n-        try {\n-            maps.remove(Integer.valueOf(mapid));\n-        } finally {\n-            mapsWLock.unlock();\n-        }\n-\n-        return getMap(mapid);\n+    private static Map<Integer, Float> mapRecoveryRateCache = new HashMap<>();\n+    \n+    private static MapleData nameData;\n+    private static MapleDataProvider mapSource;\n+    \n+    static {\n+        nameData = MapleDataProviderFactory.getDataProvider(new File(System.getProperty(\"wzpath\") + \"/String.wz\")).getData(\"Map.img\");\n+        mapSource = MapleDataProviderFactory.getDataProvider(new File(System.getProperty(\"wzpath\") + \"/Map.wz\"));\n     }\n \n-    private void loadLifeFromWz(MapleMap map, MapleData mapData) {\n+    private static void loadLifeFromWz(MapleMap map, MapleData mapData) {\n         for (MapleData life : mapData.getChildByPath(\"life\")) {\n             life.getName();\n             String id = MapleDataTool.getString(life.getChildByPath(\"id\"));\n@@ -115,7 +87,7 @@ private void loadLifeFromWz(MapleMap map, MapleData mapData) {\n         }\n     }\n \n-    private void loadLifeFromDb(MapleMap map) {\n+    private static void loadLifeFromDb(MapleMap map) {\n         try {\n             Connection con = DatabaseConnection.getConnection();\n             PreparedStatement ps = con.prepareStatement(\"SELECT * FROM plife WHERE map = ? and world = ?\");\n@@ -148,7 +120,7 @@ private void loadLifeFromDb(MapleMap map) {\n         }\n     }\n \n-    private void loadLifeRaw(MapleMap map, int id, String type, int cy, int f, int fh, int rx0, int rx1, int x, int y, int hide, int mobTime, int team) {\n+    private static void loadLifeRaw(MapleMap map, int id, String type, int cy, int f, int fh, int rx0, int rx1, int x, int y, int hide, int mobTime, int team) {\n         AbstractLoadedMapleLife myLife = loadLife(id, type, cy, f, fh, rx0, rx1, x, y, hide);\n         if (myLife instanceof MapleMonster) {\n             MapleMonster monster = (MapleMonster) myLife;\n@@ -166,30 +138,17 @@ private void loadLifeRaw(MapleMap map, int id, String type, int cy, int f, int f\n         }\n     }\n \n-    private synchronized MapleMap loadMapFromWz(int mapid, Integer omapid, boolean cache) {\n+    public static MapleMap loadMapFromWz(int mapid, int world, int channel, EventInstanceManager event) {\n         MapleMap map;\n-\n-        if (cache) {\n-            mapsRLock.lock();\n-            try {\n-                map = maps.get(omapid);\n-            } finally {\n-                mapsRLock.unlock();\n-            }\n-\n-            if (map != null) {\n-                return map;\n-            }\n-        }\n-\n+        \n         String mapName = getMapName(mapid);\n-        MapleData mapData = source.getData(mapName);    // source.getData issue with giving nulls in rare ocasions found thanks to MedicOP\n+        MapleData mapData = mapSource.getData(mapName);    // source.getData issue with giving nulls in rare ocasions found thanks to MedicOP\n         MapleData infoData = mapData.getChildByPath(\"info\");\n \n         String link = MapleDataTool.getString(infoData.getChildByPath(\"link\"), \"\");\n         if (!link.equals(\"\")) { //nexon made hundreds of dojo maps so to reduce the size they added links.\n             mapName = getMapName(Integer.parseInt(link));\n-            mapData = source.getData(mapName);\n+            mapData = mapSource.getData(mapName);\n         }\n         float monsterRate = 0;\n         MapleData mobRate = infoData.getChildByPath(\"mobRate\");\n@@ -288,7 +247,7 @@ private synchronized MapleMap loadMapFromWz(int mapid, Integer omapid, boolean c\n             try {\n                 Connection con = DatabaseConnection.getConnection();\n                 try (PreparedStatement ps = con.prepareStatement(\"SELECT * FROM playernpcs WHERE map = ? AND world = ?\")) {\n-                    ps.setInt(1, omapid);\n+                    ps.setInt(1, mapid);\n                     ps.setInt(2, world);\n                     try (ResultSet rs = ps.executeQuery()) {\n                         while (rs.next()) {\n@@ -352,21 +311,21 @@ private synchronized MapleMap loadMapFromWz(int mapid, Integer omapid, boolean c\n             }\n         }\n         try {\n-            map.setMapName(MapleDataTool.getString(\"mapName\", nameData.getChildByPath(getMapStringName(omapid)), \"\"));\n-            map.setStreetName(MapleDataTool.getString(\"streetName\", nameData.getChildByPath(getMapStringName(omapid)), \"\"));\n+            map.setMapName(MapleDataTool.getString(\"mapName\", nameData.getChildByPath(getMapStringName(mapid)), \"\"));\n+            map.setStreetName(MapleDataTool.getString(\"streetName\", nameData.getChildByPath(getMapStringName(mapid)), \"\"));\n         } catch (Exception e) {\n-            if (omapid / 1000 != 1020) {     // explorer job introducion scenes\n+            if (mapid / 1000 != 1020) {     // explorer job introduction scenes\n                 e.printStackTrace();\n-                System.err.println(\"Not found mapid \" + omapid);\n+                System.err.println(\"Not found mapid \" + mapid);\n             }\n \n             map.setMapName(\"\");\n             map.setStreetName(\"\");\n         }\n \n         map.setClock(mapData.getChildByPath(\"clock\") != null);\n-        map.setEverlast(infoData.getChildByPath(\"everlast\") != null);\n-        map.setTown(infoData.getChildByPath(\"town\") != null);\n+        map.setEverlast(MapleDataTool.getIntConvert(\"everlast\", infoData, 0) != 0); // thanks davidlafriniere for noticing value 0 accounting as true\n+        map.setTown(MapleDataTool.getIntConvert(\"town\", infoData, 0) != 0);\n         map.setHPDec(MapleDataTool.getIntConvert(\"decHP\", infoData, 0));\n         map.setHPDecProtect(MapleDataTool.getIntConvert(\"protectItem\", infoData, 0));\n         map.setForcedReturnMap(MapleDataTool.getInt(infoData.getChildByPath(\"forcedReturn\"), 999999999));\n@@ -378,7 +337,7 @@ private synchronized MapleMap loadMapFromWz(int mapid, Integer omapid, boolean c\n         MapleData recData = infoData.getChildByPath(\"recovery\");\n         if (recData != null) {\n             float recoveryRate = MapleDataTool.getFloat(recData);\n-            mapRecoveryRate.put(mapid, recoveryRate);\n+            mapRecoveryRateCache.put(mapid, recoveryRate);\n         }\n \n         HashMap<Integer, Integer> backTypes = new HashMap<>();\n@@ -397,46 +356,10 @@ private synchronized MapleMap loadMapFromWz(int mapid, Integer omapid, boolean c\n         map.setBackgroundTypes(backTypes);\n         map.generateMapDropRangeCache();\n \n-        if (cache) {\n-            mapsWLock.lock();\n-            try {\n-                maps.put(omapid, map);\n-            } finally {\n-                mapsWLock.unlock();\n-            }\n-        }\n-\n         return map;\n     }\n-\n-    public MapleMap getMap(int mapid) {\n-        Integer omapid = Integer.valueOf(mapid);\n-        MapleMap map;\n-\n-        mapsRLock.lock();\n-        try {\n-            map = maps.get(omapid);\n-        } finally {\n-            mapsRLock.unlock();\n-        }\n-\n-        return (map != null) ? map : loadMapFromWz(mapid, omapid, true);\n-    }\n     \n-    public MapleMap getDisposableMap(int mapid) {\n-        return loadMapFromWz(mapid, mapid, false);\n-    }\n-\n-    public boolean isMapLoaded(int mapId) {\n-        mapsRLock.lock();\n-        try {\n-            return maps.containsKey(mapId);\n-        } finally {\n-            mapsRLock.unlock();\n-        }\n-    }\n-\n-    private AbstractLoadedMapleLife loadLife(int id, String type, int cy, int f, int fh, int rx0, int rx1, int x, int y, int hide) {\n+    private static AbstractLoadedMapleLife loadLife(int id, String type, int cy, int f, int fh, int rx0, int rx1, int x, int y, int hide) {\n         AbstractLoadedMapleLife myLife = MapleLifeFactory.getLife(id, type);\n         myLife.setCy(cy);\n         myLife.setF(f);\n@@ -450,7 +373,7 @@ private AbstractLoadedMapleLife loadLife(int id, String type, int cy, int f, int\n         return myLife;\n     }\n \n-    private MapleReactor loadReactor(MapleData reactor, String id, final byte FacingDirection) {\n+    private static MapleReactor loadReactor(MapleData reactor, String id, final byte FacingDirection) {\n         MapleReactor myReactor = new MapleReactor(MapleReactorFactory.getReactor(Integer.parseInt(id)), Integer.parseInt(id));\n         int x = MapleDataTool.getInt(reactor.getChildByPath(\"x\"));\n         int y = MapleDataTool.getInt(reactor.getChildByPath(\"y\"));\n@@ -462,7 +385,7 @@ private MapleReactor loadReactor(MapleData reactor, String id, final byte Facing\n         return myReactor;\n     }\n \n-    private String getMapName(int mapid) {\n+    private static String getMapName(int mapid) {\n         String mapName = StringUtil.getLeftPaddedStr(Integer.toString(mapid), '0', 9);\n         StringBuilder builder = new StringBuilder(\"Map/Map\");\n         int area = mapid / 100000000;\n@@ -474,7 +397,7 @@ private String getMapName(int mapid) {\n         return mapName;\n     }\n \n-    private String getMapStringName(int mapid) {\n+    private static String getMapStringName(int mapid) {\n         StringBuilder builder = new StringBuilder();\n         if (mapid < 100000000) {\n             builder.append(\"maple\");\n@@ -513,35 +436,8 @@ private String getMapStringName(int mapid) {\n         return builder.toString();\n     }\n \n-    public void setChannel(int channel) {\n-        this.channel = channel;\n-    }\n-\n-    public void setWorld(int world) {\n-        this.channel = world;\n-    }\n-\n-    public Map<Integer, MapleMap> getMaps() {\n-        mapsRLock.lock();\n-        try {\n-            return new HashMap<>(maps);\n-        } finally {\n-            mapsRLock.unlock();\n-        }\n-    }\n-\n-    public void dispose() {\n-        Collection<MapleMap> mapValues = getMaps().values();\n-\n-        for (MapleMap map : mapValues) {\n-            map.dispose();\n-        }\n-\n-        this.event = null;\n-    }\n-\n     public static float getMapRecoveryRate(int mapid) {\n-        Float recRate = mapRecoveryRate.get(mapid);\n+        Float recRate = mapRecoveryRateCache.get(mapid);\n         return recRate != null ? recRate : 1.0f;\n     }\n }"}, {"sha": "7c5958954c4a37ae9619af2010d957876850d010", "filename": "src/server/maps/MapleMapManager.java", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/maps/MapleMapManager.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/maps/MapleMapManager.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/maps/MapleMapManager.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -0,0 +1,162 @@\n+/*\n+    This file is part of the HeavenMS MapleStory Server\n+    Copyleft (L) 2016 - 2018 RonanLana\n+\n+    This program is free software: you can redistribute it and/or modify\n+    it under the terms of the GNU Affero General Public License as\n+    published by the Free Software Foundation version 3 as published by\n+    the Free Software Foundation. You may not use, modify or distribute\n+    this program under any other version of the GNU Affero General Public\n+    License.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU Affero General Public License for more details.\n+\n+    You should have received a copy of the GNU Affero General Public License\n+    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+*/\n+package server.maps;\n+\n+import constants.ServerConstants;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;\n+import net.server.audit.locks.MonitoredLockType;\n+import net.server.audit.locks.MonitoredReentrantReadWriteLock;\n+import scripting.event.EventInstanceManager;\n+import server.TimerManager;\n+\n+public class MapleMapManager {\n+\n+    private int channel, world;\n+    private EventInstanceManager event;\n+    \n+    private Map<Integer, MapleMap> maps = new HashMap<>();\n+    \n+    private ScheduledFuture<?> updateTask;\n+    \n+    private ReadLock mapsRLock;\n+    private WriteLock mapsWLock;\n+\n+    public MapleMapManager(EventInstanceManager eim, int world, int channel) {\n+        this.world = world;\n+        this.channel = channel;\n+        this.event = eim;\n+\n+        ReentrantReadWriteLock rrwl = new MonitoredReentrantReadWriteLock(MonitoredLockType.MAP_MANAGER);\n+        this.mapsRLock = rrwl.readLock();\n+        this.mapsWLock = rrwl.writeLock();\n+        \n+        updateTask = TimerManager.getInstance().register(new Runnable() {\n+            @Override\n+            public void run() {\n+                updateMaps();\n+            }\n+        }, ServerConstants.RESPAWN_INTERVAL);\n+    }\n+\n+    public MapleMap resetMap(int mapid) {\n+        mapsWLock.lock();\n+        try {\n+            maps.remove(mapid);\n+        } finally {\n+            mapsWLock.unlock();\n+        }\n+\n+        return getMap(mapid);\n+    }\n+\n+    private synchronized MapleMap loadMapFromWz(int mapid, boolean cache) {\n+        MapleMap map;\n+\n+        if (cache) {\n+            mapsRLock.lock();\n+            try {\n+                map = maps.get(mapid);\n+            } finally {\n+                mapsRLock.unlock();\n+            }\n+\n+            if (map != null) {\n+                return map;\n+            }\n+        }\n+\n+        map = MapleMapFactory.loadMapFromWz(mapid, world, channel, event);\n+\n+        if (cache) {\n+            mapsWLock.lock();\n+            try {\n+                maps.put(mapid, map);\n+            } finally {\n+                mapsWLock.unlock();\n+            }\n+        }\n+\n+        return map;\n+    }\n+\n+    public MapleMap getMap(int mapid) {\n+        MapleMap map;\n+\n+        mapsRLock.lock();\n+        try {\n+            map = maps.get(mapid);\n+        } finally {\n+            mapsRLock.unlock();\n+        }\n+\n+        return (map != null) ? map : loadMapFromWz(mapid, true);\n+    }\n+    \n+    public MapleMap getDisposableMap(int mapid) {\n+        return loadMapFromWz(mapid, false);\n+    }\n+\n+    public boolean isMapLoaded(int mapId) {\n+        mapsRLock.lock();\n+        try {\n+            return maps.containsKey(mapId);\n+        } finally {\n+            mapsRLock.unlock();\n+        }\n+    }\n+\n+    public Map<Integer, MapleMap> getMaps() {\n+        mapsRLock.lock();\n+        try {\n+            return new HashMap<>(maps);\n+        } finally {\n+            mapsRLock.unlock();\n+        }\n+    }\n+    \n+    private void updateMaps() {\n+        for (MapleMap map : getMaps().values()) {\n+            map.respawn();\n+            map.mobMpRecovery();\n+        }\n+    }\n+    \n+    public void dispose() {\n+        if (updateTask != null) {\n+            updateTask.cancel(false);\n+            updateTask = null;\n+        }\n+        \n+        for (MapleMap map : getMaps().values()) {\n+            map.dispose();\n+        }\n+\n+        this.event = null;\n+    }\n+\n+    public static float getMapRecoveryRate(int mapid) {\n+        return MapleMapFactory.getMapRecoveryRate(mapid);\n+    }\n+}"}, {"sha": "38f2128d7e208a488f6e56e9b61c364b83dbf5f5", "filename": "src/server/maps/MapleReactor.java", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/maps/MapleReactor.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/server/maps/MapleReactor.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/maps/MapleReactor.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -194,15 +194,15 @@ public void forceHitReactor(final byte newState) {\n     }\n \n     private void tryForceHitReactor(final byte newState) {  // weak hit state signal, if already changed reactor state before timeout then drop this\n-        if (!this.reactorLock.tryLock()) {\n+        if (!reactorLock.tryLock()) {\n             return;\n         }\n \n         try {\n             this.resetReactorActions(newState);\n             map.broadcastMessage(MaplePacketCreator.triggerReactor(this, (short) 0));\n         } finally {\n-            this.reactorLock.unlock();\n+            reactorLock.unlock();\n         }\n     }\n \n@@ -311,9 +311,8 @@ public void hitReactor(boolean wHit, int charPos, short stance, int skillid, Map\n                     }\n                 } finally {\n                     this.unlockReactor();\n+                    hitLock.unlock();   // non-encapsulated unlock found thanks to MiLin\n                 }\n-\n-                hitLock.unlock();\n             }\n         } catch (Exception e) {\n             e.printStackTrace();"}, {"sha": "1b578515b56731c46e1c2932b4722e5ea9e4912d", "filename": "src/tools/IntervalBuilder.java", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/tools/IntervalBuilder.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/tools/IntervalBuilder.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/tools/IntervalBuilder.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -0,0 +1,132 @@\n+/*\n+    This file is part of the HeavenMS MapleStory Server\n+    Copyleft (L) 2016 - 2018 RonanLana\n+\n+    This program is free software: you can redistribute it and/or modify\n+    it under the terms of the GNU Affero General Public License as\n+    published by the Free Software Foundation version 3 as published by\n+    the Free Software Foundation. You may not use, modify or distribute\n+    this program under any other version of the GNU Affero General Public\n+    License.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU Affero General Public License for more details.\n+\n+    You should have received a copy of the GNU Affero General Public License\n+    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+*/\n+package tools;\n+\n+import java.awt.geom.Line2D;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;\n+import net.server.audit.locks.MonitoredLockType;\n+import net.server.audit.locks.MonitoredReentrantReadWriteLock;\n+\n+/**\n+ *\n+ * @author Ronan\n+ */\n+public class IntervalBuilder {\n+        \n+    private List<Line2D> intervalLimits = new ArrayList<>();\n+    \n+    protected ReadLock intervalRlock;\n+    protected WriteLock intervalWlock;\n+    \n+    public IntervalBuilder() {\n+        ReentrantReadWriteLock locks = new MonitoredReentrantReadWriteLock(MonitoredLockType.INTERVAL, true);\n+        intervalRlock = locks.readLock();\n+        intervalWlock = locks.writeLock();\n+    }\n+\n+    private void refitOverlappedIntervals(int st, int en, int newFrom, int newTo) {\n+        List<Line2D> checkLimits = new ArrayList<>(intervalLimits.subList(st, en));\n+\n+        float newLimitX1, newLimitX2;\n+        if (!checkLimits.isEmpty()) {\n+            Line2D firstLimit = checkLimits.get(0);\n+            Line2D lastLimit = checkLimits.get(checkLimits.size() - 1);\n+\n+            newLimitX1 = (float) ((newFrom < firstLimit.getX1()) ? newFrom : firstLimit.getX1());\n+            newLimitX2 = (float) ((newTo > lastLimit.getX2()) ? newTo : lastLimit.getX2());\n+\n+            for (Line2D limit : checkLimits) {\n+                intervalLimits.remove(st);\n+            }\n+        } else {\n+            newLimitX1 = newFrom;\n+            newLimitX2 = newTo;\n+        }\n+\n+        intervalLimits.add(st, new Line2D.Float((float) newLimitX1, 0, (float) newLimitX2, 0));\n+    }\n+\n+    private int bsearchInterval(int point) {\n+        int st = 0, en = intervalLimits.size() - 1;\n+\n+        int mid, idx;\n+        while (en >= st) {\n+            idx = (st + en) / 2;\n+            mid = (int) intervalLimits.get(idx).getX1();\n+\n+            if (mid == point) {\n+                return idx;\n+            } else if (mid < point) {\n+                st = idx + 1;\n+            } else {\n+                en = idx - 1;\n+            }\n+        }\n+\n+        return en;\n+    }\n+\n+    public void addInterval(int from, int to) {\n+        intervalWlock.lock();\n+        try {\n+            int st = bsearchInterval(from);\n+            if (st < 0) {\n+                st = 0;\n+            } else if (intervalLimits.get(st).getX2() < from) {\n+                st += 1;\n+            }\n+\n+            int en = bsearchInterval(to);\n+            if (en < st) en = st - 1;\n+\n+            refitOverlappedIntervals(st, en + 1, from, to);\n+        } finally {\n+            intervalWlock.unlock();\n+        }\n+    }\n+\n+    public boolean inInterval(int point) {\n+        return inInterval(point, point);\n+    }\n+    \n+    public boolean inInterval(int from, int to) {\n+        intervalRlock.lock();\n+        try {\n+            int idx = bsearchInterval(from);\n+            return idx >= 0 && to <= intervalLimits.get(idx).getX2();\n+        } finally {\n+            intervalRlock.unlock();\n+        }\n+    }\n+\n+    public void clear() {\n+        intervalWlock.lock();\n+        try {\n+            intervalLimits.clear();\n+        } finally {\n+            intervalWlock.unlock();\n+        }\n+    }\n+    \n+}"}, {"sha": "03cf40c39988ee429f9ad8b57afba9c7d3ae07cb", "filename": "src/tools/MaplePacketCreator.java", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/tools/MaplePacketCreator.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/src/tools/MaplePacketCreator.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/tools/MaplePacketCreator.java?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -51,7 +51,7 @@\n import server.CashShop.CashItem;\n import server.CashShop.CashItemFactory;\n import server.CashShop.SpecialCashItem;\n-import server.DueyPackages;\n+import server.DueyPackage;\n import server.MTSItemInfo;\n import server.MapleItemInformationProvider;\n import server.MapleShopItem;\n@@ -7039,26 +7039,35 @@ private static void getGuildInfo(final MaplePacketLittleEndianWriter mplew, Mapl\n                 return sendDuey(operation, null);\n         }\n \n-        public static byte[] sendDuey(byte operation, List<DueyPackages> packages) {\n+        public static byte[] sendDuey(byte operation, List<DueyPackage> packages) {\n                 final MaplePacketLittleEndianWriter mplew = new MaplePacketLittleEndianWriter();\n                 mplew.writeShort(SendOpcode.PARCEL.getValue());\n                 mplew.write(operation);\n                 if (operation == 8) {\n                         mplew.write(0);\n                         mplew.write(packages.size());\n-                        for (DueyPackages dp : packages) {\n+                        for (DueyPackage dp : packages) {\n                                 mplew.writeInt(dp.getPackageId());\n                                 mplew.writeAsciiString(dp.getSender());\n                                 for (int i = dp.getSender().length(); i < 13; i++) {\n                                         mplew.write(0);\n                                 }\n+                                \n                                 mplew.writeInt(dp.getMesos());\n                                 mplew.writeLong(getTime(dp.sentTimeInMilliseconds()));\n-                                mplew.writeLong(0); // Contains message o____o.\n-                                for (int i = 0; i < 48; i++) {\n-                                        mplew.writeInt(Randomizer.nextInt(Integer.MAX_VALUE));\n+                                \n+                                String msg = dp.getMessage();\n+                                if (!msg.isEmpty()) {\n+                                    mplew.writeInt(1);\n+                                    mplew.writeAsciiString(msg);\n+                                    for (int i = msg.length(); i < 200; i++) {\n+                                            mplew.write(0);\n+                                    }\n+                                } else {\n+                                    mplew.writeInt(0);\n+                                    mplew.skip(200);\n                                 }\n-                                mplew.writeInt(0);\n+                                \n                                 mplew.write(0);\n                                 if (dp.getItem() != null) {\n                                         mplew.write(1);"}, {"sha": "89ae398f6ec2d65071492fd13e0345fb69fc78f8", "filename": "tools/MapleCouponInstaller/dist/MapleCouponInstaller.jar", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/tools/MapleCouponInstaller/dist/MapleCouponInstaller.jar", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/tools/MapleCouponInstaller/dist/MapleCouponInstaller.jar", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/tools/MapleCouponInstaller/dist/MapleCouponInstaller.jar?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2"}, {"sha": "67c9c27960de98cc75964c3b684be04e7628d439", "filename": "tools/MapleCouponInstaller/nbproject/private/private.properties", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/tools/MapleCouponInstaller/nbproject/private/private.properties", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/tools/MapleCouponInstaller/nbproject/private/private.properties", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/tools/MapleCouponInstaller/nbproject/private/private.properties?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -3,4 +3,4 @@ do.depend=false\n do.jar=true\n javac.debug=true\n javadoc.preview=true\n-user.properties.file=C:\\\\Users\\\\USER\\\\AppData\\\\Roaming\\\\NetBeans\\\\8.0.2\\\\build.properties\n+user.properties.file=C:\\\\Users\\\\RonanLana\\\\AppData\\\\Roaming\\\\NetBeans\\\\8.0.2\\\\build.properties"}, {"sha": "6949c94b996c1e6a9bfe647f2224612c1ad04e3f", "filename": "tools/MapleGachaponItemidRetriever/nbbuild.xml", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/tools/MapleGachaponItemidRetriever/nbbuild.xml", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/tools/MapleGachaponItemidRetriever/nbbuild.xml", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/tools/MapleGachaponItemidRetriever/nbbuild.xml?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "previous_filename": "tools/MapleGachaponItemidRetriever/build.xml"}, {"sha": "e612835194a1c69183602db0aa675075763f49c3", "filename": "wz/Quest.wz/Act.img.xml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/wz/Quest.wz/Act.img.xml", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/a39a210c1f6993a8747ba43f160c5b8dbfe761f2/wz/Quest.wz/Act.img.xml", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/wz/Quest.wz/Act.img.xml?ref=a39a210c1f6993a8747ba43f160c5b8dbfe761f2", "patch": "@@ -15773,7 +15773,7 @@\n           <int name=\"count\" value=\"1\"/>\n         </imgdir>\n         <imgdir name=\"2\">\n-          <int name=\"item\" value=\"4032492\"/>\n+          <int name=\"id\" value=\"4032492\"/>\n           <int name=\"count\" value=\"-1\"/>\n         </imgdir>\n       </imgdir>"}]}]},
