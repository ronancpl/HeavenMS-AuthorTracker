{"fetchDate": "2019-12-19", "content": [{"sha": "0d7e8daf8e62f0173a6260a6f028591d756c082e", "node_id": "MDY6Q29tbWl0NDUwODIwMjM6MGQ3ZThkYWY4ZTYyZjAxNzNhNjI2MGE2ZjAyODU5MWQ3NTZjMDgyZQ==", "commit": {"author": {"name": "Diego Armando de Freitas Matos", "email": "diego.matos@bh.mi", "date": "2019-03-20T22:51:45Z"}, "committer": {"name": "Diego Armando de Freitas Matos", "email": "diego.matos@bh.mi", "date": "2019-03-20T22:51:45Z"}, "message": "ariantpq + correct use catch item", "tree": {"sha": "c76fe817879629d0f2d6dca5d8219b22e1fb33f3", "url": "https://api.github.com/repos/ronancpl/HeavenMS/git/trees/c76fe817879629d0f2d6dca5d8219b22e1fb33f3"}, "url": "https://api.github.com/repos/ronancpl/HeavenMS/git/commits/0d7e8daf8e62f0173a6260a6f028591d756c082e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/ronancpl/HeavenMS/commits/0d7e8daf8e62f0173a6260a6f028591d756c082e", "html_url": "https://github.com/ronancpl/HeavenMS/commit/0d7e8daf8e62f0173a6260a6f028591d756c082e", "comments_url": "https://api.github.com/repos/ronancpl/HeavenMS/commits/0d7e8daf8e62f0173a6260a6f028591d756c082e/comments", "author": null, "committer": null, "parents": [{"sha": "0a8efa42384c54ca26546c881d10b7fe4b881064", "url": "https://api.github.com/repos/ronancpl/HeavenMS/commits/0a8efa42384c54ca26546c881d10b7fe4b881064", "html_url": "https://github.com/ronancpl/HeavenMS/commit/0a8efa42384c54ca26546c881d10b7fe4b881064"}], "stats": {"total": 4775, "additions": 2365, "deletions": 2410}, "files": [{"sha": "46ac04b7bf3fa8252c239592393a4a39edc6d6d1", "filename": "launch_server_linux.sh", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/launch_server_linux.sh", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/launch_server_linux.sh", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/launch_server_linux.sh?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -0,0 +1,3 @@\n+#!/bin/sh\n+export CLASSPATH=\".:dist/*\" \n+java -Xmx3000m -Dwzpath=wz/ net.server.Server\n\\ No newline at end of file"}, {"sha": "e5512415f382e45fc38ddd8143d92eb034a082be", "filename": "nbproject/build-impl.xml", "status": "modified", "additions": 47, "deletions": 65, "changes": 112, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/nbproject/build-impl.xml", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/nbproject/build-impl.xml", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/nbproject/build-impl.xml?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -54,43 +54,7 @@ is divided into following sections:\n         <property file=\"nbproject/project.properties\"/>\n     </target>\n     <target depends=\"-pre-init,-init-private,-init-user,-init-project,-init-macrodef-property\" name=\"-do-init\">\n-        <j2seproject1:property name=\"platform.home\" value=\"platforms.${platform.active}.home\"/>\n-        <j2seproject1:property name=\"platform.bootcp\" value=\"platforms.${platform.active}.bootclasspath\"/>\n-        <j2seproject1:property name=\"platform.compiler\" value=\"platforms.${platform.active}.compile\"/>\n-        <j2seproject1:property name=\"platform.javac.tmp\" value=\"platforms.${platform.active}.javac\"/>\n-        <condition property=\"platform.javac\" value=\"${platform.home}/bin/javac\">\n-            <equals arg1=\"${platform.javac.tmp}\" arg2=\"$${platforms.${platform.active}.javac}\"/>\n-        </condition>\n-        <property name=\"platform.javac\" value=\"${platform.javac.tmp}\"/>\n-        <j2seproject1:property name=\"platform.java.tmp\" value=\"platforms.${platform.active}.java\"/>\n-        <condition property=\"platform.java\" value=\"${platform.home}/bin/java\">\n-            <equals arg1=\"${platform.java.tmp}\" arg2=\"$${platforms.${platform.active}.java}\"/>\n-        </condition>\n-        <property name=\"platform.java\" value=\"${platform.java.tmp}\"/>\n-        <j2seproject1:property name=\"platform.javadoc.tmp\" value=\"platforms.${platform.active}.javadoc\"/>\n-        <condition property=\"platform.javadoc\" value=\"${platform.home}/bin/javadoc\">\n-            <equals arg1=\"${platform.javadoc.tmp}\" arg2=\"$${platforms.${platform.active}.javadoc}\"/>\n-        </condition>\n-        <property name=\"platform.javadoc\" value=\"${platform.javadoc.tmp}\"/>\n-        <condition property=\"platform.invalid\" value=\"true\">\n-            <or>\n-                <contains string=\"${platform.javac}\" substring=\"$${platforms.\"/>\n-                <contains string=\"${platform.java}\" substring=\"$${platforms.\"/>\n-                <contains string=\"${platform.javadoc}\" substring=\"$${platforms.\"/>\n-            </or>\n-        </condition>\n-        <fail unless=\"platform.home\">Must set platform.home</fail>\n-        <fail unless=\"platform.bootcp\">Must set platform.bootcp</fail>\n-        <fail unless=\"platform.java\">Must set platform.java</fail>\n-        <fail unless=\"platform.javac\">Must set platform.javac</fail>\n-        <fail if=\"platform.invalid\">\n- The J2SE Platform is not correctly set up.\n- Your active platform is: ${platform.active}, but the corresponding property \"platforms.${platform.active}.home\" is not found in the project's properties files. \n- Either open the project in the IDE and setup the Platform with the same name or add it manually.\n- For example like this:\n-     ant -Duser.properties.file=&lt;path_to_property_file&gt; jar (where you put the property \"platforms.${platform.active}.home\" in a .properties file)\n-  or ant -Dplatforms.${platform.active}.home=&lt;path_to_JDK_home&gt; jar (where no properties file is used) \n-  </fail>\n+        <property name=\"platform.java\" value=\"${java.home}/bin/java\"/>\n         <available file=\"${manifest.file}\" property=\"manifest.available\"/>\n         <condition property=\"splashscreen.available\">\n             <and>\n@@ -157,7 +121,9 @@ is divided into following sections:\n             </and>\n         </condition>\n         <condition property=\"have.tests\">\n-            <or/>\n+            <or>\n+                <available file=\"${test.scripts.dir}\"/>\n+            </or>\n         </condition>\n         <condition property=\"have.sources\">\n             <or>\n@@ -217,6 +183,15 @@ is divided into following sections:\n         <condition else=\"\" property=\"javac.profile.cmd.line.arg\" value=\"-profile ${javac.profile}\">\n             <isset property=\"profile.available\"/>\n         </condition>\n+        <condition else=\"false\" property=\"jdkBug6558476\">\n+            <and>\n+                <matches pattern=\"1\\.[56]\" string=\"${java.specification.version}\"/>\n+                <not>\n+                    <os family=\"unix\"/>\n+                </not>\n+            </and>\n+        </condition>\n+        <property name=\"javac.fork\" value=\"${jdkBug6558476}\"/>\n         <property name=\"jar.index\" value=\"false\"/>\n         <property name=\"jar.index.metainf\" value=\"${jar.index}\"/>\n         <property name=\"copylibs.rebase\" value=\"true\"/>\n@@ -249,6 +224,7 @@ is divided into following sections:\n     </target>\n     <target depends=\"-pre-init,-init-private,-init-user,-init-project,-do-init\" name=\"-init-check\">\n         <fail unless=\"src.dir\">Must set src.dir</fail>\n+        <fail unless=\"test.scripts.dir\">Must set test.scripts.dir</fail>\n         <fail unless=\"build.dir\">Must set build.dir</fail>\n         <fail unless=\"dist.dir\">Must set dist.dir</fail>\n         <fail unless=\"build.classes.dir\">Must set build.classes.dir</fail>\n@@ -284,7 +260,7 @@ is divided into following sections:\n                 <property location=\"${build.dir}/empty\" name=\"empty.dir\"/>\n                 <mkdir dir=\"${empty.dir}\"/>\n                 <mkdir dir=\"@{apgeneratedsrcdir}\"/>\n-                <javac debug=\"@{debug}\" deprecation=\"${javac.deprecation}\" destdir=\"@{destdir}\" encoding=\"${source.encoding}\" excludes=\"@{excludes}\" executable=\"${platform.javac}\" fork=\"yes\" includeantruntime=\"false\" includes=\"@{includes}\" source=\"${javac.source}\" sourcepath=\"@{sourcepath}\" srcdir=\"@{srcdir}\" target=\"${javac.target}\" tempdir=\"${java.io.tmpdir}\">\n+                <javac debug=\"@{debug}\" deprecation=\"${javac.deprecation}\" destdir=\"@{destdir}\" encoding=\"${source.encoding}\" excludes=\"@{excludes}\" fork=\"${javac.fork}\" includeantruntime=\"false\" includes=\"@{includes}\" source=\"${javac.source}\" sourcepath=\"@{sourcepath}\" srcdir=\"@{srcdir}\" target=\"${javac.target}\" tempdir=\"${java.io.tmpdir}\">\n                     <src>\n                         <dirset dir=\"@{gensrcdir}\" erroronmissingdir=\"false\">\n                             <include name=\"*\"/>\n@@ -324,7 +300,7 @@ is divided into following sections:\n             <sequential>\n                 <property location=\"${build.dir}/empty\" name=\"empty.dir\"/>\n                 <mkdir dir=\"${empty.dir}\"/>\n-                <javac debug=\"@{debug}\" deprecation=\"${javac.deprecation}\" destdir=\"@{destdir}\" encoding=\"${source.encoding}\" excludes=\"@{excludes}\" executable=\"${platform.javac}\" fork=\"yes\" includeantruntime=\"false\" includes=\"@{includes}\" source=\"${javac.source}\" sourcepath=\"@{sourcepath}\" srcdir=\"@{srcdir}\" target=\"${javac.target}\" tempdir=\"${java.io.tmpdir}\">\n+                <javac debug=\"@{debug}\" deprecation=\"${javac.deprecation}\" destdir=\"@{destdir}\" encoding=\"${source.encoding}\" excludes=\"@{excludes}\" fork=\"${javac.fork}\" includeantruntime=\"false\" includes=\"@{includes}\" source=\"${javac.source}\" sourcepath=\"@{sourcepath}\" srcdir=\"@{srcdir}\" target=\"${javac.target}\" tempdir=\"${java.io.tmpdir}\">\n                     <src>\n                         <dirset dir=\"@{gensrcdir}\" erroronmissingdir=\"false\">\n                             <include name=\"*\"/>\n@@ -405,7 +381,7 @@ is divided into following sections:\n             <element name=\"customize\" optional=\"true\"/>\n             <sequential>\n                 <property name=\"junit.forkmode\" value=\"perTest\"/>\n-                <junit dir=\"${work.dir}\" errorproperty=\"tests.failed\" failureproperty=\"tests.failed\" fork=\"true\" forkmode=\"${junit.forkmode}\" jvm=\"${platform.java}\" showoutput=\"true\" tempdir=\"${build.dir}\">\n+                <junit dir=\"${work.dir}\" errorproperty=\"tests.failed\" failureproperty=\"tests.failed\" fork=\"true\" forkmode=\"${junit.forkmode}\" showoutput=\"true\" tempdir=\"${build.dir}\">\n                     <test methods=\"@{testmethods}\" name=\"@{testincludes}\" todir=\"${build.test.results.dir}\"/>\n                     <syspropertyset>\n                         <propertyref prefix=\"test-sys-prop.\"/>\n@@ -428,8 +404,11 @@ is divided into following sections:\n             <element name=\"customize\" optional=\"true\"/>\n             <sequential>\n                 <property name=\"junit.forkmode\" value=\"perTest\"/>\n-                <junit dir=\"${work.dir}\" errorproperty=\"tests.failed\" failureproperty=\"tests.failed\" fork=\"true\" forkmode=\"${junit.forkmode}\" jvm=\"${platform.java}\" showoutput=\"true\" tempdir=\"${build.dir}\">\n+                <junit dir=\"${work.dir}\" errorproperty=\"tests.failed\" failureproperty=\"tests.failed\" fork=\"true\" forkmode=\"${junit.forkmode}\" showoutput=\"true\" tempdir=\"${build.dir}\">\n                     <batchtest todir=\"${build.test.results.dir}\">\n+                        <fileset dir=\"${test.scripts.dir}\" excludes=\"@{excludes},${excludes}\" includes=\"@{includes}\">\n+                            <filename name=\"@{testincludes}\"/>\n+                        </fileset>\n                         <fileset dir=\"${build.test.classes.dir}\" excludes=\"@{excludes},${excludes},${test.binaryexcludes}\" includes=\"${test.binaryincludes}\">\n                             <filename name=\"${test.binarytestincludes}\"/>\n                         </fileset>\n@@ -458,9 +437,13 @@ is divided into following sections:\n                 <condition else=\"\" property=\"testng.methods.arg\" value=\"@{testincludes}.@{testmethods}\">\n                     <isset property=\"test.method\"/>\n                 </condition>\n-                <union id=\"test.set\"/>\n+                <union id=\"test.set\">\n+                    <fileset dir=\"${test.scripts.dir}\" excludes=\"@{excludes},**/*.xml,${excludes}\" includes=\"@{includes}\">\n+                        <filename name=\"@{testincludes}\"/>\n+                    </fileset>\n+                </union>\n                 <taskdef classname=\"org.testng.TestNGAntTask\" classpath=\"${run.test.classpath}\" name=\"testng\"/>\n-                <testng classfilesetref=\"test.set\" failureProperty=\"tests.failed\" jvm=\"${platform.java}\" listeners=\"org.testng.reporters.VerboseReporter\" methods=\"${testng.methods.arg}\" mode=\"${testng.mode}\" outputdir=\"${build.test.results.dir}\" suitename=\"HeavenMS\" testname=\"TestNG tests\" workingDir=\"${work.dir}\">\n+                <testng classfilesetref=\"test.set\" failureProperty=\"tests.failed\" listeners=\"org.testng.reporters.VerboseReporter\" methods=\"${testng.methods.arg}\" mode=\"${testng.mode}\" outputdir=\"${build.test.results.dir}\" suitename=\"HeavenMS\" testname=\"TestNG tests\" workingDir=\"${work.dir}\">\n                     <xmlfileset dir=\"${build.test.classes.dir}\" includes=\"@{testincludes}\"/>\n                     <propertyset>\n                         <propertyref prefix=\"test-sys-prop.\"/>\n@@ -540,7 +523,7 @@ is divided into following sections:\n             <element name=\"customize\" optional=\"true\"/>\n             <sequential>\n                 <property name=\"junit.forkmode\" value=\"perTest\"/>\n-                <junit dir=\"${work.dir}\" errorproperty=\"tests.failed\" failureproperty=\"tests.failed\" fork=\"true\" forkmode=\"${junit.forkmode}\" jvm=\"${platform.java}\" showoutput=\"true\" tempdir=\"${build.dir}\">\n+                <junit dir=\"${work.dir}\" errorproperty=\"tests.failed\" failureproperty=\"tests.failed\" fork=\"true\" forkmode=\"${junit.forkmode}\" showoutput=\"true\" tempdir=\"${build.dir}\">\n                     <test methods=\"@{testmethods}\" name=\"@{testincludes}\" todir=\"${build.test.results.dir}\"/>\n                     <syspropertyset>\n                         <propertyref prefix=\"test-sys-prop.\"/>\n@@ -565,8 +548,11 @@ is divided into following sections:\n             <element name=\"customize\" optional=\"true\"/>\n             <sequential>\n                 <property name=\"junit.forkmode\" value=\"perTest\"/>\n-                <junit dir=\"${work.dir}\" errorproperty=\"tests.failed\" failureproperty=\"tests.failed\" fork=\"true\" forkmode=\"${junit.forkmode}\" jvm=\"${platform.java}\" showoutput=\"true\" tempdir=\"${build.dir}\">\n+                <junit dir=\"${work.dir}\" errorproperty=\"tests.failed\" failureproperty=\"tests.failed\" fork=\"true\" forkmode=\"${junit.forkmode}\" showoutput=\"true\" tempdir=\"${build.dir}\">\n                     <batchtest todir=\"${build.test.results.dir}\">\n+                        <fileset dir=\"${test.scripts.dir}\" excludes=\"@{excludes},${excludes}\" includes=\"@{includes}\">\n+                            <filename name=\"@{testincludes}\"/>\n+                        </fileset>\n                         <fileset dir=\"${build.test.classes.dir}\" excludes=\"@{excludes},${excludes},${test.binaryexcludes}\" includes=\"${test.binaryincludes}\">\n                             <filename name=\"${test.binarytestincludes}\"/>\n                         </fileset>\n@@ -742,9 +728,6 @@ is divided into following sections:\n                     <classpath>\n                         <path path=\"@{classpath}\"/>\n                     </classpath>\n-                    <bootclasspath>\n-                        <path path=\"${platform.bootcp}\"/>\n-                    </bootclasspath>\n                 </nbjpdastart>\n             </sequential>\n         </macrodef>\n@@ -760,9 +743,7 @@ is divided into following sections:\n         </macrodef>\n     </target>\n     <target name=\"-init-debug-args\">\n-        <exec executable=\"${platform.java}\" outputproperty=\"version-output\">\n-            <arg value=\"-version\"/>\n-        </exec>\n+        <property name=\"version-output\" value=\"java version &quot;${ant.java.version}\"/>\n         <condition property=\"have-jdk-older-than-1.4\">\n             <or>\n                 <contains string=\"${version-output}\" substring=\"java version &quot;1.0\"/>\n@@ -787,7 +768,7 @@ is divided into following sections:\n             <attribute default=\"${debug.classpath}\" name=\"classpath\"/>\n             <element name=\"customize\" optional=\"true\"/>\n             <sequential>\n-                <java classname=\"@{classname}\" dir=\"${work.dir}\" fork=\"true\" jvm=\"${platform.java}\">\n+                <java classname=\"@{classname}\" dir=\"${work.dir}\" fork=\"true\">\n                     <jvmarg line=\"${endorsed.classpath.cmd.line.arg}\"/>\n                     <jvmarg line=\"${debug-args-line}\"/>\n                     <jvmarg value=\"-Xrunjdwp:transport=${debug-transport},address=${jpda.address}\"/>\n@@ -814,7 +795,7 @@ is divided into following sections:\n             <attribute default=\"jvm\" name=\"jvm\"/>\n             <element name=\"customize\" optional=\"true\"/>\n             <sequential>\n-                <java classname=\"@{classname}\" dir=\"${work.dir}\" fork=\"true\" jvm=\"${platform.java}\">\n+                <java classname=\"@{classname}\" dir=\"${work.dir}\" fork=\"true\">\n                     <jvmarg line=\"${endorsed.classpath.cmd.line.arg}\"/>\n                     <jvmarg value=\"-Dfile.encoding=${runtime.encoding}\"/>\n                     <redirector errorencoding=\"${runtime.encoding}\" inputencoding=\"${runtime.encoding}\" outputencoding=\"${runtime.encoding}\"/>\n@@ -1012,7 +993,7 @@ is divided into following sections:\n         <j2seproject3:copylibs manifest=\"${tmp.manifest.file}\"/>\n         <echo level=\"info\">To run this application from the command line without Ant, try:</echo>\n         <property location=\"${dist.jar}\" name=\"dist.jar.resolved\"/>\n-        <echo level=\"info\">${platform.java} -jar \"${dist.jar.resolved}\"</echo>\n+        <echo level=\"info\">java -jar \"${dist.jar.resolved}\"</echo>\n     </target>\n     <target depends=\"init,compile,-pre-pre-jar,-pre-jar,-do-jar-create-manifest,-do-jar-copy-manifest,-do-jar-set-mainclass,-do-jar-set-profile,-do-jar-set-splashscreen\" if=\"do.archive\" name=\"-do-jar-jar\" unless=\"do.mkdist\">\n         <j2seproject1:jar manifest=\"${tmp.manifest.file}\"/>\n@@ -1221,13 +1202,10 @@ is divided into following sections:\n                 </not>\n             </and>\n         </condition>\n-        <exec executable=\"${platform.java}\" failonerror=\"false\" outputproperty=\"platform.version.output\">\n-            <arg value=\"-version\"/>\n-        </exec>\n         <condition else=\"\" property=\"bug5101868workaround\" value=\"*.java\">\n-            <matches multiline=\"true\" pattern=\"1\\.[56](\\..*)?\" string=\"${platform.version.output}\"/>\n+            <matches pattern=\"1\\.[56](\\..*)?\" string=\"${java.version}\"/>\n         </condition>\n-        <javadoc additionalparam=\"-J-Dfile.encoding=${file.encoding} ${javadoc.additionalparam}\" author=\"${javadoc.author}\" charset=\"UTF-8\" destdir=\"${dist.javadoc.dir}\" docencoding=\"UTF-8\" encoding=\"${javadoc.encoding.used}\" executable=\"${platform.javadoc}\" failonerror=\"true\" noindex=\"${javadoc.noindex}\" nonavbar=\"${javadoc.nonavbar}\" notree=\"${javadoc.notree}\" private=\"${javadoc.private}\" source=\"${javac.source}\" splitindex=\"${javadoc.splitindex}\" use=\"${javadoc.use}\" useexternalfile=\"true\" version=\"${javadoc.version}\" windowtitle=\"${javadoc.windowtitle}\">\n+        <javadoc additionalparam=\"-J-Dfile.encoding=${file.encoding} ${javadoc.additionalparam}\" author=\"${javadoc.author}\" charset=\"UTF-8\" destdir=\"${dist.javadoc.dir}\" docencoding=\"UTF-8\" encoding=\"${javadoc.encoding.used}\" failonerror=\"true\" noindex=\"${javadoc.noindex}\" nonavbar=\"${javadoc.nonavbar}\" notree=\"${javadoc.notree}\" private=\"${javadoc.private}\" source=\"${javac.source}\" splitindex=\"${javadoc.splitindex}\" use=\"${javadoc.use}\" useexternalfile=\"true\" version=\"${javadoc.version}\" windowtitle=\"${javadoc.windowtitle}\">\n             <classpath>\n                 <path path=\"${javac.classpath}\"/>\n             </classpath>\n@@ -1266,11 +1244,13 @@ is divided into following sections:\n         <!-- You can override this target in the ../build.xml file. -->\n     </target>\n     <target if=\"do.depend.true\" name=\"-compile-test-depend\">\n-        <j2seproject3:depend classpath=\"${javac.test.classpath}\" destdir=\"${build.test.classes.dir}\" srcdir=\"\"/>\n+        <j2seproject3:depend classpath=\"${javac.test.classpath}\" destdir=\"${build.test.classes.dir}\" srcdir=\"${test.scripts.dir}\"/>\n     </target>\n     <target depends=\"init,deps-jar,compile,-pre-pre-compile-test,-pre-compile-test,-compile-test-depend\" if=\"have.tests\" name=\"-do-compile-test\">\n-        <j2seproject3:javac apgeneratedsrcdir=\"${build.test.classes.dir}\" classpath=\"${javac.test.classpath}\" debug=\"true\" destdir=\"${build.test.classes.dir}\" processorpath=\"${javac.test.processorpath}\" srcdir=\"\"/>\n-        <copy todir=\"${build.test.classes.dir}\"/>\n+        <j2seproject3:javac apgeneratedsrcdir=\"${build.test.classes.dir}\" classpath=\"${javac.test.classpath}\" debug=\"true\" destdir=\"${build.test.classes.dir}\" processorpath=\"${javac.test.processorpath}\" srcdir=\"${test.scripts.dir}\"/>\n+        <copy todir=\"${build.test.classes.dir}\">\n+            <fileset dir=\"${test.scripts.dir}\" excludes=\"${build.classes.excludes},${excludes}\" includes=\"${includes}\"/>\n+        </copy>\n     </target>\n     <target name=\"-post-compile-test\">\n         <!-- Empty placeholder for easier customization. -->\n@@ -1284,8 +1264,10 @@ is divided into following sections:\n     <target depends=\"init,deps-jar,compile,-pre-pre-compile-test,-pre-compile-test-single\" if=\"have.tests\" name=\"-do-compile-test-single\">\n         <fail unless=\"javac.includes\">Must select some files in the IDE or set javac.includes</fail>\n         <j2seproject3:force-recompile destdir=\"${build.test.classes.dir}\"/>\n-        <j2seproject3:javac apgeneratedsrcdir=\"${build.test.classes.dir}\" classpath=\"${javac.test.classpath}\" debug=\"true\" destdir=\"${build.test.classes.dir}\" excludes=\"\" includes=\"${javac.includes}\" processorpath=\"${javac.test.processorpath}\" sourcepath=\"\" srcdir=\"\"/>\n-        <copy todir=\"${build.test.classes.dir}\"/>\n+        <j2seproject3:javac apgeneratedsrcdir=\"${build.test.classes.dir}\" classpath=\"${javac.test.classpath}\" debug=\"true\" destdir=\"${build.test.classes.dir}\" excludes=\"\" includes=\"${javac.includes}\" processorpath=\"${javac.test.processorpath}\" sourcepath=\"${test.scripts.dir}\" srcdir=\"${test.scripts.dir}\"/>\n+        <copy todir=\"${build.test.classes.dir}\">\n+            <fileset dir=\"${test.scripts.dir}\" excludes=\"${build.classes.excludes},${excludes}\" includes=\"${includes}\"/>\n+        </copy>\n     </target>\n     <target name=\"-post-compile-test-single\">\n         <!-- Empty placeholder for easier customization. -->"}, {"sha": "8346fd394f7ae814a76b7c7dea6bc5821641e83d", "filename": "nbproject/genfiles.properties", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/nbproject/genfiles.properties", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/nbproject/genfiles.properties", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/nbproject/genfiles.properties?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -1,8 +1,8 @@\n-build.xml.data.CRC32=92113194\n+build.xml.data.CRC32=d58eb2a3\n build.xml.script.CRC32=ff13faf5\n build.xml.stylesheet.CRC32=8064a381@1.75.2.48\n # This file is used by a NetBeans-based IDE to track changes in generated files such as build-impl.xml.\n # Do not edit this file. You may delete it but then the IDE will never regenerate such files for you.\n-nbproject/build-impl.xml.data.CRC32=92113194\n-nbproject/build-impl.xml.script.CRC32=cef58264\n+nbproject/build-impl.xml.data.CRC32=d58eb2a3\n+nbproject/build-impl.xml.script.CRC32=17919f88\n nbproject/build-impl.xml.stylesheet.CRC32=876e7a8f@1.75.2.48"}, {"sha": "2ae0c54985c9cfcb7736d9d4c2f5d891b0b41813", "filename": "nbproject/private/private.properties", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/nbproject/private/private.properties", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/nbproject/private/private.properties", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/nbproject/private/private.properties?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -3,4 +3,4 @@ do.depend=false\n do.jar=true\n javac.debug=true\n javadoc.preview=true\n-user.properties.file=C:\\\\Users\\\\RonanLana\\\\AppData\\\\Roaming\\\\NetBeans\\\\8.0.2\\\\build.properties\n+user.properties.file=C:\\\\Users\\\\diego.matos\\\\AppData\\\\Roaming\\\\NetBeans\\\\8.0.2\\\\build.properties"}, {"sha": "25e98e099cd8872053256966f2b71edeecaefd2d", "filename": "nbproject/private/private.xml", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/nbproject/private/private.xml", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/nbproject/private/private.xml", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/nbproject/private/private.xml?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -2,6 +2,12 @@\n <project-private xmlns=\"http://www.netbeans.org/ns/project-private/1\">\n     <editor-bookmarks xmlns=\"http://www.netbeans.org/ns/editor-bookmarks/2\" lastBookmarkId=\"2\"/>\n     <open-files xmlns=\"http://www.netbeans.org/ns/projectui-open-files/2\">\n-        <group/>\n+        <group>\n+            <file>file:/C:/Users/diego.matos/Documents/MS/servergit/HeavenMS/HeavenMS/scripts/npc/2103013.js</file>\n+            <file>file:/C:/Users/diego.matos/Documents/MS/servergit/HeavenMS/HeavenMS/src/scripting/npc/NPCConversationManager.java</file>\n+            <file>file:/C:/Users/diego.matos/Documents/MS/servergit/HeavenMS/HeavenMS/scripts/npc/2101015.js</file>\n+            <file>file:/C:/Users/diego.matos/Documents/MS/servergit/HeavenMS/HeavenMS/scripts/npc/2101017.js</file>\n+            <file>file:/C:/Users/diego.matos/Documents/MS/servergit/HeavenMS/HeavenMS/scripts/npc/2101016.js</file>\n+        </group>\n     </open-files>\n </project-private>"}, {"sha": "1a918780d4eb8367626444dad3eaf35c3e155a6d", "filename": "nbproject/project.properties", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/nbproject/project.properties", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/nbproject/project.properties", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/nbproject/project.properties?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -84,7 +84,7 @@ manifest.custom.permissions=\n manifest.file=manifest.mf\n meta.inf.dir=${src.dir}/META-INF\n mkdist.disabled=false\n-platform.active=JDK_1.7\n+platform.active=default_platform\n project.license=gpl30_msv2\n project.licensePath=./nbproject/licenseheader.txt\n run.classpath=\\\n@@ -97,5 +97,6 @@ run.jvmargs=-Xmx2048m -Dwzpath=wz/\n run.test.classpath=\\\n     ${javac.test.classpath}:\\\n     ${build.test.classes.dir}\n-source.encoding=UTF-8\n+source.encoding=ISO-8859-1\n src.dir=${file.reference.MapleSolaxia-src}\n+test.scripts.dir=scripts"}, {"sha": "4cb4077b4ef66f07816f20a7d2726c0ee5edde27", "filename": "nbproject/project.xml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/nbproject/project.xml", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/nbproject/project.xml", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/nbproject/project.xml?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -4,11 +4,12 @@\n     <configuration>\n         <data xmlns=\"http://www.netbeans.org/ns/j2se-project/3\">\n             <name>HeavenMS</name>\n-            <explicit-platform explicit-source-supported=\"true\"/>\n             <source-roots>\n                 <root id=\"src.dir\"/>\n             </source-roots>\n-            <test-roots/>\n+            <test-roots>\n+                <root id=\"test.scripts.dir\"/>\n+            </test-roots>\n         </data>\n     </configuration>\n </project>"}, {"sha": "a075c820e3d468408f5f2a67d9e4353b6f27d62a", "filename": "scripts/event/AirPlane.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/scripts/event/AirPlane.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/scripts/event/AirPlane.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/event/AirPlane.js?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -15,7 +15,7 @@ var  rideTime = 1 * 60 * 1000; //The time that require move to destination\n function init() {\n     closeTime = em.getTransportationTime(closeTime);\n     beginTime = em.getTransportationTime(beginTime);\n-     rideTime = em.getTransportationTime(rideTime);\n+    rideTime = em.getTransportationTime(rideTime);\n     \n     KC_bfd = em.getChannelServer().getMapFactory().getMap(540010100);\n     CBD_bfd = em.getChannelServer().getMapFactory().getMap(540010001);"}, {"sha": "87c07429f6069895b45d06f439640f1dcf630134", "filename": "scripts/event/AmoriaPQ.js", "status": "removed", "additions": 0, "deletions": 291, "changes": 291, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0a8efa42384c54ca26546c881d10b7fe4b881064/scripts/event/AmoriaPQ.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0a8efa42384c54ca26546c881d10b7fe4b881064/scripts/event/AmoriaPQ.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/event/AmoriaPQ.js?ref=0a8efa42384c54ca26546c881d10b7fe4b881064", "patch": "@@ -1,291 +0,0 @@\n-/*\n-    This file is part of the HeavenMS MapleStory Server\n-    Copyleft (L) 2016 - 2018 RonanLana\n-\n-    This program is free software: you can redistribute it and/or modify\n-    it under the terms of the GNU Affero General Public License as\n-    published by the Free Software Foundation version 3 as published by\n-    the Free Software Foundation. You may not use, modify or distribute\n-    this program under any other version of the GNU Affero General Public\n-    License.\n-\n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU Affero General Public License for more details.\n-\n-    You should have received a copy of the GNU Affero General Public License\n-    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-*/\n-\n-/**\n- * @author: Ronan\n- * @event: Amoria PQ\n-*/\n-\n-var isPq = true;\n-var onlyMarriedPlayers = true;\n-var minPlayers = 6, maxPlayers = 6;\n-var minLevel = 40, maxLevel = 255;\n-var entryMap = 670010200;\n-var exitMap = 670011000;\n-var recruitMap = 670010100;\n-var clearMap = 670010800;\n-\n-var minMapId = 670010200;\n-var maxMapId = 670010800;\n-\n-var eventTime = 75;     // 75 minutes\n-\n-var lobbyRange = [0, 0];\n-\n-function init() {\n-        setEventRequirements();\n-}\n-\n-function setLobbyRange() {\n-        return lobbyRange;\n-}\n-\n-function setEventRequirements() {\n-        var reqStr = \"\";\n-        \n-        reqStr += \"\\r\\n    Number of players: \";\n-        if(maxPlayers - minPlayers >= 1) reqStr += minPlayers + \" ~ \" + maxPlayers;\n-        else reqStr += minPlayers;\n-        \n-        reqStr += \"\\r\\n    Level range: \";\n-        if(maxLevel - minLevel >= 1) reqStr += minLevel + \" ~ \" + maxLevel;\n-        else reqStr += minLevel;\n-        \n-        reqStr += \"\\r\\n    At least 1 of both genders\";\n-        if(onlyMarriedPlayers) reqStr += \"\\r\\n    All married\";\n-        \n-        reqStr += \"\\r\\n    Time limit: \";\n-        reqStr += eventTime + \" minutes\";\n-        \n-        em.setProperty(\"party\", reqStr);\n-}\n-\n-function setEventExclusives(eim) {\n-        var itemSet = [4031594, 4031595, 4031596, 4031597];\n-        eim.setExclusiveItems(itemSet);\n-}\n-\n-function setEventRewards(eim) {\n-        var itemSet, itemQty, evLevel, expStages;\n-\n-        evLevel = 1;    //Rewards at clear PQ\n-        itemSet = [];\n-        itemQty = [];\n-        eim.setEventRewards(evLevel, itemSet, itemQty);\n-        \n-        expStages = [2000, 4000, 6000, 8000, 9000, 11000];    //bonus exp given on CLEAR stage signal\n-        eim.setEventClearStageExp(expStages);\n-}\n-\n-function getEligibleParty(party) {      //selects, from the given party, the team that is allowed to attempt this event\n-        var eligible = [];\n-        var hasLeader = false, hasNotMarried = false;\n-        var mask = 0;\n-        \n-        if(party.size() > 0) {\n-                var partyList = party.toArray();\n-\n-                for(var i = 0; i < party.size(); i++) {\n-                        var ch = partyList[i];\n-\n-                        if(ch.getMapId() == recruitMap && ch.getLevel() >= minLevel && ch.getLevel() <= maxLevel) {\n-                                if(ch.isLeader()) hasLeader = true;\n-                                if(!ch.getPlayer().isMarried()) hasNotMarried = true;\n-                                eligible.push(ch);\n-                                \n-                                mask |= (1 << ch.getPlayer().getGender());\n-                        }\n-                }\n-        }\n-        \n-        if(!(hasLeader && eligible.length >= minPlayers && eligible.length <= maxPlayers && mask == 3)) eligible = [];\n-        if(onlyMarriedPlayers && hasNotMarried) eligible = [];\n-        return eligible;\n-}\n-\n-function setup(level, lobbyid) {\n-        var eim = em.newInstance(\"Amoria\" + lobbyid);\n-        eim.setProperty(\"level\", level);\n-        \n-        eim.setProperty(\"marriedGroup\", 0);\n-        eim.setProperty(\"missCount\", 0);\n-        eim.setProperty(\"statusStg1\", -1);\n-        eim.setProperty(\"statusStg2\", -1);\n-        eim.setProperty(\"statusStg3\", -1);\n-        eim.setProperty(\"statusStg4\", -1);\n-        eim.setProperty(\"statusStg5\", -1);\n-        eim.setProperty(\"statusStg6\", -1);\n-        eim.setProperty(\"statusStgBonus\", 0);\n-        \n-        eim.getInstanceMap(670010200).resetPQ(level);\n-        eim.getInstanceMap(670010300).resetPQ(level);\n-        eim.getInstanceMap(670010301).resetPQ(level);\n-        eim.getInstanceMap(670010302).resetPQ(level);\n-        eim.getInstanceMap(670010400).resetPQ(level);\n-        eim.getInstanceMap(670010500).resetPQ(level);\n-        eim.getInstanceMap(670010600).resetPQ(level);\n-        eim.getInstanceMap(670010700).resetPQ(level);\n-        eim.getInstanceMap(670010750).resetPQ(level);\n-        eim.getInstanceMap(670010800).resetPQ(level);\n-        \n-        eim.getInstanceMap(670010200).toggleDrops();\n-        eim.getInstanceMap(670010300).toggleDrops();\n-        eim.getInstanceMap(670010301).toggleDrops();\n-        eim.getInstanceMap(670010302).toggleDrops();\n-        \n-        eim.getInstanceMap(670010200).instanceMapForceRespawn();\n-        eim.getInstanceMap(670010500).instanceMapForceRespawn();\n-        \n-        eim.getInstanceMap(670010750).shuffleReactors();\n-        eim.getInstanceMap(670010800).shuffleReactors();\n-        \n-        var mapObj = eim.getInstanceMap(670010700);\n-        var mobObj = Packages.server.life.MapleLifeFactory.getMonster(9400536);\n-        mapObj.spawnMonsterOnGroundBelow(mobObj, new Packages.java.awt.Point(942, 478));\n-        \n-        respawnStages(eim);\n-        \n-        eim.startEventTimer(eventTime * 60000);\n-        setEventRewards(eim);\n-        setEventExclusives(eim);\n-        \n-        return eim;\n-}\n-\n-function isTeamAllCouple(eim) {     // everyone partner of someone on the team\n-        var eventPlayers = eim.getPlayers();\n-    \n-        for (var iterator = eventPlayers.iterator(); iterator.hasNext();) {\n-                var chr = iterator.next();\n-                \n-                var pid = chr.getPartnerId();\n-                if(pid <= 0 || eim.getPlayerById(pid) == null) {\n-                        return false;\n-                }\n-        }\n-        \n-        return true;\n-}\n-\n-function afterSetup(eim) {\n-        if(isTeamAllCouple(eim)) {\n-                eim.setIntProperty(\"marriedGroup\", 1);\n-        }\n-}\n-\n-function respawnStages(eim) {}\n-\n-function playerEntry(eim, player) {\n-        var map = eim.getMapInstance(entryMap);\n-        player.changeMap(map, map.getPortal(0));\n-}\n-\n-function scheduledTimeout(eim) {\n-        if(eim.getIntProperty(\"statusStg6\") == 1) {\n-                eim.warpEventTeam(exitMap);\n-        }\n-        else {\n-                end(eim);\n-        }\n-}\n-\n-function playerUnregistered(eim, player) {}\n-\n-function playerExit(eim, player) {\n-        eim.unregisterPlayer(player);\n-        player.changeMap(exitMap, 0);\n-}\n-\n-function playerLeft(eim, player) {\n-        if(!eim.isEventCleared()) {\n-                playerExit(eim, player);\n-        }\n-}\n-\n-function changedMap(eim, player, mapid) {\n-        if (mapid < minMapId || mapid > maxMapId) {\n-                if (eim.isEventTeamLackingNow(true, minPlayers, player)) {\n-                        eim.unregisterPlayer(player);\n-                        end(eim);\n-                }\n-                else\n-                        eim.unregisterPlayer(player);\n-        }\n-}\n-\n-function changedLeader(eim, leader) {\n-        var mapid = leader.getMapId();\n-        if (!eim.isEventCleared() && (mapid < minMapId || mapid > maxMapId)) {\n-                end(eim);\n-        }\n-}\n-\n-function playerDead(eim, player) {}\n-\n-function playerRevive(eim, player) { // player presses ok on the death pop up.\n-        if (eim.isEventTeamLackingNow(true, minPlayers, player)) {\n-                eim.unregisterPlayer(player);\n-                end(eim);\n-        }\n-        else\n-                eim.unregisterPlayer(player);\n-}\n-\n-function playerDisconnected(eim, player) {\n-        if (eim.isEventTeamLackingNow(true, minPlayers, player)) {\n-                eim.unregisterPlayer(player);\n-                end(eim);\n-        }\n-        else\n-                eim.unregisterPlayer(player);\n-}\n-\n-function leftParty(eim, player) {\n-        if (eim.isEventTeamLackingNow(false, minPlayers, player)) {\n-                end(eim);\n-        }\n-        else\n-                playerLeft(eim, player);\n-}\n-\n-function disbandParty(eim) {\n-        if (!eim.isEventCleared()) {\n-                end(eim);\n-        }\n-}\n-\n-function monsterValue(eim, mobId) {\n-        return 1;\n-}\n-\n-function end(eim) {\n-        var party = eim.getPlayers();\n-        for (var i = 0; i < party.size(); i++) {\n-                playerExit(eim, party.get(i));\n-        }\n-        eim.dispose();\n-}\n-\n-function giveRandomEventReward(eim, player) {\n-        eim.giveEventReward(player);\n-}\n-\n-function clearPQ(eim) {\n-        eim.stopEventTimer();\n-        eim.setEventCleared();\n-}\n-\n-function monsterKilled(mob, eim) {}\n-\n-function allMonstersDead(eim) {}\n-\n-function cancelSchedule() {}\n-\n-function dispose(eim) {}"}, {"sha": "927d0e48e79793425e067de9ceed90f2e81fefd8", "filename": "scripts/npc/2101014.js", "status": "modified", "additions": 103, "deletions": 97, "changes": 200, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/scripts/npc/2101014.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/scripts/npc/2101014.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/2101014.js?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -1,108 +1,114 @@\n-/*\n-    This file is part of the OdinMS Maple Story Server\n-    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n-    Matthias Butz <matze@odinms.de>\n-    Jan Christian Meyer <vimes@odinms.de>\n+/*2101014.js - Lobby and Entrance\n+ * @author Jvlaple\n+ * For Jvlaple's AriantPQ\n+ */\n+importPackage(java.lang);\n+importPackage(Packages.server.expeditions);\n \n-    This program is free software: you can redistribute it and/or modify\n-    it under the terms of the GNU Affero General Public License as\n-    published by the Free Software Foundation version 3 as published by\n-    the Free Software Foundation. You may not use, modify or distribute\n-    this program under any other version of the GNU Affero General Public\n-    License.\n-\n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  \n-    See the GNU Affero General Public License for more details.\n-\n-    You should have received a copy of the GNU Affero General Public License\n-    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-*/\n-\n-/*\n-\tNPC NAME: Cesar (2)\n-\tNPC ID: 2101014\n-\tAuthor: Vcoc\n-\tFunction: AriantPQ\n-*/\n-\n-status = -1;\n-var sel;\n-empty = [false, false, false];\n+var status = 0;\n+var toBan = -1;\n+var choice;\n+var arena;\n+var arenaName;\n+var type;\n+var map;\n+var exped = MapleExpeditionType.ARIANT;\n+var exped1 = MapleExpeditionType.ARIANT1;\n+var exped2 = MapleExpeditionType.ARIANT2;\n \n function start() {\n-    if((cm.getPlayer().getLevel() < 19 || cm.getPlayer().getLevel() > 30) && !cm.getPlayer().isGM()){\n-        cm.sendNext(\"You're not between level 20 and 30. Sorry, you may not participate.\");\n-        cm.dispose();\n-        return;\n-    }\n-    var text = \"What do you want?#b\";\n-    for(var i = 0; i < 3; i += 1)\n-        if (cm.getPlayerCount(980010100 + (i * 100)) > 0)\n-            if(cm.getPlayerCount(980010101 + (i * 100)) > 0)\n-                continue;\n-            else\n-                text += \"\\r\\n#L\" + i + \"# Battle Arena \" + (i + 1) + \"([\" + cm.getPlayerCount(980010100 + (i * 100)) + \"/\" + cm.getPlayer().getAriantSlotsRoom(i) + \"]  users: \" + cm.getPlayer().getAriantRoomLeaderName(i) + \")#l\";\n-        else{\n-            empty[i] = true;\n-            text += \"\\r\\n#L\" + i + \"# Battle Arena \" + (i + 1) + \"( Empty )#l\";\n-            if(cm.getPlayer().getAriantRoomLeaderName(i) != \"\")\n-                cm.getPlayer().removeAriantRoom(i);\n-        }\n-    cm.sendSimple(text + \"\\r\\n#L3# I'd like to know more about the competition.#l\");\n+    status = -1;\n+    action(1, 0, 0);\n }\n \n-function action(mode, type, selection){\n-    status++;\n-    if(mode != 1){\n-        if(mode == 0 && type == 0)\n-            status -= 2;\n-        else{\n+function action(mode, type, selection) {\n+    if (mode == -1) {\n+        cm.dispose();\n+    } else {\n+        if (mode == 0) {\n             cm.dispose();\n             return;\n         }\n-    }\n-    if (status == 0){\n-        if(sel == undefined)\n-            sel = selection;\n-        if(sel == 3)\n-            cm.sendNext(\"What do you need to do? You must be new to this. Allow me explain in detail.\");\n-        else{\n-            if(cm.getPlayer().getAriantRoomLeaderName(sel) != \"\" && empty[sel])\n-                empty[sel] = false;\n-            else if(cm.getPlayer().getAriantRoomLeaderName(sel) != \"\"){\n-                cm.warp(980010100 + (sel * 100));\n-                cm.dispose();\n-                return;\n-            }\n-            if(!empty[sel]){\n-                cm.sendNext(\"Another combatant has created the battle arena first. I advise you to either set up a new one, or join the battle arena that's already been set up.\");\n-                cm.dispose();\n-                return;\n-            }\n-            cm.sendGetNumber(\"Up to how many participants can join in this match? (2~6 ppl)\", 0, 2, 6);\n+        if (mode == 1) {\n+            status++;\n+        } else {\n+            status--;\n         }\n-    }else if (status == 1){\n-        if(sel == 3)\n-            cm.sendNextPrev(\"It's really simple, actually. You'll receive #b#t2270002##k from me, and your task is to eliminate a set amount of HP from the monster, then use #b#t2270002##k to absorb its monstrous power.\");\n-        else{\n-            if(cm.getPlayer().getAriantRoomLeaderName(sel) != \"\" && empty[sel])\n-                empty[sel] = false;\n-            if(!empty[sel]){\n-                cm.sendNext(\"Another combatant has created the battle arena first. I advise you to either set up a new one, or join the battle arena that's already been set up.\");\n-                cm.dispose();\n-                return;\n+        if (cm.getPlayer().getMapId() == 980010000) {\n+            var expedicao = cm.getExpedition(exped);\n+            var expedicao1 = cm.getExpedition(exped1);\n+            var expedicao2 = cm.getExpedition(exped2);\n+            if (status == 0) {\n+                var toSnd = \"Voc\ufffd gostaria de participar do Desafio #eAriant Coliseu#n?\\r\\n\\r\\n#e#r       (Escolha uma arena)#n#k\\r\\n#b\";\n+\n+                if (cm.getClient().getChannelServer().getMapFactory().getMap(980010100).getCharacters().size() == 0 && expedicao == null) {\n+                    toSnd += \"#L0#Comece Ariant Coliseu (1)#l\\r\\n\";\n+                } else if (expedicao != null && cm.getClient().getChannelServer().getMapFactory().getMap(980010101).getCharacters().size() == 0) {\n+                    toSnd += \"#L0#Junte-se ao Ariant Coliseu (1)  Dono (\" + expedicao.getLeader().getName() + \")\" + \" Membros Atuais: \" + cm.getNomeDosMembrosExpedition(exped) + \"\\r\\n\";\n+                }\n+                if (cm.getClient().getChannelServer().getMapFactory().getMap(980010200).getCharacters().size() == 0 && expedicao1 == null) {\n+                    toSnd += \"#L1#Comece Ariant Coliseu (2)#l\\r\\n\";\n+                } else if (expedicao1 != null && cm.getClient().getChannelServer().getMapFactory().getMap(980010201).getCharacters().size() == 0) {\n+                    toSnd += \"#L1#Junte-se ao Ariant Coliseu (2)  Dono (\" + expedicao1.getLeader().getName() + \")\" + \" Membros Atuais: \" + cm.getNomeDosMembrosExpedition(exped1) + \"\\r\\n\";\n+                }\n+                if (cm.getClient().getChannelServer().getMapFactory().getMap(980010300).getCharacters().size() == 0 && expedicao2 == null) {\n+                    toSnd += \"#L2#Comece Ariant Coliseu (3)#l\\r\\n\";\n+                } else if (expedicao2 != null && cm.getClient().getChannelServer().getMapFactory().getMap(980010301).getCharacters().size() == 0) {\n+                    toSnd += \"#L2#Junte-se ao Ariant Coliseu (3)  Dono (\" + expedicao2.getLeader().getName() + \")\" + \" Membros Atuais: \" + cm.getNomeDosMembrosExpedition(exped2) + \"\\r\\n\";\n+                }\n+                if (toSnd.equals(\"Voc\ufffd gostaria de participar do Desafio #eAriant Coliseu#n?\\r\\n\\r\\n#e#r       (Escolha uma arena)#n#k\\r\\n#b\")) {\n+                    cm.sendOk(\"Todas as arenas esta ocupadas agora. Eu sugiro que voc\ufffd volte mais tarde ou mudar de canal.\");\n+                    cm.dispose();\n+                } else {\n+                    cm.sendSimple(toSnd);\n+                }\n+            } else if (status == 1) {\n+                switch (selection) {\n+                    case 0 :\n+                        exped = MapleExpeditionType.ARIANT;\n+                        expedicao = cm.getExpedition(exped);\n+                        map = 980010100;\n+                        break;\n+                    case 1 :\n+                        exped = MapleExpeditionType.ARIANT1;\n+                        expedicao = cm.getExpedition(exped);\n+                        map = 980010200;\n+                        break;\n+                    case 2 :\n+                        exped = MapleExpeditionType.ARIANT2;\n+                        expedicao = cm.getExpedition(exped);\n+                        map = 980010300;\n+                        break;\n+                    default :\n+                        exped = null;\n+                        map = 0;\n+                        return;\n+                        break;\n+                }\n+                if (expedicao == null) {\n+                    cm.createExpedition(exped);\n+                    cm.warp(map, 0);\n+                    cm.getPlayer().dropMessage(\"Sua Arena foi criada. Aguarde as pessoas entrarem agora!\");\n+                    cm.dispose();\n+                } else {\n+                    var playerAdd = expedicao.addMemberInt(cm.getPlayer());\n+                    if (playerAdd == 3) {\n+                        cm.sendOk(\"Desculpe, a Lobby esta cheia agora.\");\n+                        cm.dispose();\n+                    } else {\n+                        if (playerAdd == 0) {\n+                            cm.warp(map, 0);\n+                            cm.dispose();\n+                        } else if (playerAdd == 2) {\n+                            cm.sendOk(\"Desculpe, mas o l\ufffdder pediu para nao ser autorizado a entrar.\");\n+                            cm.dispose();\n+                        } else {\n+                            cm.sendOk(\"erro.\");\n+                            cm.dispose();\n+                        }\n+                    }\n+                } \n             }\n-            cm.getPlayer().setAriantRoomLeader(sel, cm.getPlayer().getName());\n-            cm.getPlayer().setAriantSlotRoom(sel, selection);\n-            cm.warp(980010100 + (sel * 100));\n-            cm.dispose();\n         }\n-    }else if (status == 2)\n-        cm.sendNextPrev(\"It's simple. If you absorb the power of the monster #b#t2270002##k, then you'll make #b#t4031868##k, which is something Queen Areda loves. The combatant with the most jewels wins the match. It's actually a smart idea to prevent others from absorbing in order to win.\");\n-    else if (status == 3)\n-        cm.sendNextPrev(\"One thing. Using #b#t2100067##k, you can steal #b#t4031868##k from your enemies. Warning: #rYou may not use pets for this.#k Understood?!\");\n-    else if (status == 4)\n-        cm.dispose();\n-}\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "f06653fb76ab8e53d2bebf30912c7d5c52c16bc2", "filename": "scripts/npc/2101015.js", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/scripts/npc/2101015.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/scripts/npc/2101015.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/2101015.js?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -0,0 +1,37 @@\n+var status = 0;\n+\n+importPackage(Packages.client);\n+\n+function start() {\n+    status = -1;\n+    action(1, 0, 0);\n+}\n+\n+function action(mode, type, selection) {\n+    if (mode == -1) {\n+        cm.dispose();\n+    } else {\n+        if (mode == 0 && status == 0) {\n+            cm.dispose();\n+            return;\n+        }\n+        if (mode == 1)\n+            status++;\n+        else\n+            status--;\n+        if (status == 0) {\n+            apqpontos = cm.getPlayer().getAriantPontos();\n+            if (apqpontos < 100) {\n+                cm.sendOk(\"A sua Pontua\ufffd\ufffdo de Arena de Batalha \ufffd #b\" + apqpontos + \"#k Pontos. Voc\ufffd precisa ultrapassar os #b100 Pontos#k para que eu possa lhe dar a #bCadeira de Praia com Palmeira#k.Estou ocupado, ent\ufffdo fale comigo quando voc\ufffd tiver pontos suficientes e fale comigo novamente.\")\n+                cm.dispose();\n+            }\n+            if (apqpontos > 99) {\n+                cm.sendNext(\"Uaaal, parece que voc\ufffd conseguiu os #b100 Pontos#k necess\ufffdrios para troca, vamos l\ufffd?!\");\n+            }\n+        } else if (status == 1) {\n+            cm.getPlayer().gainAriantPontos(-100);\n+            cm.gainItem(3010018, 1);\n+            cm.dispose();\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "ac34583003088ad16db435b5708481ea89973a4a", "filename": "scripts/npc/2101016.js", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/scripts/npc/2101016.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/scripts/npc/2101016.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/2101016.js?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -0,0 +1,40 @@\n+\n+var status = 0;\n+\n+importPackage(Packages.client);\n+\n+function start() {\n+    status = -1;\n+    action(1, 0, 0);\n+}\n+\n+function action(mode, type, selection) {\n+    if (mode == -1) {\n+        cm.dispose();\n+    } else {\n+        if (mode == 0 && status == 0) {\n+            cm.dispose();\n+            return;\n+        }\n+        if (mode == 1)\n+            status++;\n+        else\n+            status--;\n+        if (status == 0) {\n+            copns = cm.getPlayer().countItem(4031868);\n+            if (copns < 1) {\n+                cm.sendOk(\"Que pena, voc\ufffd nao conseguiu nenhuma j\ufffdia!\")\n+                cm.dispose();\n+            }\n+            if (copns > 0 || !cm.getPlayer().isGM()) {\n+                cm.sendNext(\"Ok, vamos ver...Voc\ufffd foi muito bem, e voc\ufffd trouxe #b\" + copns + \"#k j\ufffdias que eu adoro. Como voc\ufffd completou a partida, vou recompens\ufffd-lo com a pontua\ufffd\ufffdo da Arena de Batalhas de #b5 Pontos#k. Se voc\ufffd quiser saber mais sobre a pontua\ufffd\ufffdo de Arena de Batalha, ent\ufffdo fale com #b#p2101015##k.\");\n+            }\n+        } else if (status == 1) {\n+            //cm.warp(980010020, 0);\n+            cm.removeAll(4031868);\n+            cm.getPlayer().gainExp(92.7 * cm.getPlayer().getExpRate() * copns, true, true);\n+            cm.getPlayer().gainAriantPontos(3);\n+            cm.dispose();\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "3586e17070cf3022112c6068c04e162afb99c29e", "filename": "scripts/npc/2101017.js", "status": "modified", "additions": 120, "deletions": 128, "changes": 248, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/scripts/npc/2101017.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/scripts/npc/2101017.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/2101017.js?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -1,150 +1,142 @@\n-/*\n-    This file is part of the OdinMS Maple Story Server\n-    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n-    Matthias Butz <matze@odinms.de>\n-    Jan Christian Meyer <vimes@odinms.de>\n+/*2101017.js\n+ *Cesar\n+ *@author Jvlaple\n+ */\n \n-    This program is free software: you can redistribute it and/or modify\n-    it under the terms of the GNU Affero General Public License as\n-    published by the Free Software Foundation version 3 as published by\n-    the Free Software Foundation. You may not use, modify or distribute\n-    this program under any other version of the GNU Affero General Public\n-    License.\n+importPackage(java.lang);\n+importPackage(Packages.server.expeditions);\n \n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  \n-    See the GNU Affero General Public License for more details.\n \n-    You should have received a copy of the GNU Affero General Public License\n-    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-*/\n-\n-/*\n-\tNPC NAME: Cesar (3)\n-\tNPC ID: 2101017\n-\tAuthor: Vcoc\n-\tFunction: AriantPQ\n-*/\n-\n-importPackage(Packages.tools);\n-importPackage(Packages.client);\n-\n-status = -1;\n-var sel;\n+var status = 0;\n+var toBan = -1;\n+var choice;\n+var arena;\n+var arenaName;\n+var type;\n+var map;\n+var exped = MapleExpeditionType.ARIANT;\n+var exped1 = MapleExpeditionType.ARIANT1;\n+var exped2 = MapleExpeditionType.ARIANT2;\n+var expedicao;\n+var expedMembers;\n \n function start() {\n-    if((cm.getPlayer().getLevel() < 19 || cm.getPlayer().getLevel() > 30) && !cm.getPlayer().isGM()){\n-        cm.sendNext(\"You're not between level 20 and 30. Sorry, you may not participate.\");\n-        cm.dispose();\n-        return;\n-    }\n-    if(cm.getPlayer().getMapId() % 10 == 1)\n-        cm.sendSimple(\"Do you have a request for me?\\r\\n#b#L0# Give me #t2270002# and #t2100067#.#l\\r\\n#L1# What should I do?#l\\r\\n#L2# Get me out of here.#l\");\n-    else\n-        cm.sendSimple(cm.getPlayer().getAriantRoomLeaderName(((cm.getPlayer().getMapId() / 100) % 10) - 1) == cm.getPlayer().getName() ? \"Would you like to start the match?#b\\r\\n#b#L3# Ready to enter the Battle Arena!!#l\\r\\n#L1# I'd like to kick another character.#l\\r\\n#L2# Get me out of here.#l\" : \"What do you want?#b\\r\\n#L2# Get me out of here.#l\");\n+    action(1, 0, 0);\n }\n \n-function action(mode, type, selection){\n-    status++;\n-    if(mode != 1){\n-        if(mode == 0 && type == 0)\n-            status -= 2;\n-        else{\n+function action(mode, type, selection) {\n+    \n+    if (mode == -1) {\n+        cm.dispose();\n+    } else {\n+        if (mode == 0) {\n             cm.dispose();\n             return;\n         }\n-    }\n-    if(cm.getPlayer().getMapId() % 10 == 1){\n-        if (status == 0){\n-            if (sel == undefined)\n-                sel = selection;\n-            if(sel == 0){\n-                if(cm.haveItem(2270002))\n-                    cm.sendNext(\"You already have #b#t2270002##k.\");\n-            else if(cm.canHold(2270002) && cm.canHold(2100067)){\n-                if(cm.haveItem(2100067))\n-                    cm.removeAll(2100067);\n-                    cm.gainItem(2270002, 50);\n-                    cm.gainItem(2100067, 5);\n-                    cm.sendNext(\"Now lower the HP of the monsters, and use #b#t2270002##k to absorb their power!\");\n-                }else\n-                    cm.sendNext(\"Check and see if your Use inventory is full or not\");\n-                cm.dispose();\n-            }else if(sel == 1)\n-                cm.sendNext(\"What do you need to do? You must be new to this. Allow me explain in detail.\");\n-            else\n-                cm.sendYesNo(\"Are you sure you want to leave?\"); //No GMS like.\n-        } else if (status == 1){\n-            if(type == 1){\n-                cm.removeAll(4031868);\n-                cm.removeAll(2270002);\n-                cm.removeAll(2100067);\n-                cm.warp(980010020);\n-                cm.dispose();\n-                return;\n+\n+        if (cm.getPlayer().getMapId() == 980010100 || cm.getPlayer().getMapId() == 980010200 || cm.getPlayer().getMapId() == 980010300) {\n+            if (cm.getPlayer().getMapId() == 980010100) {\n+                exped = MapleExpeditionType.ARIANT;\n+                expedicao = cm.getExpedition(exped);\n+\n+            } else if (cm.getPlayer().getMapId() == 980010200) {\n+                exped = MapleExpeditionType.ARIANT1;\n+                expedicao = cm.getExpedition(exped);\n+            } else {\n+                exped = MapleExpeditionType.ARIANT2;\n+                expedicao = cm.getExpedition(exped);\n             }\n-            cm.sendNextPrev(\"It's really simple, actually. You'll receive #b#t2270002##k from me, and your task is to eliminate a set amount of HP from the monster, then use #b#t2270002##k to absorb its monstrous power.\");\n-        } else if (status == 2)\n-            cm.sendNextPrev(\"It's simple. If you absorb the power of the monster #b#t2270002##k, then you'll make #b#t4031868##k, which is something Queen Areda loves. The combatant with the most jewels wins the match. It's actually a smart idea to prevent others from absorbing in order to win.\");\n-        else if (status == 3)\n-            cm.sendNextPrev(\"One thing. Using #b#t2100067##k, you can steal #b#t4031868##k from your enemies. Warning: #rYou may not use pets for this.#k Understood?!\");\n-        else if (status == 4)\n-            cm.dispose();\n-    }else{\n-        var nextchar = cm.getMap(cm.getPlayer().getMapId()).getCharacters().iterator();\n-        if(status == 0){\n-            if (sel == undefined)\n-                sel = selection;\n-            if(sel == 1)\n-                if(cm.getPlayerCount(cm.getPlayer().getMapId()) > 1){\n-                    var text = \"Who would you like to kick from room?\"; //Not GMS like text\n-                    var name;\n-                    for(var i = 0; nextchar.hasNext(); i++){\n-                        name = nextchar.next().getName();\n-                        if(!cm.getPlayer().getAriantRoomLeaderName(((cm.getPlayer().getMapId() / 100) % 10) - 1).equals(name))\n-                            text += \"\\r\\n#b#L\" + i + \"#\" + name + \"#l\";\n+            expedMembers = expedicao.getMemberList();\n+            if (status == 0) {\n+                if (cm.getIsLeaderExpedition(exped)) {\n+                    cm.sendSimple(\"O que voce gostaria de fazer?#b\\r\\n\\r\\n#L1#Ver registro atual da arena!#l\\r\\n#L2#Banir player!#l\\r\\n#L3#Comece a luta!#l\\r\\n#L4#Sair desta arena!#l\");\n+                    status = 1;\n+                } else {\n+                    var toSend = \"Voce tem atualmente essas pessoas em sua arena :\\r\\n#b\";\n+                    toSend += cm.getNomeDosMembrosExpedition(exped);\n+                    cm.sendOk(toSend);\n+                    cm.dispose();\n+                }\n+            } else if (status == 1) {\n+                if (selection == 1) {\n+                    var toSend = \"Voce tem atualmente essas pessoas em sua arena :\\r\\n#b\";\n+                    toSend += cm.getNomeDosMembrosExpedition(exped);\n+                    cm.sendOk(toSend);\n+                    cm.dispose();\n+                } else if (selection == 2) {\n+                    var size = expedMembers.size();\n+                    if (size == 1) {\n+                        cm.sendOk(\"You are the only member of the expedition.\");\n+                        cm.dispose();\n+                        return;\n+                    }\n+                    var text = \"The following members make up your expedition (Click on them to expel them):\\r\\n\";\n+                    text += \"\\r\\n\\t\\t1.\" + expedicao.getLeader().getName();\n+                    for (var i = 1; i < size; i++) {\n+                        text += \"\\r\\n#b#L\" + (i + 1) + \"#\" + (i + 1) + \". \" + expedMembers.get(i).getValue() + \"#l\\n\";\n                     }\n                     cm.sendSimple(text);\n-                }else{\n-                    cm.sendNext(\"There's no character that can be kicked right now.\");\n+                    status = 6;\n+                } else if (selection == 3) {\n+                    if (expedicao.getMembers().size() < 1) {\n+                        cm.sendOk(\"Voc\ufffd precisa de mais que 2 jogadores para iniciar.\");\n+                        cm.dispose();\n+                    } else {\n+                        if (cm.getParty() != null) {\n+                            cm.sendOk(\"Voc\ufffd n\ufffdo pode entrar na batalha em um grupo.\");\n+                            cm.dispose();\n+                        }\n+                        if (cm.getPlayer().getMapId() == 980010100) {\n+                            cm.warpExpedition(980010101, exped);\n+                        } else if (cm.getPlayer().getMapId() == 980010200) {\n+                            cm.warpExpedition(980010201, exped);\n+                        } else {\n+                            cm.warpExpedition(980010301, exped);\n+                        }\n+                        cm.dispose();\n+                    }\n+                } else if (selection == 4) {\n+                    cm.mapMessage(5, \"O lider da Arena saiu.\");\n+                    cm.warpExpedition(980010000, null);\n+                    cm.endExpedition(expedicao);\n                     cm.dispose();\n                 }\n-            else if(sel == 2){\n-                if(cm.getPlayer().getAriantRoomLeaderName(((cm.getPlayer().getMapId() / 100) % 10) - 1) == cm.getPlayer().getName())\n-                    cm.sendYesNo(\"Are you sure you want to leave? You're the leader of the Arena, so if you leave, the whole Battle Arena will close.\");\n-                else\n-                    cm.sendYesNo(\"Are you sure you want to leave?\"); //No GMS like.\n-            }else if(sel == 3)\n-                if(cm.getPlayerCount(cm.getPlayer().getMapId()) > 1)\n-                    cm.sendYesNo(\"The room is all set, and no other character may join this Battle Arena. Do you want to start the game right now?\");\n-                else{\n-                    cm.sendNext(\"You'll need at least 2 participants inside in order to start the match.\");\n+            } else if (status == 6) {\n+                if (selection > 0) {\n+                    var banned = expedMembers.get(selection - 1);\n+                    expedicao.ban(banned);\n+                    cm.sendOk(\"You have banned \" + banned.getValue() + \" from the expedition.\");\n                     cm.dispose();\n+                } else {\n+                    cm.sendSimple(list);\n+                    status = 2;\n                 }\n-        }else if (status == 1){\n-            if(sel == 1){\n-                for(var i = 0; nextchar.hasNext(); i++)\n-                    if(i == selection){\n-                        nextchar.next().changeMap(cm.getMap(980010000));\n-                        break;\n-                    }else\n-                        nextchar.next();\n-                cm.sendNext(\"Player have been kicked out of the Arena.\"); //Not GMS like\n-            }else if(sel == 2){\n-                if(cm.getPlayer().getAriantRoomLeaderName(((cm.getPlayer().getMapId() / 100) % 10) - 1) != cm.getPlayer().getName())\n-                    cm.warp(980010000);\n-                else{\n-                    cm.getPlayer().removeAriantRoom((cm.getPlayer().getMapId() / 100) % 10);\n-                    cm.mapMessage(6, cm.getPlayer().getName() + \" has left the Arena, so the Arena will now close.\");\n-                    cm.warpMap(980010000);\n+            }\n+        } else if (cm.getPlayer().getMapId() == 980010101 || cm.getPlayer().getMapId() == 980010201 || cm.getPlayer().getMapId() == 980010301) {\n+            if (cm.getPlayer().getMapId() == 980010100) {\n+                exped = MapleExpeditionType.ARIANT;\n+                expedicao = cm.getExpedition(exped);\n+\n+            } else if (cm.getPlayer().getMapId() == 980010200) {\n+                exped = MapleExpeditionType.ARIANT1;\n+                expedicao = cm.getExpedition(exped);\n+            } else {\n+                exped = MapleExpeditionType.ARIANT2;\n+                expedicao = cm.getExpedition(exped);\n+            }\n+            if (status == 0) {\n+                var gotTheBombs = expedicao.getProperty(\"gotBomb\" + cm.getChar().getId());\n+                if (gotTheBombs != null) {\n+                    cm.sendOk(\"Eu ja lhe dei as bombas, por favor, mate os #eEscorpioes#n para conseguir mais na proxima!\");\n+                    cm.dispose();\n+                } else {\n+                    cm.sendOk(\"Eu lhe dei (5) #b#eBombas#k#n e (50) #b#eRochas Elementais#k#n.\\r\\nUse as rochas elementais para capturar os escorpioes para Sra.#r#eSpirit Jewels#k#n!\");\n+                    expedicao.setProperty(\"gotBomb\" + cm.getChar().getId(), \"got\");\n+                    cm.gainItem(2270002, 50);\n+                    cm.gainItem(2100067, 5);\n+                    cm.dispose();\n                 }\n-            }else{\n-                cm.warpMap(cm.getPlayer().getMapId() + 1);\n-            //}\n-            //cm.getPlayer().getMap().broadcastMessage(MaplePacketCreator.updateAriantPQRanking(cm.getPlayer().getName(), 0, true));\n             }\n-            cm.dispose();\n         }\n     }\n }"}, {"sha": "57d3689910365daaaf804b3cd6d8fc45b06827dc", "filename": "src/client/MapleBuffStat.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/client/MapleBuffStat.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/client/MapleBuffStat.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/client/MapleBuffStat.java?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -47,6 +47,7 @@\n     GHOST_MORPH(0x20000L),\n     AURA(0x40000L),\n     CONFUSE(0x80000L),\n+    ARIANT_PQ_SHIELD(0x40000L),\n     \n     // ------ COUPON feature ------\n     "}, {"sha": "5b1a6ce82c72bd69d6d8d99b9d6911038b803d02", "filename": "src/client/MapleCharacter.java", "status": "modified", "additions": 65, "deletions": 31, "changes": 96, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/client/MapleCharacter.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/client/MapleCharacter.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/client/MapleCharacter.java?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -1,25 +1,3 @@\n-/* \n- This file is part of the OdinMS Maple Story Server\n- Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n- Matthias Butz <matze@odinms.de>\n- Jan Christian Meyer <vimes@odinms.de>\n-\n- This program is free software: you can redistribute it and/or modify\n- it under the terms of the GNU Affero General Public License as\n- published by the Free Software Foundation version 3 as published by\n- the Free Software Foundation. You may not use, modify or distribute\n- this program under any otheer version of the GNU Affero General Public\n- License.\n-\n- This program is distributed in the hope that it will be useful,\n- but WITHOUT ANY WARRANTY; witout even the implied warranty of\n- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n- GNU Affero General Public License for more details.\n-\n-\n- You should have received a copy of the GNU Affero General Public License\n- along with this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n package client;\n \n import java.awt.Point;\n@@ -126,7 +104,6 @@\n import constants.ExpTable;\n import constants.GameConstants;\n import constants.ItemConstants;\n-import constants.LinguaConstants;\n import constants.ServerConstants;\n import constants.skills.Aran;\n import constants.skills.Beginner;\n@@ -320,7 +297,9 @@\n     private int banishSp = -1;\n     private long banishTime = 0;\n     private long lastExpGainTime;\n-\n+    public ScheduledFuture<?> pqMapleMap;\n+    public ScheduledFuture<?> ariantScore;\n+    \n     private MapleCharacter() {\n         super.setListener(new AbstractCharacterListener() {\n             @Override\n@@ -1944,12 +1923,14 @@ public final void pickupItem(MapleMapObject ob, int petIndex) {     // yes, one\n                             this.getMonsterBook().addCard(client, mItem.getItemId());\n                         }\n                     } else if (MapleInventoryManipulator.addFromDrop(client, mItem, true)) {\n-                    } else if (mItem.getItemId() == 4031868) {\n-                        this.getMap().broadcastMessage(MaplePacketCreator.updateAriantPQRanking(this.getName(), this.getItemQuantity(4031868, false), false));\n                     } else {\n                         client.announce(MaplePacketCreator.enableActions());\n                         return;\n                     }\n+                    if (mItem.getItemId() == 4031868) {\n+                        updateAriantScore();\n+                        getMap().broadcastMessage(MaplePacketCreator.updateAriantPQRanking(this.getName(), this.getItemQuantity(4031868, false), false));\n+                    }\n \n                     this.getMap().pickItemDrop(pickupPacket, mapitem);\n                 } else if (!hasSpaceInventory) {\n@@ -5780,6 +5761,22 @@ public void leaveMap() {\n         if (hpDecreaseTask != null) {\n             hpDecreaseTask.cancel(false);\n         }\n+        cancelPqMapleMap();\n+        cancelAriantScore();\n+    }\n+    \n+    public void cancelPqMapleMap() {\n+        if (pqMapleMap != null) {\n+            pqMapleMap.cancel(true);\n+            pqMapleMap = null;\n+        }\n+    }\n+    \n+    public void cancelAriantScore() {\n+        if (ariantScore != null) {\n+            ariantScore.cancel(true);\n+            ariantScore = null;\n+        }\n     }\n \n     private int getChangedJobSp(MapleJob newJob) {\n@@ -7007,12 +7004,12 @@ public void mount(int id, int skillid) {\n \n     private void playerDead() {\n         if (this.getMap().isCPQMap()) {\n-            int lost = getCP();\n-            if (lost > 6) {\n-                lost = 6;\n+            int losing = getMap().getDeathCP();\n+            if (getCP() < losing) {\n+                losing = getCP();\n             }\n-            getMap().broadcastMessage(MaplePacketCreator.playerDiedMessage(getName(), lost, getTeam()));\n-            gainCP(-lost);\n+            getMap().broadcastMessage(MaplePacketCreator.playerDiedMessage(getName(), losing, getTeam()));\n+            gainCP(-losing);\n             return;\n         }\n         cancelAllBuffs(false);\n@@ -10226,4 +10223,41 @@ public void obterItens() {\n             getClient().getAbstractPlayerInteraction().gainItem(item.getItemId(), item.getQuantity());\n         }\n     }\n+    \n+    public int getAriantScore() {\n+        return this.countItem(4031868);\n+    }\n+\n+    public void updateAriantScore() {\n+        this.getMap().broadcastMessage(MaplePacketCreator.updateAriantPQRanking(this.getName(), getAriantScore(), false));\n+    }\n+    \n+    public void disease(int type, int level) {\n+        if (MapleDisease.getBySkill(type) == null) {\n+            return;\n+        }\n+        giveDebuff(MapleDisease.getBySkill(type), MobSkillFactory.getMobSkill(type, level));\n+    }\n+    \n+    public void shield() {\n+        List<Pair<MapleBuffStat, Integer>> ldsstat = Collections.singletonList(new Pair<MapleBuffStat, Integer>(MapleBuffStat.ARIANT_PQ_SHIELD, 1));\n+        getMap().broadcastMessage(this, MaplePacketCreator.giveForeignBuff(id, ldsstat), false);\n+    }\n+\n+    public ScheduledFuture<?> getPqMapleMap() {\n+        return pqMapleMap;\n+    }\n+\n+    public void setPqMapleMap(ScheduledFuture<?> pqMapleMap) {\n+        this.pqMapleMap = pqMapleMap;\n+    }\n+\n+    public ScheduledFuture<?> getAriantScoreBord() {\n+        return ariantScore;\n+    }\n+\n+    public void setAriantScore(ScheduledFuture<?> ariantScore) {\n+        this.ariantScore = ariantScore;\n+    }\n+    \n }"}, {"sha": "55f2713da1fe956e368c054a4a7d7ed7a557f07c", "filename": "src/client/MapleClient.java", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/client/MapleClient.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/client/MapleClient.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/client/MapleClient.java?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -81,6 +81,8 @@\n import net.server.audit.locks.MonitoredLockType;\n import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n import net.server.coordinator.MapleLoginBypassCoordinator;\n+import server.expeditions.MapleExpedition;\n+import server.expeditions.MapleExpeditionType;\n \n public class MapleClient {\n \n@@ -767,7 +769,7 @@ public void updateLoginState(int newstate) {\n         try {\n             Connection con = DatabaseConnection.getConnection();\n             try (PreparedStatement ps = con.prepareStatement(\"UPDATE accounts SET loggedin = ?, lastlogin = ? WHERE id = ?\")) {\n-                                // using sql currenttime here could potentially break the login, thanks Arnah for pointing this out\n+                // using sql currenttime here could potentially break the login, thanks Arnah for pointing this out\n \n                 ps.setInt(1, newstate);\n                 ps.setTimestamp(2, new java.sql.Timestamp(Server.getInstance().getCurrentTime()));\n@@ -884,6 +886,9 @@ private void removePlayer(World wserv, boolean serverTransition) {\n                 if (player.getMonsterCarnival() != null) {\n                     player.getMonsterCarnival().playerDisconnected(getPlayer().getId());\n                 }\n+\n+                cancelarAriantPQ();\n+\n             }\n \n             if (player.getMap() != null) {\n@@ -899,6 +904,20 @@ private void removePlayer(World wserv, boolean serverTransition) {\n         }\n     }\n \n+    public void cancelarAriantPQ() {\n+        MapleExpedition exp = null;\n+        if (player.getMapId() == 980010101) {\n+            exp = player.getClient().getAbstractPlayerInteraction().getExpedition(MapleExpeditionType.ARIANT);\n+        } else if (player.getMapId() == 980010201) {\n+            exp = player.getClient().getAbstractPlayerInteraction().getExpedition(MapleExpeditionType.ARIANT1);\n+        } else {\n+            exp = player.getClient().getAbstractPlayerInteraction().getExpedition(MapleExpeditionType.ARIANT2);\n+        }\n+        if (exp != null && (player.getMapId() == 980010101 || player.getMapId() == 980010201 || player.getMapId() == 980010301) && player.getMap().getAllPlayer().size() == 1) {\n+            getAbstractPlayerInteraction().endExpedition(exp);\n+        }\n+    }\n+\n     public final void disconnect(final boolean shutdown, final boolean cashshop) {\n         if (canDisconnect()) {\n             ThreadManager.getInstance().newTask(new Runnable() {\n@@ -985,7 +1004,7 @@ private void disconnectInternal(boolean shutdown, boolean cashshop) {//once per\n                         chrg.setCharacter(null);\n                     }\n                     wserv.removePlayer(player);\n-                                        //getChannelServer().removePlayer(player); already being done\n+                    //getChannelServer().removePlayer(player); already being done\n \n                     player.saveCooldowns();\n                     player.cancelAllDebuffs();\n@@ -1448,7 +1467,7 @@ public void changeChannel(int channel) {\n         player.cancelDiseaseExpireTask();\n         player.cancelSkillCooldownTask();\n         player.cancelQuestExpirationTask();\n-\t\t//Cancelling magicdoor? Nope\n+        //Cancelling magicdoor? Nope\n         //Cancelling mounts? Noty\n \n         player.getInventory(MapleInventoryType.EQUIPPED).checked(false); //test"}, {"sha": "3c636a491aac3081d63a0f01898571b5fbab1adb", "filename": "src/client/MapleDisease.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/client/MapleDisease.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/client/MapleDisease.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/client/MapleDisease.java?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -29,7 +29,7 @@\n     SEDUCE(0x80, 128),\n     FISHABLE(0x100),\n     ZOMBIFY(0x4000),\n-    CONFUSE(0x80000),\n+    CONFUSE(0x80000, 132),\n     STUN(0x2000000000000L, 123),\n     POISON(0x4000000000000L, 125),\n     SEAL(0x8000000000000L, 120),"}, {"sha": "4b5135bed0bdb9809fb97ce475fa63c6109a8c31", "filename": "src/constants/GameConstants.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/constants/GameConstants.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/constants/GameConstants.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/constants/GameConstants.java?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -20,6 +20,7 @@\n public class GameConstants {\n     public static String[] WORLD_NAMES = {\"Scania\", \"Bera\", \"Broa\", \"Windia\", \"Khaini\", \"Bellocan\", \"Mardia\", \"Kradia\", \"Yellonde\", \"Demethos\", \"Galicia\", \"El Nido\", \"Zenith\", \"Arcenia\", \"Kastia\", \"Judis\", \"Plana\", \"Kalluna\", \"Stius\", \"Croa\", \"Medere\"};\n     public static final int[]  OWL_DATA = new int[]{1082002, 2070005, 2070006, 1022047, 1102041, 2044705, 2340000, 2040017, 1092030, 2040804};\n+    public static final String[] stats = {\"tuc\", \"reqLevel\", \"reqJob\", \"reqSTR\", \"reqDEX\", \"reqINT\", \"reqLUK\", \"reqPOP\", \"cash\", \"cursed\", \"success\", \"setItemID\", \"equipTradeBlock\", \"durability\", \"randOption\", \"randStat\", \"masterLevel\", \"reqSkillLevel\", \"elemDefault\", \"incRMAS\", \"incRMAF\", \"incRMAI\", \"incRMAL\", \"canLevel\", \"skill\", \"charmEXP\"};\n     public static final int[] CASH_DATA = new int[]{50200004, 50200069, 50200117, 50100008, 50000047};\n     \n     // Ronan's rates upgrade system"}, {"sha": "0df856fd7ce38a4179a817068fa5c767ad62cd1f", "filename": "src/net/server/Server.java", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/net/server/Server.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/net/server/Server.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/Server.java?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -88,6 +88,7 @@\n import java.util.TimeZone;\n import net.server.coordinator.MapleSessionCoordinator;\n import server.CashShop.CashItemFactory;\n+import server.MapleItemInformationProvider;\n import server.MapleSkillbookInformationProvider;\n import server.ThreadManager;\n import server.TimerManager;\n@@ -924,6 +925,7 @@ public void init() {\n         //MapleItemInformationProvider.getInstance().getAllItems(); //unused, rofl\n \n         CashItemFactory.getSpecialCashItems();\n+        MapleItemInformationProvider.getInstance().getAllItems();\n         System.out.println(\"Items loaded in \" + ((System.currentTimeMillis() - timeToTake) / 1000.0) + \" seconds\");\n         \n \ttimeToTake = System.currentTimeMillis();"}, {"sha": "dc44f2ccb9989e8fbca5ccaa47f08bb11ed47ed1", "filename": "src/net/server/channel/handlers/TakeDamageHandler.java", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/net/server/channel/handlers/TakeDamageHandler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/net/server/channel/handlers/TakeDamageHandler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/handlers/TakeDamageHandler.java?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -34,7 +34,6 @@\n import constants.ItemConstants;\n import constants.ServerConstants;\n import constants.skills.Aran;\n-import constants.skills.Corsair;\n \n import java.awt.Point;\n import java.util.Collections;\n@@ -44,6 +43,7 @@\n import net.AbstractMaplePacketHandler;\n import client.inventory.manipulator.MapleInventoryManipulator;\n import server.MapleStatEffect;\n+import server.life.MapleLifeFactory;\n import server.life.MapleLifeFactory.loseItem;\n import server.life.MapleMonster;\n import server.life.MobAttackInfo;\n@@ -87,15 +87,19 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n                     }\n                 }\n                 \n-                if (attacker != null) {\n+                if (attacker != null || monsteridfrom == 9300166) {\n                     List<loseItem> loseItems;\n                     \n-                    if (attacker.isBuffed(MonsterStatus.NEUTRALISE)) {\n+                    if (monsteridfrom != 9300166 && attacker.isBuffed(MonsterStatus.NEUTRALISE)) {\n                         return;\n                     }\n                     if (damage > 0) {\n                         MapleMonster assaulter = map.getMonsterById(monsteridfrom);\n                         \n+                        if (monsteridfrom == 9300166) {\n+                            assaulter = MapleLifeFactory.getMonster(monsteridfrom);\n+                        } \n+                        \n                         if(assaulter != null) {\n                             loseItems = assaulter.getStats().loseItem();\n                             if (loseItems != null) {\n@@ -106,8 +110,14 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n                                 for (loseItem loseItem : loseItems) {\n                                     type = ItemConstants.getInventoryType(loseItem.getId());\n                                     for (byte b = 0; b < loseItem.getX(); b++) {//LOL?\n+                                        boolean buffAtivo = false;\n                                         if (Randomizer.nextInt(100) < loseItem.getChance()) {\n-                                            if (chr.haveItem(loseItem.getId())) {\n+                                            for (Integer inteiro : chr.getAvailableBuffs()) {\n+                                                if (inteiro == -2022269) {\n+                                                    buffAtivo = true;\n+                                                }\n+                                            }\n+                                            if (chr.haveItem(loseItem.getId()) && !buffAtivo) {\n                                                 pos.x = (int) (playerpos + ((d % 2 == 0) ? (25 * (d + 1) / 2) : -(25 * (d / 2))));\n                                                 MapleInventoryManipulator.removeById(c, type, loseItem.getId(), 1, false, false);\n                                                 map.spawnItemDrop(chr, chr, new Item(loseItem.getId(), (short) 0, (short) 1), map.calcDropPos(pos, chr.getPosition()), true, true);\n@@ -118,7 +128,9 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n                                         }\n                                     }\n                                 }\n-                                map.removeMapObject(attacker);\n+                                if(monsteridfrom != 9300166) {\n+                                    map.removeMapObject(attacker);\n+                                }\n                             }\n                         }\n                     }"}, {"sha": "34cc3e582ddbde2e007a953ec49fcfdcbe1f7c78", "filename": "src/net/server/channel/handlers/UseCatchItemHandler.java", "status": "modified", "additions": 39, "deletions": 140, "changes": 179, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/net/server/channel/handlers/UseCatchItemHandler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/net/server/channel/handlers/UseCatchItemHandler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/handlers/UseCatchItemHandler.java?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -1,24 +1,24 @@\n /*\n-    This file is part of the OdinMS Maple Story Server\n-    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n-               Matthias Butz <matze@odinms.de>\n-               Jan Christian Meyer <vimes@odinms.de>\n+ This file is part of the OdinMS Maple Story Server\n+ Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n+ Matthias Butz <matze@odinms.de>\n+ Jan Christian Meyer <vimes@odinms.de>\n \n-    This program is free software: you can redistribute it and/or modify\n-    it under the terms of the GNU Affero General Public License as\n-    published by the Free Software Foundation version 3 as published by\n-    the Free Software Foundation. You may not use, modify or distribute\n-    this program under any other version of the GNU Affero General Public\n-    License.\n+ This program is free software: you can redistribute it and/or modify\n+ it under the terms of the GNU Affero General Public License as\n+ published by the Free Software Foundation version 3 as published by\n+ the Free Software Foundation. You may not use, modify or distribute\n+ this program under any other version of the GNU Affero General Public\n+ License.\n \n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU Affero General Public License for more details.\n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU Affero General Public License for more details.\n \n-    You should have received a copy of the GNU Affero General Public License\n-    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-*/\n+ You should have received a copy of the GNU Affero General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n package net.server.channel.handlers;\n \n import client.MapleCharacter;\n@@ -29,6 +29,7 @@\n import net.AbstractMaplePacketHandler;\n import net.server.Server;\n import client.inventory.manipulator.MapleInventoryManipulator;\n+import server.MapleItemInformationProvider;\n import server.life.MapleMonster;\n import tools.MaplePacketCreator;\n import tools.data.input.SeekableLittleEndianAccessor;\n@@ -38,6 +39,7 @@\n  * @author kevintjuh93\n  */\n public final class UseCatchItemHandler extends AbstractMaplePacketHandler {\n+\n     @Override\n     public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c) {\n         MapleCharacter chr = c.getPlayer();\n@@ -48,140 +50,37 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n         int itemId = slea.readInt();\n         int monsterid = slea.readInt();\n \n+        int itemGanho = MapleItemInformationProvider.getInstance().getCreatItem(itemId);\n+        int mobItem = MapleItemInformationProvider.getInstance().getMobItem(itemId);\n+        int timeCatch = MapleItemInformationProvider.getInstance().getUseDelay(itemId);\n+        int mobHp = MapleItemInformationProvider.getInstance().getMobHP(itemId);\n+\n         MapleMonster mob = chr.getMap().getMonsterByOid(monsterid);\n         if (chr.getInventory(ItemConstants.getInventoryType(itemId)).countById(itemId) <= 0) {\n-           return;\n+            return;\n         }\n         if (mob == null) {\n-           return;\n+            return;\n         }\n-        switch (itemId) {\n-            case 2270000:\n-                if (mob.getId() == 9300101) {\n+\n+        if (itemGanho != 0 && mobItem == mob.getId()) {\n+            if (timeCatch != 0 && (abm.getLastSpam(10) + timeCatch) < currentServerTime()) {\n+                if (mobHp != 0 && mob.getHp() < ((mob.getMaxHp() / 100) * mobHp)) {\n                     chr.getMap().broadcastMessage(MaplePacketCreator.catchMonster(monsterid, itemId, (byte) 1));\n                     mob.getMap().killMonster(mob, null, false);\n                     MapleInventoryManipulator.removeById(c, MapleInventoryType.USE, itemId, 1, true, true);\n-                    MapleInventoryManipulator.addById(c, 1902000, (short) 1, \"\", -1);\n-                 }\n-                c.announce(MaplePacketCreator.enableActions());\n-                break;\n-            case 2270001:\n-                if (mob.getId() == 9500197) {\n-                    if ((abm.getLastSpam(10) + 1000) < currentServerTime()) {\n-                        if (mob.getHp() < ((mob.getMaxHp() / 10) * 4)) {\n-                            chr.getMap().broadcastMessage(MaplePacketCreator.catchMonster(monsterid, itemId, (byte) 1));\n-                            mob.getMap().killMonster(mob, null, false);\n-                            MapleInventoryManipulator.removeById(c, MapleInventoryType.USE, itemId, 1, true, true);\n-                            MapleInventoryManipulator.addById(c, 4031830, (short) 1, \"\", -1);\n-                        } else {\n-                            abm.spam(10);\n-                            c.announce(MaplePacketCreator.catchMessage(0));\n-                        }\n-                    }\n-                    c.announce(MaplePacketCreator.enableActions());\n-                }\n-                break;\n-            case 2270002:\n-                if (mob.getId() == 9300157) {\n-                    if ((abm.getLastSpam(10) + 800) < currentServerTime()) {\n-                        if (mob.getHp() < ((mob.getMaxHp() / 10) * 4)) {\n-                            if (Math.random() < 0.5) { // 50% chance\n-                                chr.getMap().broadcastMessage(MaplePacketCreator.catchMonster(monsterid, itemId, (byte) 1));\n-                                mob.getMap().killMonster(mob, null, false);\n-                                MapleInventoryManipulator.removeById(c, MapleInventoryType.USE, itemId, 1, true, true);\n-                                MapleInventoryManipulator.addById(c, 4031868, (short) 1, \"\", -1);\n-                            } else {\n-                                chr.getMap().broadcastMessage(MaplePacketCreator.catchMonster(monsterid, itemId, (byte) 0));\n-                            }\n-                            abm.spam(10);\n-                        } else {\n-                            c.announce(MaplePacketCreator.catchMessage(0));\n-                        }\n+                    MapleInventoryManipulator.addById(c, itemGanho, (short) 1, \"\", -1);\n+                    if (itemGanho == 4031868) {\n+                        chr.updateAriantScore();\n                     }\n-                c.announce(MaplePacketCreator.enableActions());\n-                }\n-                break;\n-            case 2270003:\n-                if (mob.getId() == 9500320) {\n-                    if (mob.getHp() < ((mob.getMaxHp() / 10) * 4)) {\n-                        chr.getMap().broadcastMessage(MaplePacketCreator.catchMonster(monsterid, itemId, (byte) 1));\n-                        mob.getMap().killMonster(mob, null, false);\n-                        MapleInventoryManipulator.removeById(c, MapleInventoryType.USE, itemId, 1, true, true);\n-                        MapleInventoryManipulator.addById(c, 4031887, (short) 1, \"\", -1);\n-                    } else {\n-                        c.announce(MaplePacketCreator.catchMessage(0));\n-                    }\n-                }\n-                c.announce(MaplePacketCreator.enableActions());\n-                break;\n-            case 2270005:\n-                if (mob.getId() == 9300187) {\n-                    if (mob.getHp() < ((mob.getMaxHp() / 10) * 3)) {\n-                        chr.getMap().broadcastMessage(MaplePacketCreator.catchMonster(monsterid, itemId, (byte) 1));\n-                        mob.getMap().killMonster(mob, null, false);\n-                        MapleInventoryManipulator.removeById(c, MapleInventoryType.USE, itemId, 1, true, true);\n-                        MapleInventoryManipulator.addById(c, 2109001, (short) 1, \"\", -1);\n-                    } else {\n-                        c.announce(MaplePacketCreator.catchMessage(0));\n-                    }\n-                }\n-                c.announce(MaplePacketCreator.enableActions());\n-                break;\n-            case 2270006:\n-                if (mob.getId() == 9300189) {\n-                    if (mob.getHp() < ((mob.getMaxHp() / 10) * 3)) {\n-                        chr.getMap().broadcastMessage(MaplePacketCreator.catchMonster(monsterid, itemId, (byte) 1));\n-                        mob.getMap().killMonster(mob, null, false);\n-                        MapleInventoryManipulator.removeById(c, MapleInventoryType.USE, itemId, 1, true, true);\n-                        MapleInventoryManipulator.addById(c, 2109002, (short) 1, \"\", -1);\n-                    } else {\n-                        c.announce(MaplePacketCreator.catchMessage(0));\n-                    }\n-                }\n-                c.announce(MaplePacketCreator.enableActions());\n-                break;\n-            case 2270007:\n-                if (mob.getId() == 9300191) {\n-                    if (mob.getHp() < ((mob.getMaxHp() / 10) * 3)) {\n-                        chr.getMap().broadcastMessage(MaplePacketCreator.catchMonster(monsterid, itemId, (byte) 1));\n-                        mob.getMap().killMonster(mob, null, false);\n-                        MapleInventoryManipulator.removeById(c, MapleInventoryType.USE, itemId, 1, true, true);\n-                        MapleInventoryManipulator.addById(c, 2109003, (short) 1, \"\", -1);\n-                    } else {\n-                        c.announce(MaplePacketCreator.catchMessage(0));\n-                    }\n-                }\n-                c.announce(MaplePacketCreator.enableActions());\n-                break;\n-            case 2270004:\n-                if (mob.getId() == 9300175) {\n-                    if (mob.getHp() < ((mob.getMaxHp() / 10) * 4)) {\n-                    chr.getMap().broadcastMessage(MaplePacketCreator.catchMonster(monsterid, itemId, (byte) 1));\n-                    mob.getMap().killMonster(mob, null, false);\n-                    MapleInventoryManipulator.removeById(c, MapleInventoryType.USE, itemId, 1, true, true);\n-                    MapleInventoryManipulator.addById(c, 4001169, (short) 1, \"\", -1);\n-                    } else {\n+                } else if (mobHp != 0 && mob.getId() != 9500336) {\n+                    abm.spam(10);\n                     c.announce(MaplePacketCreator.catchMessage(0));\n-                    }\n-                }\n-                c.announce(MaplePacketCreator.enableActions());\n-                break;\n-            case 2270008:\n-                if (mob.getId() == 9500336) {\n-                    if ((abm.getLastSpam(10) + 3000) < currentServerTime()) {\n-                        abm.spam(10);\n-                        chr.getMap().broadcastMessage(MaplePacketCreator.catchMonster(monsterid, itemId, (byte) 1));\n-                        mob.getMap().killMonster(mob, null, false);\n-                        MapleInventoryManipulator.removeById(c, MapleInventoryType.USE, itemId, 1, true, true);\n-                        MapleInventoryManipulator.addById(c, 2022323, (short) 1, \"\", -1);\n-                    } else {\n-                        chr.message(\"You cannot use the Fishing Net yet.\");\n-                    }\n-                    c.announce(MaplePacketCreator.enableActions());\n+                } else if (mob.getId() == 9500336) {\n+                    chr.message(\"You cannot use the Fishing Net yet.\");\n                 }\n-                break;\n-            default:\n-               // System.out.println(\"UseCatchItemHandler: \\r\\n\" + slea.toString());\n+            }\n         }\n+        c.announce(MaplePacketCreator.enableActions());\n     }\n }"}, {"sha": "cfef1b017a3bf5dc46ff984ca6bccd6505e2f542", "filename": "src/provider/MapleDataTool.java", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/provider/MapleDataTool.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/provider/MapleDataTool.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/provider/MapleDataTool.java?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -72,6 +72,25 @@ public static int getIntConvert(MapleData data) {\n             return getInt(data);\n         }\n     }\n+    \n+    public static int getIntConvert(MapleData d, int def) {\n+        if (d == null) {\n+            return def;\n+        }\n+        if (d.getType() == MapleDataType.STRING) {\n+\t    String dd = getString(d);\n+\t    if (dd.endsWith(\"%\")) {\n+\t\tdd = dd.substring(0, dd.length() - 1);\n+\t    }\n+            try {\n+                return Integer.parseInt(dd);\n+            } catch (NumberFormatException nfe) {\n+                return def;\n+            }\n+        } else {\n+            return getInt(d, def);\n+        }\n+    }\n \n     public static int getIntConvert(String path, MapleData data) {\n         MapleData d = data.getChildByPath(path);"}, {"sha": "a9e901956a54d39b76799d3f65a5979983587728", "filename": "src/scripting/AbstractPlayerInteraction.java", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/scripting/AbstractPlayerInteraction.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/scripting/AbstractPlayerInteraction.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/scripting/AbstractPlayerInteraction.java?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -55,7 +55,6 @@\n import client.MapleCharacter;\n import client.MapleClient;\n import client.MapleQuestStatus;\n-import client.MapleStat;\n import client.SkillFactory;\n import client.inventory.Equip;\n import client.inventory.Item;\n@@ -331,7 +330,7 @@ public boolean canHoldAllAfterRemoving(List<Integer> toAddItemids, List<Integer>\n         return true;\n     }\n \n-        //---- \\/ \\/ \\/ \\/ \\/ \\/ \\/  NOT TESTED  \\/ \\/ \\/ \\/ \\/ \\/ \\/ \\/ \\/ ----\n+    //---- \\/ \\/ \\/ \\/ \\/ \\/ \\/  NOT TESTED  \\/ \\/ \\/ \\/ \\/ \\/ \\/ \\/ \\/ ----\n     public final MapleQuestStatus getQuestRecord(final int id) {\n         return c.getPlayer().getQuestNAdd(MapleQuest.getInstance(id));\n     }\n@@ -340,7 +339,7 @@ public final MapleQuestStatus getQuestNoRecord(final int id) {\n         return c.getPlayer().getQuestNoAdd(MapleQuest.getInstance(id));\n     }\n \n-        //---- /\\ /\\ /\\ /\\ /\\ /\\ /\\  NOT TESTED  /\\ /\\ /\\ /\\ /\\ /\\ /\\ /\\ /\\ ----\n+    //---- /\\ /\\ /\\ /\\ /\\ /\\ /\\  NOT TESTED  /\\ /\\ /\\ /\\ /\\ /\\ /\\ /\\ /\\ ----\n     public void openNpc(int npcid) {\n         openNpc(npcid, null);\n     }\n@@ -745,7 +744,7 @@ public void givePartyExp(String PQ) {\n     }\n \n     public void givePartyExp(String PQ, boolean instance) {\n-\t\t//1 player  =  +0% bonus (100)\n+        //1 player  =  +0% bonus (100)\n         //2 players =  +0% bonus (100)\n         //3 players =  +0% bonus (100)\n         //4 players = +10% bonus (110)\n@@ -1025,6 +1024,33 @@ public MapleExpedition getExpedition(MapleExpeditionType type) {\n         return null;\n     }\n \n+    public String getNomeDosMembrosExpedition(MapleExpeditionType tipo) {\n+        String membros = \"\";\n+        MapleExpedition expedicao = getExpedition(tipo);\n+        for (String memberName : expedicao.getMembers().values()) {\n+            membros += \"\" + memberName + \", \";\n+        }\n+        return membros;\n+    }\n+    \n+    public boolean getIsLeaderExpedition(MapleExpeditionType tipo) {\n+        MapleExpedition expedicao = getExpedition(tipo);\n+        return expedicao.isLeader(getPlayer());\n+    }\n+    \n+    public void warpExpedition(int mapId, MapleExpeditionType tipo) {\n+        if (tipo != null ) {\n+            MapleExpedition expedicao = getExpedition(tipo);\n+            for (MapleCharacter chr : expedicao.getActiveMembers()) {\n+                chr.changeMap(mapId);\n+            }\n+        } else {\n+            for (MapleCharacter chr : getMap().getAllPlayers()) {\n+                chr.changeMap(mapId);\n+            }\n+        }\n+    }\n+\n     public long getJailTimeLeft() {\n         return getPlayer().getJailExpirationTimeLeft();\n     }"}, {"sha": "82de97df7dd9f433d142cb17a72ea7eefc8a4114", "filename": "src/scripting/event/EventInstanceManager.java", "status": "modified", "additions": 1251, "deletions": 1180, "changes": 2431, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/scripting/event/EventInstanceManager.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/scripting/event/EventInstanceManager.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/scripting/event/EventInstanceManager.java?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -1,23 +1,23 @@\n /*\n-\tThis file is part of the OdinMS Maple Story Server\n-    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n-\t\t       Matthias Butz <matze@odinms.de>\n-\t\t       Jan Christian Meyer <vimes@odinms.de>\n-\n-    This program is free software: you can redistribute it and/or modify\n-    it under the terms of the GNU Affero General Public License as\n-    published by the Free Software Foundation version 3 as published by\n-    the Free Software Foundation. You may not use, modify or distribute\n-    this program under any other version of the GNU Affero General Public\n-    License.\n-\n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU Affero General Public License for more details.\n-\n-    You should have received a copy of the GNU Affero General Public License\n-    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ This file is part of the OdinMS Maple Story Server\n+ Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n+ Matthias Butz <matze@odinms.de>\n+ Jan Christian Meyer <vimes@odinms.de>\n+\n+ This program is free software: you can redistribute it and/or modify\n+ it under the terms of the GNU Affero General Public License as\n+ published by the Free Software Foundation version 3 as published by\n+ the Free Software Foundation. You may not use, modify or distribute\n+ this program under any other version of the GNU Affero General Public\n+ License.\n+\n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU Affero General Public License for more details.\n+\n+ You should have received a copy of the GNU Affero General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>.\n  */\n package scripting.event;\n \n@@ -80,1284 +80,1355 @@\n  * @author Ronan\n  */\n public class EventInstanceManager {\n-\tprivate Map<Integer, MapleCharacter> chars = new HashMap<>();\n-        private int leaderId = -1;\n-\tprivate List<MapleMonster> mobs = new LinkedList<>();\n-\tprivate Map<MapleCharacter, Integer> killCount = new HashMap<>();\n-\tprivate EventManager em;\n-        private EventScriptScheduler ess;\n-\tprivate MapleMapFactory mapFactory;\n-\tprivate String name;\n-\tprivate Properties props = new Properties();\n-\tprivate long timeStarted = 0;\n-\tprivate long eventTime = 0;\n-\tprivate MapleExpedition expedition = null;\n-        private List<Integer> mapIds = new LinkedList<>();\n-        \n-        private final ReentrantReadWriteLock lock = new MonitoredReentrantReadWriteLock(MonitoredLockType.EIM, true);\n-        private ReadLock rL = lock.readLock();\n-        private WriteLock wL = lock.writeLock();\n-        \n-        private MonitoredReentrantLock pL = MonitoredReentrantLockFactory.createLock(MonitoredLockType.EIM_PARTY, true);\n-        private MonitoredReentrantLock sL = MonitoredReentrantLockFactory.createLock(MonitoredLockType.EIM_SCRIPT, true);\n-        \n-        private ScheduledFuture<?> event_schedule = null;\n-        private boolean disposed = false;\n-        private boolean eventCleared = false;\n-        private boolean eventStarted = false;\n-        \n-        // multi-leveled PQ rewards!\n-        private Map<Integer, List<Integer>> collectionSet = new HashMap<>(ServerConstants.MAX_EVENT_LEVELS);\n-        private Map<Integer, List<Integer>> collectionQty = new HashMap<>(ServerConstants.MAX_EVENT_LEVELS);\n-        private Map<Integer, Integer> collectionExp = new HashMap<>(ServerConstants.MAX_EVENT_LEVELS);\n-        \n-        // Exp/Meso rewards by CLEAR on a stage\n-        private List<Integer> onMapClearExp = new ArrayList<>();\n-        private List<Integer> onMapClearMeso = new ArrayList<>();\n-        \n-        // registers player status on an event (null on this Map structure equals to 0)\n-        private Map<Integer, Integer> playerGrid = new HashMap<>();\n-        \n-        // registers all opened gates on the event. Will help late characters to encounter next stages gates already opened\n-        private Map<Integer, Pair<String, Integer>> openedGates = new HashMap<>();\n-        \n-        // forces deletion of items not supposed to be held outside of the event, dealt on a player's leaving moment.\n-        private Set<Integer> exclusiveItems = new HashSet<>();\n-        \n-\tpublic EventInstanceManager(EventManager em, String name) {\n-\t\tthis.em = em;\n-\t\tthis.name = name;\n-                this.ess = new EventScriptScheduler();\n-\t\tmapFactory = new MapleMapFactory(this, MapleDataProviderFactory.getDataProvider(new File(System.getProperty(\"wzpath\") + \"/Map.wz\")), MapleDataProviderFactory.getDataProvider(new File(System.getProperty(\"wzpath\") + \"/String.wz\")), (byte) 0, (byte) 1);//Fk this\n-\t\tmapFactory.setChannel(em.getChannelServer().getId());\n-\t}\n-        \n-        public void setName(String name) {\n-                this.name = name;\n-        }\n-\n-\tpublic EventManager getEm() {\n-                sL.lock();\n-                try {\n-                        return em;\n-                } finally {\n-                        sL.unlock();\n-                }\n-\t}\n-        \n-        public int getEventPlayersJobs() {\n+\n+    private Map<Integer, MapleCharacter> chars = new HashMap<>();\n+    private int leaderId = -1;\n+    private List<MapleMonster> mobs = new LinkedList<>();\n+    private Map<MapleCharacter, Integer> killCount = new HashMap<>();\n+    private EventManager em;\n+    private EventScriptScheduler ess;\n+    private MapleMapFactory mapFactory;\n+    private String name;\n+    private Properties props = new Properties();\n+    private long timeStarted = 0;\n+    private long eventTime = 0;\n+    private MapleExpedition expedition = null;\n+    private List<Integer> mapIds = new LinkedList<>();\n+\n+    private final ReentrantReadWriteLock lock = new MonitoredReentrantReadWriteLock(MonitoredLockType.EIM, true);\n+    private ReadLock rL = lock.readLock();\n+    private WriteLock wL = lock.writeLock();\n+\n+    private MonitoredReentrantLock pL = MonitoredReentrantLockFactory.createLock(MonitoredLockType.EIM_PARTY, true);\n+    private MonitoredReentrantLock sL = MonitoredReentrantLockFactory.createLock(MonitoredLockType.EIM_SCRIPT, true);\n+\n+    private ScheduledFuture<?> event_schedule = null;\n+    private boolean disposed = false;\n+    private boolean eventCleared = false;\n+    private boolean eventStarted = false;\n+\n+    // multi-leveled PQ rewards!\n+    private Map<Integer, List<Integer>> collectionSet = new HashMap<>(ServerConstants.MAX_EVENT_LEVELS);\n+    private Map<Integer, List<Integer>> collectionQty = new HashMap<>(ServerConstants.MAX_EVENT_LEVELS);\n+    private Map<Integer, Integer> collectionExp = new HashMap<>(ServerConstants.MAX_EVENT_LEVELS);\n+\n+    // Exp/Meso rewards by CLEAR on a stage\n+    private List<Integer> onMapClearExp = new ArrayList<>();\n+    private List<Integer> onMapClearMeso = new ArrayList<>();\n+\n+    // registers player status on an event (null on this Map structure equals to 0)\n+    private Map<Integer, Integer> playerGrid = new HashMap<>();\n+\n+    // registers all opened gates on the event. Will help late characters to encounter next stages gates already opened\n+    private Map<Integer, Pair<String, Integer>> openedGates = new HashMap<>();\n+\n+    // forces deletion of items not supposed to be held outside of the event, dealt on a player's leaving moment.\n+    private Set<Integer> exclusiveItems = new HashSet<>();\n+\n+    public EventInstanceManager(EventManager em, String name) {\n+        this.em = em;\n+        this.name = name;\n+        this.ess = new EventScriptScheduler();\n+        mapFactory = new MapleMapFactory(this, MapleDataProviderFactory.getDataProvider(new File(System.getProperty(\"wzpath\") + \"/Map.wz\")), MapleDataProviderFactory.getDataProvider(new File(System.getProperty(\"wzpath\") + \"/String.wz\")), (byte) 0, (byte) 1);//Fk this\n+        mapFactory.setChannel(em.getChannelServer().getId());\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public EventManager getEm() {\n+        sL.lock();\n+        try {\n+            return em;\n+        } finally {\n+            sL.unlock();\n+        }\n+    }\n+\n+    public int getEventPlayersJobs() {\n                 //Bits -> 0: BEGINNER 1: WARRIOR 2: MAGICIAN\n-                //        3: BOWMAN 4: THIEF 5: PIRATE\n-            \n-                int mask = 0;\n-                for(MapleCharacter chr: getPlayers()) {\n-                        mask |= (1 << chr.getJob().getJobNiche());\n-                }\n-                \n-                return mask;\n-        }\n-        \n-        public void applyEventPlayersItemBuff(int itemId) {\n-                List<MapleCharacter> players = getPlayerList();\n-                MapleStatEffect mse = MapleItemInformationProvider.getInstance().getItemEffect(itemId);\n-                \n-                if(mse != null) {\n-                        for (MapleCharacter player: players) {\n-                                mse.applyTo(player);\n-                        }\n-                }\n+        //        3: BOWMAN 4: THIEF 5: PIRATE\n+\n+        int mask = 0;\n+        for (MapleCharacter chr : getPlayers()) {\n+            mask |= (1 << chr.getJob().getJobNiche());\n         }\n-        \n-        public void applyEventPlayersSkillBuff(int skillId) {\n-                applyEventPlayersSkillBuff(skillId, Integer.MAX_VALUE);\n-        }\n-        \n-        public void applyEventPlayersSkillBuff(int skillId, int skillLv) {\n-                List<MapleCharacter> players = getPlayerList();\n-                Skill skill = SkillFactory.getSkill(skillId);\n-                \n-                if(skill != null) {\n-                        MapleStatEffect mse = skill.getEffect(Math.min(skillLv, skill.getMaxLevel()));\n-                        if(mse != null) {\n-                                for (MapleCharacter player: players) {\n-                                        mse.applyTo(player);\n-                                }\n-                        }\n-                }\n+\n+        return mask;\n+    }\n+\n+    public void applyEventPlayersItemBuff(int itemId) {\n+        List<MapleCharacter> players = getPlayerList();\n+        MapleStatEffect mse = MapleItemInformationProvider.getInstance().getItemEffect(itemId);\n+\n+        if (mse != null) {\n+            for (MapleCharacter player : players) {\n+                mse.applyTo(player);\n+            }\n         }\n-        \n-        public void giveEventPlayersExp(int gain) {\n-                giveEventPlayersExp(gain, -1);\n-        }\n-        \n-        public void giveEventPlayersExp(int gain, int mapId) {\n-                if(gain == 0) return;\n-                \n-                List<MapleCharacter> players = getPlayerList();\n-            \n-                if(mapId == -1) {\n-                        for(MapleCharacter mc: players) {\n-                                mc.gainExp(gain * mc.getExpRate(), true, true);\n-                        }\n-                }\n-                else {\n-                        for(MapleCharacter mc: players) {\n-                                if(mc.getMapId() == mapId) mc.gainExp(gain * mc.getExpRate(), true, true);\n-                        }\n-                }\n-\t}\n-        \n-        public void giveEventPlayersMeso(int gain) {\n-                giveEventPlayersMeso(gain, -1);\n-        }\n-        \n-        public void giveEventPlayersMeso(int gain, int mapId) {\n-                if(gain == 0) return;\n-                \n-                List<MapleCharacter> players = getPlayerList();\n-                \n-                if(mapId == -1) {\n-                        for(MapleCharacter mc: players) {\n-                                mc.gainMeso(gain * mc.getMesoRate());\n-                        }\n-                }\n-                else {\n-                        for(MapleCharacter mc: players) {\n-                                if(mc.getMapId() == mapId) mc.gainMeso(gain * mc.getMesoRate());\n-                        }\n-                }\n-                \n-\t}\n-\n-        public synchronized void registerPlayer(final MapleCharacter chr) {\n-                registerPlayer(chr, true);\n-        }\n-        \n-\tpublic synchronized void registerPlayer(final MapleCharacter chr, boolean runEntryScript) {\n-\t\tif (chr == null || !chr.isLoggedinWorld() || disposed) {\n-\t\t\treturn;\n-\t\t}\n-                \n-                wL.lock();\n-                try {\n-                        if(chars.containsKey(chr.getId())) {\n-                                return;\n-                        }\n+    }\n \n-                        chars.put(chr.getId(), chr);\n-                        chr.setEventInstance(this);\n-                } finally {\n-                        wL.unlock();\n-                }\n-                \n-                if (runEntryScript) {\n-                        try {\n-                                em.getIv().invokeFunction(\"playerEntry\", EventInstanceManager.this, chr);\n-                        } catch (ScriptException | NoSuchMethodException ex) {\n-                                ex.printStackTrace();\n-                        }\n-                }\n-\t}  \n-        \n-        public void exitPlayer(final MapleCharacter chr) {\n-\t\tif (chr == null || !chr.isLoggedin()){\n-\t\t\treturn;\n-\t\t}\n-\t\t\n-                unregisterPlayer(chr);\n-                \n-                try {\n-                        em.getIv().invokeFunction(\"playerExit\", EventInstanceManager.this, chr);\n-                } catch (ScriptException | NoSuchMethodException ex) {\n-                        ex.printStackTrace();\n-                }\n-\t}\n-        \n-        public void dropMessage(int type, String message) {\n-                for (MapleCharacter chr : getPlayers()) {\n-                        chr.dropMessage(type, message);\n+    public void applyEventPlayersSkillBuff(int skillId) {\n+        applyEventPlayersSkillBuff(skillId, Integer.MAX_VALUE);\n+    }\n+\n+    public void applyEventPlayersSkillBuff(int skillId, int skillLv) {\n+        List<MapleCharacter> players = getPlayerList();\n+        Skill skill = SkillFactory.getSkill(skillId);\n+\n+        if (skill != null) {\n+            MapleStatEffect mse = skill.getEffect(Math.min(skillLv, skill.getMaxLevel()));\n+            if (mse != null) {\n+                for (MapleCharacter player : players) {\n+                    mse.applyTo(player);\n                 }\n+            }\n         }\n+    }\n \n-        public void restartEventTimer(long time) {\n-                stopEventTimer();\n-                startEventTimer(time);\n+    public void giveEventPlayersExp(int gain) {\n+        giveEventPlayersExp(gain, -1);\n+    }\n+\n+    public void giveEventPlayersExp(int gain, int mapId) {\n+        if (gain == 0) {\n+            return;\n         }\n-        \n-\tpublic void startEventTimer(long time) {\n-                timeStarted = System.currentTimeMillis();\n-\t\teventTime = time;\n-                \n-                for(MapleCharacter chr: getPlayers()) {\n-                        chr.announce(MaplePacketCreator.getClock((int) (time / 1000)));\n-                }\n-                \n-                event_schedule = TimerManager.getInstance().schedule(new Runnable() {\n-                        @Override\n-                        public void run() {\n-                                dismissEventTimer();\n-                                \n-                                try {\n-                                        em.getIv().invokeFunction(\"scheduledTimeout\", EventInstanceManager.this);\n-                                } catch (ScriptException | NoSuchMethodException ex) {\n-                                        Logger.getLogger(EventManager.class.getName()).log(Level.SEVERE, \"Event '\" + em.getName() + \"' does not implement scheduledTimeout function.\", ex);\n-                                }\n-                        }\n-                }, time);\n-\t}\n-        \n-        public void addEventTimer(long time) {\n-                if (event_schedule != null) {\n-                        if (event_schedule.cancel(false)) {\n-                                long nextTime = getTimeLeft() + time;\n-                                eventTime += time;\n-\n-                                event_schedule = TimerManager.getInstance().schedule(new Runnable() {\n-                                        @Override\n-                                        public void run() {\n-                                                dismissEventTimer();\n-\n-                                                try {\n-                                                        em.getIv().invokeFunction(\"scheduledTimeout\", EventInstanceManager.this);\n-                                                } catch (ScriptException | NoSuchMethodException ex) {\n-                                                        Logger.getLogger(EventManager.class.getName()).log(Level.SEVERE, \"Event '\" + em.getName() + \"' does not implement scheduledTimeout function.\", ex);\n-                                                }\n-                                        }\n-                                }, nextTime);\n-                        }\n-                } else {\n-                        startEventTimer(time);\n+\n+        List<MapleCharacter> players = getPlayerList();\n+\n+        if (mapId == -1) {\n+            for (MapleCharacter mc : players) {\n+                mc.gainExp(gain * mc.getExpRate(), true, true);\n+            }\n+        } else {\n+            for (MapleCharacter mc : players) {\n+                if (mc.getMapId() == mapId) {\n+                    mc.gainExp(gain * mc.getExpRate(), true, true);\n                 }\n+            }\n         }\n-        \n-        private void dismissEventTimer() {\n-                for(MapleCharacter chr: getPlayers()) {\n-                        chr.getClient().announce(MaplePacketCreator.removeClock());\n-                }\n-                \n-                event_schedule = null;\n-                eventTime = 0;\n-                timeStarted = 0;\n-        }\n-        \n-        public void stopEventTimer() {\n-                if(event_schedule != null) {\n-                        event_schedule.cancel(false);\n-                        event_schedule = null;\n-                }\n-                \n-                dismissEventTimer();\n+    }\n+\n+    public void giveEventPlayersMeso(int gain) {\n+        giveEventPlayersMeso(gain, -1);\n+    }\n+\n+    public void giveEventPlayersMeso(int gain, int mapId) {\n+        if (gain == 0) {\n+            return;\n         }\n-        \n-\tpublic boolean isTimerStarted() {\n-\t\treturn eventTime > 0 && timeStarted > 0;\n-\t}\n \n-\tpublic long getTimeLeft() {\n-\t\treturn eventTime - (System.currentTimeMillis() - timeStarted);\n-\t}\n+        List<MapleCharacter> players = getPlayerList();\n \n-        public void registerParty(MapleCharacter chr) {\n-                if (chr.isPartyLeader()) {\n-                        registerParty(chr.getParty(), chr.getMap());\n+        if (mapId == -1) {\n+            for (MapleCharacter mc : players) {\n+                mc.gainMeso(gain * mc.getMesoRate());\n+            }\n+        } else {\n+            for (MapleCharacter mc : players) {\n+                if (mc.getMapId() == mapId) {\n+                    mc.gainMeso(gain * mc.getMesoRate());\n                 }\n+            }\n         }\n-        \n-\tpublic void registerParty(MapleParty party, MapleMap map) {\n-\t\tfor (MaplePartyCharacter pc : party.getEligibleMembers()) {\n-\t\t\tMapleCharacter c = map.getCharacterById(pc.getId());\n-\t\t\tregisterPlayer(c);\n-\t\t}\n-\t}\n-\n-\tpublic void registerExpedition(MapleExpedition exped) {\n-\t\texpedition = exped;\n-                registerExpeditionTeam(exped, exped.getRecruitingMap().getId());\n-\t}\n-        \n-        private void registerExpeditionTeam(MapleExpedition exped, int recruitMap) {\n-\t\texpedition = exped;\n-                \n-                for (MapleCharacter chr: exped.getActiveMembers()) {\n-                        if (chr.getMapId() == recruitMap) {\n-                                registerPlayer(chr);\n-                        }\n-                }\n-\t}\n \n-\tpublic void unregisterPlayer(final MapleCharacter chr) {\n-                try {\n-                        em.getIv().invokeFunction(\"playerUnregistered\", EventInstanceManager.this, chr);\n-                } catch (ScriptException | NoSuchMethodException ex) {\n-                        Logger.getLogger(EventManager.class.getName()).log(Level.SEVERE, \"Event '\" + em.getName() + \"' does not implement playerUnregistered function.\", ex);\n-                }\n-                        \n-                wL.lock();\n-                try {\n-                        chars.remove(chr.getId());\n-                        chr.setEventInstance(null);\n-                } finally {\n-                        wL.unlock();\n-                }\n-                \n-                gridRemove(chr);\n-                dropExclusiveItems(chr);\n-\t}\n-\t\n-\tpublic int getPlayerCount() {\n-                rL.lock();\n-                try {\n-                        return chars.size();\n-                } finally {\n-                        rL.unlock();\n-                }\n-\t}\n-        \n-        public MapleCharacter getPlayerById(int id) {\n-                rL.lock();\n-                try {\n-                        return chars.get(id);\n-                } finally {\n-                        rL.unlock();\n-                }\n-\t}\n+    }\n \n-\tpublic List<MapleCharacter> getPlayers() {\n-                rL.lock();\n-                try {\n-                        return new ArrayList<>(chars.values());\n-                } finally {\n-                        rL.unlock();\n-                }\n-\t}\n-        \n-        private List<MapleCharacter> getPlayerList() {\n-                rL.lock();\n-                try {\n-                        return new LinkedList<>(chars.values());\n-                } finally {\n-                        rL.unlock();\n-                }\n+    public synchronized void registerPlayer(final MapleCharacter chr) {\n+        registerPlayer(chr, true);\n+    }\n+\n+    public synchronized void registerPlayer(final MapleCharacter chr, boolean runEntryScript) {\n+        if (chr == null || !chr.isLoggedinWorld() || disposed) {\n+            return;\n         }\n-        \n-\tpublic void registerMonster(MapleMonster mob) {\n-\t\tif (!mob.getStats().isFriendly()) { //We cannot register moon bunny\n-\t\t\tmobs.add(mob);\n-\t\t}\n-\t}\n \n-\tpublic void movePlayer(final MapleCharacter chr) {\n-                try {\n-                        em.getIv().invokeFunction(\"moveMap\", EventInstanceManager.this, chr);\n-                } catch (ScriptException | NoSuchMethodException ex) {\n-                        ex.printStackTrace();\n-                }\n-\t}\n-        \n-        public void changedMap(final MapleCharacter chr, final int mapId) {\n-                try {\n-                        em.getIv().invokeFunction(\"changedMap\", EventInstanceManager.this, chr, mapId);\n-                } catch (ScriptException | NoSuchMethodException ex) {} // optional\n-\t}\n-        \n-        public void afterChangedMap(final MapleCharacter chr, final int mapId) {\n-                try {\n-                        em.getIv().invokeFunction(\"afterChangedMap\", EventInstanceManager.this, chr, mapId);\n-                } catch (ScriptException | NoSuchMethodException ex) {} // optional\n-\t}\n-        \n-        public synchronized void changedLeader(final MapleCharacter ldr) {\n+        wL.lock();\n+        try {\n+            if (chars.containsKey(chr.getId())) {\n+                return;\n+            }\n+\n+            chars.put(chr.getId(), chr);\n+            chr.setEventInstance(this);\n+        } finally {\n+            wL.unlock();\n+        }\n+\n+        if (runEntryScript) {\n+            try {\n+                em.getIv().invokeFunction(\"playerEntry\", EventInstanceManager.this, chr);\n+            } catch (ScriptException | NoSuchMethodException ex) {\n+                ex.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    public void exitPlayer(final MapleCharacter chr) {\n+        if (chr == null || !chr.isLoggedin()) {\n+            return;\n+        }\n+\n+        unregisterPlayer(chr);\n+\n+        try {\n+            em.getIv().invokeFunction(\"playerExit\", EventInstanceManager.this, chr);\n+        } catch (ScriptException | NoSuchMethodException ex) {\n+            ex.printStackTrace();\n+        }\n+    }\n+\n+    public void dropMessage(int type, String message) {\n+        for (MapleCharacter chr : getPlayers()) {\n+            chr.dropMessage(type, message);\n+        }\n+    }\n+\n+    public void restartEventTimer(long time) {\n+        stopEventTimer();\n+        startEventTimer(time);\n+    }\n+\n+    public void startEventTimer(long time) {\n+        timeStarted = System.currentTimeMillis();\n+        eventTime = time;\n+\n+        for (MapleCharacter chr : getPlayers()) {\n+            chr.announce(MaplePacketCreator.getClock((int) (time / 1000)));\n+        }\n+\n+        event_schedule = TimerManager.getInstance().schedule(new Runnable() {\n+            @Override\n+            public void run() {\n+                dismissEventTimer();\n+\n                 try {\n-                        em.getIv().invokeFunction(\"changedLeader\", EventInstanceManager.this, ldr);\n+                    em.getIv().invokeFunction(\"scheduledTimeout\", EventInstanceManager.this);\n                 } catch (ScriptException | NoSuchMethodException ex) {\n-                        ex.printStackTrace();\n+                    Logger.getLogger(EventManager.class.getName()).log(Level.SEVERE, \"Event '\" + em.getName() + \"' does not implement scheduledTimeout function.\", ex);\n                 }\n-\t\t\n-                leaderId = ldr.getId();\n-\t}\n-\t\n-\tpublic void monsterKilled(final MapleMonster mob, final boolean hasKiller) {\n-                int scriptResult = 0;\n-                \n-\t\tsL.lock();\n-                try {\n-                        mobs.remove(mob);\n-                        \n-                        if(eventStarted) {\n-                                scriptResult = 1;\n-\n-                                if (mobs.isEmpty()) {\n-                                        scriptResult = 2;\n-                                }\n-                        }\n-                } finally {\n-                        sL.unlock();\n-                }\n-                \n-                if (scriptResult > 0) {\n+            }\n+        }, time);\n+    }\n+\n+    public void addEventTimer(long time) {\n+        if (event_schedule != null) {\n+            if (event_schedule.cancel(false)) {\n+                long nextTime = getTimeLeft() + time;\n+                eventTime += time;\n+\n+                event_schedule = TimerManager.getInstance().schedule(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        dismissEventTimer();\n+\n                         try {\n-                                em.getIv().invokeFunction(\"monsterKilled\", mob, EventInstanceManager.this, hasKiller);\n+                            em.getIv().invokeFunction(\"scheduledTimeout\", EventInstanceManager.this);\n                         } catch (ScriptException | NoSuchMethodException ex) {\n-                                ex.printStackTrace();\n-                        }\n-                        \n-                        if (scriptResult > 1) {\n-                                try {\n-                                        em.getIv().invokeFunction(\"allMonstersDead\", EventInstanceManager.this, hasKiller);\n-                                } catch (ScriptException | NoSuchMethodException ex) {\n-                                        ex.printStackTrace();\n-                                }\n+                            Logger.getLogger(EventManager.class.getName()).log(Level.SEVERE, \"Event '\" + em.getName() + \"' does not implement scheduledTimeout function.\", ex);\n                         }\n-                }\n+                    }\n+                }, nextTime);\n+            }\n+        } else {\n+            startEventTimer(time);\n         }\n-        \n-        public void friendlyKilled(final MapleMonster mob, final boolean hasKiller) {\n-                try {\n-                        em.getIv().invokeFunction(\"friendlyKilled\", mob, EventInstanceManager.this, hasKiller);\n-                } catch (ScriptException | NoSuchMethodException ex) {} //optional\n-\t}\n-\n-\tpublic void playerKilled(final MapleCharacter chr) {\n-                ThreadManager.getInstance().newTask(new Runnable() {\n-                        @Override\n-                        public void run() {\n-                                try {\n-                                        em.getIv().invokeFunction(\"playerDead\", EventInstanceManager.this, chr);\n-                                } catch (ScriptException | NoSuchMethodException ex) {} // optional\n-                        }\n-                });\n-\t}\n+    }\n \n-        public void reviveMonster(final MapleMonster mob) {\n-                try {\n-                        em.getIv().invokeFunction(\"monsterRevive\", EventInstanceManager.this, mob);\n-                } catch (ScriptException | NoSuchMethodException ex) {} // optional\n-\t}\n-        \n-\tpublic boolean revivePlayer(final MapleCharacter chr) {\n-                try {\n-                        Object b = em.getIv().invokeFunction(\"playerRevive\", EventInstanceManager.this, chr);\n-                        if (b instanceof Boolean) {\n-                                return (Boolean) b;\n-                        }\n-                } catch (ScriptException | NoSuchMethodException ex) {} // optional\n-                \n-\t\treturn true;\n-\t}\n-        \n-\tpublic void playerDisconnected(final MapleCharacter chr) {\n-                try {\n-                        em.getIv().invokeFunction(\"playerDisconnected\", EventInstanceManager.this, chr);\n-                } catch (ScriptException | NoSuchMethodException ex) {\n-                        ex.printStackTrace();\n+    private void dismissEventTimer() {\n+        for (MapleCharacter chr : getPlayers()) {\n+            chr.getClient().announce(MaplePacketCreator.removeClock());\n+        }\n+\n+        event_schedule = null;\n+        eventTime = 0;\n+        timeStarted = 0;\n+    }\n+\n+    public void stopEventTimer() {\n+        if (event_schedule != null) {\n+            event_schedule.cancel(false);\n+            event_schedule = null;\n+        }\n+\n+        dismissEventTimer();\n+    }\n+\n+    public boolean isTimerStarted() {\n+        return eventTime > 0 && timeStarted > 0;\n+    }\n+\n+    public long getTimeLeft() {\n+        return eventTime - (System.currentTimeMillis() - timeStarted);\n+    }\n+\n+    public void registerParty(MapleCharacter chr) {\n+        if (chr.isPartyLeader()) {\n+            registerParty(chr.getParty(), chr.getMap());\n+        }\n+    }\n+\n+    public void registerParty(MapleParty party, MapleMap map) {\n+        for (MaplePartyCharacter pc : party.getEligibleMembers()) {\n+            MapleCharacter c = map.getCharacterById(pc.getId());\n+            registerPlayer(c);\n+        }\n+    }\n+\n+    public void registerExpedition(MapleExpedition exped) {\n+        expedition = exped;\n+        registerExpeditionTeam(exped, exped.getRecruitingMap().getId());\n+    }\n+\n+    private void registerExpeditionTeam(MapleExpedition exped, int recruitMap) {\n+        expedition = exped;\n+\n+        for (MapleCharacter chr : exped.getActiveMembers()) {\n+            if (chr.getMapId() == recruitMap) {\n+                registerPlayer(chr);\n+            }\n+        }\n+    }\n+\n+    public void unregisterPlayer(final MapleCharacter chr) {\n+        try {\n+            em.getIv().invokeFunction(\"playerUnregistered\", EventInstanceManager.this, chr);\n+        } catch (ScriptException | NoSuchMethodException ex) {\n+            Logger.getLogger(EventManager.class.getName()).log(Level.SEVERE, \"Event '\" + em.getName() + \"' does not implement playerUnregistered function.\", ex);\n+        }\n+\n+        wL.lock();\n+        try {\n+            chars.remove(chr.getId());\n+            chr.setEventInstance(null);\n+        } finally {\n+            wL.unlock();\n+        }\n+\n+        gridRemove(chr);\n+        dropExclusiveItems(chr);\n+    }\n+\n+    public int getPlayerCount() {\n+        rL.lock();\n+        try {\n+            return chars.size();\n+        } finally {\n+            rL.unlock();\n+        }\n+    }\n+\n+    public MapleCharacter getPlayerById(int id) {\n+        rL.lock();\n+        try {\n+            return chars.get(id);\n+        } finally {\n+            rL.unlock();\n+        }\n+    }\n+\n+    public List<MapleCharacter> getPlayers() {\n+        rL.lock();\n+        try {\n+            return new ArrayList<>(chars.values());\n+        } finally {\n+            rL.unlock();\n+        }\n+    }\n+\n+    private List<MapleCharacter> getPlayerList() {\n+        rL.lock();\n+        try {\n+            return new LinkedList<>(chars.values());\n+        } finally {\n+            rL.unlock();\n+        }\n+    }\n+\n+    public void registerMonster(MapleMonster mob) {\n+        if (!mob.getStats().isFriendly()) { //We cannot register moon bunny\n+            mobs.add(mob);\n+        }\n+    }\n+\n+    public void movePlayer(final MapleCharacter chr) {\n+        try {\n+            em.getIv().invokeFunction(\"moveMap\", EventInstanceManager.this, chr);\n+        } catch (ScriptException | NoSuchMethodException ex) {\n+            ex.printStackTrace();\n+        }\n+    }\n+\n+    public void changedMap(final MapleCharacter chr, final int mapId) {\n+        try {\n+            em.getIv().invokeFunction(\"changedMap\", EventInstanceManager.this, chr, mapId);\n+        } catch (ScriptException | NoSuchMethodException ex) {\n+        } // optional\n+    }\n+\n+    public void afterChangedMap(final MapleCharacter chr, final int mapId) {\n+        try {\n+            em.getIv().invokeFunction(\"afterChangedMap\", EventInstanceManager.this, chr, mapId);\n+        } catch (ScriptException | NoSuchMethodException ex) {\n+        } // optional\n+    }\n+\n+    public synchronized void changedLeader(final MapleCharacter ldr) {\n+        try {\n+            em.getIv().invokeFunction(\"changedLeader\", EventInstanceManager.this, ldr);\n+        } catch (ScriptException | NoSuchMethodException ex) {\n+            ex.printStackTrace();\n+        }\n+\n+        leaderId = ldr.getId();\n+    }\n+\n+    public void monsterKilled(final MapleMonster mob, final boolean hasKiller) {\n+        int scriptResult = 0;\n+\n+        sL.lock();\n+        try {\n+            mobs.remove(mob);\n+\n+            if (eventStarted) {\n+                scriptResult = 1;\n+\n+                if (mobs.isEmpty()) {\n+                    scriptResult = 2;\n                 }\n-                \n-                MapleEventRecallCoordinator.getInstance().storeEventInstance(chr.getId(), this);\n-\t}\n-        \n-\tpublic void monsterKilled(MapleCharacter chr, final MapleMonster mob) {\n+            }\n+        } finally {\n+            sL.unlock();\n+        }\n+\n+        if (scriptResult > 0) {\n+            try {\n+                em.getIv().invokeFunction(\"monsterKilled\", mob, EventInstanceManager.this, hasKiller);\n+            } catch (ScriptException | NoSuchMethodException ex) {\n+                ex.printStackTrace();\n+            }\n+\n+            if (scriptResult > 1) {\n                 try {\n-                        int inc;\n-                        \n-                        if (ServerConstants.JAVA_8) {\n-                                inc = (int)em.getIv().invokeFunction(\"monsterValue\", EventInstanceManager.this, mob.getId());\n-                        } else {\n-                                inc = ((Double) em.getIv().invokeFunction(\"monsterValue\", EventInstanceManager.this, mob.getId())).intValue();\n-                        }\n-                        \n-                        if (inc != 0) {\n-                                Integer kc = killCount.get(chr);\n-                                if (kc == null) {\n-                                        kc = inc;\n-                                } else {\n-                                        kc += inc;\n-                                }\n-                                killCount.put(chr, kc);\n-                                if (expedition != null){\n-                                        expedition.monsterKilled(chr, mob);\n-                                }\n-                        }\n+                    em.getIv().invokeFunction(\"allMonstersDead\", EventInstanceManager.this, hasKiller);\n                 } catch (ScriptException | NoSuchMethodException ex) {\n-                        ex.printStackTrace();\n+                    ex.printStackTrace();\n                 }\n-\t}\n-\n-\tpublic int getKillCount(MapleCharacter chr) {\n-\t\tInteger kc = killCount.get(chr);\n-\t\treturn (kc == null) ? 0 : kc;\n-\t}\n-        \n-        public void dispose() {\n-                rL.lock();\n-                try {\n-                        for(MapleCharacter chr: chars.values()) chr.setEventInstance(null);\n-                } finally {\n-                        rL.unlock();\n-                }\n-                \n-                dispose(false);\n-        }\n-        \n-        public synchronized void dispose(boolean shutdown) {    // should not trigger any event script method after disposed\n-                if(disposed) return;\n-                \n-                disposed = true;\n+            }\n+        }\n+    }\n+\n+    public void friendlyKilled(final MapleMonster mob, final boolean hasKiller) {\n+        try {\n+            em.getIv().invokeFunction(\"friendlyKilled\", mob, EventInstanceManager.this, hasKiller);\n+        } catch (ScriptException | NoSuchMethodException ex) {\n+        } //optional\n+    }\n+\n+    public void playerKilled(final MapleCharacter chr) {\n+        ThreadManager.getInstance().newTask(new Runnable() {\n+            @Override\n+            public void run() {\n                 try {\n-                        em.getIv().invokeFunction(\"dispose\", EventInstanceManager.this);\n+                    em.getIv().invokeFunction(\"playerDead\", EventInstanceManager.this, chr);\n                 } catch (ScriptException | NoSuchMethodException ex) {\n-                        ex.printStackTrace();\n-                }\n-                \n-                ess.dispose();\n-                \n-                wL.lock();\n-                try {\n-                        for(MapleCharacter chr: chars.values()) chr.setEventInstance(null);\n-                        chars.clear();\n-                        mobs.clear();\n-                        ess = null;\n-                } finally {\n-                        wL.unlock();\n-                }\n-                \n-                if(event_schedule != null) {\n-                        event_schedule.cancel(false);\n-                        event_schedule = null;\n-                }\n-                \n-                killCount.clear();\n-                mapIds.clear();\n-                props.clear();\n-                \n-                disposeExpedition();\n-                \n-                sL.lock();\n-                try {\n-                        if(!eventCleared) em.disposeInstance(name);\n-                } finally {\n-                        sL.unlock();\n+                } // optional\n+            }\n+        });\n+    }\n+\n+    public void reviveMonster(final MapleMonster mob) {\n+        try {\n+            em.getIv().invokeFunction(\"monsterRevive\", EventInstanceManager.this, mob);\n+        } catch (ScriptException | NoSuchMethodException ex) {\n+        } // optional\n+    }\n+\n+    public boolean revivePlayer(final MapleCharacter chr) {\n+        try {\n+            Object b = em.getIv().invokeFunction(\"playerRevive\", EventInstanceManager.this, chr);\n+            if (b instanceof Boolean) {\n+                return (Boolean) b;\n+            }\n+        } catch (ScriptException | NoSuchMethodException ex) {\n+        } // optional\n+\n+        return true;\n+    }\n+\n+    public void playerDisconnected(final MapleCharacter chr) {\n+        try {\n+            em.getIv().invokeFunction(\"playerDisconnected\", EventInstanceManager.this, chr);\n+        } catch (ScriptException | NoSuchMethodException ex) {\n+            ex.printStackTrace();\n+        }\n+\n+        MapleEventRecallCoordinator.getInstance().storeEventInstance(chr.getId(), this);\n+    }\n+\n+    public void monsterKilled(MapleCharacter chr, final MapleMonster mob) {\n+        try {\n+            int inc;\n+\n+            if (ServerConstants.JAVA_8) {\n+                inc = (int) em.getIv().invokeFunction(\"monsterValue\", EventInstanceManager.this, mob.getId());\n+            } else {\n+                inc = ((Double) em.getIv().invokeFunction(\"monsterValue\", EventInstanceManager.this, mob.getId())).intValue();\n+            }\n+\n+            if (inc != 0) {\n+                Integer kc = killCount.get(chr);\n+                if (kc == null) {\n+                    kc = inc;\n+                } else {\n+                    kc += inc;\n                 }\n-                \n-                TimerManager.getInstance().schedule(new Runnable() {\n-                        @Override\n-                        public void run() {\n-                                mapFactory.dispose();   // issues from instantly disposing some event objects found thanks to MedicOP\n-                                wL.lock();\n-                                try {\n-                                        mapFactory = null;\n-                                        em = null;\n-                                } finally {\n-                                        wL.unlock();\n-                                }\n-\n-                                disposeLocks();\n-                        }\n-                }, 60 * 1000);\n-\t}\n-        \n-        private void disposeLocks() {\n-            LockCollector.getInstance().registerDisposeAction(new Runnable() {\n-                @Override\n-                public void run() {\n-                    emptyLocks();\n+                killCount.put(chr, kc);\n+                if (expedition != null) {\n+                    expedition.monsterKilled(chr, mob);\n                 }\n-            });\n+            }\n+        } catch (ScriptException | NoSuchMethodException ex) {\n+            ex.printStackTrace();\n+        }\n+    }\n+\n+    public int getKillCount(MapleCharacter chr) {\n+        Integer kc = killCount.get(chr);\n+        return (kc == null) ? 0 : kc;\n+    }\n+\n+    public void dispose() {\n+        rL.lock();\n+        try {\n+            for (MapleCharacter chr : chars.values()) {\n+                chr.setEventInstance(null);\n+            }\n+        } finally {\n+            rL.unlock();\n+        }\n+\n+        dispose(false);\n+    }\n+\n+    public synchronized void dispose(boolean shutdown) {    // should not trigger any event script method after disposed\n+        if (disposed) {\n+            return;\n+        }\n+\n+        disposed = true;\n+        try {\n+            em.getIv().invokeFunction(\"dispose\", EventInstanceManager.this);\n+        } catch (ScriptException | NoSuchMethodException ex) {\n+            ex.printStackTrace();\n+        }\n+\n+        ess.dispose();\n+\n+        wL.lock();\n+        try {\n+            for (MapleCharacter chr : chars.values()) {\n+                chr.setEventInstance(null);\n+            }\n+            chars.clear();\n+            mobs.clear();\n+            ess = null;\n+        } finally {\n+            wL.unlock();\n         }\n-        \n-        private void emptyLocks() {\n-                pL = pL.dispose();\n-                sL = sL.dispose();\n+\n+        if (event_schedule != null) {\n+            event_schedule.cancel(false);\n+            event_schedule = null;\n         }\n \n-\tpublic MapleMapFactory getMapFactory() {\n-\t\treturn mapFactory;\n-\t}\n+        killCount.clear();\n+        mapIds.clear();\n+        props.clear();\n+\n+        disposeExpedition();\n+\n+        sL.lock();\n+        try {\n+            if (!eventCleared) {\n+                em.disposeInstance(name);\n+            }\n+        } finally {\n+            sL.unlock();\n+        }\n \n-\tpublic void schedule(final String methodName, long delay) {\n-                rL.lock();\n+        TimerManager.getInstance().schedule(new Runnable() {\n+            @Override\n+            public void run() {\n+                mapFactory.dispose();   // issues from instantly disposing some event objects found thanks to MedicOP\n+                wL.lock();\n                 try {\n-                        if (ess != null) {\n-                                Runnable r = new Runnable() {\n-                                        @Override\n-                                        public void run() {\n-                                                try {\n-                                                        em.getIv().invokeFunction(methodName, EventInstanceManager.this);\n-                                                } catch (ScriptException | NoSuchMethodException ex) {\n-                                                        ex.printStackTrace();\n-                                                }\n-                                        }\n-                                };\n-\n-                                ess.registerEntry(r, delay);\n-                        }\n+                    mapFactory = null;\n+                    em = null;\n                 } finally {\n-                        rL.unlock();\n+                    wL.unlock();\n                 }\n-\t}\n \n-\tpublic String getName() {\n-\t\treturn name;\n-\t}\n+                disposeLocks();\n+            }\n+        }, 60 * 1000);\n+    }\n+\n+    private void disposeLocks() {\n+        LockCollector.getInstance().registerDisposeAction(new Runnable() {\n+            @Override\n+            public void run() {\n+                emptyLocks();\n+            }\n+        });\n+    }\n+\n+    private void emptyLocks() {\n+        pL = pL.dispose();\n+        sL = sL.dispose();\n+    }\n \n-\tpublic MapleMap getMapInstance(int mapId) {\n-\t\tMapleMap map = mapFactory.getMap(mapId);\n-                map.setEventInstance(this);\n+    public MapleMapFactory getMapFactory() {\n+        return mapFactory;\n+    }\n \n-\t\tif (!mapFactory.isMapLoaded(mapId)) {\n-                        sL.lock();\n+    public void schedule(final String methodName, long delay) {\n+        rL.lock();\n+        try {\n+            if (ess != null) {\n+                Runnable r = new Runnable() {\n+                    @Override\n+                    public void run() {\n                         try {\n-                                if (em.getProperty(\"shuffleReactors\") != null && em.getProperty(\"shuffleReactors\").equals(\"true\")) {\n-                                        map.shuffleReactors();\n-                                }\n-                        } finally {\n-                                sL.unlock();\n+                            em.getIv().invokeFunction(methodName, EventInstanceManager.this);\n+                        } catch (ScriptException | NoSuchMethodException ex) {\n+                            ex.printStackTrace();\n                         }\n-\t\t}\n-\t\treturn map;\n-\t}\n+                    }\n+                };\n \n-        public void setIntProperty(String key, Integer value) {\n-                setProperty(key, value);\n+                ess.registerEntry(r, delay);\n+            }\n+        } finally {\n+            rL.unlock();\n         }\n-        \n-        public void setProperty(String key, Integer value) {\n-                setProperty(key, \"\" + value);\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public MapleMap getMapInstance(int mapId) {\n+        MapleMap map = mapFactory.getMap(mapId);\n+        map.setEventInstance(this);\n+\n+        if (!mapFactory.isMapLoaded(mapId)) {\n+            sL.lock();\n+            try {\n+                if (em.getProperty(\"shuffleReactors\") != null && em.getProperty(\"shuffleReactors\").equals(\"true\")) {\n+                    map.shuffleReactors();\n+                }\n+            } finally {\n+                sL.unlock();\n+            }\n         }\n-        \n-\tpublic void setProperty(String key, String value) {\n-                pL.lock();\n-                try {\n-                        props.setProperty(key, value);\n-                } finally {\n-                        pL.unlock();\n-                }\n-\t}\n+        return map;\n+    }\n \n-\tpublic Object setProperty(String key, String value, boolean prev) {\n-                pL.lock();\n-                try {\n-                        return props.setProperty(key, value);\n-                } finally {\n-                        pL.unlock();\n-                }\n-\t}\n+    public void setIntProperty(String key, Integer value) {\n+        setProperty(key, value);\n+    }\n \n-\tpublic String getProperty(String key) {\n-                pL.lock();\n-                try {\n-                        return props.getProperty(key);\n-                } finally {\n-                        pL.unlock();\n-                }\n-\t}\n+    public void setProperty(String key, Integer value) {\n+        setProperty(key, \"\" + value);\n+    }\n \n-        public int getIntProperty(String key) {\n-                pL.lock();\n-                try {\n-                        return Integer.parseInt(props.getProperty(key));\n-                } finally {\n-                        pL.unlock();\n-                }\n+    public void setProperty(String key, String value) {\n+        pL.lock();\n+        try {\n+            props.setProperty(key, value);\n+        } finally {\n+            pL.unlock();\n+        }\n+    }\n+\n+    public Object setProperty(String key, String value, boolean prev) {\n+        pL.lock();\n+        try {\n+            return props.setProperty(key, value);\n+        } finally {\n+            pL.unlock();\n+        }\n+    }\n+\n+    public String getProperty(String key) {\n+        pL.lock();\n+        try {\n+            return props.getProperty(key);\n+        } finally {\n+            pL.unlock();\n+        }\n+    }\n+\n+    public int getIntProperty(String key) {\n+        pL.lock();\n+        try {\n+            return Integer.parseInt(props.getProperty(key));\n+        } finally {\n+            pL.unlock();\n+        }\n+    }\n+\n+    public void leftParty(final MapleCharacter chr) {\n+        try {\n+            em.getIv().invokeFunction(\"leftParty\", EventInstanceManager.this, chr);\n+        } catch (ScriptException | NoSuchMethodException ex) {\n+            ex.printStackTrace();\n         }\n-\t\n-\tpublic void leftParty(final MapleCharacter chr) {\n-                try {\n-                        em.getIv().invokeFunction(\"leftParty\", EventInstanceManager.this, chr);\n-                } catch (ScriptException | NoSuchMethodException ex) {\n-                        ex.printStackTrace();\n-                }\n-\t}\n+    }\n \n-\tpublic void disbandParty() {\n-\t\ttry {\n-                        em.getIv().invokeFunction(\"disbandParty\", EventInstanceManager.this);\n-                } catch (ScriptException | NoSuchMethodException ex) {\n-                        ex.printStackTrace();\n-                }\n-\t}\n+    public void disbandParty() {\n+        try {\n+            em.getIv().invokeFunction(\"disbandParty\", EventInstanceManager.this);\n+        } catch (ScriptException | NoSuchMethodException ex) {\n+            ex.printStackTrace();\n+        }\n+    }\n \n-\tpublic void clearPQ() {\n-                try {\n-                        em.getIv().invokeFunction(\"clearPQ\", EventInstanceManager.this);\n-                } catch (ScriptException | NoSuchMethodException ex) {\n-                        ex.printStackTrace();\n-                }\n-\t}\n+    public void clearPQ() {\n+        try {\n+            em.getIv().invokeFunction(\"clearPQ\", EventInstanceManager.this);\n+        } catch (ScriptException | NoSuchMethodException ex) {\n+            ex.printStackTrace();\n+        }\n+    }\n \n-\tpublic void removePlayer(final MapleCharacter chr) {\n-                try {\n-                        em.getIv().invokeFunction(\"playerExit\", EventInstanceManager.this, chr);\n-                } catch (ScriptException | NoSuchMethodException ex) {\n-                        ex.printStackTrace();\n-                }\n-\t}\n-\n-\tpublic boolean isLeader(MapleCharacter chr) {\n-\t\treturn (chr.getParty().getLeaderId() == chr.getId());\n-\t}\n-        \n-        public boolean isEventLeader(MapleCharacter chr) {\n-\t\treturn (chr.getId() == getLeaderId());\n-\t}\n-        \n-        public final MapleMap getInstanceMap(final int mapid) {\n-                if (disposed) {\n-                        return null;\n-                }\n-                mapIds.add(mapid);\n-                return getMapFactory().getMap(mapid);\n+    public void removePlayer(final MapleCharacter chr) {\n+        try {\n+            em.getIv().invokeFunction(\"playerExit\", EventInstanceManager.this, chr);\n+        } catch (ScriptException | NoSuchMethodException ex) {\n+            ex.printStackTrace();\n         }\n-        \n-        public final boolean disposeIfPlayerBelow(final byte size, final int towarp) {\n-                if (disposed) {\n-                        return true;\n-                }\n-                if(chars == null) {\n-                        return false;\n-                }\n-                \n-                MapleMap map = null;\n-                if (towarp > 0) {\n-                        map = this.getMapFactory().getMap(towarp);\n-                }\n-                \n-                List<MapleCharacter> players = getPlayerList();\n+    }\n \n-                try {\n-                        if (players.size() < size) {\n-                                for (MapleCharacter chr : players) {\n-                                        if (chr == null) {\n-                                                continue;\n-                                        }\n-\n-                                        unregisterPlayer(chr);\n-                                        if (towarp > 0) {\n-                                                chr.changeMap(map, map.getPortal(0));\n-                                        }\n-                                }\n-\n-                                dispose();\n-                                return true;\n-                        }\n-                } catch (Exception ex) {\n-                        ex.printStackTrace();\n-                }\n-                \n-                return false;\n+    public boolean isLeader(MapleCharacter chr) {\n+        return (chr.getParty().getLeaderId() == chr.getId());\n+    }\n+\n+    public boolean isEventLeader(MapleCharacter chr) {\n+        return (chr.getId() == getLeaderId());\n+    }\n+\n+    public final MapleMap getInstanceMap(final int mapid) {\n+        if (disposed) {\n+            return null;\n         }\n-        \n-        public void spawnNpc(int npcId, Point pos, MapleMap map) {\n-                MapleNPC npc = MapleLifeFactory.getNPC(npcId);\n-                if (npc != null) {\n-                        npc.setPosition(pos);\n-                        npc.setCy(pos.y);\n-                        npc.setRx0(pos.x + 50);\n-                        npc.setRx1(pos.x - 50);\n-                        npc.setFh(map.getFootholds().findBelow(pos).getId());\n-                        map.addMapObject(npc);\n-                        map.broadcastMessage(MaplePacketCreator.spawnNPC(npc));\n-                }\n+        mapIds.add(mapid);\n+        return getMapFactory().getMap(mapid);\n+    }\n+\n+    public final boolean disposeIfPlayerBelow(final byte size, final int towarp) {\n+        if (disposed) {\n+            return true;\n+        }\n+        if (chars == null) {\n+            return false;\n+        }\n+\n+        MapleMap map = null;\n+        if (towarp > 0) {\n+            map = this.getMapFactory().getMap(towarp);\n         }\n-        \n-        public void dispatchUpdateQuestMobCount(int mobid, int mapid) {\n-            Map<Integer, MapleCharacter> mapChars = getInstanceMap(mapid).getMapPlayers();\n-            if(!mapChars.isEmpty()) {\n-                List<MapleCharacter> eventMembers = getPlayers();\n-                \n-                for (MapleCharacter evChr : eventMembers) {\n-                    MapleCharacter chr = mapChars.get(evChr.getId());\n-\n-                    if(chr != null && chr.isLoggedinWorld()) {\n-                        chr.updateQuestMobCount(mobid);\n+\n+        List<MapleCharacter> players = getPlayerList();\n+\n+        try {\n+            if (players.size() < size) {\n+                for (MapleCharacter chr : players) {\n+                    if (chr == null) {\n+                        continue;\n+                    }\n+\n+                    unregisterPlayer(chr);\n+                    if (towarp > 0) {\n+                        chr.changeMap(map, map.getPortal(0));\n                     }\n                 }\n+\n+                dispose();\n+                return true;\n             }\n+        } catch (Exception ex) {\n+            ex.printStackTrace();\n         }\n-        \n-        public MapleMonster getMonster(int mid) {\n-                return(MapleLifeFactory.getMonster(mid));\n-        }\n-        \n-        private List<Integer> convertToIntegerArray(List<Double> list) {\n-            List<Integer> intList;\n-            if(ServerConstants.JAVA_8)\n-                 intList=new ArrayList<Integer> (new ArrayList(java.util.Arrays.asList(list.toArray())));\n-            else\n-            {\n-                 intList = new ArrayList<>();\n-                for(Double d: list) intList.add(d.intValue());\n-            }\n-                return intList;\n-        }\n-        \n-        public void setEventClearStageExp(List<Double> gain) {\n-                onMapClearExp.clear();\n-                onMapClearExp.addAll(convertToIntegerArray(gain));\n-        }\n-        \n-        public void setEventClearStageMeso(List<Double> gain) {\n-                onMapClearMeso.clear();\n-                onMapClearMeso.addAll(convertToIntegerArray(gain));\n-        }\n-        \n-        public Integer getClearStageExp(int stage) {    //stage counts from ONE.\n-                if(stage > onMapClearExp.size()) return 0;\n-                return onMapClearExp.get(stage - 1);\n-        }\n-        \n-        public Integer getClearStageMeso(int stage) {   //stage counts from ONE.\n-                if(stage > onMapClearMeso.size()) return 0;\n-                return onMapClearMeso.get(stage - 1);\n-        }\n-        \n-        public List<Integer> getClearStageBonus(int stage) {\n-                List<Integer> list = new ArrayList<>();\n-                list.add(getClearStageExp(stage));\n-                list.add(getClearStageMeso(stage));\n-                \n-                return list;\n-        }\n-        \n-        private void dropExclusiveItems(MapleCharacter chr) {\n-                AbstractPlayerInteraction api = chr.getClient().getAbstractPlayerInteraction();\n-                \n-                for(Integer item: exclusiveItems) {\n-                        api.removeAll(item);\n+\n+        return false;\n+    }\n+\n+    public void spawnNpc(int npcId, Point pos, MapleMap map) {\n+        MapleNPC npc = MapleLifeFactory.getNPC(npcId);\n+        if (npc != null) {\n+            npc.setPosition(pos);\n+            npc.setCy(pos.y);\n+            npc.setRx0(pos.x + 50);\n+            npc.setRx1(pos.x - 50);\n+            npc.setFh(map.getFootholds().findBelow(pos).getId());\n+            map.addMapObject(npc);\n+            map.broadcastMessage(MaplePacketCreator.spawnNPC(npc));\n+        }\n+    }\n+\n+    public void dispatchUpdateQuestMobCount(int mobid, int mapid) {\n+        Map<Integer, MapleCharacter> mapChars = getInstanceMap(mapid).getMapPlayers();\n+        if (!mapChars.isEmpty()) {\n+            List<MapleCharacter> eventMembers = getPlayers();\n+\n+            for (MapleCharacter evChr : eventMembers) {\n+                MapleCharacter chr = mapChars.get(evChr.getId());\n+\n+                if (chr != null && chr.isLoggedinWorld()) {\n+                    chr.updateQuestMobCount(mobid);\n                 }\n+            }\n         }\n-        \n-        public final void setExclusiveItems(List<Double> items) {\n-                List<Integer> exclusive = convertToIntegerArray(items);\n-                \n-                wL.lock();\n-                try {\n-                        for(Integer item: exclusive) {\n-                                exclusiveItems.add(item);\n-                        }\n-                } finally {\n-                        wL.unlock();\n-                }\n+    }\n+\n+    public MapleMonster getMonster(int mid) {\n+        return (MapleLifeFactory.getMonster(mid));\n+    }\n+\n+    private List<Integer> convertToIntegerArray(List<Double> list) {\n+        List<Integer> intList;\n+        if (ServerConstants.JAVA_8) {\n+            intList = new ArrayList<Integer>(new ArrayList(java.util.Arrays.asList(list.toArray())));\n+        } else {\n+            intList = new ArrayList<>();\n+            for (Double d : list) {\n+                intList.add(d.intValue());\n+            }\n         }\n-        \n-        public final void setEventRewards(List<Double> rwds, List<Double> qtys, int expGiven) {\n-                setEventRewards(1, rwds, qtys, expGiven);\n+        return intList;\n+    }\n+\n+    public void setEventClearStageExp(List<Double> gain) {\n+        onMapClearExp.clear();\n+        onMapClearExp.addAll(convertToIntegerArray(gain));\n+    }\n+\n+    public void setEventClearStageMeso(List<Double> gain) {\n+        onMapClearMeso.clear();\n+        onMapClearMeso.addAll(convertToIntegerArray(gain));\n+    }\n+\n+    public Integer getClearStageExp(int stage) {    //stage counts from ONE.\n+        if (stage > onMapClearExp.size()) {\n+            return 0;\n+        }\n+        return onMapClearExp.get(stage - 1);\n+    }\n+\n+    public Integer getClearStageMeso(int stage) {   //stage counts from ONE.\n+        if (stage > onMapClearMeso.size()) {\n+            return 0;\n         }\n-        \n-        public final void setEventRewards(List<Double> rwds, List<Double> qtys) {\n-                setEventRewards(1, rwds, qtys);\n+        return onMapClearMeso.get(stage - 1);\n+    }\n+\n+    public List<Integer> getClearStageBonus(int stage) {\n+        List<Integer> list = new ArrayList<>();\n+        list.add(getClearStageExp(stage));\n+        list.add(getClearStageMeso(stage));\n+\n+        return list;\n+    }\n+\n+    private void dropExclusiveItems(MapleCharacter chr) {\n+        AbstractPlayerInteraction api = chr.getClient().getAbstractPlayerInteraction();\n+\n+        for (Integer item : exclusiveItems) {\n+            api.removeAll(item);\n         }\n-        \n-        public final void setEventRewards(int eventLevel, List<Double> rwds, List<Double> qtys) {\n-                setEventRewards(eventLevel, rwds, qtys, 0);\n+    }\n+\n+    public final void setExclusiveItems(List<Double> items) {\n+        List<Integer> exclusive = convertToIntegerArray(items);\n+\n+        wL.lock();\n+        try {\n+            for (Integer item : exclusive) {\n+                exclusiveItems.add(item);\n+            }\n+        } finally {\n+            wL.unlock();\n         }\n-        \n-        public final void setEventRewards(int eventLevel, List<Double> rwds, List<Double> qtys, int expGiven) {\n-                // fixed EXP will be rewarded at the same time the random item is given\n+    }\n \n-                if(eventLevel <= 0 || eventLevel > ServerConstants.MAX_EVENT_LEVELS) return;\n-                eventLevel--;    //event level starts from 1\n+    public final void setEventRewards(List<Double> rwds, List<Double> qtys, int expGiven) {\n+        setEventRewards(1, rwds, qtys, expGiven);\n+    }\n \n-                List<Integer> rewardIds = convertToIntegerArray(rwds);\n-                List<Integer> rewardQtys = convertToIntegerArray(qtys);\n+    public final void setEventRewards(List<Double> rwds, List<Double> qtys) {\n+        setEventRewards(1, rwds, qtys);\n+    }\n \n-                //rewardsSet and rewardsQty hold temporary values\n-                wL.lock();\n-                try {\n-                        collectionSet.put(eventLevel, rewardIds);\n-                        collectionQty.put(eventLevel, rewardQtys);\n-                        collectionExp.put(eventLevel, expGiven);\n-                } finally {\n-                        wL.unlock();\n-                }\n+    public final void setEventRewards(int eventLevel, List<Double> rwds, List<Double> qtys) {\n+        setEventRewards(eventLevel, rwds, qtys, 0);\n+    }\n+\n+    public final void setEventRewards(int eventLevel, List<Double> rwds, List<Double> qtys, int expGiven) {\n+        // fixed EXP will be rewarded at the same time the random item is given\n+\n+        if (eventLevel <= 0 || eventLevel > ServerConstants.MAX_EVENT_LEVELS) {\n+            return;\n         }\n-        \n-        private byte getRewardListRequirements(int level) {\n-                if(level >= collectionSet.size()) return 0;\n+        eventLevel--;    //event level starts from 1\n \n-                byte rewardTypes = 0;\n-                List<Integer> list = collectionSet.get(level);\n+        List<Integer> rewardIds = convertToIntegerArray(rwds);\n+        List<Integer> rewardQtys = convertToIntegerArray(qtys);\n \n-                for (Integer itemId : list) {\n-                        rewardTypes |= (1 << ItemConstants.getInventoryType(itemId).getType());\n-                }\n+        //rewardsSet and rewardsQty hold temporary values\n+        wL.lock();\n+        try {\n+            collectionSet.put(eventLevel, rewardIds);\n+            collectionQty.put(eventLevel, rewardQtys);\n+            collectionExp.put(eventLevel, expGiven);\n+        } finally {\n+            wL.unlock();\n+        }\n+    }\n \n-                return rewardTypes;\n+    private byte getRewardListRequirements(int level) {\n+        if (level >= collectionSet.size()) {\n+            return 0;\n         }\n-        \n-        private boolean hasRewardSlot(MapleCharacter player, int eventLevel) {\n-                byte listReq = getRewardListRequirements(eventLevel);   //gets all types of items present in the event reward list\n \n-                //iterating over all valid inventory types\n-                for(byte type = 1; type <= 5; type++) {\n-                        if((listReq >> type) % 2 == 1 && !player.hasEmptySlot(type))\n-                                return false;\n-                }\n+        byte rewardTypes = 0;\n+        List<Integer> list = collectionSet.get(level);\n \n-                return true;\n+        for (Integer itemId : list) {\n+            rewardTypes |= (1 << ItemConstants.getInventoryType(itemId).getType());\n         }\n-        \n-        public final boolean giveEventReward(MapleCharacter player) {\n-                return giveEventReward(player, 1);\n-        }\n-        \n-        //gives out EXP & a random item in a similar fashion of when clearing KPQ, LPQ, etc.\n-        public final boolean giveEventReward(MapleCharacter player, int eventLevel) {\n-                List<Integer> rewardsSet, rewardsQty;\n-                Integer rewardExp;\n-            \n-                rL.lock();\n-                try {\n-                        eventLevel--;       //event level starts counting from 1\n-                        if(eventLevel >= collectionSet.size()) return true;\n \n-                        rewardsSet = collectionSet.get(eventLevel);\n-                        rewardsQty = collectionQty.get(eventLevel);\n+        return rewardTypes;\n+    }\n \n-                        rewardExp = collectionExp.get(eventLevel);\n-                } finally {\n-                        rL.unlock();\n-                }\n-                        \n-                if(rewardExp == null) rewardExp = 0;\n+    private boolean hasRewardSlot(MapleCharacter player, int eventLevel) {\n+        byte listReq = getRewardListRequirements(eventLevel);   //gets all types of items present in the event reward list\n \n-                if(rewardsSet == null || rewardsSet.isEmpty()) {\n-                        if(rewardExp > 0) player.gainExp(rewardExp);\n-                        return true;\n-                }\n+        //iterating over all valid inventory types\n+        for (byte type = 1; type <= 5; type++) {\n+            if ((listReq >> type) % 2 == 1 && !player.hasEmptySlot(type)) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n \n-                if(!hasRewardSlot(player, eventLevel)) return false;\n+    public final boolean giveEventReward(MapleCharacter player) {\n+        return giveEventReward(player, 1);\n+    }\n \n-                AbstractPlayerInteraction api = player.getClient().getAbstractPlayerInteraction();\n-                int rnd = (int)Math.floor(Math.random() * rewardsSet.size());\n+    //gives out EXP & a random item in a similar fashion of when clearing KPQ, LPQ, etc.\n+    public final boolean giveEventReward(MapleCharacter player, int eventLevel) {\n+        List<Integer> rewardsSet, rewardsQty;\n+        Integer rewardExp;\n \n-                api.gainItem(rewardsSet.get(rnd), rewardsQty.get(rnd).shortValue());\n-                if(rewardExp > 0) player.gainExp(rewardExp);\n+        rL.lock();\n+        try {\n+            eventLevel--;       //event level starts counting from 1\n+            if (eventLevel >= collectionSet.size()) {\n                 return true;\n+            }\n+\n+            rewardsSet = collectionSet.get(eventLevel);\n+            rewardsQty = collectionQty.get(eventLevel);\n+\n+            rewardExp = collectionExp.get(eventLevel);\n+        } finally {\n+            rL.unlock();\n         }\n-        \n-        private void disposeExpedition() {\n-                if (expedition != null) {\n-                        expedition.dispose(eventCleared);\n-                        \n-                        sL.lock();\n-                        try {\n-                                em.getChannelServer().getExpeditions().remove(expedition);\n-                        } finally {\n-                                sL.unlock();\n-                        }\n-                        \n-                        expedition = null;\n-                }\n+\n+        if (rewardExp == null) {\n+            rewardExp = 0;\n         }\n-        \n-        public final synchronized void startEvent() {\n-                eventStarted = true;\n-                \n-                try {\n-                        em.getIv().invokeFunction(\"afterSetup\", EventInstanceManager.this);\n-                } catch (ScriptException | NoSuchMethodException ex) {\n-                        ex.printStackTrace();\n-                }\n+\n+        if (rewardsSet == null || rewardsSet.isEmpty()) {\n+            if (rewardExp > 0) {\n+                player.gainExp(rewardExp);\n+            }\n+            return true;\n         }\n-        \n-        public final void setEventCleared() {\n-                eventCleared = true;\n-                \n-                for (MapleCharacter chr : getPlayers()) {\n-                        chr.awardQuestPoint(ServerConstants.QUEST_POINT_PER_EVENT_CLEAR);\n-                }\n-                \n-                sL.lock();\n-                try {\n-                        em.disposeInstance(name);\n-                } finally {\n-                        sL.unlock();\n-                }\n-                \n-                disposeExpedition();\n+\n+        if (!hasRewardSlot(player, eventLevel)) {\n+            return false;\n         }\n-        \n-        public final boolean isEventCleared() {\n-                return eventCleared;\n+\n+        AbstractPlayerInteraction api = player.getClient().getAbstractPlayerInteraction();\n+        int rnd = (int) Math.floor(Math.random() * rewardsSet.size());\n+\n+        api.gainItem(rewardsSet.get(rnd), rewardsQty.get(rnd).shortValue());\n+        if (rewardExp > 0) {\n+            player.gainExp(rewardExp);\n         }\n-        \n-        public final boolean isEventDisposed() {\n-                return disposed;\n+        return true;\n+    }\n+\n+    private void disposeExpedition() {\n+        if (expedition != null) {\n+            expedition.dispose(eventCleared);\n+\n+            sL.lock();\n+            try {\n+                em.getChannelServer().getExpeditions().remove(expedition);\n+            } finally {\n+                sL.unlock();\n+            }\n+\n+            expedition = null;\n         }\n-        \n-        private boolean isEventTeamLeaderOn() {\n-                for(MapleCharacter chr: getPlayers()) {\n-                        if(chr.getId() == getLeaderId()) return true;\n-                }\n-                \n-                return false;\n+    }\n+\n+    public final synchronized void startEvent() {\n+        eventStarted = true;\n+\n+        try {\n+            em.getIv().invokeFunction(\"afterSetup\", EventInstanceManager.this);\n+        } catch (ScriptException | NoSuchMethodException ex) {\n+            ex.printStackTrace();\n         }\n-        \n-        public final boolean checkEventTeamLacking(boolean leavingEventMap, int minPlayers) {\n-                if(eventCleared && getPlayerCount() > 1) return false;\n-                \n-                if(!eventCleared && leavingEventMap && !isEventTeamLeaderOn()) return true;\n-                if(getPlayerCount() < minPlayers) return true;\n-                \n-                return false;\n+    }\n+\n+    public final void setEventCleared() {\n+        eventCleared = true;\n+\n+        for (MapleCharacter chr : getPlayers()) {\n+            chr.awardQuestPoint(ServerConstants.QUEST_POINT_PER_EVENT_CLEAR);\n         }\n-        \n-        public final boolean isExpeditionTeamLackingNow(boolean leavingEventMap, int minPlayers, MapleCharacter quitter) {\n-                if(eventCleared) {\n-                        if(leavingEventMap && getPlayerCount() <= 1) return true;\n-                } else {\n-                        if(leavingEventMap && getLeaderId() == quitter.getId()) return true;\n-                        if(getPlayerCount() <= (ServerConstants.USE_ENABLE_SOLO_EXPEDITIONS ? 1 : minPlayers)) return true;\n-                }\n-                \n-                return false;\n+\n+        sL.lock();\n+        try {\n+            em.disposeInstance(name);\n+        } finally {\n+            sL.unlock();\n         }\n-        \n-        public final boolean isEventTeamLackingNow(boolean leavingEventMap, int minPlayers, MapleCharacter quitter) {\n-                if(eventCleared) {\n-                        if(leavingEventMap && getPlayerCount() <= 1) return true;\n-                } else {\n-                        if(leavingEventMap && getLeaderId() == quitter.getId()) return true;\n-                        if(getPlayerCount() <= minPlayers) return true;\n-                }\n-                \n-                return false;\n+\n+        disposeExpedition();\n+    }\n+\n+    public final boolean isEventCleared() {\n+        return eventCleared;\n+    }\n+\n+    public final boolean isEventDisposed() {\n+        return disposed;\n+    }\n+\n+    private boolean isEventTeamLeaderOn() {\n+        for (MapleCharacter chr : getPlayers()) {\n+            if (chr.getId() == getLeaderId()) {\n+                return true;\n+            }\n         }\n-        \n-        public final boolean isEventTeamTogether() {\n-                rL.lock();\n-                try {\n-                        if(chars.size() <= 1) return true;\n-                        \n-                        Iterator<MapleCharacter> iterator = chars.values().iterator();\n-                        MapleCharacter mc = iterator.next();\n-                        int mapId = mc.getMapId();\n-                        \n-                        for (; iterator.hasNext();) {\n-                                mc = iterator.next();\n-                                if(mc.getMapId() != mapId) return false;\n-                        }\n-                        \n-                        return true;\n-                } finally {\n-                        rL.unlock();\n-                }\n+\n+        return false;\n+    }\n+\n+    public final boolean checkEventTeamLacking(boolean leavingEventMap, int minPlayers) {\n+        if (eventCleared && getPlayerCount() > 1) {\n+            return false;\n         }\n-        \n-        public final void warpEventTeam(int warpFrom, int warpTo) {\n-                List<MapleCharacter> players = getPlayerList();\n-                \n-                for (MapleCharacter chr : players) {\n-                        if(chr.getMapId() == warpFrom)\n-                                chr.changeMap(warpTo);\n-                }\n+\n+        if (!eventCleared && leavingEventMap && !isEventTeamLeaderOn()) {\n+            return true;\n         }\n-        \n-        public final void warpEventTeam(int warpTo) {\n-                List<MapleCharacter> players = getPlayerList();\n-                \n-                for (MapleCharacter chr : players) {\n-                        chr.changeMap(warpTo);\n-                }\n+        if (getPlayerCount() < minPlayers) {\n+            return true;\n         }\n-        \n-        public final void warpEventTeamToMapSpawnPoint(int warpFrom, int warpTo, int toSp) {\n-                List<MapleCharacter> players = getPlayerList();\n-                \n-                for (MapleCharacter chr : players) {\n-                        if(chr.getMapId() == warpFrom)\n-                                chr.changeMap(warpTo, toSp);\n-                }\n+\n+        return false;\n+    }\n+\n+    public final boolean isExpeditionTeamLackingNow(boolean leavingEventMap, int minPlayers, MapleCharacter quitter) {\n+        if (eventCleared) {\n+            if (leavingEventMap && getPlayerCount() <= 1) {\n+                return true;\n+            }\n+        } else {\n+            if (leavingEventMap && getLeaderId() == quitter.getId()) {\n+                return true;\n+            }\n+            if (getPlayerCount() <= (ServerConstants.USE_ENABLE_SOLO_EXPEDITIONS ? 1 : minPlayers)) {\n+                return true;\n+            }\n         }\n-        \n-        public final void warpEventTeamToMapSpawnPoint(int warpTo, int toSp) {\n-                List<MapleCharacter> players = getPlayerList();\n-                \n-                for (MapleCharacter chr : players) {\n-                        chr.changeMap(warpTo, toSp);\n-                }\n+\n+        return false;\n+    }\n+\n+    public final boolean isEventTeamLackingNow(boolean leavingEventMap, int minPlayers, MapleCharacter quitter) {\n+        if (eventCleared) {\n+            if (leavingEventMap && getPlayerCount() <= 1) {\n+                return true;\n+            }\n+        } else {\n+            if (leavingEventMap && getLeaderId() == quitter.getId()) {\n+                return true;\n+            }\n+            if (getPlayerCount() <= minPlayers) {\n+                return true;\n+            }\n         }\n-        \n-        public final int getLeaderId() {\n-                rL.lock();\n-                try {\n-                        return leaderId;\n-                } finally {\n-                        rL.unlock();\n+\n+        return false;\n+    }\n+\n+    public final boolean isEventTeamTogether() {\n+        rL.lock();\n+        try {\n+            if (chars.size() <= 1) {\n+                return true;\n+            }\n+\n+            Iterator<MapleCharacter> iterator = chars.values().iterator();\n+            MapleCharacter mc = iterator.next();\n+            int mapId = mc.getMapId();\n+\n+            for (; iterator.hasNext();) {\n+                mc = iterator.next();\n+                if (mc.getMapId() != mapId) {\n+                    return false;\n                 }\n+            }\n+\n+            return true;\n+        } finally {\n+            rL.unlock();\n         }\n-        \n-        public MapleCharacter getLeader() {\n-                rL.lock();\n-                try {\n-                        return chars.get(leaderId);\n-                } finally {\n-                        rL.unlock();\n-                }\n+    }\n+\n+    public final void warpEventTeam(int warpFrom, int warpTo) {\n+        List<MapleCharacter> players = getPlayerList();\n+\n+        for (MapleCharacter chr : players) {\n+            if (chr.getMapId() == warpFrom) {\n+                chr.changeMap(warpTo);\n+            }\n         }\n-        \n-        public final void setLeader(MapleCharacter chr) {\n-                wL.lock();\n-                try {\n-                        leaderId = chr.getId();\n-                } finally {\n-                        wL.unlock();\n-                }\n+    }\n+\n+    public final void warpEventTeam(int warpTo) {\n+        List<MapleCharacter> players = getPlayerList();\n+\n+        for (MapleCharacter chr : players) {\n+            chr.changeMap(warpTo);\n         }\n-        \n-        public final void showWrongEffect() {\n-                showWrongEffect(getLeader().getMapId());\n-        }\n-        \n-        public final void showWrongEffect(int mapId) {\n-                MapleMap map = getMapInstance(mapId);\n-                map.broadcastMessage(MaplePacketCreator.showEffect(\"quest/party/wrong_kor\"));\n-                map.broadcastMessage(MaplePacketCreator.playSound(\"Party1/Failed\"));\n-        }\n-        \n-        public final void showClearEffect() {\n-                showClearEffect(false);\n-        }\n-        \n-        public final void showClearEffect(boolean hasGate) {\n-                MapleCharacter leader = getLeader();\n-                if(leader != null) showClearEffect(hasGate, leader.getMapId());\n-        }\n-        \n-        public final void showClearEffect(int mapId) {\n-                showClearEffect(false, mapId);\n-        }\n-        \n-        public final void showClearEffect(boolean hasGate, int mapId) {\n-                showClearEffect(hasGate, mapId, \"gate\", 2);\n-        }\n-        \n-        public final void showClearEffect(int mapId, String mapObj, int newState) {\n-                showClearEffect(true, mapId, mapObj, newState);\n-        }\n-        \n-        public final void showClearEffect(boolean hasGate, int mapId, String mapObj, int newState) {\n-                MapleMap map = getMapInstance(mapId);\n-                map.broadcastMessage(MaplePacketCreator.showEffect(\"quest/party/clear\"));\n-                map.broadcastMessage(MaplePacketCreator.playSound(\"Party1/Clear\"));\n-                if(hasGate) {\n-                        map.broadcastMessage(MaplePacketCreator.environmentChange(mapObj, newState));\n-                        wL.lock();\n-                        try {\n-                                openedGates.put(map.getId(), new Pair<>(mapObj, newState));\n-                        } finally {\n-                                wL.unlock();\n-                        }\n-                }\n+    }\n+\n+    public final void warpEventTeamToMapSpawnPoint(int warpFrom, int warpTo, int toSp) {\n+        List<MapleCharacter> players = getPlayerList();\n+\n+        for (MapleCharacter chr : players) {\n+            if (chr.getMapId() == warpFrom) {\n+                chr.changeMap(warpTo, toSp);\n+            }\n         }\n-        \n-        public final void recoverOpenedGate(MapleCharacter chr, int thisMapId) {\n-                Pair<String, Integer> gateData = null;\n-            \n-                rL.lock();\n-                try {\n-                        if(openedGates.containsKey(thisMapId)) {\n-                                gateData = openedGates.get(thisMapId);\n-                        }\n-                } finally {\n-                        rL.unlock();\n-                }\n-                \n-                if(gateData != null) {\n-                        chr.announce(MaplePacketCreator.environmentChange(gateData.getLeft(), gateData.getRight()));\n-                }\n+    }\n+\n+    public final void warpEventTeamToMapSpawnPoint(int warpTo, int toSp) {\n+        List<MapleCharacter> players = getPlayerList();\n+\n+        for (MapleCharacter chr : players) {\n+            chr.changeMap(warpTo, toSp);\n         }\n-        \n-        public final void giveEventPlayersStageReward(int thisStage) {\n-                List<Integer> list = getClearStageBonus(thisStage);     // will give bonus exp & mesos to everyone in the event\n-                giveEventPlayersExp(list.get(0));\n-                giveEventPlayersMeso(list.get(1));\n-        }\n-        \n-        public final void linkToNextStage(int thisStage, String eventFamily, int thisMapId) {\n-                giveEventPlayersStageReward(thisStage);\n-                thisStage--;    //stages counts from ONE, scripts from ZERO\n-            \n-                MapleMap nextStage = getMapInstance(thisMapId);\n-                MaplePortal portal = nextStage.getPortal(\"next00\");\n-                if (portal != null) {\n-                        portal.setScriptName(eventFamily + thisStage);\n-                }\n+    }\n+\n+    public final int getLeaderId() {\n+        rL.lock();\n+        try {\n+            return leaderId;\n+        } finally {\n+            rL.unlock();\n+        }\n+    }\n+\n+    public MapleCharacter getLeader() {\n+        rL.lock();\n+        try {\n+            return chars.get(leaderId);\n+        } finally {\n+            rL.unlock();\n+        }\n+    }\n+\n+    public final void setLeader(MapleCharacter chr) {\n+        wL.lock();\n+        try {\n+            leaderId = chr.getId();\n+        } finally {\n+            wL.unlock();\n+        }\n+    }\n+\n+    public final void showWrongEffect() {\n+        showWrongEffect(getLeader().getMapId());\n+    }\n+\n+    public final void showWrongEffect(int mapId) {\n+        MapleMap map = getMapInstance(mapId);\n+        map.broadcastMessage(MaplePacketCreator.showEffect(\"quest/party/wrong_kor\"));\n+        map.broadcastMessage(MaplePacketCreator.playSound(\"Party1/Failed\"));\n+    }\n+\n+    public final void showClearEffect() {\n+        showClearEffect(false);\n+    }\n+\n+    public final void showClearEffect(boolean hasGate) {\n+        MapleCharacter leader = getLeader();\n+        if (leader != null) {\n+            showClearEffect(hasGate, leader.getMapId());\n         }\n-        \n-        public final void linkPortalToScript(int thisStage, String portalName, String scriptName, int thisMapId) {\n-                giveEventPlayersStageReward(thisStage);\n-                thisStage--;    //stages counts from ONE, scripts from ZERO\n-            \n-                MapleMap nextStage = getMapInstance(thisMapId);\n-                MaplePortal portal = nextStage.getPortal(portalName);\n-                if (portal != null) {\n-                        portal.setScriptName(scriptName);\n-                }\n+    }\n+\n+    public final void showClearEffect(int mapId) {\n+        showClearEffect(false, mapId);\n+    }\n+\n+    public final void showClearEffect(boolean hasGate, int mapId) {\n+        showClearEffect(hasGate, mapId, \"gate\", 2);\n+    }\n+\n+    public final void showClearEffect(int mapId, String mapObj, int newState) {\n+        showClearEffect(true, mapId, mapObj, newState);\n+    }\n+\n+    public final void showClearEffect(boolean hasGate, int mapId, String mapObj, int newState) {\n+        MapleMap map = getMapInstance(mapId);\n+        map.broadcastMessage(MaplePacketCreator.showEffect(\"quest/party/clear\"));\n+        map.broadcastMessage(MaplePacketCreator.playSound(\"Party1/Clear\"));\n+        if (hasGate) {\n+            map.broadcastMessage(MaplePacketCreator.environmentChange(mapObj, newState));\n+            wL.lock();\n+            try {\n+                openedGates.put(map.getId(), new Pair<>(mapObj, newState));\n+            } finally {\n+                wL.unlock();\n+            }\n         }\n-        \n-        // registers a player status in an event\n-        public final void gridInsert(MapleCharacter chr, int newStatus) {\n-                wL.lock();\n-                try {\n-                        playerGrid.put(chr.getId(), newStatus);\n-                } finally {\n-                        wL.unlock();\n-                }\n+    }\n+\n+    public final void recoverOpenedGate(MapleCharacter chr, int thisMapId) {\n+        Pair<String, Integer> gateData = null;\n+\n+        rL.lock();\n+        try {\n+            if (openedGates.containsKey(thisMapId)) {\n+                gateData = openedGates.get(thisMapId);\n+            }\n+        } finally {\n+            rL.unlock();\n         }\n-        \n-        // unregisters a player status in an event\n-        public final void gridRemove(MapleCharacter chr) {\n-                wL.lock();\n-                try {\n-                        playerGrid.remove(chr.getId());\n-                } finally {\n-                        wL.unlock();\n-                }\n+\n+        if (gateData != null) {\n+            chr.announce(MaplePacketCreator.environmentChange(gateData.getLeft(), gateData.getRight()));\n         }\n-        \n-        // checks a player status\n-        public final int gridCheck(MapleCharacter chr) {\n-                rL.lock();\n-                try {\n-                        Integer i = playerGrid.get(chr.getId());\n-                        return (i != null) ? i : -1;\n-                } finally {\n-                        rL.unlock();\n-                }\n+    }\n+\n+    public final void giveEventPlayersStageReward(int thisStage) {\n+        List<Integer> list = getClearStageBonus(thisStage);     // will give bonus exp & mesos to everyone in the event\n+        giveEventPlayersExp(list.get(0));\n+        giveEventPlayersMeso(list.get(1));\n+    }\n+\n+    public final void linkToNextStage(int thisStage, String eventFamily, int thisMapId) {\n+        giveEventPlayersStageReward(thisStage);\n+        thisStage--;    //stages counts from ONE, scripts from ZERO\n+\n+        MapleMap nextStage = getMapInstance(thisMapId);\n+        MaplePortal portal = nextStage.getPortal(\"next00\");\n+        if (portal != null) {\n+            portal.setScriptName(eventFamily + thisStage);\n         }\n-        \n-        public final int gridSize() {\n-                rL.lock();\n-                try {\n-                        return playerGrid.size();\n-                } finally {\n-                        rL.unlock();\n-                }\n+    }\n+\n+    public final void linkPortalToScript(int thisStage, String portalName, String scriptName, int thisMapId) {\n+        giveEventPlayersStageReward(thisStage);\n+        thisStage--;    //stages counts from ONE, scripts from ZERO\n+\n+        MapleMap nextStage = getMapInstance(thisMapId);\n+        MaplePortal portal = nextStage.getPortal(portalName);\n+        if (portal != null) {\n+            portal.setScriptName(scriptName);\n         }\n-        \n-        public final void gridClear() {\n-                wL.lock();\n-                try {\n-                        playerGrid.clear();\n-                } finally {\n-                        wL.unlock();\n-                }\n+    }\n+\n+    // registers a player status in an event\n+    public final void gridInsert(MapleCharacter chr, int newStatus) {\n+        wL.lock();\n+        try {\n+            playerGrid.put(chr.getId(), newStatus);\n+        } finally {\n+            wL.unlock();\n+        }\n+    }\n+\n+    // unregisters a player status in an event\n+    public final void gridRemove(MapleCharacter chr) {\n+        wL.lock();\n+        try {\n+            playerGrid.remove(chr.getId());\n+        } finally {\n+            wL.unlock();\n+        }\n+    }\n+\n+    // checks a player status\n+    public final int gridCheck(MapleCharacter chr) {\n+        rL.lock();\n+        try {\n+            Integer i = playerGrid.get(chr.getId());\n+            return (i != null) ? i : -1;\n+        } finally {\n+            rL.unlock();\n+        }\n+    }\n+\n+    public final int gridSize() {\n+        rL.lock();\n+        try {\n+            return playerGrid.size();\n+        } finally {\n+            rL.unlock();\n+        }\n+    }\n+\n+    public final void gridClear() {\n+        wL.lock();\n+        try {\n+            playerGrid.clear();\n+        } finally {\n+            wL.unlock();\n+        }\n+    }\n+\n+    public boolean activatedAllReactorsOnMap(int mapId, int minReactorId, int maxReactorId) {\n+        return activatedAllReactorsOnMap(this.getMapInstance(mapId), minReactorId, maxReactorId);\n+    }\n+\n+    public boolean activatedAllReactorsOnMap(MapleMap map, int minReactorId, int maxReactorId) {\n+        if (map == null) {\n+            return true;\n         }\n-        \n-        public boolean activatedAllReactorsOnMap(int mapId, int minReactorId, int maxReactorId) {\n-                return activatedAllReactorsOnMap(this.getMapInstance(mapId), minReactorId, maxReactorId);\n-        }\n-        \n-        public boolean activatedAllReactorsOnMap(MapleMap map, int minReactorId, int maxReactorId) {\n-                if(map == null) return true;\n-            \n-                for(MapleReactor mr : map.getReactorsByIdRange(minReactorId, maxReactorId)) {\n-                        if(mr.getReactorType() != -1) {\n-                                return false;\n-                        }\n-                }\n \n-                return true;\n+        for (MapleReactor mr : map.getReactorsByIdRange(minReactorId, maxReactorId)) {\n+            if (mr.getReactorType() != -1) {\n+                return false;\n+            }\n         }\n+\n+        return true;\n+    }\n }"}, {"sha": "6e013cc7f1e2c32fac9801d16412789404aaf6ea", "filename": "src/server/MapleItemInformationProvider.java", "status": "modified", "additions": 48, "deletions": 35, "changes": 83, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/server/MapleItemInformationProvider.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/server/MapleItemInformationProvider.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/MapleItemInformationProvider.java?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -116,6 +116,10 @@ public static MapleItemInformationProvider getInstance() {\n     protected Map<Integer, Boolean> karmaCache = new HashMap<>();\n     protected Map<Integer, Integer> triggerItemCache = new HashMap<>();\n     protected Map<Integer, Integer> expCache = new HashMap<>();\n+    protected Map<Integer, Integer> createItem = new HashMap<>();\n+    protected Map<Integer, Integer> mobItem = new HashMap<>();\n+    protected Map<Integer, Integer> useDelay = new HashMap<>();\n+    protected Map<Integer, Integer> mobHP = new HashMap<>();\n     protected Map<Integer, Integer> levelCache = new HashMap<>();\n     protected Map<Integer, Pair<Integer, List<RewardItem>>> rewardCache = new HashMap<>();\n     protected List<Pair<Integer, String>> itemNameCache = new ArrayList<>();\n@@ -150,40 +154,6 @@ private MapleItemInformationProvider() {\n         isPartyQuestItemCache.put(0, false);\n     }\n \n-//    public MapleInventoryType getInventoryType(int itemId) {\n-//        if (inventoryTypeCache.containsKey(itemId)) {\n-//            return inventoryTypeCache.get(itemId);\n-//        }\n-//        MapleInventoryType ret;\n-//        String idStr = \"0\" + String.valueOf(itemId);\n-//        MapleDataDirectoryEntry root = itemData.getRoot();\n-//        for (MapleDataDirectoryEntry topDir : root.getSubdirectories()) {\n-//            for (MapleDataFileEntry iFile : topDir.getFiles()) {\n-//                if (iFile.getName().equals(idStr.substring(0, 4) + \".img\")) {\n-//                    ret = MapleInventoryType.getByWZName(topDir.getName());\n-//                    inventoryTypeCache.put(itemId, ret);\n-//                    return ret;\n-//                } else if (iFile.getName().equals(idStr.substring(1) + \".img\")) {\n-//                    ret = MapleInventoryType.getByWZName(topDir.getName());\n-//                    inventoryTypeCache.put(itemId, ret);\n-//                    return ret;\n-//                }\n-//            }\n-//        }\n-//        root = equipData.getRoot();\n-//        for (MapleDataDirectoryEntry topDir : root.getSubdirectories()) {\n-//            for (MapleDataFileEntry iFile : topDir.getFiles()) {\n-//                if (iFile.getName().equals(idStr + \".img\")) {\n-//                    ret = MapleInventoryType.EQUIP;\n-//                    inventoryTypeCache.put(itemId, ret);\n-//                    return ret;\n-//                }\n-//            }\n-//        }\n-//        ret = MapleInventoryType.UNDEFINED;\n-//        inventoryTypeCache.put(itemId, ret);\n-//        return ret;\n-//    }\n \n     public List<Pair<Integer, String>> getAllItems() {\n         if (!itemNameCache.isEmpty()) {\n@@ -1176,7 +1146,10 @@ public MapleStatEffect getItemEffect(int itemId) {\n             if (item == null) {\n                 return null;\n             }\n-            MapleData spec = item.getChildByPath(\"spec\");\n+            MapleData spec = item.getChildByPath(\"specEx\");\n+            if (spec == null) {\n+                spec = item.getChildByPath(\"spec\");\n+            }\n             ret = MapleStatEffect.loadItemEffectFromData(spec, itemId);\n             itemEffects.put(Integer.valueOf(itemId), ret);\n         }\n@@ -1479,6 +1452,46 @@ public int getStateChangeItem(int itemId) {\n             return triggerItem;\n         }\n     }\n+    \n+    public int getCreatItem(int itemId) {\n+        if (createItem.containsKey(itemId)) {\n+            return createItem.get(itemId);\n+        } else {\n+            int itemFrom = MapleDataTool.getIntConvert(\"info/create\", getItemData(itemId), 0);\n+            createItem.put(itemId, itemFrom);\n+            return itemFrom;\n+        }\n+    }\n+    \n+    public int getMobItem(int itemId) {\n+        if (mobItem.containsKey(itemId)) {\n+            return mobItem.get(itemId);\n+        } else {\n+            int mobItemCatch = MapleDataTool.getIntConvert(\"info/mob\", getItemData(itemId), 0);\n+            mobItem.put(itemId, mobItemCatch);\n+            return mobItemCatch;\n+        }\n+    }\n+    \n+    public int getUseDelay(int itemId) {\n+        if (useDelay.containsKey(itemId)) {\n+            return useDelay.get(itemId);\n+        } else {\n+            int mobUseDelay = MapleDataTool.getIntConvert(\"info/useDelay\", getItemData(itemId), 0);\n+            useDelay.put(itemId, mobUseDelay);\n+            return mobUseDelay;\n+        }\n+    }\n+    \n+    public int getMobHP(int itemId) {\n+        if (mobHP.containsKey(itemId)) {\n+            return mobHP.get(itemId);\n+        } else {\n+            int mobHPItem = MapleDataTool.getIntConvert(\"info/mobHP\", getItemData(itemId), 0);\n+            mobHP.put(itemId, mobHPItem);\n+            return mobHPItem;\n+        }\n+    }\n \n     public int getExpById(int itemId) {\n         if (expCache.containsKey(itemId)) {"}, {"sha": "aab3d17dbbbdc72860a4e15397796b1811f63758", "filename": "src/server/MapleStatEffect.java", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/server/MapleStatEffect.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/server/MapleStatEffect.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/MapleStatEffect.java?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -125,10 +125,10 @@\n     private short watk, matk, wdef, mdef, acc, avoid, speed, jump;\n     private short hp, mp;\n     private double hpR, mpR;\n-    private short mhpRRate, mmpRRate;\n+    private short mhpRRate, mmpRRate, mobSkill, mobSkillLevel;\n     private byte mhpR, mmpR;\n     private short mpCon, hpCon;\n-    private int duration;\n+    private int duration, target, barrier, mob;\n     private boolean overTime, repeatEffect;\n     private int sourceid;\n     private int moveTo;\n@@ -208,6 +208,24 @@ private static MapleStatEffect loadFromData(MapleData source, int sourceid, bool\n         ret.fatigue = MapleDataTool.getInt(\"incFatigue\", source, 0);\n         ret.repeatEffect = MapleDataTool.getInt(\"repeatEffect\", source, 0) > 0;\n \n+        MapleData mdd = source.getChildByPath(\"0\");\n+        if (mdd != null && mdd.getChildren().size() > 0) {\n+            ret.mobSkill = (short) MapleDataTool.getInt(\"mobSkill\", mdd, 0);\n+            ret.mobSkillLevel = (short) MapleDataTool.getInt(\"level\", mdd, 0);\n+            ret.target = MapleDataTool.getInt(\"target\", mdd, 0);\n+        } else {\n+            ret.mobSkill = 0;\n+            ret.mobSkillLevel = 0;\n+            ret.target = 0;\n+        }\n+        ret.barrier = MapleDataTool.getInt(\"barrier\", source, 0);\n+        \n+        MapleData mdds = source.getChildByPath(\"mob\");\n+        if (mdds != null) {\n+            if (mdds.getChildren()!= null && mdds.getChildren().size() > 0) {\n+                ret.mob = MapleDataTool.getInt(\"mob\", mdds, 0);\n+            }\n+        }\n         ret.sourceid = sourceid;\n         ret.skill = skill;\n         if (!ret.skill && ret.duration > -1) {\n@@ -228,8 +246,15 @@ private static MapleStatEffect loadFromData(MapleData source, int sourceid, bool\n         ret.speed = (short) MapleDataTool.getInt(\"speed\", source, 0);\n         ret.jump = (short) MapleDataTool.getInt(\"jump\", source, 0);\n \n+        \n+        if (MapleDataTool.getInt(\"barrier\", source, 0) > 0) {\n+            ret.barrier = MapleDataTool.getInt(\"barrier\", source, 0);\n+            addBuffStatPairToListIfNotZero(statups, MapleBuffStat.ARIANT_PQ_SHIELD, Integer.valueOf(1));\n+        }\n+        \n         ret.mapProtection = mapProtection(sourceid);\n         addBuffStatPairToListIfNotZero(statups, MapleBuffStat.MAP_PROTECTION, Integer.valueOf(ret.mapProtection));\n+        \n \n         if (ret.overTime && ret.getSummonMovementType() == null) {\n             if (!skill) {\n@@ -974,8 +999,19 @@ private boolean applyTo(MapleCharacter applyfrom, MapleCharacter applyto, boolea\n                     applyfrom.dispelDebuff(debuff);\n                 }\n             }\n+        } else if (mobSkill > 0 && mobSkillLevel > 0) {\n+            if (target > 0) {\n+                for (MapleCharacter chr : applyto.getMap().getAllPlayers()) {\n+                    if (chr.getId() != applyto.getId()) {\n+                        chr.disease(mobSkill, mobSkillLevel);\n+                    }\n+                }\n+            } else {\n+                applyto.disease(mobSkill, mobSkillLevel);\n+            }\n+        } else if (barrier > 0) {\n+            applyto.shield();\n         }\n-\n         return true;\n     }\n \n@@ -1195,7 +1231,6 @@ private void applyBuffEffect(MapleCharacter applyfrom, MapleCharacter applyto, b\n \n                     localstatups = statups;\n                 }\n-\n                 buff = MaplePacketCreator.giveBuff(localsourceid, localDuration, localstatups);\n                 mbuff = MaplePacketCreator.showMonsterRiding(applyto.getId(), givemount);\n                 localDuration = duration;"}, {"sha": "cce3e8eab0b9aa6311fab70bd3588c75245e45db", "filename": "src/server/expeditions/MapleExpedition.java", "status": "modified", "additions": 298, "deletions": 245, "changes": 543, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/server/expeditions/MapleExpedition.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/server/expeditions/MapleExpedition.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/expeditions/MapleExpedition.java?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -1,25 +1,3 @@\n-/*\n-\tThis file is part of the OdinMS Maple Story Server\n-    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n-\t\t       Matthias Butz <matze@odinms.de>\n-\t\t       Jan Christian Meyer <vimes@odinms.de>\n-\n-    This program is free software: you can redistribute it and/or modify\n-    it under the terms of the GNU Affero General Public License as\n-    published by the Free Software Foundation version 3 as published by\n-    the Free Software Foundation. You may not use, modify or distribute\n-    this program under any other version of the GNU Affero General Public\n-    License.\n-\n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU Affero General Public License for more details.\n-\n-    You should have received a copy of the GNU Affero General Public License\n-    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n package server.expeditions;\n \n import java.text.SimpleDateFormat;\n@@ -41,243 +19,318 @@\n import tools.LogHelper;\n import tools.MaplePacketCreator;\n import client.MapleCharacter;\n+import java.util.Properties;\n+import net.server.audit.locks.MonitoredLockType;\n+import net.server.audit.locks.MonitoredReentrantLock;\n+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;\n \n /**\n  *\n  * @author Alan (SharpAceX)\n  */\n public class MapleExpedition {\n \n-\tprivate static final int [] EXPEDITION_BOSSES = {\n-\t\t\t8800000,// - Zakum's first body\n-\t\t\t8800001,// - Zakum's second body\n-\t\t\t8800002,// - Zakum's third body\n-\t\t\t8800003,// - Zakum's Arm 1\n-\t\t\t8800004,// - Zakum's Arm 2\n-\t\t\t8800005,// - Zakum's Arm 3\n-\t\t\t8800006,// - Zakum's Arm 4\n-\t\t\t8800007,// - Zakum's Arm 5\n-\t\t\t8800008,// - Zakum's Arm 6\n-\t\t\t8800009,// - Zakum's Arm 7\n-\t\t\t8800010,// - Zakum's Arm 8\n-\t\t\t8810000,// - Horntail's Left Head\n-\t\t\t8810001,// - Horntail's Right Head\n-\t\t\t8810002,// - Horntail's Head A\n-\t\t\t8810003,// - Horntail's Head B\n-\t\t\t8810004,// - Horntail's Head C\n-\t\t\t8810005,// - Horntail's Left Hand\n-\t\t\t8810006,// - Horntail's Right Hand\n-\t\t\t8810007,// - Horntail's Wings\n-\t\t\t8810008,// - Horntail's Legs\n-\t\t\t8810009,// - Horntail's Tails\n-\t\t\t9420546,// - Scarlion Boss\n-\t\t\t9420547,// - Scarlion Boss\n-\t\t\t9420548,// - Angry Scarlion Boss\n-\t\t\t9420549,// - Furious Scarlion Boss\n-\t\t\t9420541,// - Targa\n-\t\t\t9420542,// - Targa\n-\t\t\t9420543,// - Angry Targa\n-\t\t\t9420544,// - Furious Targa\n-\t};\n-\t\n-\tprivate MapleCharacter leader;\n-\tprivate MapleExpeditionType type;\n-\tprivate boolean registering;\n-\tprivate MapleMap startMap;\n-\tprivate List<String> bossLogs;\n-\tprivate ScheduledFuture<?> schedule;\n-\tprivate Map<Integer, String> members = new ConcurrentHashMap<>();\n-\tprivate List<Integer> banned = new CopyOnWriteArrayList<>();\n-\tprivate long startTime;\n-\n-\tpublic MapleExpedition(MapleCharacter player, MapleExpeditionType met) {\n-\t\tleader = player;\n-\t\tmembers.put(player.getId(), player.getName());\n-                startMap = player.getMap();\n-\t\ttype = met;\n-\t\tbossLogs = new CopyOnWriteArrayList<>();\n-\t\tbeginRegistration();\n-\t}\n-\n-\tprivate void beginRegistration() {\n-\t\tregistering = true;\n-                leader.announce(MaplePacketCreator.getClock(type.getRegistrationTime() * 60));\n-\t\tstartMap.broadcastMessage(leader, MaplePacketCreator.serverNotice(6, \"[Expedition] \" + leader.getName() + \" has been declared the expedition captain. Please register for the expedition.\"), false);\n-                leader.announce(MaplePacketCreator.serverNotice(6, \"[Expedition] You have become the expedition captain. Gather enough people for your team then talk to the NPC to start.\"));\n-\t\tscheduleRegistrationEnd();\n-\t}\n-\n-\tprivate void scheduleRegistrationEnd() {\n-\t\tfinal MapleExpedition exped = this;\n-                startTime = System.currentTimeMillis() + type.getRegistrationTime() * 60 * 1000;\n-                \n-\t\tschedule = TimerManager.getInstance().schedule(new Runnable() { \n-\t\t\t@Override\n-\t\t\tpublic void run() {\n-\t\t\t\tif (registering){\n-                                        startMap.getChannelServer().getExpeditions().remove(exped);\n-\t\t\t\t\tstartMap.broadcastMessage(MaplePacketCreator.serverNotice(6, \"[Expedition] The time limit has been reached. Expedition has been disbanded.\"));\n-                                        \n-                                        dispose(false);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}, type.getRegistrationTime() * 60 * 1000);\n-\t}\n-\n-\tpublic void dispose(boolean log){\n-                broadcastExped(MaplePacketCreator.removeClock());\n-            \n-                if (schedule != null){\n-\t\t\tschedule.cancel(false);\n-\t\t}\n-\t\tif (log && !registering){\n-\t\t\tLogHelper.logExpedition(this);\n-\t\t}\n-\t}\n-\n-\tpublic void start(){\n-\t\tregistering = false;\n-\t\tbroadcastExped(MaplePacketCreator.removeClock());\n-\t\tbroadcastExped(MaplePacketCreator.serverNotice(6, \"[Expedition] The expedition has started! Good luck, brave heroes!\"));\n-\t\tstartTime = System.currentTimeMillis();\n-\t\tServer.getInstance().broadcastGMMessage(startMap.getWorld(), MaplePacketCreator.serverNotice(6, \"[Expedition] \" + type.toString() + \" Expedition started with leader: \" + leader.getName()));\n-\t}\n-\n-\tpublic String addMember(MapleCharacter player) {\n-\t\tif (!registering){\n-\t\t\treturn \"Sorry, this expedition is already underway. Registration is closed!\";\n-\t\t}\n-\t\tif (banned.contains(player.getId())){\n-\t\t\treturn \"Sorry, you've been banned from this expedition by #b\" + leader.getName() + \"#k.\";\n-\t\t}\n-\t\tif (members.size() >= type.getMaxSize()){ //Would be a miracle if anybody ever saw this\n-\t\t\treturn \"Sorry, this expedition is full!\";\n-\t\t}\n-                \n-                members.put(player.getId(), player.getName());\n-                player.announce(MaplePacketCreator.getClock((int)(startTime - System.currentTimeMillis()) / 1000));\n-                broadcastExped(MaplePacketCreator.serverNotice(6, \"[Expedition] \" + player.getName() + \" has joined the expedition!\"));\n-                return \"You have registered for the expedition successfully!\";\n-\t}\n-\n-\tprivate void broadcastExped(byte[] packet){\n-\t\tfor (MapleCharacter chr : getActiveMembers()){\n-                        chr.announce(packet);\n-\t\t}\n-\t}\n-\n-\tpublic boolean removeMember(MapleCharacter chr) {\n-\t\tif(members.remove(chr.getId()) != null) {\n-                    chr.announce(MaplePacketCreator.removeClock());\n-                    broadcastExped(MaplePacketCreator.serverNotice(6, \"[Expedition] \" + chr.getName() + \" has left the expedition.\"));\n-                    chr.dropMessage(6, \"[Expedition] You have left this expedition.\");\n-                    return true;\n+    private static final int[] EXPEDITION_BOSSES = {\n+        8800000,// - Zakum's first body\n+        8800001,// - Zakum's second body\n+        8800002,// - Zakum's third body\n+        8800003,// - Zakum's Arm 1\n+        8800004,// - Zakum's Arm 2\n+        8800005,// - Zakum's Arm 3\n+        8800006,// - Zakum's Arm 4\n+        8800007,// - Zakum's Arm 5\n+        8800008,// - Zakum's Arm 6\n+        8800009,// - Zakum's Arm 7\n+        8800010,// - Zakum's Arm 8\n+        8810000,// - Horntail's Left Head\n+        8810001,// - Horntail's Right Head\n+        8810002,// - Horntail's Head A\n+        8810003,// - Horntail's Head B\n+        8810004,// - Horntail's Head C\n+        8810005,// - Horntail's Left Hand\n+        8810006,// - Horntail's Right Hand\n+        8810007,// - Horntail's Wings\n+        8810008,// - Horntail's Legs\n+        8810009,// - Horntail's Tails\n+        9420546,// - Scarlion Boss\n+        9420547,// - Scarlion Boss\n+        9420548,// - Angry Scarlion Boss\n+        9420549,// - Furious Scarlion Boss\n+        9420541,// - Targa\n+        9420542,// - Targa\n+        9420543,// - Angry Targa\n+        9420544,// - Furious Targa\n+    };\n+\n+    private MapleCharacter leader;\n+    private MapleExpeditionType type;\n+    private boolean registering;\n+    private MapleMap startMap;\n+    private List<String> bossLogs;\n+    private ScheduledFuture<?> schedule;\n+    private Map<Integer, String> members = new ConcurrentHashMap<>();\n+    private List<Integer> banned = new CopyOnWriteArrayList<>();\n+    private long startTime;\n+    private Properties props = new Properties();\n+    private MonitoredReentrantLock pL = MonitoredReentrantLockFactory.createLock(MonitoredLockType.EIM_PARTY, true);\n+\n+    public MapleExpedition(MapleCharacter player, MapleExpeditionType met) {\n+        leader = player;\n+        members.put(player.getId(), player.getName());\n+        startMap = player.getMap();\n+        type = met;\n+        bossLogs = new CopyOnWriteArrayList<>();\n+        beginRegistration();\n+    }\n+\n+    private void beginRegistration() {\n+        registering = true;\n+        leader.announce(MaplePacketCreator.getClock(type.getRegistrationTime() * 60));\n+        startMap.broadcastMessage(leader, MaplePacketCreator.serverNotice(6, \"[Expedition] \" + leader.getName() + \" has been declared the expedition captain. Please register for the expedition.\"), false);\n+        leader.announce(MaplePacketCreator.serverNotice(6, \"[Expedition] You have become the expedition captain. Gather enough people for your team then talk to the NPC to start.\"));\n+\n+        if (!MapleExpeditionType.ARIANT.equals(type) && !MapleExpeditionType.ARIANT1.equals(type) && !MapleExpeditionType.ARIANT2.equals(type)) {\n+            scheduleRegistrationEnd();\n+        }\n+    }\n+\n+    private void scheduleRegistrationEnd() {\n+        final MapleExpedition exped = this;\n+        startTime = System.currentTimeMillis() + type.getRegistrationTime() * 60 * 1000;\n+\n+        schedule = TimerManager.getInstance().schedule(new Runnable() {\n+            @Override\n+            public void run() {\n+                if (registering) {\n+                    startMap.getChannelServer().getExpeditions().remove(exped);\n+                    startMap.broadcastMessage(MaplePacketCreator.serverNotice(6, \"[Expedition] The time limit has been reached. Expedition has been disbanded.\"));\n+\n+                    dispose(false);\n                 }\n-                \n-                return false;\n-\t}\n+            }\n+        }, type.getRegistrationTime() * 60 * 1000);\n+    }\n \n-\tpublic MapleExpeditionType getType() {\n-\t\treturn type;\n-\t}\n-        \n-        public List<MapleCharacter> getActiveMembers() {    // thanks MedicOP for figuring out an issue with broadcasting packets to offline members\n-                PlayerStorage ps = startMap.getWorldServer().getPlayerStorage();\n-                \n-                List<MapleCharacter> activeMembers = new LinkedList<>();\n-\t\tfor (Integer chrid : getMembers().keySet()){\n-                        MapleCharacter chr = ps.getCharacterById(chrid);\n-                        if (chr != null && chr.isLoggedinWorld()) {\n-                                activeMembers.add(chr);\n-                        }\n-\t\t}\n-                \n-                return activeMembers;\n+    public void dispose(boolean log) {\n+        broadcastExped(MaplePacketCreator.removeClock());\n+\n+        if (schedule != null) {\n+            schedule.cancel(false);\n         }\n         \n-        public Map<Integer, String> getMembers() {\n-                return new HashMap<>(members);\n-\t}\n-        \n-        public List<Entry<Integer, String>> getMemberList() {\n-                List<Entry<Integer, String>> memberList = new LinkedList<>();\n-                Entry<Integer, String> leaderEntry = null;\n-                \n-                for (Entry<Integer, String> e : getMembers().entrySet()) {\n-                        if (!isLeader(e.getKey())) {\n-                                memberList.add(e);\n-                        } else {\n-                                leaderEntry = e;\n-                        }\n-                }\n-                \n-                if (leaderEntry != null) {\n-                        memberList.add(0, leaderEntry);\n+        props.clear();\n+        if (log && !registering) {\n+            LogHelper.logExpedition(this);\n+        }\n+    }\n+\n+    public void start() {\n+        if (MapleExpeditionType.ARIANT.equals(type) || MapleExpeditionType.ARIANT1.equals(type) || MapleExpeditionType.ARIANT2.equals(type)) {\n+            startTime = System.currentTimeMillis() + type.getRegistrationTime() * 60 * 1000;\n+        }\n+        registering = false;\n+        broadcastExped(MaplePacketCreator.removeClock());\n+        broadcastExped(MaplePacketCreator.serverNotice(6, \"[Expedition] The expedition has started! Good luck, brave heroes!\"));\n+        broadcastExped(MaplePacketCreator.getClock((int) (startTime - System.currentTimeMillis()) / 1000));\n+        Server.getInstance().broadcastGMMessage(startMap.getWorld(), MaplePacketCreator.serverNotice(6, \"[Expedition] \" + type.toString() + \" Expedition started with leader: \" + leader.getName()));\n+    }\n+\n+    public String addMember(MapleCharacter player) {\n+        if (!registering) {\n+            return \"Sorry, this expedition is already underway. Registration is closed!\";\n+        }\n+        if (banned.contains(player.getId())) {\n+            return \"Sorry, you've been banned from this expedition by #b\" + leader.getName() + \"#k.\";\n+        }\n+        if (members.size() >= type.getMaxSize()) { //Would be a miracle if anybody ever saw this\n+            return \"Sorry, this expedition is full!\";\n+        }\n+\n+        members.put(player.getId(), player.getName());\n+        player.announce(MaplePacketCreator.getClock((int) (startTime - System.currentTimeMillis()) / 1000));\n+        broadcastExped(MaplePacketCreator.serverNotice(6, \"[Expedition] \" + player.getName() + \" has joined the expedition!\"));\n+        return \"You have registered for the expedition successfully!\";\n+    }\n+\n+    public int addMemberInt(MapleCharacter player) {\n+        if (!registering) {\n+            return 1; //\"Sorry, this expedition is already underway. Registration is closed!\";\n+        }\n+        if (banned.contains(player.getId())) {\n+            return 2; //\"Sorry, you've been banned from this expedition by #b\" + leader.getName() + \"#k.\";\n+        }\n+        if (members.size() >= type.getMaxSize()) { //Would be a miracle if anybody ever saw this\n+            return 3; //\"Sorry, this expedition is full!\";\n+        }\n+\n+        members.put(player.getId(), player.getName());\n+        player.announce(MaplePacketCreator.getClock((int) (startTime - System.currentTimeMillis()) / 1000));\n+        broadcastExped(MaplePacketCreator.serverNotice(6, \"[Expedition] \" + player.getName() + \" has joined the expedition!\"));\n+        return 0; //\"You have registered for the expedition successfully!\";\n+    }\n+\n+    private void broadcastExped(byte[] packet) {\n+        for (MapleCharacter chr : getActiveMembers()) {\n+            chr.announce(packet);\n+        }\n+    }\n+\n+    public boolean removeMember(MapleCharacter chr) {\n+        if (members.remove(chr.getId()) != null) {\n+            chr.announce(MaplePacketCreator.removeClock());\n+            broadcastExped(MaplePacketCreator.serverNotice(6, \"[Expedition] \" + chr.getName() + \" has left the expedition.\"));\n+            chr.dropMessage(6, \"[Expedition] You have left this expedition.\");\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    public MapleExpeditionType getType() {\n+        return type;\n+    }\n+\n+    public List<MapleCharacter> getActiveMembers() {    // thanks MedicOP for figuring out an issue with broadcasting packets to offline members\n+        PlayerStorage ps = startMap.getWorldServer().getPlayerStorage();\n+\n+        List<MapleCharacter> activeMembers = new LinkedList<>();\n+        for (Integer chrid : getMembers().keySet()) {\n+            MapleCharacter chr = ps.getCharacterById(chrid);\n+            if (chr != null && chr.isLoggedinWorld()) {\n+                activeMembers.add(chr);\n+            }\n+        }\n+\n+        return activeMembers;\n+    }\n+\n+    public Map<Integer, String> getMembers() {\n+        return new HashMap<>(members);\n+    }\n+\n+    public List<Entry<Integer, String>> getMemberList() {\n+        List<Entry<Integer, String>> memberList = new LinkedList<>();\n+        Entry<Integer, String> leaderEntry = null;\n+\n+        for (Entry<Integer, String> e : getMembers().entrySet()) {\n+            if (!isLeader(e.getKey())) {\n+                memberList.add(e);\n+            } else {\n+                leaderEntry = e;\n+            }\n+        }\n+\n+        if (leaderEntry != null) {\n+            memberList.add(0, leaderEntry);\n+        }\n+\n+        return memberList;\n+    }\n+\n+    public void ban(Entry<Integer, String> chr) {\n+        int cid = chr.getKey();\n+        if (!banned.contains(cid)) {\n+            banned.add(cid);\n+            members.remove(cid);\n+\n+            broadcastExped(MaplePacketCreator.serverNotice(6, \"[Expedition] \" + chr.getValue() + \" has been banned from the expedition.\"));\n+\n+            MapleCharacter player = startMap.getWorldServer().getPlayerStorage().getCharacterById(cid);\n+            if (player != null && player.isLoggedinWorld()) {\n+                player.announce(MaplePacketCreator.removeClock());\n+                player.dropMessage(6, \"[Expedition] You have been banned from this expedition.\");\n+                if (MapleExpeditionType.ARIANT.equals(type) || MapleExpeditionType.ARIANT1.equals(type) || MapleExpeditionType.ARIANT2.equals(type)) {\n+                    player.changeMap(980010000);\n                 }\n-            \n-                return memberList;\n-\t}\n+            }\n+        }\n+    }\n \n-\tpublic MapleCharacter getLeader(){\n-\t\treturn leader;\n-\t}\n-        \n-        public MapleMap getRecruitingMap() {\n-                return startMap;\n+    public void monsterKilled(MapleCharacter chr, MapleMonster mob) {\n+        for (int i = 0; i < EXPEDITION_BOSSES.length; i++) {\n+            if (mob.getId() == EXPEDITION_BOSSES[i]) { //If the monster killed was a boss\n+                String timeStamp = new SimpleDateFormat(\"HH:mm:ss\").format(new Date());\n+                bossLogs.add(\">\" + mob.getName() + \" was killed after \" + LogHelper.getTimeString(startTime) + \" - \" + timeStamp + \"\\r\\n\");\n+                return;\n+            }\n         }\n+    }\n+    \n+    public void setProperty(String key, String value) {\n+        pL.lock();\n+        try {\n+            props.setProperty(key, value);\n+        } finally {\n+            pL.unlock();\n+        }\n+    }\n+\n+    public String getProperty(String key) {\n+        pL.lock();\n+        try {\n+            return props.getProperty(key);\n+        } finally {\n+            pL.unlock();\n+        }\n+    }\n+    \n+    public MapleCharacter getLeader() {\n+        return leader;\n+    }\n \n-\tpublic boolean contains(MapleCharacter player) {\n-                return members.containsKey(player.getId()) || isLeader(player);\n-\t}\n+    public MapleMap getRecruitingMap() {\n+        return startMap;\n+    }\n \n-\tpublic boolean isLeader(MapleCharacter player) {\n-\t\treturn isLeader(player.getId());\n-\t}\n-        \n-        public boolean isLeader(int playerid) {\n-\t\treturn leader.getId() == playerid;\n-\t}\n-\n-\tpublic boolean isRegistering(){\n-\t\treturn registering;\n-\t}\n-\n-\tpublic boolean isInProgress(){\n-\t\treturn !registering;\n-\t}\n-\n-\tpublic void ban(Entry<Integer, String> chr) {\n-                int cid = chr.getKey();\n-                \n-\t\tif (!banned.contains(cid)) {\n-\t\t\tbanned.add(cid);\n-\t\t\tmembers.remove(cid);\n-                        \n-                        broadcastExped(MaplePacketCreator.serverNotice(6, \"[Expedition] \" + chr.getValue() + \" has been banned from the expedition.\"));\n-                        \n-                        MapleCharacter player = startMap.getWorldServer().getPlayerStorage().getCharacterById(cid);\n-                        if (player != null && player.isLoggedinWorld()) {\n-                                player.announce(MaplePacketCreator.removeClock());\n-                                player.dropMessage(6, \"[Expedition] You have been banned from this expedition.\");\n-                        }\n-\t\t}\n-\t}\n-\n-\tpublic long getStartTime(){\n-\t\treturn startTime;\n-\t}\n-\t\n-\tpublic List<String> getBossLogs(){\n-\t\treturn bossLogs;\n-\t}\n-\t\n-\tpublic void monsterKilled(MapleCharacter chr, MapleMonster mob) {\n-\t\tfor (int i = 0; i < EXPEDITION_BOSSES.length; i++){\n-\t\t\tif (mob.getId() == EXPEDITION_BOSSES[i]){ //If the monster killed was a boss\n-\t\t\t\tString timeStamp = new SimpleDateFormat(\"HH:mm:ss\").format(new Date());\n-\t\t\t\tbossLogs.add(\">\" + mob.getName() + \" was killed after \" + LogHelper.getTimeString(startTime) + \" - \" + timeStamp + \"\\r\\n\");\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t}\n+    public boolean contains(MapleCharacter player) {\n+        return members.containsKey(player.getId()) || isLeader(player);\n+    }\n+\n+    public boolean isLeader(MapleCharacter player) {\n+        return isLeader(player.getId());\n+    }\n+\n+    public boolean isLeader(int playerid) {\n+        return leader.getId() == playerid;\n+    }\n+\n+    public boolean isRegistering() {\n+        return registering;\n+    }\n+\n+    public boolean isInProgress() {\n+        return !registering;\n+    }\n+\n+    public long getStartTime() {\n+        return startTime;\n+    }\n+\n+    public List<String> getBossLogs() {\n+        return bossLogs;\n+    }\n+\n+    public MapleMap getStartMap() {\n+        return startMap;\n+    }\n+\n+    public void setStartMap(MapleMap startMap) {\n+        this.startMap = startMap;\n+    }\n+\n+    public ScheduledFuture<?> getSchedule() {\n+        return schedule;\n+    }\n+\n+    public void setSchedule(ScheduledFuture<?> schedule) {\n+        this.schedule = schedule;\n+    }\n+\n+    public List<Integer> getBanned() {\n+        return banned;\n+    }\n+\n+    public void setBanned(List<Integer> banned) {\n+        this.banned = banned;\n+    }\n }"}, {"sha": "e3740a3e2a6be96f4f5b011564b3e97d4cfbd419", "filename": "src/server/expeditions/MapleExpeditionType.java", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/server/expeditions/MapleExpeditionType.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/server/expeditions/MapleExpeditionType.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/expeditions/MapleExpeditionType.java?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -39,6 +39,9 @@\n     HORNTAIL(6, 30, 100, 255, 5),\n     CHAOS_ZAKUM(6, 30, 120, 255, 5),\n     CHAOS_HORNTAIL(6, 30, 120, 255, 5),\n+    ARIANT(2, 4, 20, 30, 5),\n+    ARIANT1(2, 4, 20, 30, 5),\n+    ARIANT2(2, 4, 20, 30, 5),\n     PINKBEAN(6, 30, 120, 255, 5),\n     CWKPQ(6, 30, 90, 255, 5);   // CWKPQ min-level 90, found thanks to Cato\n     "}, {"sha": "9d22fd9b8a6f6e99f52315aeae33db6b1e554572", "filename": "src/server/life/Element.java", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/server/life/Element.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/server/life/Element.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/life/Element.java?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -22,8 +22,23 @@\n package server.life;\n \n public enum Element {\n-    NEUTRAL, FIRE, ICE, LIGHTING, POISON, HOLY, DARK;\n+    NEUTRAL(0), PHYSICAL(1), FIRE(2, true), ICE(3, true), LIGHTING(4), POISON(5), HOLY(6, true), DARKNESS(7);\n \n+    private int value;\n+    private boolean special = false;\n+    private Element(int v) {\n+\tthis.value = v;\n+    }\n+\n+    private Element(int v, boolean special) {\n+\tthis.value = v;\n+\tthis.special = special;\n+    }\n+\n+    public boolean isSpecial() {\n+\treturn special;\n+    }\n+    \n     public static Element getFromChar(char c) {\n         switch (Character.toUpperCase(c)) {\n             case 'F':\n@@ -37,10 +52,14 @@ public static Element getFromChar(char c) {\n             case 'H':\n                 return HOLY;\n             case 'D':\n-            \treturn DARK;\n+            \treturn DARKNESS;\n             case 'P':\n                 return NEUTRAL;\n         }\n         throw new IllegalArgumentException(\"unknown elemnt char \" + c);\n     }\n+    \n+    public int getValue() {\n+\treturn value;\n+    }\n }"}, {"sha": "edfa5f7cfeb986d5971cad3691d1e2720438fe27", "filename": "src/server/life/MapleLifeFactory.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/server/life/MapleLifeFactory.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/server/life/MapleLifeFactory.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/life/MapleLifeFactory.java?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -299,7 +299,7 @@ public String getMsg() {\n         private int id;\n         private byte chance, x;\n \n-        private loseItem(int id, byte chance, byte x) {\n+        public loseItem(int id, byte chance, byte x) {\n             this.id = id;\n             this.chance = chance;\n             this.x = x;"}, {"sha": "f40bbf23a083287beb8cd6e2aa01433b1b0a8768", "filename": "src/server/life/MapleMonsterInformationProvider.java", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/server/life/MapleMonsterInformationProvider.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/server/life/MapleMonsterInformationProvider.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/life/MapleMonsterInformationProvider.java?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -186,7 +186,12 @@ private void retrieveGlobal() {\n         if (monsterId >= 9300127 && monsterId <= 9300136 || monsterId >= 9300315 && monsterId <= 9300324) {\n             int dropArray[] = {2022157, 2022158, 2022159, 2022160, 2022161, 2022162, 2022163, 2022164, 2022165, 2022166, 2022167, 2022168, 2022169, 2022170, 2022171, 2022172, 2022173, 2022174, 2022175, 2022176, 2022177, 2022178, 4001129}; //These are the drops, -1 means meso :D\n             for (int id : dropArray) {\n-                ret.add(new MonsterDropEntry(id, 2000, 1, 1, (short) 0));\n+                ret.add(new MonsterDropEntry(id, 20000, 1, 1, (short) 0));\n+            }\n+        } else if (monsterId == 9300157) {\n+            int dropArray[] = {2022266, 2022267, 2022268, 2022269}; //These are the drops, -1 means meso :D\n+            for (int id : dropArray) {\n+                ret.add(new MonsterDropEntry(id, 20000, 1, 1, (short) 0));\n             }\n         } else {\n             PreparedStatement ps = null;"}, {"sha": "9cdcb6bd21e70b4d9d90515b0a7a044eb1b7488b", "filename": "src/server/maps/MapleMap.java", "status": "modified", "additions": 86, "deletions": 24, "changes": 110, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/server/maps/MapleMap.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/server/maps/MapleMap.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/maps/MapleMap.java?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -1,24 +1,3 @@\n-/*\n- This file is part of the OdinMS Maple Story Server\n- Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n- Matthias Butz <matze@odinms.de>\n- Jan Christian Meyer <vimes@odinms.de>\n-\n- This program is free software: you can redistribute it and/or modify\n- it under the terms of the GNU Affero General Public License as\n- published by the Free Software Foundation version 3 as published by\n- the Free Software Foundation. You may not use, modify or distribute\n- this program under any other version of the GNU Affero General Public\n- License.\n-\n- This program is distributed in the hope that it will be useful,\n- but WITHOUT ANY WARRANTY; without even the implied warranty of\n- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n- GNU Affero General Public License for more details.\n-\n- You should have received a copy of the GNU Affero General Public License\n- along with this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n package server.maps;\n \n import client.MapleBuffStat;\n@@ -84,9 +63,9 @@\n import server.life.MonsterGlobalDropEntry;\n import server.life.SpawnPoint;\n import scripting.event.EventInstanceManager;\n+import server.expeditions.MapleExpedition;\n+import server.expeditions.MapleExpeditionType;\n import server.life.MaplePlayerNPC;\n-import server.life.MobSkill;\n-import server.life.MobSkillFactory;\n import server.life.MonsterListener;\n import server.partyquest.GuardianSpawnPoint;\n import server.partyquest.MapleCarnivalFactory;\n@@ -162,6 +141,13 @@\n     private MapleSnowball snowball0 = null;\n     private MapleSnowball snowball1 = null;\n     private MapleCoconut coconut;\n+    \n+    //CPQ\n+    private int maxMobs;\n+    private int maxReactors;\n+    private int deathCP;\n+    private int timeDefault;\n+    private int timeExpand;\n \n     //locks\n     private ReadLock chrRLock;\n@@ -2499,6 +2485,42 @@ public void run() {\n             if (mmd != null) {\n                 mmd.registerPlayer(chr);\n             }\n+        } else if (mapid == 980010101 || mapid == 980010201 || mapid == 980010301) { // AriantPQ\n+            int pqTimer = (10 * 60 * 1000);\n+            int pqTimerBord = (9 * 60 * 1000) + 50 * 1000;\n+\n+            chr.announce(MaplePacketCreator.getClock(pqTimer / 1000));\n+\n+            chr.setAriantScore(TimerManager.getInstance().schedule(new Runnable() {\n+                @Override\n+                public void run() {\n+                    if (chr.getMapId() == 980010101 || chr.getMapId() == 980010201 || chr.getMapId() == 980010301) {\n+                        broadcastMessage(MaplePacketCreator.showAriantScoreBoard());\n+                        killAllMonsters();\n+                    }\n+                }\n+            }, pqTimerBord));\n+\n+            chr.setPqMapleMap(TimerManager.getInstance().schedule(new Runnable() {\n+                @Override\n+                public void run() {\n+                    if (chr.getMapId() == 980010101 || chr.getMapId() == 980010201 || chr.getMapId() == 980010301) {\n+                        MapleExpedition exp = null;\n+                        if (chr.getMapId() == 980010101) {\n+                            exp = chr.getClient().getAbstractPlayerInteraction().getExpedition(MapleExpeditionType.ARIANT);\n+                        } else if (chr.getMapId() == 980010201) {\n+                            exp = chr.getClient().getAbstractPlayerInteraction().getExpedition(MapleExpeditionType.ARIANT1);\n+                        } else {\n+                            exp = chr.getClient().getAbstractPlayerInteraction().getExpedition(MapleExpeditionType.ARIANT2);\n+                        }\n+                        chr.changeMap(980010010, 0);\n+                        chr.cancelPqMapleMap();\n+                        if (exp != null) {\n+                            chr.getClient().getAbstractPlayerInteraction().endExpedition(exp);\n+                        }\n+                    }\n+                }\n+            }, pqTimer));\n         }\n \n         MaplePet[] pets = chr.getPets();\n@@ -4350,7 +4372,7 @@ public final void addMobSpawn(int mobId, int spendCP) {\n     public final List<Pair<Integer, Integer>> getMobsToSpawn() {\n         return mobsToSpawn;\n     }\n-    \n+\n     public boolean isCPQWinnerMap() {\n         switch (this.getId()) {\n             case 980000103:\n@@ -4382,4 +4404,44 @@ public boolean isCPQLoserMap() {\n         }\n         return false;\n     }\n+    \n+    public int getMaxMobs() {\n+        return maxMobs;\n+    }\n+\n+    public void setMaxMobs(int maxMobs) {\n+        this.maxMobs = maxMobs;\n+    }\n+\n+    public int getMaxReactors() {\n+        return maxReactors;\n+    }\n+\n+    public void setMaxReactors(int maxReactors) {\n+        this.maxReactors = maxReactors;\n+    }\n+\n+    public int getDeathCP() {\n+        return deathCP;\n+    }\n+\n+    public void setDeathCP(int deathCP) {\n+        this.deathCP = deathCP;\n+    }\n+\n+    public int getTimeDefault() {\n+        return timeDefault;\n+    }\n+\n+    public void setTimeDefault(int timeDefault) {\n+        this.timeDefault = timeDefault;\n+    }\n+\n+    public int getTimeExpand() {\n+        return timeExpand;\n+    }\n+\n+    public void setTimeExpand(int timeExpand) {\n+        this.timeExpand = timeExpand;\n+    }\n }"}, {"sha": "d4e1e19b3b952c6025870adcf7775ea656cceeca", "filename": "src/server/maps/MapleMapFactory.java", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/server/maps/MapleMapFactory.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/server/maps/MapleMapFactory.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/maps/MapleMapFactory.java?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -94,12 +94,12 @@ private void loadLifeFromWz(MapleMap map, MapleData mapData) {\n             String type = MapleDataTool.getString(life.getChildByPath(\"type\"));\n             int team = MapleDataTool.getInt(\"team\", life, -1);\n             if (map.isCPQMap2() && type.equals(\"m\")) {\n-                if((Integer.parseInt(life.getName()) % 2) == 0)  {\n+                if ((Integer.parseInt(life.getName()) % 2) == 0) {\n                     team = 0;\n                 } else {\n                     team = 1;\n                 }\n-            } \n+            }\n             int cy = MapleDataTool.getInt(life.getChildByPath(\"cy\"));\n             MapleData dF = life.getChildByPath(\"f\");\n             int f = (dF != null) ? MapleDataTool.getInt(dF) : 0;\n@@ -313,25 +313,31 @@ private synchronized MapleMap loadMapFromWz(int mapid, Integer omapid) {\n         if (map.isCPQMap()) {\n             MapleData mcData = mapData.getChildByPath(\"monsterCarnival\");\n             if (mcData != null) {\n+                map.setDeathCP(MapleDataTool.getIntConvert(\"deathCP\", mcData, 0));\n+                map.setMaxMobs(MapleDataTool.getIntConvert(\"mobGenMax\", mcData, 0));\n+                map.setTimeDefault(MapleDataTool.getIntConvert(\"timeDefault\", mcData, 0));\n+                map.setTimeExpand(MapleDataTool.getIntConvert(\"timeExpand\", mcData, 0));\n+                map.setMaxReactors(MapleDataTool.getIntConvert(\"guardianGenMax\", mcData, 0));\n                 MapleData guardianGenData = mcData.getChildByPath(\"guardianGenPos\");\n                 for (MapleData node : guardianGenData.getChildren()) {\n                     GuardianSpawnPoint pt = new GuardianSpawnPoint(new Point(MapleDataTool.getIntConvert(\"x\", node), MapleDataTool.getIntConvert(\"y\", node)));\n                     pt.setTeam(MapleDataTool.getIntConvert(\"team\", node, -1));\n                     pt.setTaken(false);\n                     map.addGuardianSpawnPoint(pt);\n                 }\n-            }\n-            if (mcData.getChildByPath(\"skill\") != null) {\n-                for (MapleData area : mcData.getChildByPath(\"skill\")) {\n-                    map.addSkillId(MapleDataTool.getInt(area));\n+                if (mcData.getChildByPath(\"skill\") != null) {\n+                    for (MapleData area : mcData.getChildByPath(\"skill\")) {\n+                        map.addSkillId(MapleDataTool.getInt(area));\n+                    }\n                 }\n-            }\n-            \n-            if (mcData.getChildByPath(\"mob\") != null) {\n-                for (MapleData area : mcData.getChildByPath(\"mob\")) {\n-                    map.addMobSpawn(MapleDataTool.getInt(area.getChildByPath(\"id\")), MapleDataTool.getInt(area.getChildByPath(\"spendCP\")));\n+\n+                if (mcData.getChildByPath(\"mob\") != null) {\n+                    for (MapleData area : mcData.getChildByPath(\"mob\")) {\n+                        map.addMobSpawn(MapleDataTool.getInt(area.getChildByPath(\"id\")), MapleDataTool.getInt(area.getChildByPath(\"spendCP\")));\n+                    }\n                 }\n             }\n+\n         }\n \n         if (mapData.getChildByPath(\"reactor\") != null) {"}, {"sha": "1b03e989c658c9217749e1da718e3160da8ea4dc", "filename": "src/server/partyquest/MonsterCarnival.java", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/server/partyquest/MonsterCarnival.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/server/partyquest/MonsterCarnival.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/partyquest/MonsterCarnival.java?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -14,7 +14,6 @@\n /**\n  * @author Drago/Dragohe4rt\n  */\n-\n public class MonsterCarnival {\n \n     public static int D = 3;\n@@ -36,6 +35,8 @@ public MonsterCarnival(MapleParty p1, MapleParty p2, int mapid, boolean cpq1) {\n             this.cpq1 = cpq1;\n             this.p1 = p1;\n             this.p2 = p2;\n+            setSummons(map.getMaxMobs());\n+            setSummonss(map.getMaxMobs());\n             Channel cs = Server.getInstance().getWorld(p2.getLeader().getWorld()).getChannel(p2.getLeader().getChannel());\n             p1.setEnemy(p2);\n             p2.setEnemy(p1);\n@@ -91,17 +92,17 @@ public MonsterCarnival(MapleParty p1, MapleParty p2, int mapid, boolean cpq1) {\n                 public void run() {\n                     timeUp();\n                 }\n-            }, 10 * 60 * 1000);\n+            }, (map.getTimeDefault() - 10) * 1000);\n             effectTimer = TimerManager.getInstance().schedule(new Runnable() {\n                 @Override\n                 public void run() {\n                     complete();\n                 }\n-            }, 10 * 60 * 1000 - 10 * 1000);\n+            }, (map.getTimeDefault() - 10) * 1000 - 10 * 1000);\n             TimerManager.getInstance().schedule(new Runnable() {\n                 @Override\n                 public void run() {\n-                    map.addClock(60 * 10);\n+                    map.addClock(map.getTimeDefault() - 10);\n                 }\n             }, 2000);\n         } catch (Exception e) {\n@@ -321,13 +322,13 @@ public void extendTime() {\n             public void run() {\n                 timeUp();\n             }\n-        }, 3 * 60 * 1000);\n+        }, map.getTimeExpand() * 1000);\n         effectTimer = TimerManager.getInstance().schedule(new Runnable() {\n             @Override\n             public void run() {\n                 complete();\n             }\n-        }, 3 * 60 * 1000 - 10);\n+        }, map.getTimeExpand() * 1000 - 10);\n     }\n \n     public void complete() {\n@@ -486,4 +487,20 @@ public void setCP(int CP, int team) {\n             this.blueCP = CP;\n         }\n     }\n+\n+    public int getSummons() {\n+        return summons;\n+    }\n+\n+    public void setSummons(int summons) {\n+        this.summons = summons;\n+    }\n+\n+    public int getSummonss() {\n+        return summonss;\n+    }\n+\n+    public void setSummonss(int summonss) {\n+        this.summonss = summonss;\n+    }\n }"}, {"sha": "f066d7474039dfa80c71b416ae0ac91f9555b05d", "filename": "src/server/partyquest/MonsterCarnivalParty.java", "status": "removed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0a8efa42384c54ca26546c881d10b7fe4b881064/src/server/partyquest/MonsterCarnivalParty.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0a8efa42384c54ca26546c881d10b7fe4b881064/src/server/partyquest/MonsterCarnivalParty.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/partyquest/MonsterCarnivalParty.java?ref=0a8efa42384c54ca26546c881d10b7fe4b881064", "patch": "@@ -1,125 +0,0 @@\n-package server.partyquest;\n-\n-import client.MapleCharacter;\n-import java.util.LinkedList;\n-import java.util.List;\n-import server.maps.MapleMap;\n-import tools.MaplePacketCreator;\n-\n-/**\n- * @author Rob\n- */\n-public class MonsterCarnivalParty {\n-\n-    private List<MapleCharacter> members = new LinkedList<>();\n-    private MapleCharacter leader;\n-    private byte team;\n-    private short availableCP = 0, totalCP = 0;\n-    private int summons = 7;\n-    private boolean winner = false;\n-\n-    public MonsterCarnivalParty(final MapleCharacter owner, final List<MapleCharacter> members1, final byte team1) {\n-        leader = owner;\n-        members = members1;\n-        team = team1;\n-\n-        for (final MapleCharacter chr : members) {\n-            chr.setCarnivalParty(this);\n-            chr.setTeam(team);\n-        }\n-    }\n-\n-    public final MapleCharacter getLeader() {\n-        return leader;\n-    }\n-\n-    public void addCP(MapleCharacter player, int ammount) {\n-        totalCP += ammount;\n-        availableCP += ammount;\n-        player.addCP(ammount);\n-    }\n-\n-    public int getTotalCP() {\n-        return totalCP;\n-    }\n-\n-    public int getAvailableCP() {\n-        return availableCP;\n-    }\n-\n-    public void useCP(MapleCharacter player, int ammount) {\n-        availableCP -= ammount;\n-        player.useCP(ammount);\n-    }\n-\n-    public List<MapleCharacter> getMembers() {\n-        return members;\n-    }\n-\n-    public int getTeam() {\n-        return team;\n-    }\n-\n-    public void warpOut(final int map) {\n-        for (MapleCharacter chr : members) {\n-            chr.changeMap(map, 0);\n-            chr.setCarnivalParty(null);\n-            chr.setCarnival(null);\n-        }\n-        members.clear();\n-    }\n-\n-    public void warp(final MapleMap map, final int portalid) {\n-        for (MapleCharacter chr : members) {\n-            chr.changeMap(map, map.getPortal(portalid));\n-        }\n-    }\n-\n-    public void warpOut() {\n-        if (winner == true)\n-            warpOut(980000003 + (leader.getCarnival().getRoom() * 100));\n-        else\n-            warpOut(980000004 + (leader.getCarnival().getRoom() * 100));\n-    }\n-\n-    public boolean allInMap(MapleMap map) {\n-        boolean status = true;\n-        for (MapleCharacter chr : members) {\n-            if (chr.getMap() != map) {\n-                status = false;\n-            }\n-        }\n-        return status;\n-    }\n-\n-    public void removeMember(MapleCharacter chr) {\n-        members.remove(chr);\n-        chr.changeMap(980000010);\n-        chr.setCarnivalParty(null);\n-        chr.setCarnival(null);\n-    }\n-\n-    public boolean isWinner() {\n-        return winner;\n-    }\n-\n-    public void setWinner(boolean status) {\n-        winner = status;\n-    }\n-\n-    public void displayMatchResult() {\n-        final String effect = winner ? \"quest/carnival/win\" : \"quest/carnival/lose\";\n-\n-        for (final MapleCharacter chr : members) {\n-            chr.announce(MaplePacketCreator.showEffect(effect));\n-        }\n-    }\n-\n-    public void summon() {\n-        this.summons--;\n-    }\n-\n-    public boolean canSummon() {\n-        return this.summons > 0;\n-    }\n-}"}, {"sha": "301419701549bf794828ca3305c8c61149066b18", "filename": "src/tools/MaplePacketCreator.java", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/tools/MaplePacketCreator.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/0d7e8daf8e62f0173a6260a6f028591d756c082e/src/tools/MaplePacketCreator.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/tools/MaplePacketCreator.java?ref=0d7e8daf8e62f0173a6260a6f028591d756c082e", "patch": "@@ -4988,14 +4988,20 @@ private static void addPetInfo(final MaplePacketLittleEndianWriter mplew, MapleP\n \n     public static byte[] updateAriantPQRanking(String name, int score, boolean empty) {\n         final MaplePacketLittleEndianWriter mplew = new MaplePacketLittleEndianWriter();\n-        mplew.writeShort(SendOpcode.ARIANT_SCORE.getValue());\n+        mplew.writeShort(SendOpcode.ARIANT_ARENA_USER_SCORE.getValue());\n         mplew.write(empty ? 0 : 1);\n         if (!empty) {\n             mplew.writeMapleAsciiString(name);\n             mplew.writeInt(score);\n         }\n         return mplew.getPacket();\n     }\n+    \n+    public static byte[] showAriantScoreBoard() {\n+        MaplePacketLittleEndianWriter mplew = new MaplePacketLittleEndianWriter();\n+        mplew.writeShort(SendOpcode.ARIANT_ARENA_SHOW_RESULT.getValue());\n+        return mplew.getPacket();\n+    }\n \n     public static byte[] catchMessage(int message) { // not done, I guess\n         final MaplePacketLittleEndianWriter mplew = new MaplePacketLittleEndianWriter();"}]}]},
