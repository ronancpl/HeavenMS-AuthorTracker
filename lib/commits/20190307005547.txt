{"fetchDate": "2019-12-19", "content": [{"sha": "90ad58f17feec67ea4a50c859ba472e94ef8a595", "node_id": "MDY6Q29tbWl0NDUwODIwMjM6OTBhZDU4ZjE3ZmVlYzY3ZWE0YTUwYzg1OWJhNDcyZTk0ZWY4YTU5NQ==", "commit": {"author": {"name": "Diego Armando de Freitas Matos", "email": "diego.matos@bh.mi", "date": "2019-03-07T00:55:47Z"}, "committer": {"name": "Diego Armando de Freitas Matos", "email": "diego.matos@bh.mi", "date": "2019-03-07T00:55:47Z"}, "message": "CPQ 1 CPQ 2 CASAMENTO", "tree": {"sha": "8f63b87fd46e75588cec7e35291fc966a417d684", "url": "https://api.github.com/repos/ronancpl/HeavenMS/git/trees/8f63b87fd46e75588cec7e35291fc966a417d684"}, "url": "https://api.github.com/repos/ronancpl/HeavenMS/git/commits/90ad58f17feec67ea4a50c859ba472e94ef8a595", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/ronancpl/HeavenMS/commits/90ad58f17feec67ea4a50c859ba472e94ef8a595", "html_url": "https://github.com/ronancpl/HeavenMS/commit/90ad58f17feec67ea4a50c859ba472e94ef8a595", "comments_url": "https://api.github.com/repos/ronancpl/HeavenMS/commits/90ad58f17feec67ea4a50c859ba472e94ef8a595/comments", "author": null, "committer": null, "parents": [{"sha": "799870df63f4c855d6e5f828704f7b69c53aa800", "url": "https://api.github.com/repos/ronancpl/HeavenMS/commits/799870df63f4c855d6e5f828704f7b69c53aa800", "html_url": "https://github.com/ronancpl/HeavenMS/commit/799870df63f4c855d6e5f828704f7b69c53aa800"}], "stats": {"total": 32468, "additions": 17384, "deletions": 15084}, "files": [{"sha": "ca0f753f7e1144c1b52824a6ebab7bd88cc6e998", "filename": "scripts/npc/1012112.js", "status": "modified", "additions": 111, "deletions": 111, "changes": 222, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/1012112.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/1012112.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/1012112.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -1,24 +1,24 @@\n /*\n-\tThis file is part of the OdinMS Maple Story Server\n-    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n-\t\t       Matthias Butz <matze@odinms.de>\n-\t\t       Jan Christian Meyer <vimes@odinms.de>\n-\n-    This program is free software: you can redistribute it and/or modify\n-    it under the terms of the GNU Affero General Public License as\n-    published by the Free Software Foundation version 3 as published by\n-    the Free Software Foundation. You may not use, modify or distribute\n-    this program under any other version of the GNU Affero General Public\n-    License.\n-\n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU Affero General Public License for more details.\n-\n-    You should have received a copy of the GNU Affero General Public License\n-    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-*/\n+ This file is part of the OdinMS Maple Story Server\n+ Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n+ Matthias Butz <matze@odinms.de>\n+ Jan Christian Meyer <vimes@odinms.de>\n+ \n+ This program is free software: you can redistribute it and/or modify\n+ it under the terms of the GNU Affero General Public License as\n+ published by the Free Software Foundation version 3 as published by\n+ the Free Software Foundation. You may not use, modify or distribute\n+ this program under any other version of the GNU Affero General Public\n+ License.\n+ \n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU Affero General Public License for more details.\n+ \n+ You should have received a copy of the GNU Affero General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n /**\n  * @author BubblesDev\n  * @author Ronan\n@@ -29,104 +29,104 @@ var status = 0;\n var em = null;\n \n function start() {\n-\tstatus = -1;\n-\taction(1, 0, 0);\n+    status = -1;\n+    action(1, 0, 0);\n }\n \n function action(mode, type, selection) {\n-        if (mode == -1) {\n-                cm.dispose();\n-        } else {\n-                if (mode == 0 && status == 0) {\n-                        cm.dispose();\n-                        return;\n-                }\n-                if (mode == 1)\n-                        status++;\n-                else\n-                        status--;\n-                \n-                if(cm.getMapId() == 100000200) {\n-                        if (status == 0) {\n-                                em = cm.getEventManager(\"HenesysPQ\");\n-                                if(em == null) {\n-                                        cm.sendOk(\"The Henesys PQ has encountered an error.\");\n-                                        cm.dispose();\n-                                        return;\n-                                } else if(cm.isUsingOldPqNpcStyle()) {\n-                                        action(1, 0, 0);\n-                                        return;\n-                                }\n+    if (mode == -1) {\n+        cm.dispose();\n+    } else {\n+        if (mode == 0 && status == 0) {\n+            cm.dispose();\n+            return;\n+        }\n+        if (mode == 1)\n+            status++;\n+        else\n+            status--;\n \n-                                cm.sendSimple(\"#e#b<Party Quest: Primrose Hill>\\r\\n#k#n\" + em.getProperty(\"party\") + \"\\r\\n\\r\\nI'm Tory. Inside here is a beautiful hill where the primrose blooms. There's a tiger that lives in the hill, Growlie, and he seems to be looking for something to eat. Would you like to head over to the hill of primrose and join forces with your party members to help Growlie out?#b\\r\\n#L0#I want to participate in the party quest.\\r\\n#L1#I want to find party members.\\r\\n#L2#I would like to hear more details.\\r\\n#L3#I would like to redeem an instance hat.\");\n-                        } else if (status == 1) {\n-                                if (selection == 0) {\n-                                        if (cm.getParty() == null) {\n-                                                cm.sendOk(\"Hi there! I'm Tory. This place is covered with mysterious aura of the full moon, and no one person can enter here by him/herself.\");\n-                                                cm.dispose();\n-                                        } else if(!cm.isLeader()) {\n-                                                cm.sendOk(\"If you'd like to enter here, the leader of your party will have to talk to me. Talk to your party leader about this.\");\n-                                                cm.dispose();\n-                                        } else {\n-                                                var eli = em.getEligibleParty(cm.getParty());\n-                                                if(eli.size() > 0) {\n-                                                        if(!em.startInstance(cm.getParty(), cm.getPlayer().getMap(), 1)) {\n-                                                                cm.sendOk(\"Someone is already attempting the PQ. Please wait for them to finish, or find another channel.\");\n-                                                        }\n-                                                }\n-                                                else {\n-                                                        cm.sendOk(\"You cannot start this party quest yet, because either your party is not in the range size, some of your party members are not eligible to attempt it or they are not in this map. If you're having trouble finding party members, try Party Search.\");\n-                                                }\n+        if (cm.getMapId() == 100000200) {\n+            if (status == 0) {\n+                em = cm.getEventManager(\"HenesysPQ\");\n+                if (em == null) {\n+                    cm.sendOk(\"The Henesys PQ has encountered an error.\");\n+                    cm.dispose();\n+                    return;\n+                } else if (cm.isUsingOldPqNpcStyle()) {\n+                    action(1, 0, 0);\n+                    return;\n+                }\n \n-                                                cm.dispose();\n-                                        }\n-                                } else if (selection == 1) {\n-                                        cm.sendOk(\"Try using a Super Megaphone or asking your buddies or guild to join!\");\n-                                        cm.dispose();\n-                                } else if (selection == 2) {\n-                                        cm.sendOk(\"#e#b<Party Quest: Primrose Hill>#k#n\\r\\nCollect primrose seeds from the flowers at the bottom part of the map and drop them by the platforms above the stage. Primrose seed color must match to grow the seeds, so test until you find the correct combination. When all the seeds have been planted, that is, starting second part of the mission, scout the Moon Bunny while it prepares Rice Cakes for the hungry Growlie. Once Growlie becomes satisfied, your mission is complete.\");\n-                                        cm.dispose();\n-                                } else {\n-                                        cm.sendYesNo(\"So you want to exchange #b20 #b#t4001158##k for the instance-designed hat?\");\n-                                }\n-                        } else {\n-                                if(cm.hasItem(4001158, 20)) {\n-                                        if(cm.canHold(1002798)) {\n-                                                cm.gainItem(4001158, -20);\n-                                                cm.gainItem(1002798, 20);\n-                                                cm.sendNext(\"Here it is. Enjoy!\");\n-                                        }\n-                                } else {\n-                                        cm.sendNext(\"You don't have enough #t4001158# to buy it yet!\");\n-                                }\n-                                \n-                                cm.dispose();\n-                        }\n-                } else if (cm.getMapId() == 910010100) {\n-                        if (status == 0) {\n-                                cm.sendYesNo(\"Thank you for aiding in the effort of feeding the Growlie. As a matter of fact, your team has already been rewarded for reaching this far. With this problem now solved, there is another issue happening right now, if you are interessed check #bTommy#k there for the info. So, are you returning straight to Henesys now?\");\n-                        } else if (status == 1) {\n-                                if(cm.getEventInstance().giveEventReward(cm.getPlayer())) {\n-                                        cm.warp(100000200);\n-                                }\n-                                else {\n-                                        cm.sendOk(\"It seems you are short on space in one of your inventories. Please check that first to get rewarded properly.\");\n-                                }\n-                                cm.dispose();\n+                cm.sendSimple(\"#e#b<Party Quest: Primrose Hill>\\r\\n#k#n\" + em.getProperty(\"party\") + \"\\r\\n\\r\\nI'm Tory. Inside here is a beautiful hill where the primrose blooms. There's a tiger that lives in the hill, Growlie, and he seems to be looking for something to eat. Would you like to head over to the hill of primrose and join forces with your party members to help Growlie out?#b\\r\\n#L0#I want to participate in the party quest.\\r\\n#L1#I want to find party members.\\r\\n#L2#I would like to hear more details.\\r\\n#L3#I would like to redeem an instance hat.\");\n+            } else if (status == 1) {\n+                if (selection == 0) {\n+                    if (cm.getParty() == null) {\n+                        cm.sendOk(\"Hi there! I'm Tory. This place is covered with mysterious aura of the full moon, and no one person can enter here by him/herself.\");\n+                        cm.dispose();\n+                    } else if (!cm.isLeader()) {\n+                        cm.sendOk(\"If you'd like to enter here, the leader of your party will have to talk to me. Talk to your party leader about this.\");\n+                        cm.dispose();\n+                    } else {\n+                        var eli = em.getEligibleParty(cm.getParty());\n+                        if (eli.size() > 0) {\n+                            if (!em.startInstance(cm.getParty(), cm.getPlayer().getMap(), 1)) {\n+                                cm.sendOk(\"Someone is already attempting the PQ. Please wait for them to finish, or find another channel.\");\n+                            }\n                         }\n-                } else if (cm.getMapId() == 910010400) {\n-                        if (status == 0) {\n-                                cm.sendYesNo(\"So, are you returning to Henesys now?\");\n-                        } else if (status == 1) {\n-                                if(cm.getEventInstance() == null) {\n-                                        cm.warp(100000200);\n-                                } else if(cm.getEventInstance().giveEventReward(cm.getPlayer())) {\n-                                        cm.warp(100000200);\n-                                } else {\n-                                        cm.sendOk(\"It seems you are short on space in one of your inventories. Please check that first to get rewarded properly.\");\n-                                }\n-                                cm.dispose();\n+                        else {\n+                            cm.sendOk(\"You cannot start this party quest yet, because either your party is not in the range size, some of your party members are not eligible to attempt it or they are not in this map. If you're having trouble finding party members, try Party Search.\");\n                         }\n+\n+                        cm.dispose();\n+                    }\n+                } else if (selection == 1) {\n+                    cm.sendOk(\"Try using a Super Megaphone or asking your buddies or guild to join!\");\n+                    cm.dispose();\n+                } else if (selection == 2) {\n+                    cm.sendOk(\"#e#b<Party Quest: Primrose Hill>#k#n\\r\\nCollect primrose seeds from the flowers at the bottom part of the map and drop them by the platforms above the stage. Primrose seed color must match to grow the seeds, so test until you find the correct combination. When all the seeds have been planted, that is, starting second part of the mission, scout the Moon Bunny while it prepares Rice Cakes for the hungry Growlie. Once Growlie becomes satisfied, your mission is complete.\");\n+                    cm.dispose();\n+                } else {\n+                    cm.sendYesNo(\"So you want to exchange #b20 #b#t4001158##k for the instance-designed hat?\");\n                 }\n+            } else {\n+                if (cm.hasItem(4001158, 20)) {\n+                    if (cm.canHold(1002798)) {\n+                        cm.gainItem(4001158, -20);\n+                        cm.gainItem(1002798, 20);\n+                        cm.sendNext(\"Here it is. Enjoy!\");\n+                    }\n+                } else {\n+                    cm.sendNext(\"You don't have enough #t4001158# to buy it yet!\");\n+                }\n+\n+                cm.dispose();\n+            }\n+        } else if (cm.getMapId() == 910010100) {\n+            if (status == 0) {\n+                cm.sendYesNo(\"Thank you for aiding in the effort of feeding the Growlie. As a matter of fact, your team has already been rewarded for reaching this far. With this problem now solved, there is another issue happening right now, if you are interessed check #bTommy#k there for the info. So, are you returning straight to Henesys now?\");\n+            } else if (status == 1) {\n+                if (cm.getEventInstance().giveEventReward(cm.getPlayer())) {\n+                    cm.warp(100000200);\n+                }\n+                else {\n+                    cm.sendOk(\"It seems you are short on space in one of your inventories. Please check that first to get rewarded properly.\");\n+                }\n+                cm.dispose();\n+            }\n+        } else if (cm.getMapId() == 910010400) {\n+            if (status == 0) {\n+                cm.sendYesNo(\"So, are you returning to Henesys now?\");\n+            } else if (status == 1) {\n+                if (cm.getEventInstance() == null) {\n+                    cm.warp(100000200);\n+                } else if (cm.getEventInstance().giveEventReward(cm.getPlayer())) {\n+                    cm.warp(100000200);\n+                } else {\n+                    cm.sendOk(\"It seems you are short on space in one of your inventories. Please check that first to get rewarded properly.\");\n+                }\n+                cm.dispose();\n+            }\n         }\n+    }\n }\n\\ No newline at end of file"}, {"sha": "d07fdd6504d8d17315782d10880b115eb2b7bd15", "filename": "scripts/npc/1012113.js", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/1012113.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/1012113.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/1012113.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -1,24 +1,24 @@\n /*\n-\tThis file is part of the OdinMS Maple Story Server\n-    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n-\t\t       Matthias Butz <matze@odinms.de>\n-\t\t       Jan Christian Meyer <vimes@odinms.de>\n-\n-    This program is free software: you can redistribute it and/or modify\n-    it under the terms of the GNU Affero General Public License as\n-    published by the Free Software Foundation version 3 as published by\n-    the Free Software Foundation. You may not use, modify or distribute\n-    this program under any other version of the GNU Affero General Public\n-    License.\n-\n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU Affero General Public License for more details.\n-\n-    You should have received a copy of the GNU Affero General Public License\n-    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-*/\n+ This file is part of the OdinMS Maple Story Server\n+ Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n+ Matthias Butz <matze@odinms.de>\n+ Jan Christian Meyer <vimes@odinms.de>\n+ \n+ This program is free software: you can redistribute it and/or modify\n+ it under the terms of the GNU Affero General Public License as\n+ published by the Free Software Foundation version 3 as published by\n+ the Free Software Foundation. You may not use, modify or distribute\n+ this program under any other version of the GNU Affero General Public\n+ License.\n+ \n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU Affero General Public License for more details.\n+ \n+ You should have received a copy of the GNU Affero General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n /**\n  * @author BubblesDev\n  * @author Ronan\n@@ -31,45 +31,45 @@ function start() {\n }\n \n function action(mode, type, selection) {\n-        if (mode < 1) {\n-                cm.dispose();\n-        } else {\n-                status++;\n-                if (cm.getPlayer().getMap().getId() == 910010100) { //Clear map\n-                        if (status == 0) {\n-                                cm.sendNext(\"Hello, there! I'm Tommy. There's a Pig Town nearby where we're standing. The pigs there are rowdy and uncontrollable to the point where they have stolen numerous weapons from travelers. They were kicked out from their towns, and are currently hiding out at the Pig Town.\");\n-                        } else if (status == 1) {\n-                                if(cm.isEventLeader()) {\n-                                        cm.sendYesNo(\"What do you think about making your way there with your party members and teach those rowdy pigs a lesson?\");\n-                                }\n-                                else {\n-                                        cm.sendOk(\"Interessed? Tell your party leader to talk to me to head there!\");\n-                                        cm.dispose();\n-                                        return;\n-                                }\n-                        } else if (status == 2) {\n-                                cm.getEventInstance().startEventTimer(5 * 60000);                \n-                                cm.getEventInstance().warpEventTeam(910010200);\n-                                \n-                                cm.dispose();\n-                                return;\n-                        }\n-                } else if (cm.getPlayer().getMap().getId() == 910010200) { //Bonus map\n-                        if (status == 0) {\n-                                cm.sendYesNo(\"Would you like to exit the bonus now?\");\n-                        } else {\n-                                cm.warp(910010400);\n-                                cm.dispose();\n-                                return;\n-                        }\n-                } else if (cm.getPlayer().getMap().getId() == 910010300) { //Exit map\n-                        if (status == 0) {\n-                                cm.sendOk(\"You will now be warped out, thank you for helping us!\");\n-                        } else {\n-                                cm.warp(100000200);\n-                                cm.dispose();\n-                                return;\n-                        }\n+    if (mode < 1) {\n+        cm.dispose();\n+    } else {\n+        status++;\n+        if (cm.getPlayer().getMap().getId() == 910010100) { //Clear map\n+            if (status == 0) {\n+                cm.sendNext(\"Hello, there! I'm Tommy. There's a Pig Town nearby where we're standing. The pigs there are rowdy and uncontrollable to the point where they have stolen numerous weapons from travelers. They were kicked out from their towns, and are currently hiding out at the Pig Town.\");\n+            } else if (status == 1) {\n+                if (cm.isEventLeader()) {\n+                    cm.sendYesNo(\"What do you think about making your way there with your party members and teach those rowdy pigs a lesson?\");\n                 }\n+                else {\n+                    cm.sendOk(\"Interessed? Tell your party leader to talk to me to head there!\");\n+                    cm.dispose();\n+                    return;\n+                }\n+            } else if (status == 2) {\n+                cm.getEventInstance().startEventTimer(5 * 60000);\n+                cm.getEventInstance().warpEventTeam(910010200);\n+\n+                cm.dispose();\n+                return;\n+            }\n+        } else if (cm.getPlayer().getMap().getId() == 910010200) { //Bonus map\n+            if (status == 0) {\n+                cm.sendYesNo(\"Would you like to exit the bonus now?\");\n+            } else {\n+                cm.warp(910010400);\n+                cm.dispose();\n+                return;\n+            }\n+        } else if (cm.getPlayer().getMap().getId() == 910010300) { //Exit map\n+            if (status == 0) {\n+                cm.sendOk(\"You will now be warped out, thank you for helping us!\");\n+            } else {\n+                cm.warp(100000200);\n+                cm.dispose();\n+                return;\n+            }\n         }\n+    }\n }"}, {"sha": "726519e0b7bfc35d063151976cf369b181808a7c", "filename": "scripts/npc/2042000.js", "status": "modified", "additions": 69, "deletions": 217, "changes": 286, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/2042000.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/2042000.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/2042000.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -1,232 +1,84 @@\n-/*\n-    This file is part of the HeavenMS MapleStory Server\n-    Copyleft (L) 2016 - 2018 RonanLana\n+var map = 980000000;\n+var minLvl = 0;\n+var maxLvl = 255;\n+var minAmt = 0;\n+var maxAmt = 6;\n \n-    This program is free software: you can redistribute it and/or modify\n-    it under the terms of the GNU Affero General Public License as\n-    published by the Free Software Foundation version 3 as published by\n-    the Free Software Foundation. You may not use, modify or distribute\n-    this program under any other version of the GNU Affero General Public\n-    License.\n-\n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU Affero General Public License for more details.\n-\n-    You should have received a copy of the GNU Affero General Public License\n-    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-*/\n-/* Spiegelmann\n-        Refining NPC: \n-\t* Auto ore refiner\n-        * \n-        * @author RonanLana\n-*/\n-\n-var status;\n-var refineRocks = true;     // enables moon rock, star rock\n-var refineCrystals = true;  // enables common crystals\n-var refineSpecials = true;  // enables lithium, special crystals\n-var feeMultiplier = 7.0;\n- \n function start() {\n-        status = -1;\n-        action(1, 0, 0);\n+    status = -1;\n+    action(1, 0, 0);\n }\n \n function action(mode, type, selection) {\n-        if (mode == -1) {\n-                cm.dispose();\n-        } else {\n-                if (mode == 0 && type > 0) {\n-                        cm.dispose();\n-                        return;\n-                }\n-                if (mode == 1)\n-                        status++;\n-                else\n-                        status--;\n-    \n-                if(status == 0) {\n-                        if (!Packages.constants.ServerConstants.USE_ENABLE_CUSTOM_NPC_SCRIPT) {\n-                                cm.sendOk(\"The Monster Carnival is currently unavailable.\");\n-                                cm.dispose();\n-                                return;\n-                        }\n-                    \n-                        var selStr = \"The Monster Carnival is currently unavailable, but instead I offer a steadfast #bore refining#k service for you, taxing #r\" + ((feeMultiplier * 100) | 0) + \"%#k over the usual fee to synthetize them. What will you do?#b\";\n-                        \n-                        var options = new Array(\"Refine mineral ores\",\"Refine jewel ores\");\n-                        if(refineCrystals) {\n-                                options.push(\"Refine crystal ores\");\n-                        }\n-                        if(refineRocks) {\n-                                options.push(\"Refine plates/jewels\");\n-                        }\n-                        \n-                        for (var i = 0; i < options.length; i++){\n-                                selStr += \"\\r\\n#L\" + i + \"# \" + options[i] + \"#l\";\n-                        }\n-                        \n-                        cm.sendSimple(selStr);\n-                } else if(status == 1) {\n-                        var allDone;\n-                        \n-                        if (selection == 0) {\n-                                allDone = refineItems(0); // minerals\n-                        } else if (selection == 1) {\n-                                allDone = refineItems(1); // jewels\n-                        } else if (selection == 2 && refineCrystals) {\n-                                allDone = refineItems(2); // crystals\n-                        } else if (selection == 2 && !refineCrystals || selection == 3) {\n-                                allDone = refineRockItems(); // moon/star rock\n-                        }\n-                        \n-                        if(allDone) {\n-                            cm.sendOk(\"Done. Thanks for showing up~.\");\n-                        } else {\n-                            cm.sendOk(\"Done. Be aware some of the items #rcould not be synthetized#k because either you have a lack of space on your ETC inventory or there's not enough mesos to cover the fee.\");\n-                        }\n-                        cm.dispose();\n-                }\n-        }\n-}\n-\n-function getRefineFee(fee) {\n-    return ((feeMultiplier * fee) | 0);\n-}\n-\n-function isRefineTarget(refineType, refineItemid) {\n-    if(refineType == 0) { //mineral refine\n-        return refineItemid >= 4010000 && refineItemid <= 4010007 && !(refineItemid == 4010007 && !refineSpecials);\n-    } else if(refineType == 1) { //jewel refine\n-        return refineItemid >= 4020000 && refineItemid <= 4020008 && !(refineItemid == 4020008 && !refineSpecials);\n-    } else if(refineType == 2) { //crystal refine\n-        return refineItemid >= 4004000 && refineItemid <= 4004004 && !(refineItemid == 4004004 && !refineSpecials);\n-    }\n-    \n-    return false;\n-}\n-\n-function getRockRefineTarget(refineItemid) {\n-    if(refineItemid >= 4011000 && refineItemid <= 4011006) {\n-        return 0;\n-    } else if(refineItemid >= 4021000 && refineItemid <= 4021008) {\n-        return 1;\n-    }\n-    \n-    return -1;\n-}\n-\n-function refineItems(refineType) {\n-    var allDone = true;\n-    \n-    var refineFees = [[300,300,300,500,500,500,800,270],[500,500,500,500,500,500,500,1000,3000],[5000,5000,5000,5000,1000000]];\n-    var itemCount = {};\n-    \n-    var iter = cm.getPlayer().getInventory(Packages.client.inventory.MapleInventoryType.ETC).iterator();\n-    while (iter.hasNext()) {\n-        var it = iter.next();\n-        var itemid = it.getItemId();\n-\n-        if(isRefineTarget(refineType, itemid)) {\n-            var ic = itemCount[itemid];\n-            \n-            if(ic != undefined) {\n-                itemCount[itemid] += it.getQuantity();\n-            } else {\n-                itemCount[itemid] = it.getQuantity();\n-            }\n+    if (mode == -1) {\n+        cm.dispose();\n+    } else {\n+        if (mode == 0 && status == 0) {\n+            cm.dispose();\n+            return;\n         }\n-    }\n-    \n-    for(var key in itemCount) {\n-        var itemqty = itemCount[key];\n-        var itemid = parseInt(key);\n-        \n-        var refineQty = ((itemqty / 10) | 0);\n-        if(refineQty <= 0) continue;\n-        \n-        while(true) {\n-            itemqty = refineQty * 10;\n-        \n-            var fee = getRefineFee(refineFees[refineType][(itemid % 100) | 0] * refineQty);\n-            if(cm.canHold(itemid + 1000, refineQty, itemid, itemqty) && cm.getMeso() >= fee) {\n-                cm.gainMeso(-fee);\n-                cm.gainItem(itemid, -itemqty);\n-                cm.gainItem(itemid + (itemid != 4010007 ? 1000 : 1001), refineQty);\n-                \n-                break;\n-            } else if(refineQty <= 1) {\n-                allDone = false;\n-                break;\n+        if (mode == 1)\n+            status++;\n+        else\n+            status--;\n+        if (status == 0) {\n+            if (cm.getParty() == null) {\n+                status = 10;\n+                cm.sendOk(\"#e\ufffd necess\ufffdrio criar um grupo antes de come\ufffdar o Festival de Monstros!#k\");\n+            } else if (!cm.isLeader()) {\n+                status = 10;\n+                cm.sendOk(\"Se voc\ufffd quer come\ufffdar o Festival, avise o #bl\ufffdder do grupo#k para falar comigo.\");\n             } else {\n-                refineQty--;\n-            }\n-        }\n-    }\n-    \n-    return allDone;\n-}\n-\n-function refineRockItems() {\n-    var allDone = true;\n-    var minItems = [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]];\n-    var minRocks = [2147483647, 2147483647];\n-    \n-    var rockItems = [4011007, 4021009];\n-    var rockFees = [10000, 15000];\n+                var party = cm.getParty().getMembers();\n+                var inMap = cm.partyMembersInMap();\n+                var lvlOk = 0;\n+                var isInMap = 0;\n+                for (var i = 0; i < party.size(); i++) {\n+                    if (party.get(i).getLevel() >= minLvl && party.get(i).getLevel() <= maxLvl) {\n+                        lvlOk++;\n+                    }\n+                    if (party.get(i).getPlayer().getMapId() != 980000000) {\n+                        //isInMap = false;\n+                        isInMap++\n+                    }\n+                }\n \n-    var iter = cm.getPlayer().getInventory(Packages.client.inventory.MapleInventoryType.ETC).iterator();\n-    while (iter.hasNext()) {\n-        var it = iter.next();\n-        var itemid = it.getItemId();\n-        var rockRefine = getRockRefineTarget(itemid);\n-        if(rockRefine >= 0) {\n-            var rockItem = ((itemid % 100) | 0);\n-            var itemqty = it.getQuantity();\n-            \n-            minItems[rockRefine][rockItem] += itemqty;\n-        }\n-    }\n-    \n-    for(var i = 0; i < minRocks.length; i++) {\n-        for(var j = 0; j < minItems[i].length; j++) {\n-            if(minRocks[i] > minItems[i][j]) {\n-                minRocks[i] = minItems[i][j];\n+                if (party >= 1) {\n+                    status = 10;\n+                    cm.sendOk(\"Voc\ufffd n\ufffdo tem n\ufffdmero suficiente de pessoas em seu grupo. Voc\ufffd precisa de um grupo com #b\" + minAmt + \"#k - #r\" + maxAmt + \"#k membros e eles devem estar no mapa com voc\ufffd.\");\n+                } else if (lvlOk != inMap) {\n+                    status = 10;\n+                    cm.sendOk(\"Certifique se todos em seu grupo est\ufffdo dentre os n\ufffdveis corretos (\" + minLvl + \"~\" + maxLvl + \")!\");\n+                } else if (isInMap > 0) {\n+                    status = 10;\n+                    cm.sendOk(\"Existe algu\ufffdm do grupo que n\ufffdo esta no mapa!\");\n+                } else {\n+                    cm.sendCPQMapLists();\n+                }\n             }\n-        }\n-        if(minRocks[i] <= 0 || minRocks[i] == 2147483647) continue;\n-        \n-        var refineQty = minRocks[i];\n-        while(true) {\n-            var fee = getRefineFee(rockFees[i] * refineQty);\n-            if(cm.canHold(rockItems[i], refineQty) && cm.getMeso() >= fee) {\n-                cm.gainMeso(-fee);\n-\n-                var j;\n-                if(i == 0) {\n-                    for(j = 4011000; j < 4011007; j++) {\n-                        cm.gainItem(j, -refineQty);\n-                    }\n-                    cm.gainItem(j, refineQty);\n+        } else if (status == 1) {\n+            \n+            if (cm.fieldTaken(selection)) {\n+                if (cm.fieldLobbied(selection)) {\n+                    cm.challengeParty(selection);\n+                    cm.dispose();\n                 } else {\n-                    for(j = 4021000; j < 4021009; j++) {\n-                        cm.gainItem(j, -refineQty);\n-                    }\n-                    cm.gainItem(j, refineQty);\n+                    cm.sendOk(\"A sala esta cheia.\");\n+                    cm.dispose();\n                 }\n-                \n-                break;\n-            } else if(refineQty <= 1) {\n-                allDone = false;\n-                break;\n             } else {\n-                refineQty--;\n+                var party = cm.getParty().getMembers();\n+                if ((selection === 0 || selection === 1 || selection === 2 || selection === 3) && party.size() < 2) {\n+                    cm.sendOk(\"Voc\ufffd precisa de no m\ufffdnimo 2 player para entrar na competi\ufffd\ufffdo.\");\n+                } else if ((selection === 4 || selection === 5) && party.size() < 3) {\n+                    cm.sendOk(\"Voc\ufffd precisa de no m\ufffdnimo 3 player para entrar na competi\ufffd\ufffdo.\");\n+                } else {\n+                    cm.cpqLobby(selection);\n+                }\n+                cm.dispose();\n             }\n+        } else if (status == 11) {\n+            cm.dispose();\n         }\n     }\n-    \n-    return allDone;\n-}\n+}\n\\ No newline at end of file"}, {"sha": "4f7ae7d9c39f8ff5168990326a3773e9329ff99d", "filename": "scripts/npc/2042002.js", "status": "modified", "additions": 300, "deletions": 206, "changes": 506, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/2042002.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/2042002.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/2042002.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -1,226 +1,320 @@\n-/*\n-    This file is part of the HeavenMS MapleStory Server\n-    Copyleft (L) 2016 - 2018 RonanLana\n+importPackage(Packages.server.maps);\n \n-    This program is free software: you can redistribute it and/or modify\n-    it under the terms of the GNU Affero General Public License as\n-    published by the Free Software Foundation version 3 as published by\n-    the Free Software Foundation. You may not use, modify or distribute\n-    this program under any other version of the GNU Affero General Public\n-    License.\n+var status = 0;\n+var rnk = -1;\n+var n1 = 50; //???\n+var n2 = 40; //??? ???\n+var n3 = 7; //35\n+var n4 = 10; //40\n+var n5 = 20; //50\n \n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU Affero General Public License for more details.\n-\n-    You should have received a copy of the GNU Affero General Public License\n-    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-*/\n-/* Spiegelmann\n-        Refining NPC: \n-\t* Auto ore refiner\n-        * \n-        * @author RonanLana\n-*/\n-\n-var status;\n-var refineRocks = true;     // enables moon rock, star rock\n-var refineCrystals = true;  // enables common crystals\n-var refineSpecials = true;  // enables lithium, special crystals\n-var feeMultiplier = 7.0;\n- \n function start() {\n-        status = -1;\n-        action(1, 0, 0);\n+    status = -1;\n+    action(1, 0, 0);\n }\n \n function action(mode, type, selection) {\n-        if (mode == -1) {\n+    if (mode == -1) {\n+        cm.dispose();\n+    } else {\n+        if (status >= 0 && mode == 0) {\n+            cm.dispose();\n+            return;\n+        }\n+        if (mode == 1)\n+            status++;\n+        else\n+            status--;\n+        if (cm.getPlayer().getMapId() == 980000010) {\n+            if (status == 0) {\n+                cm.sendNext(\"Eu espero que voc\ufffd tinha divertido na Folia dos Monstros!\");\n+            } else if (status > 0) {\n+                cm.warp(980000000, 0);\n                 cm.dispose();\n-        } else {\n-                if (mode == 0 && type > 0) {\n-                        cm.dispose();\n-                        return;\n+            }\n+        } else if (cm.getChar().getMap().isCPQLoserMap()) {\n+            if (status == 0) {\n+                if (cm.getChar().getParty() != null) {\n+                    var shiu = \"\";\n+                    if (cm.getPlayer().getFestivalPoints() >= 100) {\n+                        shiu += \"#rA#k\";\n+                        cm.sendOk(\"Infelizmente, voc\ufffd ou empatou ou perdeu a batalha, apesar da sua excelente performance. A vit\ufffdria pode ser sua da pr\ufffdxima vez.\\r\\n\\r\\n#bNota da Folia de Monstros : \" + shiu);\n+                        rnk = 10;\n+                    } else if (cm.getPlayer().getFestivalPoints() >= 50 && cm.getPlayer().getFestivalPoints() < 100) {\n+                        shiu += \"#rB#k\";\n+                        rnk = 20;\n+                        cm.sendOk(\"Infelizmente, voc\ufffd ou empatou ou perdeu a batalha, mesmo com sua \ufffdtima performance. S\ufffd mais um pouquinho, e a vit\ufffdria poderia ter sido sua.\\r\\n\\r\\n#bNota da Folia de Monstros : \" + shiu);\n+                    } else if (cm.getPlayer().getFestivalPoints() >= 30 && cm.getPlayer().getFestivalPoints() < 50) {\n+                        shiu += \"#rC#k\";\n+                        rnk = 30;\n+                        cm.sendOk(\"Infelizmente, voc\ufffd ou empatou ou perdeu a batalha. A vit\ufffdria est\ufffd para aqueles que se esfor\ufffdam. Vejo seus esfor\ufffdos, ent\ufffdo a vit\ufffdria n\ufffdo est\ufffd t\ufffdo longe do seu alcance. Continue assim!\\r\\n\\r\\n#bNota da Folia de Monstros : \" + shiu);\n+                    } else {\n+                        shiu += \"#rD#k\";\n+                        rnk = 40;\n+                        cm.sendOk(\"Infelizmente, voc\ufffd ou empatou ou perdeu a batalha, e sua performance claramente reflete nisso. Espero mais de voc\ufffd da pr\ufffdxima vez.\\r\\n\\r\\n#bNota da Folia de Monstros : \" + shiu);\n+                    }\n+                } else {\n+                    cm.warp(980000000, 0);\n+                    cm.dispose();\n                 }\n-                if (mode == 1)\n-                        status++;\n-                else\n-                        status--;\n-    \n-                if(status == 0) {\n-                        var selStr = \"The Monster Carnival is currently unavailable, but instead I offer a steadfast #bore refining#k service for you, taxing #r\" + ((feeMultiplier * 100) | 0) + \"%#k over the usual fee to synthetize them. What will you do?#b\";\n-                        \n-                        var options = new Array(\"Refine mineral ores\",\"Refine jewel ores\");\n-                        if(refineCrystals) {\n-                            options.push(\"Refine crystal ores\");\n-                        }\n-                        if(refineRocks) {\n-                            options.push(\"Refine plates/jewels\");\n-                        }\n-                        \n-                        for (var i = 0; i < options.length; i++){\n-                            selStr += \"\\r\\n#L\" + i + \"# \" + options[i] + \"#l\";\n-                        }\n-                        \n-                        cm.sendSimple(selStr);\n-                } else if(status == 1) {\n-                        var allDone;\n-                        \n-                        if (selection == 0) {\n-                                allDone = refineItems(0); // minerals\n-                        } else if (selection == 1) {\n-                                allDone = refineItems(1); // jewels\n-                        } else if (selection == 2 && refineCrystals) {\n-                                allDone = refineItems(2); // crystals\n-                        } else if (selection == 2 && !refineCrystals || selection == 3) {\n-                                allDone = refineRockItems(); // moon/star rock\n-                        }\n-                        \n-                        if(allDone) {\n-                            cm.sendOk(\"Done. Thanks for showing up~.\");\n-                        } else {\n-                            cm.sendOk(\"Done. Be aware some of the items could not be synthetized because either you have a lack of space on your ETC inventory or there's not enough mesos to cover the fee.\");\n-                        }\n+            } else if (status == 1) {\n+                switch (rnk) {\n+                    case 10:\n+                        cm.warp(980000000, 0);\n+                        cm.gainExp(17500);\n+                        cm.dispose();\n+                        break;\n+                    case 20:\n+                        cm.warp(980000000, 0);\n+                        cm.gainExp(1200);\n+                        cm.dispose();\n+                        break;\n+                    case 30:\n+                        cm.warp(980000000, 0);\n+                        cm.gainExp(5000);\n                         cm.dispose();\n+                        break;\n+                    case 40:\n+                        cm.warp(980000000, 0);\n+                        cm.gainExp(2500);\n+                        cm.dispose();\n+                        break;\n+                    default:\n+                        cm.warp(980000000, 0);\n+                        cm.dispose();\n+                        break;\n                 }\n-        }\n-}\n-\n-function getRefineFee(fee) {\n-    return ((feeMultiplier * fee) | 0);\n-}\n-\n-function isRefineTarget(refineType, refineItemid) {\n-    if(refineType == 0) { //mineral refine\n-        return refineItemid >= 4010000 && refineItemid <= 4010007 && !(refineItemid == 4010007 && !refineSpecials);\n-    } else if(refineType == 1) { //jewel refine\n-        return refineItemid >= 4020000 && refineItemid <= 4020008 && !(refineItemid == 4020008 && !refineSpecials);\n-    } else if(refineType == 2) { //crystal refine\n-        return refineItemid >= 4004000 && refineItemid <= 4004004 && !(refineItemid == 4004004 && !refineSpecials);\n-    }\n-    \n-    return false;\n-}\n-\n-function getRockRefineTarget(refineItemid) {\n-    if(refineItemid >= 4011000 && refineItemid <= 4011006) {\n-        return 0;\n-    } else if(refineItemid >= 4021000 && refineItemid <= 4021008) {\n-        return 1;\n-    }\n-    \n-    return -1;\n-}\n-\n-function refineItems(refineType) {\n-    var allDone = true;\n-    \n-    var refineFees = [[300,300,300,500,500,500,800,270],[500,500,500,500,500,500,500,1000,3000],[5000,5000,5000,5000,1000000]];\n-    var itemCount = {};\n-    \n-    var iter = cm.getPlayer().getInventory(Packages.client.inventory.MapleInventoryType.ETC).iterator();\n-    while (iter.hasNext()) {\n-        var it = iter.next();\n-        var itemid = it.getItemId();\n-\n-        if(isRefineTarget(refineType, itemid)) {\n-            var ic = itemCount[itemid];\n-            \n-            if(ic != undefined) {\n-                itemCount[itemid] += it.getQuantity();\n-            } else {\n-                itemCount[itemid] = it.getQuantity();\n-            }\n-        }\n-    }\n-    \n-    for(var key in itemCount) {\n-        var itemqty = itemCount[key];\n-        var itemid = parseInt(key);\n-        \n-        var refineQty = ((itemqty / 10) | 0);\n-        if(refineQty <= 0) continue;\n-        \n-        while(true) {\n-            itemqty = refineQty * 10;\n-        \n-            var fee = getRefineFee(refineFees[refineType][(itemid % 100) | 0] * refineQty);\n-            if(cm.canHold(itemid + 1000, refineQty, itemid, itemqty) && cm.getMeso() >= fee) {\n-                cm.gainMeso(-fee);\n-                cm.gainItem(itemid, -itemqty);\n-                cm.gainItem(itemid + (itemid != 4010007 ? 1000 : 1001), refineQty);\n-                \n-                break;\n-            } else if(refineQty <= 1) {\n-                allDone = false;\n-                break;\n-            } else {\n-                refineQty--;\n             }\n-        }\n-    }\n-    \n-    return allDone;\n-}\n-\n-function refineRockItems() {\n-    var allDone = true;\n-    var minItems = [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]];\n-    var minRocks = [2147483647, 2147483647];\n-    \n-    var rockItems = [4011007, 4021009];\n-    var rockFees = [10000, 15000];\n-\n-    var iter = cm.getPlayer().getInventory(Packages.client.inventory.MapleInventoryType.ETC).iterator();\n-    while (iter.hasNext()) {\n-        var it = iter.next();\n-        var itemid = it.getItemId();\n-        var rockRefine = getRockRefineTarget(itemid);\n-        if(rockRefine >= 0) {\n-            var rockItem = ((itemid % 100) | 0);\n-            var itemqty = it.getQuantity();\n-            \n-            minItems[rockRefine][rockItem] += itemqty;\n-        }\n-    }\n-    \n-    for(var i = 0; i < minRocks.length; i++) {\n-        for(var j = 0; j < minItems[i].length; j++) {\n-            if(minRocks[i] > minItems[i][j]) {\n-                minRocks[i] = minItems[i][j];\n+        } else if (cm.getChar().getMap().isCPQWinnerMap()) {\n+            if (status == 0) {\n+                if (cm.getChar().getParty() != null) {\n+                    var shi = \"\";\n+                    if (cm.getPlayer().getFestivalPoints() >= 300) {\n+                        shi += \"#rA#k\";\n+                        rnk = 1;\n+                        cm.sendOk(\"Parab\ufffdns pela sua vit\ufffdria!!! Que \ufffdtima performance! O grupo advers\ufffdrio n\ufffdo p\ufffdde fazer nada! Espero o mesmo bom trabalho da pr\ufffdxima vez!\\r\\n\\r\\n#bNota da Folia de Monstros : \" + shi);\n+                    } else if (cm.getPlayer().getFestivalPoints() >= 100 && cm.getPlayer().getFestivalPoints() < 300) {\n+                        shi += \"#rB#k\";\n+                        rnk = 2;\n+                        cm.sendOk(\"Parab\ufffdns pela sua vit\ufffdria! Isso foi impressionante! Voc\ufffd fez um bom trabalho contra o grupo advers\ufffdrio! S\ufffd mais um pouco, e voc\ufffd definitivamente vai conseguir um A na pr\ufffdxima vez. \\r\\n\\r\\n#bNota da Folia de Monstros : \" + shi);\n+                    } else if (cm.getPlayer().getFestivalPoints() >= 50 && cm.getPlayer().getFestivalPoints() < 100) {\n+                        shi += \"#rC#k\";\n+                        rnk = 3;\n+                        cm.sendOk(\"Parab\ufffdns pela sua vit\ufffdria. Voc\ufffd fez algumas coisas c\ufffd e l\ufffd, mas essa n\ufffdo pode ser considerada uma boa vit\ufffdria. Espero mais de ti da pr\ufffdxima vez.\\r\\n\\r\\n#bNota da Folia de Monstros : \" + shi);\n+                    } else {\n+                        shi += \"#rD#k\";\n+                        rnk = 4;\n+                        cm.sendOk(\"Parab\ufffdns pela sua vit\ufffdria, entretanto sua performance n\ufffdo refletiu muito bem isso. Seja mais ativo na sua pr\ufffdxima participa\ufffd\ufffdo da Folia de Monstros!\\r\\n\\r\\n#bNota da Folia de Monstros : \" + shi);\n+                    }\n+                } else {\n+                    cm.warp(980000000, 0);\n+                    cm.dispose();\n+                }\n+            } else if (status == 1) {\n+                switch (rnk) {\n+                    case 1:\n+                        cm.warp(980000000, 0);\n+                        cm.gainExp(50000);\n+                        cm.dispose();\n+                        break;\n+                    case 2:\n+                        cm.warp(980000000, 0);\n+                        cm.gainExp(25500);\n+                        cm.dispose();\n+                        break;\n+                    case 3:\n+                        cm.warp(980000000, 0);\n+                        cm.gainExp(21000);\n+                        cm.dispose();\n+                        break;\n+                    case 4:\n+                        cm.warp(980000000, 0);\n+                        cm.gainExp(19505);\n+                        cm.dispose();\n+                        break;\n+                    default:\n+                        cm.warp(980000000, 0);\n+                        cm.dispose();\n+                        break;\n+                }\n             }\n-        }\n-        if(minRocks[i] <= 0 || minRocks[i] == 2147483647) continue;\n-        \n-        var refineQty = minRocks[i];\n-        while(true) {\n-            var fee = getRefineFee(rockFees[i] * refineQty);\n-            if(cm.canHold(rockItems[i], refineQty) && cm.getMeso() >= fee) {\n-                cm.gainMeso(-fee);\n+        } else {\n+            if (status == 0) {\n+               // cm.sendSimple(\"O que gostaria de fazer? Se voc\ufffd nunca participou da Folia de Monstros, voc\ufffd precisar\ufffd saber de algumas coisas antes de participar.\\r\\n#b#L0# Ir para o campo da Folia de Monstros 1.#l\\r\\n#L1# Aprender sobre a Folia de Monstros.#l\\r\\n#L2# Trocar #t4001129#.#l\");\n+                cm.sendSimple(\"O que gostaria de fazer? Se voc\ufffd nunca participou da Folia de Monstros, voc\ufffd precisar\ufffd saber de algumas coisas antes de participar.\\r\\n#b#L0# Ir para o campo da Folia de Monstros 1.#l\\r\\n#L3# Ir para o campo da Folia de Monstros 2.#l\\r\\n#L1# Aprender sobre a Folia de Monstros.#l\\r\\n#L2# Trocar #t4001129#.#l\");\n+            } else if (status == 1) {\n+                if (selection == 0) {\n+                    if ((cm.getLevel() > 29 && cm.getLevel() < 51) || cm.getPlayer().isGM()) {\n+                        cm.getChar().saveLocation(\"MONSTER_CARNIVAL\");\n+                        cm.warp(980000000, 0);\n+                        cm.dispose();\n+                        return;\n+                    } else if (cm.getLevel() < 30) {\n+                        cm.sendOk(\"Voc\ufffd precisa ser no m\ufffdnimo n\ufffdvel 30 para participar da Folia de Monstros. Fale comigo quando for forte o bastante.\");\n+                        cm.dispose();\n+                        return;\n+                    } else {\n+                        cm.sendOk(\"Sinto muito, mas apenas os jogadores de n\ufffdvel 30~50 podem participar da Folia de Monstros.\");\n+                        cm.dispose();\n+                        return;\n+                    }\n+                } else if (selection == 1) {\n+                    status = 60;\n+                    cm.sendSimple(\"O que gostaria de fazer?\\r\\n#b#L0# O que \ufffd a Folia de Monstros?#l\\r\\n#L1# Vis\ufffdo geral sobre a Folia de Monstros#l\\r\\n#L2# Informa\ufffd\ufffdes detalhadas sobre a Folia de Monstros#l\\r\\n#L3# Nada, de verdade. Mudei de ideia.#l\");\n+                } else if (selection == 2) {\n+                    cm.sendSimple(\"Lembre-se se voc\ufffd possui #t4001129#, voc\ufffd pode troc\ufffd-las por itens. Tenha certeza que voc\ufffd possui #t4001129# suficientes para o item que voc\ufffd deseja. Selecione o item que voc\ufffd gostaria de troc\ufffd-las! \\r\\n#b#L0# #t1122007#(\" + n1 + \" moedas)#l\\r\\n#L1# #t2041211#(\" + n2 + \" moedas)#l\\r\\n#L2# Armas para Guerreiros#l\\r\\n#L3# Armas para Bruxos#l\\r\\n#L4# Armas para Arqueiros#l\\r\\n#L5# Armas para Gatunos#l\");\n+                } else if (selection == 3) {\n+                    cm.getChar().saveLocation(\"MONSTER_CARNIVAL\");\n+                    cm.warp(980030000, 0);\n+                    cm.dispose();\n+                    return;\n+                }\n \n-                var j;\n-                if(i == 0) {\n-                    for(j = 4011000; j < 4011007; j++) {\n-                        cm.gainItem(j, -refineQty);\n+            } else if (status == 2) {\n+                select = selection;\n+                if (select == 0) {\n+                    if (cm.haveItem(4001129, n1) && cm.canHold(4001129)) {\n+                        cm.gainItem(1122007, 1);\n+                        cm.gainItem(4001129, -n1);\n+                        cm.dispose();\n+                    } else {\n+                        cm.sendOk(\"Verifique e veja se est\ufffdo faltando #b#t4001129##k ou se seu invent\ufffdrio de Equipamentos est\ufffd cheio.\");\n+                        cm.dispose();\n+                    }\n+                } else if (select == 1) {\n+                    if (cm.haveItem(4001129, n2) && cm.canHold(2041211)) {\n+                        cm.gainItem(2041211, 1);\n+                        cm.gainItem(4001129, -n2);\n+                        cm.dispose();\n+                    } else {\n+                        cm.sendOk(\"Verifique e veja se est\ufffdo faltando #b#t4001129##k ou se seu invent\ufffdrio de Uso est\ufffd cheio.\");\n+                        cm.dispose();\n                     }\n-                    cm.gainItem(j, refineQty);\n+                } else if (select == 2) {//S2 Warrior 26 S3 Magician 6 S4 Bowman 6 S5 Thief 8\n+                    status = 10;\n+                    cm.sendSimple(\"Por favor tenha certeza que voc\ufffd possui #t4001129# para a arma que voc\ufffd deseja. Selecione a arma que voc\ufffd gostaria de trocar #t4001129# por. As op\ufffd\ufffdes que tenho s\ufffdo realmente boas, e eu n\ufffdo sou eu que falo \ufffd o povo que diz! \\r\\n#b#L0# #z1302004#(\" + n3 + \" moedas)#l\\r\\n#L1# #z1402006#(\" + n3 + \" moedas)#l\\r\\n#L2# #z1302009#(\" + n4 + \" moedas)#l\\r\\n#L3# #z1402007#(\" + n4 + \" moedas)#l\\r\\n#L4# #z1302010#(\" + n5 + \" moedas)#l\\r\\n#L5# #z1402003#(\" + n5 + \" moedas)#l\\r\\n#L6# #z1312006#(\" + n3 + \" moedas)#l\\r\\n#L7# #z1412004#(\" + n3 + \" moedas)#l\\r\\n#L8# #z1312007#(\" + n4 + \" moedas)#l\\r\\n#L9# #z1412005#(\" + n4 + \" moedas)#l\\r\\n#L10# #z1312008#(\" + n5 + \" moedas)#l\\r\\n#L11# #z1412003#(\" + n5 + \" moedas)#l\\r\\n#L12# Ir para a pr\ufffdxima p\ufffdgina(1/2)#l\");\n+                } else if (select == 3) {\n+                    status = 20;\n+                    cm.sendSimple(\"Selecione a arma que voc\ufffd gostaria de trocar. As armas que eu tenho aqui s\ufffdo extremamente atraentes. Veja voc\ufffd mesmo! \\r\\n#b#L0# #z1372001#(\" + n3 + \" moedas)#l\\r\\n#L1# #z1382018#(\" + n3 + \" moedas)#l\\r\\n#L2# #z1372012#(\" + n4 + \"moedas)#l\\r\\n#L3# #z1382019#(\" + n4 + \"moedas)#l\\r\\n#L4# #z1382001#(\" + n5 + \" moedas)#l\\r\\n#L5# #z1372007#(\" + n5 + \" moedas)#l\");\n+                } else if (select == 4) {\n+                    status = 30;\n+                    cm.sendSimple(\"Selecione a arma que voc\ufffd gostaria de trocar. As armas que eu tenho aqui s\ufffdo extremamente atraentes. Veja voc\ufffd mesmo! \\r\\n#b#L0# #z1452006#(\" + n3 + \" moedas)#l\\r\\n#L1# #z1452007#(\" + n4 + \" moedas)#l\\r\\n#L2# #z1452008#(\" + n5 + \" moedas)#l\\r\\n#L3# #z1462005#(\" + n3 + \" moedas)#l\\r\\n#L4# #z1462006#(\" + n4 + \" moedas)#l\\r\\n#L5# #z1462007#(\" + n5 + \" moedas)#l\");\n+                } else if (select == 5) {\n+                    status = 40;\n+                    cm.sendSimple(\"Selecione a arma que voc\ufffd gostaria de trocar por. As armas que eu tenho s\ufffdo da maior qualidade. Seleciona a mais atraente para voc\ufffd! \\r\\n#b#L0# #z1472013#(\" + n3 + \" moedas)#l\\r\\n#L1# #z1472017#(\" + n4 + \"moedas)#l\\r\\n#L2# #z1472021#(\" + n5 + \" moedas)#l\\r\\n#L3# #z1332014#(\" + n3 + \" moedas)#l\\r\\n#L4# #z1332031#(\" + n4 + \"moedas)#l\\r\\n#L5# #z1332011#(\" + n4 + \"moedas)#l\\r\\n#L6# #z1332016#(\" + n5 + \" moedas)#l\\r\\n#L7# #z1332003#(\" + n5 + \" moedas)#l\");\n+                }\n+            } else if (status == 11) {\n+                if (selection == 12) {\n+                    cm.sendSimple(\"Selecione a arma que voc\ufffd gostaria de trocar. As armas que eu tenho aqui s\ufffdo extremamente \ufffdteis. D\ufffd uma olhada! \\r\\n#b#L0# #z1322015#(\" + n3 + \" moedas)#l\\r\\n#L1# #z1422008#(\" + n3 + \" moedas)#l\\r\\n#L2# #z1322016#(\" + n4 + \"moedas)#l\\r\\n#L3# #z1422007#(\" + n4 + \"moedas)#l\\r\\n#L4# #z1322017#(\" + n5 + \" moedas)#l\\r\\n#L5# #z1422005#(\" + n5 + \" moedas)#l\\r\\n#L6# #z1432003#(\" + n3 + \" moedas)#l\\r\\n#L7# #z1442003#(\" + n3 + \" moedas)#l\\r\\n#L8# #z1432005#(\" + n4 + \"moedas)#l\\r\\n#L9# #z1442009#(\" + n4 + \"moedas)#l\\r\\n#L10# #z1442005#(\" + n5 + \" moedas)#l\\r\\n#L11# #z1432004#(\" + n5 + \" moedas)#l\\r\\n#L12# Voltar para a p\ufffdgina inicial(2/2)#l\");\n                 } else {\n-                    for(j = 4021000; j < 4021009; j++) {\n-                        cm.gainItem(j, -refineQty);\n+                    var item = new Array(1302004, 1402006, 1302009, 1402007, 1302010, 1402003, 1312006, 1412004, 1312007, 1412005, 1312008, 1412003);\n+                    var cost = new Array(n3, n3, n4, n4, n5, n5, n3, n3, n4, n4, n5);\n+                    if (cm.haveItem(4001129, cost[selection]) && cm.canHold(item[selection])) {\n+                        cm.gainItem(item[selection], 1);\n+                        cm.gainItem(4001129, -cost[selection]);\n+                        cm.dispose();\n+                    } else {\n+                        cm.sendOk(\"Voc\ufffd ou n\ufffdo possui #b#t4001129##k suficientes, ou seu invent\ufffdrio est\ufffd cheio. Verifique novamente.\");\n+                        cm.dispose();\n                     }\n-                    cm.gainItem(j, refineQty);\n-                }\n-                \n-                break;\n-            } else if(refineQty <= 1) {\n-                allDone = false;\n-                break;\n-            } else {\n-                refineQty--;\n+                }\n+            } else if (status == 12) {\n+                if (selection == 12) {\n+                    status = 10;\n+                    cm.sendSimple(\"Por favor tenha certeza que voc\ufffd possui #t4001129# para a arma que voc\ufffd deseja. Selecione a arma que voc\ufffd gostaria de trocar #t4001129# por. As op\ufffd\ufffdes que tenho s\ufffdo realmente boas, e eu n\ufffdo sou eu que falo \ufffd o povo que diz! \\r\\n#b#L0# #z1302004#(\" + n3 + \" moedas)#l\\r\\n#L1# #z1402006#(\" + n3 + \" moedas)#l\\r\\n#L2# #z1302009#(\" + n4 + \" moedas)#l\\r\\n#L3# #z1402007#(\" + n4 + \" moedas)#l\\r\\n#L4# #z1302010#(\" + n5 + \" moedas)#l\\r\\n#L5# #z1402003#(\" + n5 + \" moedas)#l\\r\\n#L6# #z1312006#(\" + n3 + \" moedas)#l\\r\\n#L7# #z1412004#(\" + n3 + \" moedas)#l\\r\\n#L8# #z1312007#(\" + n4 + \" moedas)#l\\r\\n#L9# #z1412005#(\" + n4 + \" moedas)#l\\r\\n#L10# #z1312008#(\" + n5 + \" moedas)#l\\r\\n#L11# #z1412003#(\" + n5 + \" moedas)#l\\r\\n#L12# Ir para a pr\ufffdxima p\ufffdgina(1/2)#l\");\n+                } else {\n+                    var item = new Array(1322015, 1422008, 1322016, 1422007, 1322017, 1422005, 1432003, 1442003, 1432005, 1442009, 1442005, 1432004);\n+                    var cost = new Array(n3, n3, n4, n4, n5, n5, n3, n3, n4, n4, n5, n5);\n+                    if (cm.haveItem(4001129, cost[selection]) && cm.canHold(item[selection])) {\n+                        cm.gainItem(item[selection], 1);\n+                        cm.gainItem(4001129, -cost[selection]);\n+                        cm.dispose();\n+                    } else {\n+                        cm.sendOk(\"Voc\ufffd ou n\ufffdo possui #b#t4001129##k suficientes, ou seu invent\ufffdrio est\ufffd cheio. Verifique novamente.\");\n+                        cm.dispose();\n+                    }\n+                }\n+            } else if (status == 21) {\n+                var item = new Array(1372001, 1382018, 1372012, 1382019, 1382001, 1372007);\n+                var cost = new Array(n3, n3, n4, n4, n5, n5);\n+                if (cm.haveItem(4001129, cost[selection]) && cm.canHold(item[selection])) {\n+                    cm.gainItem(item[selection], 1);\n+                    cm.gainItem(4001129, -cost[selection]);\n+                    cm.dispose();\n+                } else {\n+                    cm.sendOk(\"Ou voc\ufffd n\ufffdo possui #b#t4001129##k suficientes, ou seu invent\ufffdrio est\ufffd cheio. Verifique novamente.\");\n+                    cm.dispose();\n+                }\n+            } else if (status == 31) {\n+                var item = new Array(1452006, 1452007, 1452008, 1462005, 1462006, 1462007);\n+                var cost = new Array(n3, n4, n5, n3, n4, n5);\n+                if (cm.haveItem(4001129, cost[selection]) && cm.canHold(item[selection])) {\n+                    cm.gainItem(item[selection], 1);\n+                    cm.gainItem(4001129, -cost[selection]);\n+                    cm.dispose();\n+                } else {\n+                    cm.sendOk(\"Ou voc\ufffd n\ufffdo possui #b#t4001129##k suficientes, ou seu invent\ufffdrio est\ufffd cheio. Verifique novamente.\");\n+                    cm.dispose();\n+                }\n+            } else if (status == 41) {\n+                var item = new Array(1472013, 1472017, 1472021, 1332014, 1332031, 1332011, 1332016, 1332003);\n+                var cost = new Array(n3, n4, n5, n3, n4, n4, n5, n5);\n+                if (cm.haveItem(4001129, cost[selection]) && cm.canHold(item[selection])) {\n+                    cm.gainItem(item[selection], 1);\n+                    cm.gainItem(4001129, -cost[selection]);\n+                    cm.dispose();\n+                } else {\n+                    cm.sendOk(\"Ou voc\ufffd n\ufffdo possui #b#t4001129##k suficientes, ou seu invent\ufffdrio est\ufffd cheio. Verifique novamente.\");\n+                    cm.dispose();\n+                }\n+            } else if (status == 61) {\n+                select = selection;\n+                if (selection == 0) {\n+                    cm.sendNext(\"Haha! Eu sou Spiegelmann, o l\ufffdder dessa Folia. Eu comecei a primeira #bFolia de Monstros#k aqui, aguardando por viajantes como voc\ufffd para participar dessa extravaganza!\");\n+                } else if (selection == 1) {\n+                    cm.sendNext(\"#bFolia de Monstros#k consiste em 2 grupos entrando no campo de batalha, e ca\ufffdando os monstros invocados pelo outro grupo. \ufffd uma #bmiss\ufffdo de combate que determina o vitorioso pela quantia de Pontos de Folia (CP) recebidos#k.\");\n+                } else if (selection == 2) {\n+                    cm.sendNext(\"Quando entrar no Campo da Folia, voc\ufffd ver\ufffd a janela da Folia de Monstros aparecer. Tudo que precisa fazer \ufffd #bselecionar o que voc\ufffde quer usar, e pressionar OK#k. Muito f\ufffdcil, n\ufffd?\");\n+                } else {\n+                    cm.dispose();\n+                }\n+            } else if (status == 62) {\n+                if (select == 0) {\n+                    cm.sendNext(\"O que \ufffd a #bFolia de Monstros#k? Hahaha! Vamos dizer que \ufffd uma experi\ufffdncia que jamais esquecer\ufffd! \ufffd uma #bbatalha contra outros viajantes assim como voc\ufffd!#k\");\n+                } else if (select == 1) {\n+                    cm.sendNext(\"Quando entrar no Campo da Folia, sua tarefa \ufffd #breceber CP ca\ufffdando os monstros do grupo oposto, e usar estes CP's para distrair o grupo oposto de ca\ufffdar monstros.#k.\");\n+                } else if (select == 2) {\n+                    cm.sendNext(\"Assim que se acostumar com os comandos, tente usar #bas teclas TAB e F1 ~ F12#k. #bTAB alterna entre Invoca\ufffd\ufffdo de Monstros/Habilidades/Protetor,#k e, #bF1~ F12 possibilita-o de acessar uma das janelas diretamente#k.\");\n+                }\n+            } else if (status == 63) {\n+                if (select == 0) {\n+                    cm.sendNext(\"Eu sei que \ufffd muito perigoso para voc\ufffds lutarem uns com os outros usando armas de verdade; e eu n\ufffdo sugeriria um ato t\ufffdo barb\ufffdrico. N\ufffdo meu amigo, o que eu ofere\ufffdo \ufffd competi\ufffd\ufffdo. A emo\ufffd\ufffdo da batalha e a emo\ufffd\ufffdo de competir contra pessoas t\ufffdo fortes e motivadas. Eu ofere\ufffdo a premissa de que seu grupo e o grupo oposto ambos #binvoquem os monstros, e derrote os monstros invocados pelo grupo advers\ufffdrio. Essa \ufffd a ess\ufffdncia da Folia de Monstros. Al\ufffdm disso, voc\ufffd pode usar Maple Coins ganhos durante a Folia de Monstros para obter novos itens e armas! #k\");\n+                } else if (select == 1) {\n+                    cm.sendNext(\"Existem 3 maneiras de distrair o grupo advers\ufffdrio: #bInvodar um monstro, Habilidade, and Protetor#k. Vou dar-lhe um olhar mais aprofundado, se voc\ufffd quiser saber mais sobre 'Instru\ufffd\ufffdes detalhadas'.\");\n+                } else if (select == 2) {\n+                    cm.sendNext(\"#bInvocar um Monstro#k chama um monstro que ataca o grupo advers\ufffdrio, sob seu controle. Use CP para trazer um Monstro Invocado, e ele ir\ufffd aparecer na mesma \ufffdrea, atacando o grupo oposto.\");\n+                }\n+            } else if (status == 64) {\n+                if (select == 0) {\n+                    cm.sendNext(\"Claro, n\ufffdo \ufffd t\ufffdo simples assim. Existem outras maneiras de prevenir o outro grupo de ca\ufffdar monstros, e cabe a voc\ufffd descobrir como faz\ufffd-lo. O que acha? Interessado em uma competi\ufffd\ufffdo amig\ufffdvel?\");\n+                    cm.dispose();\n+                } else if (select == 1) {\n+                    cm.sendNext(\"Por favor lembre-se. Nunca \ufffd uma boa ideia guardar seus CP's. #bOs CP's que voc\ufffd usou ir\ufffdo ajudar a determinar o vencedor e o perdedor da Folia.\");\n+                } else if (select == 2) {\n+                    cm.sendNext(\"#bHabilidade#k \ufffd uma op\ufffd\ufffdo de usar habilidades tais como Escurid\ufffdo, Fraqueza, e outras para prevenir o grupo oposto de matar outros monstros. S\ufffdo necess\ufffdrios muitos CP's, mas vale muito a pena. O \ufffdnico problema \ufffd que eles n\ufffdo duram muito. Use essa t\ufffdtica com sabedoria!\");\n+                }\n+            } else if (status == 65) {\n+                if (select == 1) {\n+                    cm.sendNext(\"Oh, e n\ufffdo se preocupe em tranformar-se em um fantasma. Na Folia de Monstros, #bvoc\ufffd n\ufffdo perder\ufffd EXP ap\ufffds a morte#k. \ufffd realmente uma exper\ufffdncia como nenhuma outra!\");\n+                    cm.dispose();\n+                } else if (select == 2) {\n+                    cm.sendNext(\"#bProtetor#k \ufffd basicamente um item invocado que aumenta dr\ufffdsticamente as habilidades dos monstros invocados pelo seu grupo. Protetor funciona enquanto n\ufffdo for demolido pelo grupo oposto, ent\ufffdo eu surigo que voc\ufffd invoque v\ufffdrios monstros primeiro, e ent\ufffdo traga o Protetor.\");\n+                }\n+            } else if (status == 66) {\n+                cm.sendNext(\"Por \ufffdltimo, enquanto estiver na Folia de Monstros, #bvoc\ufffd n\ufffdo pode usar items/po\ufffd\ufffdes de recupera\ufffd\ufffdo que voc\ufffd leva por ai contigo.#k Entretanto, os monstros deixam esses items cair de vez em quando, e #bassim que peg\ufffd-los, o item ativar\ufffd imediatamente#k. \ufffd por isso que \ufffd importante saber quando pegar estes items.\");\n+                cm.dispose();\n             }\n         }\n     }\n-    \n-    return allDone;\n }\n+"}, {"sha": "4a475a35ffcb2fbcda181e7da7d6ac7627632a6f", "filename": "scripts/npc/2042003.js", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/2042003.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/2042003.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/2042003.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -0,0 +1,30 @@\n+var status = 0;\n+var request;\n+\n+function start() {\n+    status = -1;\n+    action(1, 0, 0);\n+}\n+\n+\n+function action(mode, type, selection) {\n+    if (mode == -1) {\n+        cm.dispose();\n+    } else {\n+        if (mode == 0 && status == 0) {\n+            cm.dispose();\n+            return;\n+        }\n+        if (mode == 1)\n+            status++;\n+        else\n+            status--;\n+        if (status == 0) {\n+            cm.warpParty(980000000);\n+            cm.cancelarSaida();\n+            cm.dispose();\n+        }\n+    }\n+}\n+\n+"}, {"sha": "fa5965c5bf785205f75b43e216f7fce9ef844d17", "filename": "scripts/npc/2042004.js", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/2042004.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/2042004.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/2042004.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -0,0 +1,16 @@\n+var status = 0;\n+var request;\n+\n+function start() {\n+    status = -1;\n+    action(1, 0, 0);\n+}\n+\n+\n+function action(mode, type, selection) {\n+    cm.warpParty(980000000);\n+    cm.cancelarSaida();\n+    cm.dispose();\n+}\n+\n+"}, {"sha": "0cf77cbf77e931b0ce3d406a274403c2377c692d", "filename": "scripts/npc/2042005.js", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/2042005.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/2042005.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/2042005.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -0,0 +1,83 @@\n+var map = 980030000;\n+var minLvl = 30;\n+var maxLvl = 255;\n+var minAmt = 0;\n+var maxAmt = 6;\n+\n+function start() {\n+    status = -1;\n+    action(1, 0, 0);\n+}\n+\n+function action(mode, type, selection) {\n+    if (mode == -1) {\n+        cm.dispose();\n+    } else {\n+        if (mode == 0 && status == 0) {\n+            cm.dispose();\n+            return;\n+        }\n+        if (mode == 1)\n+            status++;\n+        else\n+            status--;\n+        if (status == 0) {\n+            if (cm.getParty() == null) {\n+                status = 10;\n+                cm.sendOk(\"#e\ufffd necess\ufffdrio criar um grupo antes de come\ufffdar o Festival de Monstros!#k\");\n+            } else if (!cm.isLeader()) {\n+                status = 10;\n+                cm.sendOk(\"Se voc\ufffd quer come\ufffdar o Festival, avise o #bl\ufffdder do grupo#k para falar comigo.\");\n+            } else {\n+                var party = cm.getParty().getMembers();\n+                var inMap = cm.partyMembersInMap();\n+                var lvlOk = 0;\n+                var isInMap = 0;\n+                for (var i = 0; i < party.size(); i++) {\n+                    if (party.get(i).getLevel() >= minLvl && party.get(i).getLevel() <= maxLvl) {\n+                        lvlOk++;\n+                    }\n+                    if (party.get(i).getPlayer().getMapId()!= 980030000) {\n+                        //isInMap = false;\n+                        isInMap++\n+                    }\n+                }\n+\n+                if (party >= 1) {\n+                    status = 10;\n+                    cm.sendOk(\"Voc\ufffd n\ufffdo tem n\ufffdmero suficiente de pessoas em seu grupo. Voc\ufffd precisa de um grupo com #b\" + minAmt + \"#k - #r\" + maxAmt + \"#k membros e eles devem estar no mapa com voc\ufffd.\");\n+                } else if (lvlOk != inMap) {\n+                    status = 10;\n+                    cm.sendOk(\"Certifique se todos em seu grupo est\ufffdo dentre os n\ufffdveis corretos (\" + minLvl + \"~\" + maxLvl + \")!\");\n+                } else if (isInMap > 0) {\n+                    status = 10;\n+                    cm.sendOk(\"Existe algu\ufffdm do grupo que n\ufffdo esta no mapa!\");\n+                } else {\n+                    cm.sendCPQMapLists2();\n+                }\n+            }\n+        } else if (status == 1) {\n+            if (cm.fieldTaken2(selection)) {\n+                if (cm.fieldLobbied2(selection)) {\n+                    cm.challengeParty2(selection);\n+                    cm.dispose();\n+                } else {\n+                    cm.sendOk(\"A sala esta cheia.\");\n+                    cm.dispose();\n+                }\n+            } else {\n+                var party = cm.getParty().getMembers();\n+                if ((selection === 0 || selection === 1 ) && party.size() < 2) {\n+                    cm.sendOk(\"Voc\ufffd precisa de no m\ufffdnimo 2 player para entrar na competi\ufffd\ufffdo.\");\n+                } else if ((selection === 2 ) && party.size() < 3) {\n+                    cm.sendOk(\"Voc\ufffd precisa de no m\ufffdnimo 3 player para entrar na competi\ufffd\ufffdo.\");\n+                } else {\n+                    cm.cpqLobby2(selection);\n+                }\n+                cm.dispose();\n+            }\n+        } else if (status == 11) {\n+            cm.dispose();\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "722f0229dc5fc825ab9a55c177ca65fddfb016b4", "filename": "scripts/npc/2042007.js", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/2042007.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/2042007.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/2042007.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -0,0 +1,132 @@\n+importPackage(net.sf.odinms.server.maps);\n+\n+var status = 0;\n+var rnk = -1;\n+\n+function start() {\n+    status = -1;\n+    action(1, 0, 0);\n+}\n+\n+function action(mode, type, selection) {\n+    if (mode == -1) {\n+        cm.dispose();\n+    } else {\n+        if (status >= 0 && mode == 0) {\n+            cm.sendOk(\"Alright then, I hope we can chat later next time.\");\n+            cm.dispose();\n+            return;\n+        }\n+        if (mode == 1)\n+            status++;\n+        else\n+            status--;\n+        if (cm.getChar().getMap().isCPQLoserMap()) {\n+            if (status == 0) {\n+                if (cm.getChar().getParty() != null) {\n+                    var shiu = \"\";\n+                    if (cm.getPlayer().getFestivalPoints() >= 100) {\n+                        shiu += \"#rA#k\";\n+                        cm.sendOk(\"Infelizmente, voc\ufffd ou empatou ou perdeu a batalha, apesar da sua excelente performance. A vit\ufffdria pode ser sua da pr\ufffdxima vez.\\r\\n\\r\\n#bNota da Folia de Monstros : \" + shiu);\n+                        rnk = 10;\n+                    } else if (cm.getPlayer().getFestivalPoints() >= 50 && cm.getPlayer().getFestivalPoints() < 100) {\n+                        shiu += \"#rB#k\";\n+                        rnk = 20;\n+                        cm.sendOk(\"Infelizmente, voc\ufffd ou empatou ou perdeu a batalha, mesmo com sua \ufffdtima performance. S\ufffd mais um pouquinho, e a vit\ufffdria poderia ter sido sua.\\r\\n\\r\\n#bNota da Folia de Monstros : \" + shiu);\n+                    } else if (cm.getPlayer().getFestivalPoints() >= 30 && cm.getPlayer().getFestivalPoints() < 50) {\n+                        shiu += \"#rC#k\";\n+                        rnk = 30;\n+                        cm.sendOk(\"Infelizmente, voc\ufffd ou empatou ou perdeu a batalha. A vit\ufffdria est\ufffd para aqueles que se esfor\ufffdam. Vejo seus esfor\ufffdos, ent\ufffdo a vit\ufffdria n\ufffdo est\ufffd t\ufffdo longe do seu alcance. Continue assim!\\r\\n\\r\\n#bNota da Folia de Monstros : \" + shiu);\n+                    } else {\n+                        shiu += \"#rD#k\";\n+                        rnk = 40;\n+                        cm.sendOk(\"Infelizmente, voc\ufffd ou empatou ou perdeu a batalha, e sua performance claramente reflete nisso. Espero mais de voc\ufffd da pr\ufffdxima vez.\\r\\n\\r\\n#bNota da Folia de Monstros : \" + shiu);\n+                    }\n+                } else {\n+                    cm.warp(980030000, 0);\n+                    cm.dispose();\n+                }\n+            } else if (status == 1) {\n+                switch (rnk) {\n+                    case 10:\n+                        cm.warp(980030000, 0);\n+                        cm.gainExp(35000);\n+                        cm.dispose();\n+                        break;\n+                    case 20:\n+                        cm.warp(980030000, 0);\n+                        cm.gainExp(25000);\n+                        cm.dispose();\n+                        break;\n+                    case 30:\n+                        cm.warp(980030000, 0);\n+                        cm.gainExp(12500);\n+                        cm.dispose();\n+                        break;\n+                    case 40:\n+                        cm.warp(980030000, 0);\n+                        cm.gainExp(3500);\n+                        cm.dispose();\n+                        break;\n+                    default:\n+                        cm.warp(980030000, 0);\n+                        cm.dispose();\n+                        break;\n+                }\n+            }\n+        } else if (cm.getChar().getMap().isCPQWinnerMap()) {\n+            if (status == 0) {\n+                if (cm.getChar().getParty() != null) {\n+                    var shi = \"\";\n+                    if (cm.getPlayer().getFestivalPoints() >= 300) {\n+                        shi += \"#rA#k\";\n+                        rnk = 1;\n+                        cm.sendOk(\"Parab\ufffdns pela sua vit\ufffdria!!! Que \ufffdtima performance! O grupo advers\ufffdrio n\ufffdo p\ufffdde fazer nada! Espero o mesmo bom trabalho da pr\ufffdxima vez!\\r\\n\\r\\n#bNota da Folia de Monstros : \" + shi);\n+                    } else if (cm.getPlayer().getFestivalPoints() >= 100 && cm.getPlayer().getFestivalPoints() < 300) {\n+                        shi += \"#rB#k\";\n+                        rnk = 2;\n+                        cm.sendOk(\"Parab\ufffdns pela sua vit\ufffdria! Isso foi impressionante! Voc\ufffd fez um bom trabalho contra o grupo advers\ufffdrio! S\ufffd mais um pouco, e voc\ufffd definitivamente vai conseguir um A na pr\ufffdxima vez. \\r\\n\\r\\n#bNota da Folia de Monstros : \" + shi);\n+                    } else if (cm.getPlayer().getFestivalPoints() >= 50 && cm.getPlayer().getFestivalPoints() < 100) {\n+                        shi += \"#rC#k\";\n+                        rnk = 3;\n+                        cm.sendOk(\"Parab\ufffdns pela sua vit\ufffdria. Voc\ufffd fez algumas coisas c\ufffd e l\ufffd, mas essa n\ufffdo pode ser considerada uma boa vit\ufffdria. Espero mais de ti da pr\ufffdxima vez.\\r\\n\\r\\n#bNota da Folia de Monstros : \" + shi);\n+                    } else {\n+                        shi += \"#rD#k\";\n+                        rnk = 4;\n+                        cm.sendOk(\"Parab\ufffdns pela sua vit\ufffdria, entretanto sua performance n\ufffdo refletiu muito bem isso. Seja mais ativo na sua pr\ufffdxima participa\ufffd\ufffdo da Folia de Monstros!\\r\\n\\r\\n#bNota da Folia de Monstros : \" + shi);\n+                    }\n+                } else {\n+                    cm.warp(980030000, 0);\n+                    cm.dispose();\n+                }\n+            } else if (status == 1) {\n+                switch (rnk) {\n+                    case 1:\n+                        cm.warp(980030000, 0);\n+                        cm.gainExp(875000);\n+                        cm.dispose();\n+                        break;\n+                    case 2:\n+                        cm.warp(980030000, 0);\n+                        cm.gainExp(700000);\n+                        cm.dispose();\n+                        break;\n+                    case 3:\n+                        cm.warp(980030000, 0);\n+                        cm.gainExp(555000);\n+                        cm.dispose();\n+                        break;\n+                    case 4:\n+                        cm.warp(980030000, 0);\n+                        cm.gainExp(100000);\n+                        cm.dispose();\n+                        break;\n+                    default:\n+                        cm.warp(980030000, 0);\n+                        cm.dispose();\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+}  \n\\ No newline at end of file"}, {"sha": "d8ec8d846561cf6e6d76c9d3da8b36fb6be55c7a", "filename": "scripts/npc/2042008.js", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/2042008.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/2042008.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/2042008.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -0,0 +1,30 @@\n+var status = 0;\n+var request;\n+\n+function start() {\n+    status = -1;\n+    action(1, 0, 0);\n+}\n+\n+\n+function action(mode, type, selection) {\n+    if (mode == -1) {\n+        cm.dispose();\n+    } else {\n+        if (mode == 0 && status == 0) {\n+            cm.dispose();\n+            return;\n+        }\n+        if (mode == 1)\n+            status++;\n+        else\n+            status--;\n+        if (status == 0) {\n+            cm.warpParty(980030000, 4);\n+            cm.cancelarSaida();\n+            cm.dispose();\n+        }\n+    }\n+}\n+\n+"}, {"sha": "d8ec8d846561cf6e6d76c9d3da8b36fb6be55c7a", "filename": "scripts/npc/2042009.js", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/2042009.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/2042009.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/2042009.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -0,0 +1,30 @@\n+var status = 0;\n+var request;\n+\n+function start() {\n+    status = -1;\n+    action(1, 0, 0);\n+}\n+\n+\n+function action(mode, type, selection) {\n+    if (mode == -1) {\n+        cm.dispose();\n+    } else {\n+        if (mode == 0 && status == 0) {\n+            cm.dispose();\n+            return;\n+        }\n+        if (mode == 1)\n+            status++;\n+        else\n+            status--;\n+        if (status == 0) {\n+            cm.warpParty(980030000, 4);\n+            cm.cancelarSaida();\n+            cm.dispose();\n+        }\n+    }\n+}\n+\n+"}, {"sha": "aa7e970fee49fc10ac3cd0493f6f103673096c88", "filename": "scripts/npc/9201002.js", "status": "modified", "additions": 97, "deletions": 88, "changes": 185, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/9201002.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/9201002.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/9201002.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -1,24 +1,24 @@\n /*\n-    This file is part of the HeavenMS MapleStory Server\n-    Copyleft (L) 2017 RonanLana\n-\n-    This program is free software: you can redistribute it and/or modify\n-    it under the terms of the GNU Affero General Public License as\n-    published by the Free Software Foundation version 3 as published by\n-    the Free Software Foundation. You may not use, modify or distribute\n-    this program under any other version of the GNU Affero General Public\n-    License.\n-\n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU Affero General Public License for more details.\n-\n-    You should have received a copy of the GNU Affero General Public License\n-    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-*/\n+ This file is part of the HeavenMS MapleStory Server\n+ Copyleft (L) 2017 RonanLana\n+ \n+ This program is free software: you can redistribute it and/or modify\n+ it under the terms of the GNU Affero General Public License as\n+ published by the Free Software Foundation version 3 as published by\n+ the Free Software Foundation. You may not use, modify or distribute\n+ this program under any other version of the GNU Affero General Public\n+ License.\n+ \n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU Affero General Public License for more details.\n+ \n+ You should have received a copy of the GNU Affero General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n /* High Priest John\n-\tMarriage NPC\n+ Marriage NPC\n  */\n \n importPackage(Packages.constants);\n@@ -40,14 +40,14 @@ function isWeddingIndoors(mapid) {\n \n function getMarriageInstance(player) {\n     var em = cm.getEventManager(weddingEventName);\n-    \n-    for (var iterator = em.getInstances().iterator(); iterator.hasNext();) {\n+\n+    for (var iterator = em.getInstances().iterator(); iterator.hasNext(); ) {\n         var eim = iterator.next();\n-        if(eim.isEventLeader(player)) {\n+        if (eim.isEventLeader(player)) {\n             return eim;\n         }\n     }\n-    \n+\n     return null;\n }\n \n@@ -57,7 +57,7 @@ function detectPlayerItemid(player) {\n             return x;\n         }\n     }\n-    \n+\n     return -1;\n }\n \n@@ -67,39 +67,44 @@ function getRingId(boxItemId) {\n \n function isSuitedForWedding(player, equipped) {\n     var baseid = (player.getGender() == 0) ? 1050131 : 1051150;\n-    \n-    if(equipped) {\n-        for(var i = 0; i < 4; i++) {\n-            if(player.haveItemEquipped(baseid + i)) {\n+\n+    if (equipped) {\n+        for (var i = 0; i < 4; i++) {\n+            if (player.haveItemEquipped(baseid + i)) {\n                 return true;\n             }\n         }\n     } else {\n-        for(var i = 0; i < 4; i++) {\n-            if(player.haveItemWithId(baseid + i, true)) {\n+        for (var i = 0; i < 4; i++) {\n+            if (player.haveItemWithId(baseid + i, true)) {\n                 return true;\n             }\n         }\n     }\n-    \n+\n     return false;\n }\n \n function getWeddingPreparationStatus(player, partner) {\n-    if(!player.haveItem(4000313)) return -3;\n-    if(!partner.haveItem(4000313)) return 3;\n-    \n-    if(!isSuitedForWedding(player, true)) return -4;\n-    if(!isSuitedForWedding(partner, true)) return 4;\n-    \n+    if (!player.haveItem(4000313))\n+        return -3;\n+    if (!partner.haveItem(4000313))\n+        return 3;\n+\n+    if (!isSuitedForWedding(player, true))\n+        return -4;\n+    if (!isSuitedForWedding(partner, true))\n+        return 4;\n+\n     var hasEngagement = false;\n     for (var x = 4031357; x <= 4031364; x++) {\n         if (player.haveItem(x)) {\n             hasEngagement = true;\n             break;\n         }\n     }\n-    if(!hasEngagement) return -1;\n+    if (!hasEngagement)\n+        return -1;\n \n     hasEngagement = false;\n     for (var x = 4031357; x <= 4031364; x++) {\n@@ -108,24 +113,28 @@ function getWeddingPreparationStatus(player, partner) {\n             break;\n         }\n     }\n-    if(!hasEngagement) return -2;\n+    if (!hasEngagement)\n+        return -2;\n \n-    if(!player.canHold(1112803)) return 1;\n-    if(!partner.canHold(1112803)) return 2;\n+    if (!player.canHold(1112803))\n+        return 1;\n+    if (!partner.canHold(1112803))\n+        return 2;\n \n     return 0;\n }\n \n function giveCoupleBlessings(eim, player, partner) {\n     var blessCount = eim.gridSize();\n-    \n+\n     player.gainExp(blessCount * weddingBlessingExp);\n     partner.gainExp(blessCount * weddingBlessingExp);\n }\n \n-function start() {  \n+function start() {\n     weddingIndoors = isWeddingIndoors(cm.getMapId());\n-    if(weddingIndoors) eim = cm.getEventInstance();\n+    if (weddingIndoors)\n+        eim = cm.getEventInstance();\n \n     status = -1;\n     action(1, 0, 0);\n@@ -144,8 +153,8 @@ function action(mode, type, selection) {\n         else\n             status--;\n \n-        if(!weddingIndoors) {\n-            if(status == 0) {\n+        if (!weddingIndoors) {\n+            if (status == 0) {\n                 var hasEngagement = false;\n                 for (var x = 4031357; x <= 4031364; x++) {\n                     if (cm.haveItem(x, 1)) {\n@@ -154,7 +163,7 @@ function action(mode, type, selection) {\n                     }\n                 }\n \n-                if(hasEngagement) {\n+                if (hasEngagement) {\n                     var text = \"Hi there. How can I help you?\";\n                     var choice = new Array(\"We're ready to get married.\");\n                     for (x = 0; x < choice.length; x++) {\n@@ -165,32 +174,32 @@ function action(mode, type, selection) {\n                     cm.sendOk(\"Hmm, today two fluttering hearts are about to be joined together by the blessings of love!\");\n                     cm.dispose();\n                 }\n-            } else if(status == 1) {\n+            } else if (status == 1) {\n                 var wid = cm.getClient().getWorldServer().getRelationshipId(cm.getPlayer().getId());\n                 var cserv = cm.getClient().getChannelServer();\n \n-                if(cserv.isWeddingReserved(wid)) {\n-                    if(wid == cserv.getOngoingWedding(cathedralWedding)) {\n+                if (cserv.isWeddingReserved(wid)) {\n+                    if (wid == cserv.getOngoingWedding(cathedralWedding)) {\n                         var partner = cserv.getPlayerStorage().getCharacterById(cm.getPlayer().getPartnerId());\n-                        if(!(partner == null || !cm.getMap().equals(partner.getMap()))) {\n-                            if(!cm.canHold(4000313)) {\n+                        if (!(partner == null || !cm.getMap().equals(partner.getMap()))) {\n+                            if (!cm.canHold(4000313)) {\n                                 cm.sendOk(\"Please have a free ETC slot available to get the #b#t4000313##k.\");\n                                 cm.dispose();\n                                 return;\n-                            } else if(!partner.canHold(4000313)) {\n+                            } else if (!partner.canHold(4000313)) {\n                                 cm.sendOk(\"Please let your partner know they must have a free ETC slot available to get the #b#t4000313##k.\");\n                                 cm.dispose();\n                                 return;\n-                            } else if(!isSuitedForWedding(cm.getPlayer(), false)) {\n+                            } else if (!isSuitedForWedding(cm.getPlayer(), false)) {\n                                 cm.sendOk(\"Please purchase a #rwedding garment#k for the ceremony, quickly! Without it I am not able to marry you.\");\n                                 cm.dispose();\n                                 return;\n-                            } else if(!isSuitedForWedding(partner, false)) {\n+                            } else if (!isSuitedForWedding(partner, false)) {\n                                 cm.sendOk(\"Please let your partner know they must have a #rwedding garment#k ready for the ceremony.\");\n                                 cm.dispose();\n                                 return;\n                             }\n-                            \n+\n                             cm.sendOk(\"Very well, the preparatives here are finished too. This indeed is a beautiful day, you two are truly blessed to marry on such a day. Let us begin the marriage!!\");\n                         } else {\n                             cm.sendOk(\"Hmm, it seems your partner is elsewhere... Please let them come here before starting the ceremony.\");\n@@ -206,19 +215,19 @@ function action(mode, type, selection) {\n                     cm.sendOk(\"Hmm, I'm sorry but there are no reservations made for you at this channel for the time being.\");\n                     cm.dispose();\n                 }\n-            } else if(status == 2) {\n+            } else if (status == 2) {\n                 var cserv = cm.getClient().getChannelServer();\n                 var wtype = cserv.getOngoingWeddingType(cathedralWedding);\n-                \n+\n                 var partner = cserv.getPlayerStorage().getCharacterById(cm.getPlayer().getPartnerId());\n-                if(!(partner == null || !cm.getMap().equals(partner.getMap()))) {\n-                    if(cserv.acceptOngoingWedding(cathedralWedding)) {\n+                if (!(partner == null || !cm.getMap().equals(partner.getMap()))) {\n+                    if (cserv.acceptOngoingWedding(cathedralWedding)) {\n                         var wid = cm.getClient().getWorldServer().getRelationshipId(cm.getPlayer().getId());\n-                        if(wid > 0) {\n+                        if (wid > 0) {\n                             var em = cm.getEventManager(weddingEventName);\n-                            if(em.startInstance(cm.getPlayer())) {\n+                            if (em.startInstance(cm.getPlayer())) {\n                                 eim = getMarriageInstance(cm.getPlayer());\n-                                if(eim != null) {\n+                                if (eim != null) {\n                                     eim.setIntProperty(\"weddingId\", wid);\n                                     eim.setIntProperty(\"groomId\", cm.getPlayer().getId());\n                                     eim.setIntProperty(\"brideId\", cm.getPlayer().getPartnerId());\n@@ -248,20 +257,20 @@ function action(mode, type, selection) {\n             }\n         } else {\n             if (status == 0) {\n-                if(eim == null) {\n-                    cm.warp(680000000,0);\n+                if (eim == null) {\n+                    cm.warp(680000000, 0);\n                     cm.dispose();\n                     return;\n                 }\n-                \n+\n                 var playerId = cm.getPlayer().getId();\n-                if(playerId == eim.getIntProperty(\"groomId\") || playerId == eim.getIntProperty(\"brideId\")) {\n+                if (playerId == eim.getIntProperty(\"groomId\") || playerId == eim.getIntProperty(\"brideId\")) {\n                     var wstg = eim.getIntProperty(\"weddingStage\");\n-                    \n-                    if(wstg == 2) {\n+\n+                    if (wstg == 2) {\n                         cm.sendYesNo(\"Very well, the guests has bestowed all their blessings to you now. The time has come, #rshould I make you Husband and Wife#k?\");\n                         state = 1;\n-                    } else if(wstg == 1) {\n+                    } else if (wstg == 1) {\n                         cm.sendOk(\"While you two are making your wedding vows to each other, your guests are currently giving their blessings to you. This is a time of happiness for both of you, please rejoice the ceremony.\");\n                         cm.dispose();\n                     } else {\n@@ -270,20 +279,20 @@ function action(mode, type, selection) {\n                     }\n                 } else {\n                     var wstg = eim.getIntProperty(\"weddingStage\");\n-                    if(wstg == 1) {\n-                        if(eim.gridCheck(cm.getPlayer()) != -1) {\n+                    if (wstg == 1) {\n+                        if (eim.gridCheck(cm.getPlayer()) != -1) {\n                             cm.sendOk(\"Everyone give your blessings to this lovely couple!\");\n                             cm.dispose();\n                         } else {\n-                            if(eim.getIntProperty(\"guestBlessings\") == 1) {\n+                            if (eim.getIntProperty(\"guestBlessings\") == 1) {\n                                 cm.sendYesNo(\"Do you want to bless this couple?\");\n                                 state = 0;\n                             } else {\n                                 cm.sendOk(\"Today we are gathered here to reunite this lively couple in matrimony!\");\n                                 cm.dispose();\n                             }\n                         }\n-                    } else if(wstg == 3) {\n+                    } else if (wstg == 3) {\n                         cm.sendOk(\"The two loving birds are now married. What a lively day! Please #rget ready for the afterparty#k, it should start soon. Follow the married couple's lead.\");\n                         cm.dispose();\n                     } else {\n@@ -292,10 +301,10 @@ function action(mode, type, selection) {\n                     }\n                 }\n             } else if (status == 1) {\n-                if(state == 0) {    // give player blessings\n+                if (state == 0) {    // give player blessings\n                     eim.gridInsert(cm.getPlayer(), 1);\n-                    \n-                    if(ServerConstants.WEDDING_BLESSER_SHOWFX) {\n+\n+                    if (ServerConstants.WEDDING_BLESSER_SHOWFX) {\n                         var target = cm.getPlayer();\n                         target.announce(MaplePacketCreator.showSpecialEffect(9));\n                         target.getMap().broadcastMessage(target, MaplePacketCreator.showForeignEffect(target.getId(), 9), false);\n@@ -308,30 +317,30 @@ function action(mode, type, selection) {\n                         target.announce(MaplePacketCreator.showSpecialEffect(9));\n                         target.getMap().broadcastMessage(target, MaplePacketCreator.showForeignEffect(target.getId(), 9), false);\n                     }\n-                    \n+\n                     cm.sendOk(\"Your blessings have been added to their love. What a noble act for a lovely couple!\");\n                     cm.dispose();\n                 } else {            // couple wants to complete the wedding\n                     var wstg = eim.getIntProperty(\"weddingStage\");\n-                    \n-                    if(wstg == 2) {\n+\n+                    if (wstg == 2) {\n                         var pid = cm.getPlayer().getPartnerId();\n-                        if(pid <= 0) {\n+                        if (pid <= 0) {\n                             cm.sendOk(\"It seems you are no longer engaged to your partner, just before the altar... Where did all that happiness you two had sported a while ago went?\");\n                             cm.dispose();\n                             return;\n                         }\n \n                         var player = cm.getPlayer();\n                         var partner = cm.getMap().getCharacterById(cm.getPlayer().getPartnerId());\n-                        if(partner != null) {\n+                        if (partner != null) {\n                             state = getWeddingPreparationStatus(player, partner);\n \n-                            switch(state) {\n+                            switch (state) {\n                                 case 0:\n                                     var pid = eim.getIntProperty(\"confirmedVows\");\n-                                    if(pid != -1) {\n-                                        if(pid == player.getId()) {\n+                                    if (pid != -1) {\n+                                        if (pid == player.getId()) {\n                                             cm.sendOk(\"You have already confirmed your vows. All that is left is for your partner to confirm now.\");\n                                         } else {\n                                             eim.setIntProperty(\"weddingStage\", 3);\n@@ -362,7 +371,7 @@ function action(mode, type, selection) {\n                                         eim.setIntProperty(\"confirmedVows\", player.getId());\n                                         cm.getMap().dropMessage(6, \"Wedding Assistant: \" + player.getName() + \" has confirmed vows! Alright, one step away to make it official. Tighten your seatbelts!\");\n                                     }\n-                                    \n+\n                                     break;\n \n                                 case -1:\n@@ -376,7 +385,7 @@ function action(mode, type, selection) {\n                                 case -3:\n                                     cm.sendOk(\"It seems you don't have the #r#t4000313##k given at the entrance... Please find it, I can't marry you without that item in hands.\");\n                                     break;\n-                                    \n+\n                                 case -4:\n                                     cm.sendOk(\"Pardon my rudiness, but the garments are a essential part of the ceremony. Please #rsuit yourself properly#k for a wedding.\");\n                                     break;\n@@ -392,7 +401,7 @@ function action(mode, type, selection) {\n                                 case 3:\n                                     cm.sendOk(\"It seems your partner don't have the #r#t4000313##k given at the entrance... Please find it, I can't marry you without that item in hands.\");\n                                     break;\n-                                \n+\n                                 case 4:\n                                     cm.sendOk(\"It seems your partner is not properly dressed for the wedding... Pardon my rudiness, but the garments are a essential part of the ceremony.\");\n                                     break;"}, {"sha": "ec23bcf5fb7c3a38137346008b3c49cdb17287a1", "filename": "scripts/npc/9201006.js", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/9201006.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/9201006.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/9201006.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -50,6 +50,7 @@ function action(mode, type, selection) {\n     var eim = cm.getEventInstance();\n     if(eim == null) {\n         cm.warp(680000000,0);\n+        //cm.criarLista();\n         cm.dispose();\n         return;\n     }\n@@ -71,7 +72,7 @@ function action(mode, type, selection) {\n                     cm.sendOk(\"Congratulations on your wedding. Please talk to #b#p9201007##k to start the afterparty.\");\n                     cm.dispose();\n                 } else if(hasEngagement) {\n-                    cm.sendOk(\"Please continue with the wedding.\");\n+                    cm.criarLista();\n                     cm.dispose();\n                 } else {\n                     cm.sendOk(\"You do not have the required item to continue through this wedding. Unfortunately, it's over...\");"}, {"sha": "7d1bc9da2f7e0545e9bcd2c771dc40e734005d38", "filename": "scripts/npc/9201014.js", "status": "modified", "additions": 9, "deletions": 59, "changes": 68, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/9201014.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/9201014.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/9201014.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -27,75 +27,25 @@\n \t1.0 - First Version by Angel\n         2.0 - Second Version by happydud3 & XotiCraze\n         3.0 - Third Version by RonanLana (HeavenMS)\n+        4.0 - Four Version bby Drago(MapleStorySA)\n ---------------------------------------------------------------------------------------------------\n **/\n-\n-var bgPrizes = [[2022179,10], [2022282,10], [2210005,5], [2210003,5]];\n-var cmPrizes = [[2022011,10], [2000005,50], [2022273,10], [2022179,3]];\n-\n-var status;\n+var status = -1;\n \n function start() {\n     status = -1;\n     action(1, 0, 0);\n }\n \n-function action(mode, type, selection) { \n-    if (mode == -1 || mode == 0) {\n-        cm.sendOk(\"Goodbye then.\"); \n-        cm.dispose();\n-        return;\n-    } else if (mode == 1) {\n+function action(mode, type, selection) {\n+    if (mode == 1) {\n         status++;\n     } else {\n-        status--;\n+        cm.dispose();\n+        return;\n     }\n-\t\t\n     if (status == 0) {\n-        var msg = \"Hello I exchange Onyx Chest for Bride and Groom and the Onyx Chest for prizes!#b\";\n-        var choice1 = new Array(\"I have an Onyx Chest for Bride and Groom\", \"I have an Onyx Chest\");\n-        for (var i = 0; i < choice1.length; i++) {\n-            msg += \"\\r\\n#L\" + i + \"#\" + choice1[i] + \"#l\";\n-        }\n-        cm.sendSimple(msg);\n-    } else if (status == 1) {\n-        if (selection == 0) {\n-            if (cm.haveItem(4031424)) {\n-                if (cm.getPlayer().isMarried()) {   // thanks MedicOP for solving an issue here\n-                    if(cm.getInventory(2).getNextFreeSlot() >= 0) {\n-                        var rand = Math.floor(Math.random() * bgPrizes.length);\n-                        cm.gainItem(bgPrizes[rand][0], bgPrizes[rand][1]);\n-\n-                        cm.gainItem(4031424,-1);\n-                        cm.dispose();\n-                    } else {\n-                        cm.sendOk(\"You don't have a free USE slot right now.\");\n-                        cm.dispose();\n-                    }\n-                } else {\n-                    cm.sendOk(\"You must be married to claim the prize for this box.\");\n-                    cm.dispose();\n-                }\n-            } else {\n-                cm.sendOk(\"You don't have an Onyx Chest for Bride and Groom.\");\n-                cm.dispose();\n-            }\n-        } else if (selection == 1) {\n-            if (cm.haveItem(4031423)) {\n-                if(cm.getInventory(2).getNextFreeSlot() >= 0) {\n-                    var rand = Math.floor(Math.random() * cmPrizes.length);\n-                    cm.gainItem(cmPrizes[rand][0], cmPrizes[rand][1]);\n-\n-                    cm.gainItem(4031423,-1);\n-                    cm.dispose();\n-                } else {\n-                    cm.sendOk(\"You don't have a free USE slot right now.\");\n-                    cm.dispose();\n-                }\n-            } else {\n-                cm.sendOk(\"You don't have an Onyx Chest.\");\n-                cm.dispose();\n-            }\n-        }\n+        cm.enviarLista();\n+        cm.dispose();\n     }\n-} \n+}\n\\ No newline at end of file"}, {"sha": "2a1fe89c04efab92dc663fddebdebe987e7d700f", "filename": "scripts/npc/cpqchallenge.js", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/cpqchallenge.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/cpqchallenge.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/cpqchallenge.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -0,0 +1,54 @@\n+/* global cm */\n+\n+var status = 0;\n+var party;\n+\n+function start(chrs) {\n+    status = -1;\n+    party = chrs;\n+    action(1, 0, 0);\n+}\n+\n+function action(mode, type, selection) {\n+    if (mode == -1) {\n+        cm.getChar().setChallenged(false);\n+        cm.dispose();\n+    } else {\n+        if (mode == 0) {\n+            cm.sendOk(\"Come back once you have thought about it some more.\");\n+            cm.getChar().setChallenged(false);\n+            cm.dispose();\n+            return;\n+        }\n+    }\n+    if (mode == -1)\n+        cm.dispose();\n+    else {\n+        if (mode == 1)\n+            status++;\n+        else\n+            status--;\n+        if (status == 0) {\n+            if (cm.getParty().getMembers().size() == party.size()) {\n+                cm.getPlayer().setChallenged(true);\n+                var snd = \"\";\n+                for (var i = 0; i < party.size(); i++)\n+                    snd += \"#bNome: \" + party.get(i).getName() + \" / (Level: \" + party.get(i).getLevel() + \") / \" + party.get(i).getJobNameById(party.get(i).getJobId()) + \"#k\\r\\n\\r\\n\";\n+                cm.sendAcceptDecline(snd + \"Gostaria de lutar contra este grupo no Festival de Monstros?\");\n+            } else {\n+                return;\n+            }\n+        } else if (status == 1) {\n+            var ch = cm.getChrById(party.get(0).getId());\n+            if (party.size() == cm.getParty().getMembers().size()) {\n+                cm.startCPQ(ch, ch.getMapId() + 1);\n+                ch.getParty().setEnemy(cm.getPlayer().getParty());\n+                cm.getChar().getParty().setEnemy(ch.getParty());\n+                cm.getChar().setChallenged(false);\n+            } else {\n+                cm.sendOk(\"O numero de players entre os times n\ufffdo esta igual.\");\n+            }\n+            cm.dispose();\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "8795e8467acfcf081d9fc5988d3de9ee205781a0", "filename": "scripts/npc/cpqchallenge2.js", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/cpqchallenge2.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/npc/cpqchallenge2.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/npc/cpqchallenge2.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -0,0 +1,48 @@\n+var status = 0;\n+var party;\n+\n+function start(chrs) {\n+    status = -1;\n+    party = chrs;\n+    action(1, 0, 0);\n+}\n+\n+function action(mode, type, selection) {\n+    if (mode == -1) {\n+        cm.getChar().setChallenged(false);\n+        cm.dispose();\n+    } else {\n+        if (mode == 0) {\n+            cm.sendOk(\"Come back once you have thought about it some more.\");\n+            cm.getChar().setChallenged(false);\n+            cm.dispose();\n+            return;\n+        }\n+    }\n+    if (mode == -1)\n+        cm.dispose();\n+    else {\n+        if (mode == 1)\n+            status++;\n+        else\n+            status--;\n+        if (status == 0) {\n+            if (cm.getParty().getMembers().size() == party.size()) {\n+                cm.getPlayer().setChallenged(true);\n+                var snd = \"\";\n+                for (var i = 0; i < party.size(); i++)\n+                    snd += \"#bNome: \" + party.get(i).getName() + \" / (Level: \" + party.get(i).getLevel() + \") / \" + party.get(i).getJobNameById(party.get(i).getJobId()) + \"#k\\r\\n\\r\\n\";\n+                cm.sendAcceptDecline(snd + \"Gostaria de lutar contra este grupo no Festival de Monstros?\");\n+            } else {\n+                return;\n+            }\n+        } else if (status == 1) {\n+            var ch = cm.getChrById(party.get(0).getId());\n+            cm.startCPQ2(ch, ch.getMapId() + 1);\n+            ch.getParty().setEnemy(cm.getPlayer().getParty());\n+            cm.getChar().getParty().setEnemy(ch.getParty());\n+            cm.getChar().setChallenged(false);\n+            cm.dispose();\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "07e40027291b44e88768414000fff27004a755cb", "filename": "scripts/portal/MC2revive.js", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/portal/MC2revive.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/portal/MC2revive.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/portal/MC2revive.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -0,0 +1,8 @@\n+function enter(pi) {\n+    if ( pi.getPlayer().getTeam() == 0 ) {\n+\tpi.warp( pi.getMapId() - 100);\n+    } else {\n+\tpi.warp( pi.getMapId() - 100);\n+    }\n+    return true;\n+}\n\\ No newline at end of file"}, {"sha": "6b83b15910eb472dc9845cd4933a2e54347dc6d2", "filename": "scripts/portal/MCRevive1.js", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/portal/MCRevive1.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/portal/MCRevive1.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/portal/MCRevive1.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -0,0 +1,10 @@\n+importPackage(Packages.server.maps);\n+\n+/*\n+ [CelticMS] Monster Carnival Reviving Field 1\n+ */\n+\n+function enter(pi) {\n+    pi.warp(980000101, 0);\n+    return true;\n+}"}, {"sha": "333958c6d2f774d70871095bd44aa55b2c933f9f", "filename": "scripts/portal/MCRevive2.js", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/portal/MCRevive2.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/portal/MCRevive2.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/portal/MCRevive2.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -0,0 +1,10 @@\n+importPackage(Packages.server.maps);\n+\n+/*\n+ [CelticMS] Monster Carnival Reviving Field 1\n+ */\n+\n+function enter(pi) {\n+    pi.warp(980000201, 0);\n+    return true;\n+}"}, {"sha": "2ec50bacda94f2240e1c95982201c66a91387396", "filename": "scripts/portal/MCRevive3.js", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/portal/MCRevive3.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/portal/MCRevive3.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/portal/MCRevive3.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -0,0 +1,19 @@\n+importPackage(Packages.server.maps);\n+\n+/*\n+[CelticMS] Monster Carnival Reviving Field 1\n+*/\n+\n+function enter(pi) {\n+\tvar portal = 0;\n+\tswitch (pi.getPlayer().getTeam()) {\n+\t\tcase 0:\n+\t\t\tportal = 4;\n+\t\t\tbreak;\n+\t\tcase 1:\n+\t\t\tportal = 3;\n+\t\t\tbreak;\n+\t}\n+\tpi.warp(980000301, portal);\n+\treturn true;\n+}"}, {"sha": "95fc0f1ad7eda6090637fee7b2a57476fc68ba4f", "filename": "scripts/portal/MCRevive4.js", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/portal/MCRevive4.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/portal/MCRevive4.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/portal/MCRevive4.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -0,0 +1,19 @@\n+importPackage(Packages.server.maps);\n+\n+/*\n+[CelticMS] Monster Carnival Reviving Field 1\n+*/\n+\n+function enter(pi) {\n+\tvar portal = 0;\n+\tswitch (pi.getPlayer().getTeam()) {\n+\t\tcase 0:\n+\t\t\tportal = 4;\n+\t\t\tbreak;\n+\t\tcase 1:\n+\t\t\tportal = 3;\n+\t\t\tbreak;\n+\t}\n+\tpi.warp(980000401, portal);\n+\treturn true;\n+}"}, {"sha": "7ced4ab4beafe71be9545c44fabfcae2363020ee", "filename": "scripts/portal/MCRevive5.js", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/portal/MCRevive5.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/portal/MCRevive5.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/portal/MCRevive5.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -0,0 +1,10 @@\n+importPackage(Packages.server.maps);\n+\n+/*\n+[CelticMS] Monster Carnival Reviving Field 1\n+*/\n+\n+function enter(pi) {\n+\tpi.warp(980000501, 0);\n+\treturn true;\n+}"}, {"sha": "26c1a63ca06b5c758b1d3a48a321d6007212300f", "filename": "scripts/portal/MCRevive6.js", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/portal/MCRevive6.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/portal/MCRevive6.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/portal/MCRevive6.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -0,0 +1,10 @@\n+importPackage(Packages.server.maps);\n+\n+/*\n+[CelticMS] Monster Carnival Reviving Field 1\n+*/\n+\n+function enter(pi) {\n+\tpi.warp(980000601, 0);\n+\treturn true;\n+}"}, {"sha": "cc38a8f14b2861fde7d0c32083a606bd87c2262d", "filename": "scripts/portal/mc_out.js", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/portal/mc_out.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/portal/mc_out.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/portal/mc_out.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -1,28 +1,35 @@\n /*\n-\tThis file is part of the OdinMS Maple Story Server\n-    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc> \n-                       Matthias Butz <matze@odinms.de>\n-                       Jan Christian Meyer <vimes@odinms.de>\n+ This file is part of the OdinMS Maple Story Server\n+ Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc> \n+ Matthias Butz <matze@odinms.de>\n+ Jan Christian Meyer <vimes@odinms.de>\n+ \n+ This program is free software: you can redistribute it and/or modify\n+ it under the terms of the GNU Affero General Public License version 3\n+ as published by the Free Software Foundation. You may not use, modify\n+ or distribute this program under any other version of the\n+ GNU Affero General Public License.\n+ \n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU Affero General Public License for more details.\n+ \n+ You should have received a copy of the GNU Affero General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n \n-    This program is free software: you can redistribute it and/or modify\n-    it under the terms of the GNU Affero General Public License version 3\n-    as published by the Free Software Foundation. You may not use, modify\n-    or distribute this program under any other version of the\n-    GNU Affero General Public License.\n+importPackage(Packages.server.maps);\n \n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU Affero General Public License for more details.\n-\n-    You should have received a copy of the GNU Affero General Public License\n-    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-*/\n /*\n-Author: kevintjuh93\n-*/ \n+ */\n \n function enter(pi) {\n-    pi.playPortalSound(); pi.warp(pi.getPlayer().getSavedLocation(\"MIRROR\"));\n+    var returnMap = pi.getPlayer().getSavedLocation(\"MONSTER_CARNIVAL\");\n+    if (returnMap < 0) {\n+        returnMap = 102000000; // Just Incase there is no saved location.\n+    }\n+    var target = pi.getPlayer().getClient().getChannelServer().getMapFactory().getMap(returnMap);\n+    pi.getPlayer().changeMap(target);\n     return true;\n }\n\\ No newline at end of file"}, {"sha": "278c67dfea33c044c8a364f4ddaad26a92f31626", "filename": "scripts/reactor/9980000.js", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/reactor/9980000.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/reactor/9980000.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/reactor/9980000.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -1,28 +1,3 @@\n-/* \n- * This file is part of the OdinMS Maple Story Server\n-    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc> \n-                       Matthias Butz <matze@odinms.de>\n-                       Jan Christian Meyer <vimes@odinms.de>\n-\n-    This program is free software: you can redistribute it and/or modify\n-    it under the terms of the GNU Affero General Public License version 3\n-    as published by the Free Software Foundation. You may not use, modify\n-    or distribute this program under any other version of the\n-    GNU Affero General Public License.\n-\n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU Affero General Public License for more details.\n-\n-    You should have received a copy of the GNU Affero General Public License\n-    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-/*\n-@Author kevintjuh93\n-*/\n-\n function act() {\n-        rm.getReactor().removeMonsterStatus();\n+    rm.dispelAllMonsters(parseInt(rm.getReactor().getName().substring(1,2)), parseInt(rm.getReactor().getName().substring(0,1)));\n }\n\\ No newline at end of file"}, {"sha": "278c67dfea33c044c8a364f4ddaad26a92f31626", "filename": "scripts/reactor/9980001.js", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/reactor/9980001.js", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/scripts/reactor/9980001.js", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/scripts/reactor/9980001.js?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -1,28 +1,3 @@\n-/* \n- * This file is part of the OdinMS Maple Story Server\n-    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc> \n-                       Matthias Butz <matze@odinms.de>\n-                       Jan Christian Meyer <vimes@odinms.de>\n-\n-    This program is free software: you can redistribute it and/or modify\n-    it under the terms of the GNU Affero General Public License version 3\n-    as published by the Free Software Foundation. You may not use, modify\n-    or distribute this program under any other version of the\n-    GNU Affero General Public License.\n-\n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU Affero General Public License for more details.\n-\n-    You should have received a copy of the GNU Affero General Public License\n-    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-/*\n-@Author kevintjuh93\n-*/\n-\n function act() {\n-        rm.getReactor().removeMonsterStatus();\n+    rm.dispelAllMonsters(parseInt(rm.getReactor().getName().substring(1,2)), parseInt(rm.getReactor().getName().substring(0,1)));\n }\n\\ No newline at end of file"}, {"sha": "b36adb2f85b11fb826419d9860b47fa586ae17cd", "filename": "src/client/MapleCharacter.java", "status": "modified", "additions": 1810, "deletions": 1540, "changes": 3350, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/client/MapleCharacter.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/client/MapleCharacter.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/client/MapleCharacter.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595"}, {"sha": "ec62f10fe81bf5b4be081c56fc21e8aea1791525", "filename": "src/client/MapleClient.java", "status": "modified", "additions": 1419, "deletions": 1408, "changes": 2827, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/client/MapleClient.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/client/MapleClient.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/client/MapleClient.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -1,23 +1,23 @@\n /*\n-This file is part of the OdinMS Maple Story Server\n-Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n-Matthias Butz <matze@odinms.de>\n-Jan Christian Meyer <vimes@odinms.de>\n-\n-This program is free software: you can redistribute it and/or modify\n-it under the terms of the GNU Affero General Public License as\n-published by the Free Software Foundation version 3 as published by\n-the Free Software Foundation. You may not use, modify or distribute\n-this program under any other version of the GNU Affero General Public\n-License.\n-\n-This program is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU Affero General Public License for more details.\n-\n-You should have received a copy of the GNU Affero General Public License\n-along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ This file is part of the OdinMS Maple Story Server\n+ Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n+ Matthias Butz <matze@odinms.de>\n+ Jan Christian Meyer <vimes@odinms.de>\n+\n+ This program is free software: you can redistribute it and/or modify\n+ it under the terms of the GNU Affero General Public License as\n+ published by the Free Software Foundation version 3 as published by\n+ the Free Software Foundation. You may not use, modify or distribute\n+ this program under any other version of the GNU Affero General Public\n+ License.\n+\n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU Affero General Public License for more details.\n+\n+ You should have received a copy of the GNU Affero General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>.\n  */\n package client;\n \n@@ -84,1437 +84,1448 @@\n \n public class MapleClient {\n \n-\tpublic static final int LOGIN_NOTLOGGEDIN = 0;\n-\tpublic static final int LOGIN_SERVER_TRANSITION = 1;\n-\tpublic static final int LOGIN_LOGGEDIN = 2;\n-\tpublic static final String CLIENT_KEY = \"CLIENT\";\n-        public static final String CLIENT_HWID = \"HWID\";\n-        public static final String CLIENT_NIBBLEHWID = \"HWID2\";\n-\tprivate MapleAESOFB send;\n-\tprivate MapleAESOFB receive;\n-\tprivate final IoSession session;\n-\tprivate MapleCharacter player;\n-\tprivate int channel = 1;\n-\tprivate int accId = 0;\n-\tprivate boolean loggedIn = false;\n-\tprivate boolean serverTransition = false;\n-\tprivate Calendar birthday = null;\n-\tprivate String accountName = null;\n-\tprivate int world;\n-\tprivate long lastPong;\n-\tprivate int gmlevel;\n-\tprivate Set<String> macs = new HashSet<>();\n-\tprivate Map<String, ScriptEngine> engines = new HashMap<>();\n-\tprivate byte characterSlots = 3;\n-\tprivate byte loginattempt = 0;\n-\tprivate String pin = null;\n-\tprivate int pinattempt = 0;\n-\tprivate String pic = null;\n-\tprivate String hwid = null;\n-\tprivate int picattempt = 0;\n-        private byte csattempt = 0;\n-\tprivate byte gender = -1;\n-\tprivate boolean disconnecting = false;\n-        private final Semaphore actionsSemaphore = new Semaphore(7);\n-\tprivate final Lock lock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.CLIENT, true);\n-        private final Lock encoderLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.CLIENT_ENCODER, true);\n-        private static final Lock loginLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.CLIENT_LOGIN, true);\n-\tprivate int votePoints;\n-\tprivate int voteTime = -1;\n-        private int visibleWorlds;\n-\tprivate long lastNpcClick;\n-\tprivate long sessionId;\n-\n-        public MapleClient(MapleAESOFB send, MapleAESOFB receive, IoSession session) {\n-\t\tthis.send = send;\n-\t\tthis.receive = receive;\n-\t\tthis.session = session;\n-\t}\n-\n-\tpublic MapleAESOFB getReceiveCrypto() {\n-\t\treturn receive;\n-\t}\n-\n-\tpublic MapleAESOFB getSendCrypto() {\n-\t\treturn send;\n-\t}\n-\n-\tpublic IoSession getSession() {\n-\t\treturn session;\n-\t}\n-        \n-        public EventManager getEventManager(String event) {\n-                return getChannelServer().getEventSM().getEventManager(event);\n-        }\n-\n-\tpublic MapleCharacter getPlayer() {\n-\t\treturn player;\n-\t}\n-\n-\tpublic void setPlayer(MapleCharacter player) {\n-\t\tthis.player = player;\n-\t}\n-        \n-        public AbstractPlayerInteraction getAbstractPlayerInteraction() {\n-                return new AbstractPlayerInteraction(this);\n-        }\n-\n-\tpublic void sendCharList(int server) {\n-\t\tthis.announce(MaplePacketCreator.getCharList(this, server, 0));\n-\t}\n-\n-\tpublic List<MapleCharacter> loadCharacters(int serverId) {\n-\t\tList<MapleCharacter> chars = new ArrayList<>(15);\n-\t\ttry {\n-\t\t\tfor (CharNameAndId cni : loadCharactersInternal(serverId)) {\n-\t\t\t\tchars.add(MapleCharacter.loadCharFromDB(cni.id, this, false));\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-                    e.printStackTrace();\n-\t\t}\n-\t\treturn chars;\n-\t}\n-\n-\tpublic List<String> loadCharacterNames(int worldId) {\n-\t\tList<String> chars = new ArrayList<>(15);\n-\t\tfor (CharNameAndId cni : loadCharactersInternal(worldId)) {\n-\t\t\tchars.add(cni.name);\n-\t\t}\n-\t\treturn chars;\n-\t}\n-\n-\tprivate List<CharNameAndId> loadCharactersInternal(int worldId) {\n-\t\tPreparedStatement ps;\n-\t\tList<CharNameAndId> chars = new ArrayList<>(15);\n-\t\ttry {\n-                        Connection con = DatabaseConnection.getConnection();\n-\t\t\tps = con.prepareStatement(\"SELECT id, name FROM characters WHERE accountid = ? AND world = ?\");\n-\t\t\tps.setInt(1, this.getAccID());\n-\t\t\tps.setInt(2, worldId);\n-\t\t\ttry (ResultSet rs = ps.executeQuery()) {\n-\t\t\t\twhile (rs.next()) {\n-\t\t\t\t\tchars.add(new CharNameAndId(rs.getString(\"name\"), rs.getInt(\"id\")));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tps.close();\n-                        con.close();\n-\t\t} catch (SQLException e) {\n-\t\t\te.printStackTrace();\n-\t\t}\n-\t\treturn chars;\n-\t}\n-\n-\tpublic boolean isLoggedIn() {\n-\t\treturn loggedIn;\n-\t}\n-\n-\tpublic boolean hasBannedIP() {\n-\t\tboolean ret = false;\n-\t\ttry {\n-                        Connection con = DatabaseConnection.getConnection();\n-\t\t\ttry (PreparedStatement ps = con.prepareStatement(\"SELECT COUNT(*) FROM ipbans WHERE ? LIKE CONCAT(ip, '%')\")) {\n-\t\t\t\tps.setString(1, session.getRemoteAddress().toString());\n-\t\t\t\ttry (ResultSet rs = ps.executeQuery()) {\n-\t\t\t\t\trs.next();\n-\t\t\t\t\tif (rs.getInt(1) > 0) {\n-\t\t\t\t\t\tret = true;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-                        con.close();\n-\t\t} catch (SQLException e) {\n-                    e.printStackTrace();\n-\t\t}\n-\t\treturn ret;\n-\t}\n-\n-\tpublic int getVoteTime(){\n-\t\tif (voteTime != -1){\n-\t\t\treturn voteTime;\n-\t\t}\n-\t\ttry {\n-                        Connection con = DatabaseConnection.getConnection();\n-\t\t\ttry (PreparedStatement ps = con.prepareStatement(\"SELECT date FROM bit_votingrecords WHERE UPPER(account) = UPPER(?)\")) {\n-\t\t\t\tps.setString(1, accountName);\n-\t\t\t\ttry (ResultSet rs = ps.executeQuery()) {\n-\t\t\t\t\tif (!rs.next()) {\n-\t\t\t\t\t\treturn -1;\n-\t\t\t\t\t}\n-\t\t\t\t\tvoteTime = rs.getInt(\"date\");\n-\t\t\t\t}\n-\t\t\t}\n-                        con.close();\n-\t\t} catch (SQLException e) {\n-\t\t\tFilePrinter.printError(\"hasVotedAlready.txt\", e);\n-\t\t\treturn -1;\n-\t\t}\n-\t\treturn voteTime;\n-\t}\n-        \n-        public void resetVoteTime() {\n-            voteTime = -1;\n-        }\n-\n-\tpublic boolean hasVotedAlready(){\n-\t\tDate currentDate = new Date();\n-\t\tint timeNow = (int) (currentDate.getTime() / 1000);\n-\t\tint difference = (timeNow - getVoteTime());\n-\t\treturn difference < 86400 && difference > 0;\n-\t}\n-\t\n-\tpublic boolean hasBannedHWID() {\n-\t\tif(hwid == null)\n-\t\t\treturn false;\n-\t\t\n-\t\tboolean ret = false;\n-\t\tPreparedStatement ps = null;\n-                Connection con = null;\n-\t\ttry {\n-                        con = DatabaseConnection.getConnection();\n-\t\t\tps = con.prepareStatement(\"SELECT COUNT(*) FROM hwidbans WHERE hwid LIKE ?\");\n-\t\t\tps.setString(1, hwid);\n-\t\t\tResultSet rs = ps.executeQuery();\n-\t\t\tif(rs != null && rs.next()) {\n-\t\t\t\tif(rs.getInt(1) > 0) \n-\t\t\t\t\tret = true; \n-\t\t\t}\n-\t\t} catch (SQLException e) {\n-\t\t\te.printStackTrace();\n-\t\t} finally {\n-\t\t\ttry {\n-\t\t\t\tif(ps != null && !ps.isClosed()) {\n-\t\t\t\t\tps.close();\n-\t\t\t\t}\n-                                \n-                                if(con != null && !con.isClosed()) {\n-\t\t\t\t\tcon.close();\n-\t\t\t\t}\n-\t\t\t} catch (SQLException e){\n-                            e.printStackTrace();\n-\t\t\t}\n-\t\t}\n-\t\t\n-\t\treturn ret;\n-\t}\n-\n-\tpublic boolean hasBannedMac() {\n-\t\tif (macs.isEmpty()) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tboolean ret = false;\n-\t\tint i;\n-\t\ttry {\n-\t\t\tStringBuilder sql = new StringBuilder(\"SELECT COUNT(*) FROM macbans WHERE mac IN (\");\n-\t\t\tfor (i = 0; i < macs.size(); i++) {\n-\t\t\t\tsql.append(\"?\");\n-\t\t\t\tif (i != macs.size() - 1) {\n-\t\t\t\t\tsql.append(\", \");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tsql.append(\")\");\n-                        \n-                        Connection con = DatabaseConnection.getConnection();\n-\t\t\ttry (PreparedStatement ps = con.prepareStatement(sql.toString())) {\n-\t\t\t\ti = 0;\n-\t\t\t\tfor (String mac : macs) {\n-\t\t\t\t\ti++;\n-\t\t\t\t\tps.setString(i, mac);\n-\t\t\t\t}\n-\t\t\t\ttry (ResultSet rs = ps.executeQuery()) {\n-\t\t\t\t\trs.next();\n-\t\t\t\t\tif (rs.getInt(1) > 0) {\n-\t\t\t\t\t\tret = true;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} finally {\n-                                con.close();\n-                        }\n-\t\t} catch (Exception e) {\n-                    e.printStackTrace();\n-\t\t}\n-\t\treturn ret;\n-\t}\n-\t\n-\tprivate void loadHWIDIfNescessary() throws SQLException {\n-\t\tif(hwid == null) {\n-                        Connection con = DatabaseConnection.getConnection();\n-\t\t\ttry(PreparedStatement ps = con.prepareStatement(\"SELECT hwid FROM accounts WHERE id = ?\")) {\n-\t\t\t\tps.setInt(1, accId);\n-\t\t\t\ttry(ResultSet rs = ps.executeQuery()) {\n-\t\t\t\t\tif(rs.next()) {\n-\t\t\t\t\t\thwid = rs.getString(\"hwid\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} finally {\n-                                con.close();\n-                        }\n-\t\t}\n-\t}\n-\n-\t// TODO: Recode to close statements...\n-\tprivate void loadMacsIfNescessary() throws SQLException {\n-\t\tif (macs.isEmpty()) {\n-                        Connection con = DatabaseConnection.getConnection();\n-\t\t\ttry (PreparedStatement ps = con.prepareStatement(\"SELECT macs FROM accounts WHERE id = ?\")) {\n-\t\t\t\tps.setInt(1, accId);\n-\t\t\t\ttry (ResultSet rs = ps.executeQuery()) {\n-\t\t\t\t\tif (rs.next()) {\n-\t\t\t\t\t\tfor (String mac : rs.getString(\"macs\").split(\", \")) {\n-\t\t\t\t\t\t\tif (!mac.equals(\"\")) {\n-\t\t\t\t\t\t\t\tmacs.add(mac);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} finally {\n-                                con.close();\n-                        }\n-\t\t}\n-\t}\n-\t\n-\tpublic void banHWID() {\n-\t\tPreparedStatement ps = null;\n-                Connection con = null;\n-\t\ttry {\n-\t\t\tloadHWIDIfNescessary();\n-                        \n-                        con = DatabaseConnection.getConnection();\n-\t\t\tps = con.prepareStatement(\"INSERT INTO hwidbans (hwid) VALUES (?)\");\n-\t\t\tps.setString(1, hwid);\n-\t\t\tps.executeUpdate();\n-\t\t} catch (SQLException e) {\n-\t\t\te.printStackTrace();\n-\t\t} finally {\n-\t\t\ttry {\n-\t\t\t\tif(ps != null && !ps.isClosed()) {\n-\t\t\t\t\tps.close();\n-                                }\n-                                if(con != null && !con.isClosed()) {\n-\t\t\t\t\tcon.close();\n-                                }\n-\t\t\t} catch (SQLException e) {\n-                            e.printStackTrace();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void banMacs() {\n-\t\tConnection con = null;\n-\t\ttry {\n-\t\t\tloadMacsIfNescessary();\n-                        \n-                        con = DatabaseConnection.getConnection();\n-\t\t\tList<String> filtered = new LinkedList<>();\n-\t\t\ttry (PreparedStatement ps = con.prepareStatement(\"SELECT filter FROM macfilters\"); ResultSet rs = ps.executeQuery()) {\n-\t\t\t\twhile (rs.next()) {\n-\t\t\t\t\tfiltered.add(rs.getString(\"filter\"));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\ttry (PreparedStatement ps = con.prepareStatement(\"INSERT INTO macbans (mac, aid) VALUES (?, ?)\")) {\n-\t\t\t\tfor (String mac : macs) {\n-\t\t\t\t\tboolean matched = false;\n-\t\t\t\t\tfor (String filter : filtered) {\n-\t\t\t\t\t\tif (mac.matches(filter)) {\n-\t\t\t\t\t\t\tmatched = true;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tif (!matched) {\n-\t\t\t\t\t\tps.setString(1, mac);\n-                                                ps.setString(2, String.valueOf(getAccID()));\n-\t\t\t\t\t\tps.executeUpdate();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-                        \n-                        con.close();\n-\t\t} catch (SQLException e) {\n-                    e.printStackTrace();\n-\t\t}\n-\t}\n+    public static final int LOGIN_NOTLOGGEDIN = 0;\n+    public static final int LOGIN_SERVER_TRANSITION = 1;\n+    public static final int LOGIN_LOGGEDIN = 2;\n+    public static final String CLIENT_KEY = \"CLIENT\";\n+    public static final String CLIENT_HWID = \"HWID\";\n+    public static final String CLIENT_NIBBLEHWID = \"HWID2\";\n+    private MapleAESOFB send;\n+    private MapleAESOFB receive;\n+    private final IoSession session;\n+    private MapleCharacter player;\n+    private int channel = 1;\n+    private int accId = 0;\n+    private boolean loggedIn = false;\n+    private boolean serverTransition = false;\n+    private Calendar birthday = null;\n+    private String accountName = null;\n+    private int world;\n+    private long lastPong;\n+    private int gmlevel;\n+    private Set<String> macs = new HashSet<>();\n+    private Map<String, ScriptEngine> engines = new HashMap<>();\n+    private byte characterSlots = 3;\n+    private byte loginattempt = 0;\n+    private String pin = null;\n+    private int pinattempt = 0;\n+    private String pic = null;\n+    private String hwid = null;\n+    private int picattempt = 0;\n+    private byte csattempt = 0;\n+    private byte gender = -1;\n+    private boolean disconnecting = false;\n+    private final Semaphore actionsSemaphore = new Semaphore(7);\n+    private final Lock lock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.CLIENT, true);\n+    private final Lock encoderLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.CLIENT_ENCODER, true);\n+    private static final Lock loginLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.CLIENT_LOGIN, true);\n+    private int votePoints;\n+    private int voteTime = -1;\n+    private int visibleWorlds;\n+    private long lastNpcClick;\n+    private long sessionId;\n+\n+    public MapleClient(MapleAESOFB send, MapleAESOFB receive, IoSession session) {\n+        this.send = send;\n+        this.receive = receive;\n+        this.session = session;\n+    }\n+\n+    public MapleAESOFB getReceiveCrypto() {\n+        return receive;\n+    }\n+\n+    public MapleAESOFB getSendCrypto() {\n+        return send;\n+    }\n+\n+    public IoSession getSession() {\n+        return session;\n+    }\n+\n+    public EventManager getEventManager(String event) {\n+        return getChannelServer().getEventSM().getEventManager(event);\n+    }\n+\n+    public MapleCharacter getPlayer() {\n+        return player;\n+    }\n+\n+    public void setPlayer(MapleCharacter player) {\n+        this.player = player;\n+    }\n+\n+    public AbstractPlayerInteraction getAbstractPlayerInteraction() {\n+        return new AbstractPlayerInteraction(this);\n+    }\n+\n+    public void sendCharList(int server) {\n+        this.announce(MaplePacketCreator.getCharList(this, server, 0));\n+    }\n+\n+    public List<MapleCharacter> loadCharacters(int serverId) {\n+        List<MapleCharacter> chars = new ArrayList<>(15);\n+        try {\n+            for (CharNameAndId cni : loadCharactersInternal(serverId)) {\n+                chars.add(MapleCharacter.loadCharFromDB(cni.id, this, false));\n+            }\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+        return chars;\n+    }\n \n-\tpublic int finishLogin() {\n-                loginLock.lock();\n-                try {\n-                    if (getLoginState() > LOGIN_NOTLOGGEDIN) { // 0 = LOGIN_NOTLOGGEDIN, 1= LOGIN_SERVER_TRANSITION, 2 = LOGIN_LOGGEDIN\n-                        loggedIn = false;\n-                        return 7;\n+    public List<String> loadCharacterNames(int worldId) {\n+        List<String> chars = new ArrayList<>(15);\n+        for (CharNameAndId cni : loadCharactersInternal(worldId)) {\n+            chars.add(cni.name);\n+        }\n+        return chars;\n+    }\n+\n+    private List<CharNameAndId> loadCharactersInternal(int worldId) {\n+        PreparedStatement ps;\n+        List<CharNameAndId> chars = new ArrayList<>(15);\n+        try {\n+            Connection con = DatabaseConnection.getConnection();\n+            ps = con.prepareStatement(\"SELECT id, name FROM characters WHERE accountid = ? AND world = ?\");\n+            ps.setInt(1, this.getAccID());\n+            ps.setInt(2, worldId);\n+            try (ResultSet rs = ps.executeQuery()) {\n+                while (rs.next()) {\n+                    chars.add(new CharNameAndId(rs.getString(\"name\"), rs.getInt(\"id\")));\n+                }\n+            }\n+            ps.close();\n+            con.close();\n+        } catch (SQLException e) {\n+            e.printStackTrace();\n+        }\n+        return chars;\n+    }\n+\n+    public boolean isLoggedIn() {\n+        return loggedIn;\n+    }\n+\n+    public boolean hasBannedIP() {\n+        boolean ret = false;\n+        try {\n+            Connection con = DatabaseConnection.getConnection();\n+            try (PreparedStatement ps = con.prepareStatement(\"SELECT COUNT(*) FROM ipbans WHERE ? LIKE CONCAT(ip, '%')\")) {\n+                ps.setString(1, session.getRemoteAddress().toString());\n+                try (ResultSet rs = ps.executeQuery()) {\n+                    rs.next();\n+                    if (rs.getInt(1) > 0) {\n+                        ret = true;\n                     }\n-                    updateLoginState(LOGIN_LOGGEDIN);\n-                } finally {\n-                    loginLock.unlock();\n                 }\n-            \n-\t\treturn 0;\n-\t}\n-\n-\tpublic void setPin(String pin) {\n-\t\tthis.pin = pin;\n-\t\ttry {\n-                        Connection con = DatabaseConnection.getConnection();\n-\t\t\ttry (PreparedStatement ps = con.prepareStatement(\"UPDATE accounts SET pin = ? WHERE id = ?\")) {\n-\t\t\t\tps.setString(1, pin);\n-\t\t\t\tps.setInt(2, accId);\n-\t\t\t\tps.executeUpdate();\n-\t\t\t} finally {\n-                                con.close();\n-                        }\n-\t\t} catch (SQLException e) {\n-                    e.printStackTrace();\n-\t\t}\n-\t}\n-\n-\tpublic String getPin() {\n-\t\treturn pin;\n-\t}\n-\n-\tpublic boolean checkPin(String other) {\n-\t\tpinattempt++;\n-\t\tif (pinattempt > 5) {\n-                        MapleSessionCoordinator.getInstance().closeSession(session, false);\n-\t\t}\n-\t\tif (pin.equals(other)) {\n-\t\t\tpinattempt = 0;\n-                        MapleLoginBypassCoordinator.getInstance().registerLoginBypassEntry(getNibbleHWID(), accId, false);\n-\t\t\treturn true;\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\tpublic void setPic(String pic) {\n-\t\tthis.pic = pic;\n-\t\ttry {\n-                        Connection con = DatabaseConnection.getConnection();\n-\t\t\ttry (PreparedStatement ps = con.prepareStatement(\"UPDATE accounts SET pic = ? WHERE id = ?\")) {\n-\t\t\t\tps.setString(1, pic);\n-\t\t\t\tps.setInt(2, accId);\n-\t\t\t\tps.executeUpdate();\n-\t\t\t} finally {\n-                                con.close();\n-                        }\n-\t\t} catch (SQLException e) {\n-                    e.printStackTrace();\n-\t\t}\n-\t}\n-\n-\tpublic String getPic() {\n-\t\treturn pic;\n-\t}\n-\n-\tpublic boolean checkPic(String other) {\n-                if(!(ServerConstants.ENABLE_PIC && !canBypassPic())) return true;\n-            \n-\t\tpicattempt++;\n-\t\tif (picattempt > 5) {\n-\t\t\tMapleSessionCoordinator.getInstance().closeSession(session, false);\n-\t\t}\n-\t\tif (pic.equals(other)) {\n-\t\t\tpicattempt = 0;\n-                        MapleLoginBypassCoordinator.getInstance().registerLoginBypassEntry(getNibbleHWID(), accId, true);\n-\t\t\treturn true;\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\tpublic int login(String login, String pwd, String nibbleHwid) {\n-\t\tint loginok = 5;\n-                \n-\t\tloginattempt++;\n-                if (loginattempt > 4) {\n-                        loggedIn = false;\n-\t\t\tMapleSessionCoordinator.getInstance().closeSession(session, false);\n-                        return loginok;\n-\t\t}\n-\t\t\n-\t\tConnection con = null;\n-\t\tPreparedStatement ps = null;\n-\t\tResultSet rs = null;\n-\t\ttry {\n-\t\t\tcon = DatabaseConnection.getConnection();\n-\t\t\tps = con.prepareStatement(\"SELECT id, password, gender, banned, pin, pic, characterslots, tos FROM accounts WHERE name = ?\");\n-\t\t\tps.setString(1, login);\n-\t\t\trs = ps.executeQuery();\n-\t\t\tif (rs.next()) {\n-\t\t\t\tboolean banned = (rs.getByte(\"banned\") == 1);\n-\t\t\t\taccId = rs.getInt(\"id\");\n-\t\t\t\tgmlevel = 0;\n-\t\t\t\tpin = rs.getString(\"pin\");\n-\t\t\t\tpic = rs.getString(\"pic\");\n-\t\t\t\tgender = rs.getByte(\"gender\");\n-\t\t\t\tcharacterSlots = rs.getByte(\"characterslots\");\n-\t\t\t\tString passhash = rs.getString(\"password\");\n-\t\t\t\tbyte tos = rs.getByte(\"tos\");\n-\n-\t\t\t\tps.close();\n-\t\t\t\trs.close();\n-\n-\t\t\t\tif (banned) {\n-\t\t\t\t\treturn 3;\n-\t\t\t\t}\n-\n-\t\t\t\tif (getLoginState() > LOGIN_NOTLOGGEDIN) { // already loggedin\n-\t\t\t\t\tloggedIn = false;\n-\t\t\t\t\tloginok = 7;\n-\t\t\t\t} else if (passhash.charAt(0) == '$' && passhash.charAt(1) == '2' && BCrypt.checkpw(pwd, passhash)) {\n-\t\t\t\t\tloginok = (tos == 0) ? 23 : 0;\n-\t\t\t\t} else if (pwd.equals(passhash) || checkHash(passhash, \"SHA-1\", pwd) || checkHash(passhash, \"SHA-512\", pwd)) {\n-                                        // thanks GabrielSin for detecting some no-bcrypt inconsistencies here\n-\t\t\t\t\tloginok = (tos == 0) ? (!ServerConstants.BCRYPT_MIGRATION ? 23 : -23) : (!ServerConstants.BCRYPT_MIGRATION ? 0 : -10); // migrate to bcrypt\n-\t\t\t\t} else {\n-\t\t\t\t\tloggedIn = false;\n-\t\t\t\t\tloginok = 4;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch (SQLException e) {\n-\t\t\te.printStackTrace();\n-\t\t} finally {\n-\t\t\ttry {\n-\t\t\t\tif (ps != null && !ps.isClosed()) {\n-\t\t\t\t\tps.close();\n-\t\t\t\t}\n-\t\t\t\tif (rs != null && !rs.isClosed()) {\n-\t\t\t\t\trs.close();\n-\t\t\t\t}\n-\t\t\t\tif (con != null && !con.isClosed()) {\n-\t\t\t\t\tcon.close();\n-\t\t\t\t}\n-\t\t\t} catch (SQLException e) {\n-\t\t\t\te.printStackTrace();\n-\t\t\t}\n-\t\t}\n-                \n-\t\tif (loginok == 0 || loginok == 4) {\n-                        AntiMulticlientResult res = MapleSessionCoordinator.getInstance().attemptLoginSession(session, nibbleHwid, accId, loginok == 4);\n-                        \n-                        switch (res) {\n-                                case SUCCESS:\n-                                        if (loginok == 0) {\n-                                                loginattempt = 0;\n-                                        }\n-                                        \n-                                        return loginok;\n-\n-                                case REMOTE_LOGGEDIN:\n-                                        return 17;\n-\n-                                case REMOTE_REACHED_LIMIT:\n-                                        return 13;\n-\n-                                case REMOTE_PROCESSING:\n-                                        return 10;\n-                                    \n-                                case MANY_ACCOUNT_ATTEMPTS:\n-                                        return 16;\n-\n-                                default:\n-                                        return 8;\n-                        }\n-\t\t} else {\n-                        return loginok;\n+            }\n+            con.close();\n+        } catch (SQLException e) {\n+            e.printStackTrace();\n+        }\n+        return ret;\n+    }\n+\n+    public int getVoteTime() {\n+        if (voteTime != -1) {\n+            return voteTime;\n+        }\n+        try {\n+            Connection con = DatabaseConnection.getConnection();\n+            try (PreparedStatement ps = con.prepareStatement(\"SELECT date FROM bit_votingrecords WHERE UPPER(account) = UPPER(?)\")) {\n+                ps.setString(1, accountName);\n+                try (ResultSet rs = ps.executeQuery()) {\n+                    if (!rs.next()) {\n+                        return -1;\n+                    }\n+                    voteTime = rs.getInt(\"date\");\n                 }\n-\t}\n-\n-\tpublic Calendar getTempBanCalendar() {\n-\t\tConnection con = null;\n-\t\tPreparedStatement ps = null;\n-\t\tResultSet rs = null;\n-\t\tfinal Calendar lTempban = Calendar.getInstance();\n-\t\ttry {\n-                        con = DatabaseConnection.getConnection();\n-\t\t\tps = con.prepareStatement(\"SELECT `tempban` FROM accounts WHERE id = ?\");\n-\t\t\tps.setInt(1, getAccID());\n-\t\t\trs = ps.executeQuery();\n-\t\t\tif (!rs.next()) {\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t\tlong blubb = rs.getLong(\"tempban\");\n-\t\t\tif (blubb == 0) { // basically if timestamp in db is 0000-00-00\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t\tlTempban.setTimeInMillis(rs.getTimestamp(\"tempban\").getTime());\n-\t\t\treturn lTempban;\n-\t\t} catch (SQLException e) {\n-                    e.printStackTrace();\n-\t\t} finally {\n-\t\t\ttry {\n-\t\t\t\tif (ps != null) {\n-\t\t\t\t\tps.close();\n-\t\t\t\t}\n-\t\t\t\tif (rs != null) {\n-\t\t\t\t\trs.close();\n-\t\t\t\t}\n-                                if (con != null && !con.isClosed()) {\n-\t\t\t\t\tcon.close();\n-\t\t\t\t}\n-\t\t\t} catch (SQLException e) {\n-                            e.printStackTrace();\n-\t\t\t}\n-\t\t}\n-\t\treturn null;//why oh why!?!\n-\t}\n-\n-\tpublic static long dottedQuadToLong(String dottedQuad) throws RuntimeException {\n-\t\tString[] quads = dottedQuad.split(\"\\\\.\");\n-\t\tif (quads.length != 4) {\n-\t\t\tthrow new RuntimeException(\"Invalid IP Address format.\");\n-\t\t}\n-\t\tlong ipAddress = 0;\n-\t\tfor (int i = 0; i < 4; i++) {\n-\t\t\tint quad = Integer.parseInt(quads[i]);\n-\t\t\tipAddress += (long) (quad % 256) * (long) Math.pow(256, (double) (4 - i));\n-\t\t}\n-\t\treturn ipAddress;\n-\t}\n-\t\n-\tpublic void updateHWID(String newHwid) {\n-\t\tString[] split = newHwid.split(\"_\");\n-\t\tif(split.length > 1 && split[1].length() == 8) {\n-\t\t\tStringBuilder hwid = new StringBuilder();\n-\t\t\tString convert = split[1]; \n-\t\t\t\n-\t\t\tint len = convert.length();\n-\t\t\tfor(int i=len-2; i>=0; i -= 2) {\n-\t\t\t\thwid.append(convert.substring(i, i + 2));\n-\t\t\t}\n-\t\t\thwid.insert(4, \"-\");\n-\t\t\t\t\t\n-\t\t\tthis.hwid = hwid.toString();\n-\t\t\t\n-\t\t\tPreparedStatement ps = null;\n-                        Connection con = null;\n-\t\t\ttry {\n-                                con = DatabaseConnection.getConnection();\n-\t\t\t\tps = con.prepareStatement(\"UPDATE accounts SET hwid = ? WHERE id = ?\");\n-\t\t\t\tps.setString(1, this.hwid);\n-\t\t\t\tps.setInt(2, accId);\n-\t\t\t\tps.executeUpdate();\n-\t\t\t\tps.close();\n-\t\t\t} catch (SQLException e) {\n-\t\t\t\te.printStackTrace();\n-\t\t\t} finally {\n-\t\t\t\ttry {\n-\t\t\t\t\tif(ps != null && !ps.isClosed()) {\n-\t\t\t\t\t\tps.close();\n-\t\t\t\t\t}\n-                                        if(con != null && !con.isClosed()) {\n-\t\t\t\t\t\tcon.close();\n-\t\t\t\t\t}\n-\t\t\t\t} catch (SQLException e) {\n-                                    e.printStackTrace();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} else {\n-\t\t\tthis.disconnect(false, false); // Invalid HWID...\n-\t\t}\n-\t}\n-\n-\tpublic void updateMacs(String macData) {\n-\t\tmacs.addAll(Arrays.asList(macData.split(\", \")));\n-\t\tStringBuilder newMacData = new StringBuilder();\n-\t\tIterator<String> iter = macs.iterator();\n-\t\tPreparedStatement ps = null;\n-\t\twhile (iter.hasNext()) {\n-\t\t\tString cur = iter.next();\n-\t\t\tnewMacData.append(cur);\n-\t\t\tif (iter.hasNext()) {\n-\t\t\t\tnewMacData.append(\", \");\n-\t\t\t}\n-\t\t}\n-                Connection con = null;\n-\t\ttry {\n-                        con = DatabaseConnection.getConnection();\n-\t\t\tps = con.prepareStatement(\"UPDATE accounts SET macs = ? WHERE id = ?\");\n-\t\t\tps.setString(1, newMacData.toString());\n-\t\t\tps.setInt(2, accId);\n-\t\t\tps.executeUpdate();\n-\t\t\tps.close();\n-\t\t} catch (SQLException e) {\n-\t\t\te.printStackTrace();\n-\t\t} finally {\n-\t\t\ttry {\n-\t\t\t\tif (ps != null && !ps.isClosed()) {\n-\t\t\t\t\tps.close();\n-\t\t\t\t}\n-                                if (con != null && !con.isClosed()) {\n-\t\t\t\t\tcon.close();\n-\t\t\t\t}\n-\t\t\t} catch (SQLException ex) {\n-                                ex.printStackTrace();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void setAccID(int id) {\n-\t\tthis.accId = id;\n-\t}\n-\n-\tpublic int getAccID() {\n-\t\treturn accId;\n-\t}\n-        \n-        public void updateLoginState(int newstate) {\n-                // rules out possibility of multiple account entries\n-                if (newstate == LOGIN_LOGGEDIN) {\n-                        MapleSessionCoordinator.getInstance().updateOnlineSession(this.getSession());\n+            }\n+            con.close();\n+        } catch (SQLException e) {\n+            FilePrinter.printError(\"hasVotedAlready.txt\", e);\n+            return -1;\n+        }\n+        return voteTime;\n+    }\n+\n+    public void resetVoteTime() {\n+        voteTime = -1;\n+    }\n+\n+    public boolean hasVotedAlready() {\n+        Date currentDate = new Date();\n+        int timeNow = (int) (currentDate.getTime() / 1000);\n+        int difference = (timeNow - getVoteTime());\n+        return difference < 86400 && difference > 0;\n+    }\n+\n+    public boolean hasBannedHWID() {\n+        if (hwid == null) {\n+            return false;\n+        }\n+\n+        boolean ret = false;\n+        PreparedStatement ps = null;\n+        Connection con = null;\n+        try {\n+            con = DatabaseConnection.getConnection();\n+            ps = con.prepareStatement(\"SELECT COUNT(*) FROM hwidbans WHERE hwid LIKE ?\");\n+            ps.setString(1, hwid);\n+            ResultSet rs = ps.executeQuery();\n+            if (rs != null && rs.next()) {\n+                if (rs.getInt(1) > 0) {\n+                    ret = true;\n                 }\n-                \n-\t\ttry {\n-                        Connection con = DatabaseConnection.getConnection();\n-\t\t\ttry (PreparedStatement ps = con.prepareStatement(\"UPDATE accounts SET loggedin = ?, lastlogin = ? WHERE id = ?\")) {\n-                                // using sql currenttime here could potentially break the login, thanks Arnah for pointing this out\n-                            \n-\t\t\t\tps.setInt(1, newstate);\n-                                ps.setTimestamp(2, new java.sql.Timestamp(Server.getInstance().getCurrentTime()));\n-\t\t\t\tps.setInt(3, getAccID());\n-\t\t\t\tps.executeUpdate();\n-\t\t\t}\n-                        con.close();\n-\t\t} catch (SQLException e) {\n-\t\t\te.printStackTrace();\n-\t\t}\n-                \n-\t\tif (newstate == LOGIN_NOTLOGGEDIN) {\n-\t\t\tloggedIn = false;\n-\t\t\tserverTransition = false;\n-                        setAccID(0);\n-\t\t} else {\n-\t\t\tserverTransition = (newstate == LOGIN_SERVER_TRANSITION);\n-\t\t\tloggedIn = !serverTransition;\n-\t\t}\n-\t}\n-\n-\tpublic int getLoginState() {  // 0 = LOGIN_NOTLOGGEDIN, 1= LOGIN_SERVER_TRANSITION, 2 = LOGIN_LOGGEDIN\n-\t\ttry {\n-\t\t\tConnection con = DatabaseConnection.getConnection();\n-\t\t\tPreparedStatement ps = con.prepareStatement(\"SELECT loggedin, lastlogin, birthday FROM accounts WHERE id = ?\");\n-\t\t\tps.setInt(1, getAccID());\n-\t\t\tResultSet rs = ps.executeQuery();\n-\t\t\tif (!rs.next()) {\n-\t\t\t\trs.close();\n-\t\t\t\tps.close();\n-\t\t\t\tthrow new RuntimeException(\"getLoginState - MapleClient AccID: \" + getAccID());\n-\t\t\t}\n-                        \n-\t\t\tbirthday = Calendar.getInstance();\n-                        try {\n-                            birthday.setTime(rs.getDate(\"birthday\"));\n-                        } catch(SQLException e) {}\n-\t\t\t\n-\t\t\tint state = rs.getInt(\"loggedin\");\n-\t\t\tif (state == LOGIN_SERVER_TRANSITION) {\n-\t\t\t\tif (rs.getTimestamp(\"lastlogin\").getTime() + 30000 < Server.getInstance().getCurrentTime()) {\n-\t\t\t\t\tstate = LOGIN_NOTLOGGEDIN;\n-                                        MapleSessionCoordinator.getInstance().closeSession(session, null);\n-\t\t\t\t\tupdateLoginState(LOGIN_NOTLOGGEDIN);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\trs.close();\n-\t\t\tps.close();\n-\t\t\tif (state == LOGIN_LOGGEDIN) {\n-\t\t\t\tloggedIn = true;\n-\t\t\t} else if (state == LOGIN_SERVER_TRANSITION) {\n-\t\t\t\tps = con.prepareStatement(\"UPDATE accounts SET loggedin = 0 WHERE id = ?\");\n-\t\t\t\tps.setInt(1, getAccID());\n-\t\t\t\tps.executeUpdate();\n-\t\t\t\tps.close();\n-\t\t\t} else {\n-\t\t\t\tloggedIn = false;\n-\t\t\t}\n-                        \n-                        con.close();\n-\t\t\treturn state;\n-\t\t} catch (SQLException e) {\n-\t\t\tloggedIn = false;\n-\t\t\te.printStackTrace();\n-\t\t\tthrow new RuntimeException(\"login state\");\n-\t\t}\n-\t}\n-\n-\tpublic boolean checkBirthDate(Calendar date) {\n-                return date.get(Calendar.YEAR) == birthday.get(Calendar.YEAR) && date.get(Calendar.MONTH) == birthday.get(Calendar.MONTH) && date.get(Calendar.DAY_OF_MONTH) == birthday.get(Calendar.DAY_OF_MONTH);\n-\t}\n-\n-        private void removePartyPlayer(World wserv) {\n-                MapleMap map = player.getMap();\n-                final MapleParty party = player.getParty();\n-                final int idz = player.getId();\n-                final MaplePartyCharacter chrp = new MaplePartyCharacter(player);\n-                \n-                if (party != null) {\n-                        chrp.setOnline(false);\n-                        wserv.updateParty(party.getId(), PartyOperation.LOG_ONOFF, chrp);\n-                        if (party.getLeader().getId() == idz && map != null) {\n-                                MaplePartyCharacter lchr = null;\n-                                for (MaplePartyCharacter pchr : party.getMembers()) {\n-                                        if (pchr != null && pchr.getId() != idz && (lchr == null || lchr.getLevel() <= pchr.getLevel()) && map.getCharacterById(pchr.getId()) != null) {\n-                                                lchr = pchr;\n-                                        }\n-                                }\n-                                if (lchr != null) {\n-                                        wserv.updateParty(party.getId(), PartyOperation.CHANGE_LEADER, lchr);\n-                                }\n-                        }\n+            }\n+        } catch (SQLException e) {\n+            e.printStackTrace();\n+        } finally {\n+            try {\n+                if (ps != null && !ps.isClosed()) {\n+                    ps.close();\n                 }\n+\n+                if (con != null && !con.isClosed()) {\n+                    con.close();\n+                }\n+            } catch (SQLException e) {\n+                e.printStackTrace();\n+            }\n         }\n-        \n-\tprivate void removePlayer(World wserv, boolean serverTransition) {\n-\t\ttry {\n-                        player.setDisconnectedFromChannelWorld();\n-                        player.notifyMapTransferToPartner(-1);\n-                        player.cancelAllBuffs(true);\n-                        \n-                        player.closePlayerInteractions();\n-                        QuestScriptManager.getInstance().dispose(this);\n-                        \n-                        if (!serverTransition) {    // thanks MedicOP for detecting an issue with party leader change on changing channels\n-                                removePartyPlayer(wserv);\n-\n-                                EventInstanceManager eim = player.getEventInstance();\n-                                if (eim != null) {\n-                                        eim.playerDisconnected(player);\n-                                }\n+\n+        return ret;\n+    }\n+\n+    public boolean hasBannedMac() {\n+        if (macs.isEmpty()) {\n+            return false;\n+        }\n+        boolean ret = false;\n+        int i;\n+        try {\n+            StringBuilder sql = new StringBuilder(\"SELECT COUNT(*) FROM macbans WHERE mac IN (\");\n+            for (i = 0; i < macs.size(); i++) {\n+                sql.append(\"?\");\n+                if (i != macs.size() - 1) {\n+                    sql.append(\", \");\n+                }\n+            }\n+            sql.append(\")\");\n+\n+            Connection con = DatabaseConnection.getConnection();\n+            try (PreparedStatement ps = con.prepareStatement(sql.toString())) {\n+                i = 0;\n+                for (String mac : macs) {\n+                    i++;\n+                    ps.setString(i, mac);\n+                }\n+                try (ResultSet rs = ps.executeQuery()) {\n+                    rs.next();\n+                    if (rs.getInt(1) > 0) {\n+                        ret = true;\n+                    }\n+                }\n+            } finally {\n+                con.close();\n+            }\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+        return ret;\n+    }\n+\n+    private void loadHWIDIfNescessary() throws SQLException {\n+        if (hwid == null) {\n+            Connection con = DatabaseConnection.getConnection();\n+            try (PreparedStatement ps = con.prepareStatement(\"SELECT hwid FROM accounts WHERE id = ?\")) {\n+                ps.setInt(1, accId);\n+                try (ResultSet rs = ps.executeQuery()) {\n+                    if (rs.next()) {\n+                        hwid = rs.getString(\"hwid\");\n+                    }\n+                }\n+            } finally {\n+                con.close();\n+            }\n+        }\n+    }\n+\n+    // TODO: Recode to close statements...\n+    private void loadMacsIfNescessary() throws SQLException {\n+        if (macs.isEmpty()) {\n+            Connection con = DatabaseConnection.getConnection();\n+            try (PreparedStatement ps = con.prepareStatement(\"SELECT macs FROM accounts WHERE id = ?\")) {\n+                ps.setInt(1, accId);\n+                try (ResultSet rs = ps.executeQuery()) {\n+                    if (rs.next()) {\n+                        for (String mac : rs.getString(\"macs\").split(\", \")) {\n+                            if (!mac.equals(\"\")) {\n+                                macs.add(mac);\n+                            }\n                         }\n-                        \n-                        if (player.getMap() != null) {\n-                                int mapId = player.getMapId();\n-                                player.getMap().removePlayer(player);\n-                                if(GameConstants.isDojo(mapId)) {\n-                                        this.getChannelServer().freeDojoSectionIfEmpty(mapId);\n-                                }\n-\t\t\t}\n-\n-\t\t} catch (final Throwable t) {\n-\t\t\tFilePrinter.printError(FilePrinter.ACCOUNT_STUCK, t);\n-\t\t}\n-\t}\n-\n-        public final void disconnect(final boolean shutdown, final boolean cashshop) {\n-                if (canDisconnect()) {\n-                        ThreadManager.getInstance().newTask(new Runnable() {\n-                                @Override\n-                                public void run() {\n-                                        disconnectInternal(shutdown, cashshop);\n-                                }\n-                        });\n+                    }\n                 }\n+            } finally {\n+                con.close();\n+            }\n         }\n-        \n-        public final void forceDisconnect() {\n-                if (canDisconnect()) {\n-                        disconnectInternal(true, false);\n+    }\n+\n+    public void banHWID() {\n+        PreparedStatement ps = null;\n+        Connection con = null;\n+        try {\n+            loadHWIDIfNescessary();\n+\n+            con = DatabaseConnection.getConnection();\n+            ps = con.prepareStatement(\"INSERT INTO hwidbans (hwid) VALUES (?)\");\n+            ps.setString(1, hwid);\n+            ps.executeUpdate();\n+        } catch (SQLException e) {\n+            e.printStackTrace();\n+        } finally {\n+            try {\n+                if (ps != null && !ps.isClosed()) {\n+                    ps.close();\n+                }\n+                if (con != null && !con.isClosed()) {\n+                    con.close();\n                 }\n+            } catch (SQLException e) {\n+                e.printStackTrace();\n+            }\n         }\n-        \n-        private synchronized boolean canDisconnect() {\n-                if (disconnecting) {\n-\t\t\treturn false;\n-\t\t}\n-                \n-\t\tdisconnecting = true;\n-                return true;\n-        }\n-        \n-\tprivate void disconnectInternal(boolean shutdown, boolean cashshop) {//once per MapleClient instance\n-\t\tif (player != null && player.isLoggedin() && player.getClient() != null) {\n-\t\t\tfinal int messengerid = player.getMessenger() == null ? 0 : player.getMessenger().getId();\n-\t\t\t//final int fid = player.getFamilyId();\n-\t\t\tfinal BuddyList bl = player.getBuddylist();\n-\t\t\tfinal MapleMessengerCharacter chrm = new MapleMessengerCharacter(player, 0);\n-\t\t\tfinal MapleGuildCharacter chrg = player.getMGC();\n-\t\t\tfinal MapleGuild guild = player.getGuild();\n-                        \n-                        player.cancelMagicDoor();\n-                        \n-                        final World wserv = getWorldServer();   // obviously wserv is NOT null if this player was online on it\n-                        try {\n-                                removePlayer(wserv, this.serverTransition);\n-                                \n-                                if (!(channel == -1 || shutdown)) {\n-                                        if (!cashshop) {\n-                                                if (!this.serverTransition) { // meaning not changing channels\n-                                                        if (messengerid > 0) {\n-                                                                wserv.leaveMessenger(messengerid, chrm);\n-                                                        }\n-                                                        /*      \n-                                                        if (fid > 0) {\n-                                                                final MapleFamily family = worlda.getFamily(fid);\n-                                                                family.\n-                                                        }\n-                                                        */\n-                                                        for (MapleQuestStatus status : player.getStartedQuests()) { //This is for those quests that you have to stay logged in for a certain amount of time\n-                                                                MapleQuest quest = status.getQuest();\n-                                                                if (quest.getTimeLimit() > 0) {\n-                                                                        MapleQuestStatus newStatus = new MapleQuestStatus(quest, MapleQuestStatus.Status.NOT_STARTED);\n-                                                                        newStatus.setForfeited(player.getQuest(quest).getForfeited() + 1);\n-                                                                        player.updateQuest(newStatus);\n-                                                                }\n-                                                        }\t                   \n-                                                        if (guild != null) {\n-                                                                final Server server = Server.getInstance();\n-                                                                server.setGuildMemberOnline(player, false, player.getClient().getChannel());\n-                                                                player.getClient().announce(MaplePacketCreator.showGuildInfo(player));\n-                                                        }\n-                                                        if (bl != null) {\n-                                                                wserv.loggedOff(player.getName(), player.getId(), channel, player.getBuddylist().getBuddyIds());\n-                                                        }\n-                                                }\n-                                        } else {\n-                                                if (!this.serverTransition) { // if dc inside of cash shop.\t                \n-                                                        if (bl != null) {\n-                                                                wserv.loggedOff(player.getName(), player.getId(), channel, player.getBuddylist().getBuddyIds());\n-                                                        }\n-                                                }\n-                                        }\n-                                }\n-\t\t\t} catch (final Exception e) {\n-\t\t\t\tFilePrinter.printError(FilePrinter.ACCOUNT_STUCK, e);\n-\t\t\t} finally {\n-                                if (!this.serverTransition) {\n-                                        if(chrg != null) chrg.setCharacter(null);\n-\t\t\t\t\twserv.removePlayer(player);\n-                                        //getChannelServer().removePlayer(player); already being done\n-                                        \n-                                        player.saveCooldowns();\n-                                        player.cancelAllDebuffs();\n-                                        player.saveCharToDB(true);\n-                                        \n-\t\t\t\t\tplayer.logOff();\n-                                        clear();\n-\t\t\t\t} else {\n-                                        getChannelServer().removePlayer(player);\n-\n-                                        player.saveCooldowns();\n-                                        player.cancelAllDebuffs();\n-                                        player.saveCharToDB();\n-                                }\n-\t\t\t}\n-\t\t}\n-\t\tif (!serverTransition && isLoggedIn()) {\n-                        MapleSessionCoordinator.getInstance().closeSession(session, false);\n-\t\t\tupdateLoginState(MapleClient.LOGIN_NOTLOGGEDIN);\n-\t\t\tsession.removeAttribute(MapleClient.CLIENT_KEY); // prevents double dcing during login\n-\t\t\t\n-                        clear();\n-\t\t} else {\n-                        if (session.containsAttribute(MapleClient.CLIENT_KEY)) {\n-                                MapleSessionCoordinator.getInstance().closeSession(session, false);\n-                                session.removeAttribute(MapleClient.CLIENT_KEY);\n+    }\n+\n+    public void banMacs() {\n+        Connection con = null;\n+        try {\n+            loadMacsIfNescessary();\n+\n+            con = DatabaseConnection.getConnection();\n+            List<String> filtered = new LinkedList<>();\n+            try (PreparedStatement ps = con.prepareStatement(\"SELECT filter FROM macfilters\"); ResultSet rs = ps.executeQuery()) {\n+                while (rs.next()) {\n+                    filtered.add(rs.getString(\"filter\"));\n+                }\n+            }\n+            try (PreparedStatement ps = con.prepareStatement(\"INSERT INTO macbans (mac, aid) VALUES (?, ?)\")) {\n+                for (String mac : macs) {\n+                    boolean matched = false;\n+                    for (String filter : filtered) {\n+                        if (mac.matches(filter)) {\n+                            matched = true;\n+                            break;\n                         }\n-                    \n-                        engines.clear();\n+                    }\n+                    if (!matched) {\n+                        ps.setString(1, mac);\n+                        ps.setString(2, String.valueOf(getAccID()));\n+                        ps.executeUpdate();\n+                    }\n                 }\n-\t}\n+            }\n \n-\tprivate void clear() {\n-                // player hard reference removal thanks to Steve (kaito1410)\n-                if (this.player != null) {\n-                    this.player.empty(true); // clears schedules and stuff\n+            con.close();\n+        } catch (SQLException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    public int finishLogin() {\n+        loginLock.lock();\n+        try {\n+            if (getLoginState() > LOGIN_NOTLOGGEDIN) { // 0 = LOGIN_NOTLOGGEDIN, 1= LOGIN_SERVER_TRANSITION, 2 = LOGIN_LOGGEDIN\n+                loggedIn = false;\n+                return 7;\n+            }\n+            updateLoginState(LOGIN_LOGGEDIN);\n+        } finally {\n+            loginLock.unlock();\n+        }\n+\n+        return 0;\n+    }\n+\n+    public void setPin(String pin) {\n+        this.pin = pin;\n+        try {\n+            Connection con = DatabaseConnection.getConnection();\n+            try (PreparedStatement ps = con.prepareStatement(\"UPDATE accounts SET pin = ? WHERE id = ?\")) {\n+                ps.setString(1, pin);\n+                ps.setInt(2, accId);\n+                ps.executeUpdate();\n+            } finally {\n+                con.close();\n+            }\n+        } catch (SQLException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    public String getPin() {\n+        return pin;\n+    }\n+\n+    public boolean checkPin(String other) {\n+        pinattempt++;\n+        if (pinattempt > 5) {\n+            MapleSessionCoordinator.getInstance().closeSession(session, false);\n+        }\n+        if (pin.equals(other)) {\n+            pinattempt = 0;\n+            MapleLoginBypassCoordinator.getInstance().registerLoginBypassEntry(getNibbleHWID(), accId, false);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public void setPic(String pic) {\n+        this.pic = pic;\n+        try {\n+            Connection con = DatabaseConnection.getConnection();\n+            try (PreparedStatement ps = con.prepareStatement(\"UPDATE accounts SET pic = ? WHERE id = ?\")) {\n+                ps.setString(1, pic);\n+                ps.setInt(2, accId);\n+                ps.executeUpdate();\n+            } finally {\n+                con.close();\n+            }\n+        } catch (SQLException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    public String getPic() {\n+        return pic;\n+    }\n+\n+    public boolean checkPic(String other) {\n+        if (!(ServerConstants.ENABLE_PIC && !canBypassPic())) {\n+            return true;\n+        }\n+\n+        picattempt++;\n+        if (picattempt > 5) {\n+            MapleSessionCoordinator.getInstance().closeSession(session, false);\n+        }\n+        if (pic.equals(other)) {\n+            picattempt = 0;\n+            MapleLoginBypassCoordinator.getInstance().registerLoginBypassEntry(getNibbleHWID(), accId, true);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public int login(String login, String pwd, String nibbleHwid) {\n+        int loginok = 5;\n+\n+        loginattempt++;\n+        if (loginattempt > 4) {\n+            loggedIn = false;\n+            MapleSessionCoordinator.getInstance().closeSession(session, false);\n+            return loginok;\n+        }\n+\n+        Connection con = null;\n+        PreparedStatement ps = null;\n+        ResultSet rs = null;\n+        try {\n+            con = DatabaseConnection.getConnection();\n+            ps = con.prepareStatement(\"SELECT id, password, gender, banned, pin, pic, characterslots, tos FROM accounts WHERE name = ?\");\n+            ps.setString(1, login);\n+            rs = ps.executeQuery();\n+            if (rs.next()) {\n+                boolean banned = (rs.getByte(\"banned\") == 1);\n+                accId = rs.getInt(\"id\");\n+                gmlevel = 0;\n+                pin = rs.getString(\"pin\");\n+                pic = rs.getString(\"pic\");\n+                gender = rs.getByte(\"gender\");\n+                characterSlots = rs.getByte(\"characterslots\");\n+                String passhash = rs.getString(\"password\");\n+                byte tos = rs.getByte(\"tos\");\n+\n+                ps.close();\n+                rs.close();\n+\n+                if (banned) {\n+                    return 3;\n                 }\n-            \n-                Server.getInstance().unregisterLoginState(this);\n-            \n-                this.accountName = null;\n-\t\tthis.macs = null;\n-\t\tthis.hwid = null;\n-\t\tthis.birthday = null;\n-\t\tthis.engines = null;\n-\t\tthis.player = null;\n-\t\tthis.receive = null;\n-\t\tthis.send = null;\n-\t\t//this.session = null;\n-\t}\n-\n-\tpublic int getChannel() {\n-\t\treturn channel;\n-\t}\n-\n-\tpublic Channel getChannelServer() {\n-\t\treturn Server.getInstance().getChannel(world, channel);\n-\t}\n-\n-\tpublic World getWorldServer() {\n-\t\treturn Server.getInstance().getWorld(world);\n-\t}\n-\n-\tpublic Channel getChannelServer(byte channel) {\n-\t\treturn Server.getInstance().getChannel(world, channel);\n-\t}\n-\n-        public boolean deleteCharacter(int cid, int senderAccId) {\n-                try {\n-                        return MapleCharacter.deleteCharFromDB(MapleCharacter.loadCharFromDB(cid, this, false), senderAccId);\n-                } catch(SQLException ex) {\n-                        ex.printStackTrace();\n-                        return false;\n+\n+                if (getLoginState() > LOGIN_NOTLOGGEDIN) { // already loggedin\n+                    loggedIn = false;\n+                    loginok = 7;\n+                } else if (passhash.charAt(0) == '$' && passhash.charAt(1) == '2' && BCrypt.checkpw(pwd, passhash)) {\n+                    loginok = (tos == 0) ? 23 : 0;\n+                } else if (pwd.equals(passhash) || checkHash(passhash, \"SHA-1\", pwd) || checkHash(passhash, \"SHA-512\", pwd)) {\n+                    // thanks GabrielSin for detecting some no-bcrypt inconsistencies here\n+                    loginok = (tos == 0) ? (!ServerConstants.BCRYPT_MIGRATION ? 23 : -23) : (!ServerConstants.BCRYPT_MIGRATION ? 0 : -10); // migrate to bcrypt\n+                } else {\n+                    loggedIn = false;\n+                    loginok = 4;\n+                }\n+            }\n+        } catch (SQLException e) {\n+            e.printStackTrace();\n+        } finally {\n+            try {\n+                if (ps != null && !ps.isClosed()) {\n+                    ps.close();\n+                }\n+                if (rs != null && !rs.isClosed()) {\n+                    rs.close();\n+                }\n+                if (con != null && !con.isClosed()) {\n+                    con.close();\n                 }\n-\t}\n+            } catch (SQLException e) {\n+                e.printStackTrace();\n+            }\n+        }\n \n-\tpublic String getAccountName() {\n-\t\treturn accountName;\n-\t}\n+        if (loginok == 0 || loginok == 4) {\n+            AntiMulticlientResult res = MapleSessionCoordinator.getInstance().attemptLoginSession(session, nibbleHwid, accId, loginok == 4);\n \n-\tpublic void setAccountName(String a) {\n-\t\tthis.accountName = a;\n-\t}\n+            switch (res) {\n+                case SUCCESS:\n+                    if (loginok == 0) {\n+                        loginattempt = 0;\n+                    }\n \n-\tpublic void setChannel(int channel) {\n-\t\tthis.channel = channel;\n-\t}\n+                    return loginok;\n \n-\tpublic int getWorld() {\n-\t\treturn world;\n-\t}\n+                case REMOTE_LOGGEDIN:\n+                    return 17;\n \n-\tpublic void setWorld(int world) {\n-\t\tthis.world = world;\n-\t}\n+                case REMOTE_REACHED_LIMIT:\n+                    return 13;\n \n-\tpublic void pongReceived() {\n-\t\tlastPong = Server.getInstance().getCurrentTime();\n-\t}\n+                case REMOTE_PROCESSING:\n+                    return 10;\n \n-        public void testPing(long timeThen) {\n-                try {\n-                        if (lastPong < timeThen) {\n-                                if (session != null && session.isConnected()) {\n-                                        MapleSessionCoordinator.getInstance().closeSession(session, false);\n-                                        updateLoginState(MapleClient.LOGIN_NOTLOGGEDIN);\n-                                        session.removeAttribute(MapleClient.CLIENT_KEY);\n-                                }\n-                        }\n-                } catch (NullPointerException e) {\n-                    e.printStackTrace();\n+                case MANY_ACCOUNT_ATTEMPTS:\n+                    return 16;\n+\n+                default:\n+                    return 8;\n+            }\n+        } else {\n+            return loginok;\n+        }\n+    }\n+\n+    public Calendar getTempBanCalendar() {\n+        Connection con = null;\n+        PreparedStatement ps = null;\n+        ResultSet rs = null;\n+        final Calendar lTempban = Calendar.getInstance();\n+        try {\n+            con = DatabaseConnection.getConnection();\n+            ps = con.prepareStatement(\"SELECT `tempban` FROM accounts WHERE id = ?\");\n+            ps.setInt(1, getAccID());\n+            rs = ps.executeQuery();\n+            if (!rs.next()) {\n+                return null;\n+            }\n+            long blubb = rs.getLong(\"tempban\");\n+            if (blubb == 0) { // basically if timestamp in db is 0000-00-00\n+                return null;\n+            }\n+            lTempban.setTimeInMillis(rs.getTimestamp(\"tempban\").getTime());\n+            return lTempban;\n+        } catch (SQLException e) {\n+            e.printStackTrace();\n+        } finally {\n+            try {\n+                if (ps != null) {\n+                    ps.close();\n+                }\n+                if (rs != null) {\n+                    rs.close();\n+                }\n+                if (con != null && !con.isClosed()) {\n+                    con.close();\n                 }\n+            } catch (SQLException e) {\n+                e.printStackTrace();\n+            }\n         }\n-\t\n-\tpublic String getHWID() {\n-\t\treturn hwid;\n-\t}\n-        \n-        public void setHWID(String hwid) {\n-\t\tthis.hwid = hwid;\n-\t}\n-\n-\tpublic Set<String> getMacs() {\n-\t\treturn Collections.unmodifiableSet(macs);\n-\t}\n-\n-\tpublic int getGMLevel() {\n-\t\treturn gmlevel;\n-\t}\n-        \n-        public void setGMLevel(int level) {\n-\t\tgmlevel = level;\n-\t}\n-\n-\tpublic void setScriptEngine(String name, ScriptEngine e) {\n-                engines.put(name, e);\n-\t}\n-\n-\tpublic ScriptEngine getScriptEngine(String name) {\n-\t\treturn engines.get(name);\n-\t}\n-\n-\tpublic void removeScriptEngine(String name) {\n-                engines.remove(name);\n-\t}\n-\n-\tpublic NPCConversationManager getCM() {\n-\t\treturn NPCScriptManager.getInstance().getCM(this);\n-\t}\n-\n-\tpublic QuestActionManager getQM() {\n-\t\treturn QuestScriptManager.getInstance().getQM(this);\n-\t}\n-\n-\tpublic boolean acceptToS() {\n-\t\tboolean disconnectForBeingAFaggot = false;\n-\t\tif (accountName == null) {\n-\t\t\treturn true;\n-\t\t}\n-\t\ttry {\n-                        Connection con = DatabaseConnection.getConnection();\n-\t\t\tPreparedStatement ps = con.prepareStatement(\"SELECT `tos` FROM accounts WHERE id = ?\");\n-\t\t\tps.setInt(1, accId);\n-\t\t\tResultSet rs = ps.executeQuery();\n-\n-\t\t\tif (rs.next()) {\n-\t\t\t\tif (rs.getByte(\"tos\") == 1) {\n-\t\t\t\t\tdisconnectForBeingAFaggot = true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tps.close();\n-\t\t\trs.close();\n-\t\t\tps = con.prepareStatement(\"UPDATE accounts SET tos = 1 WHERE id = ?\");\n-\t\t\tps.setInt(1, accId);\n-\t\t\tps.executeUpdate();\n-\t\t\tps.close();\n-                        con.close();\n-\t\t} catch (SQLException e) {\n-                    e.printStackTrace();\n-\t\t}\n-\t\treturn disconnectForBeingAFaggot;\n-\t}\n-\n-\tpublic int getVotePoints(){\n-\t\tint points = 0;\n-\t\ttry {\n-                        Connection con = DatabaseConnection.getConnection();\n-\t\t\tPreparedStatement ps = con.prepareStatement(\"SELECT `votepoints` FROM accounts WHERE id = ?\");\n-\t\t\tps.setInt(1, accId);\n-\t\t\tResultSet rs = ps.executeQuery();\n-\n-\t\t\tif (rs.next()) {\n-\t\t\t\tpoints = rs.getInt(\"votepoints\");\n-\t\t\t}\n-\t\t\tps.close();\n-\t\t\trs.close();\n+        return null;//why oh why!?!\n+    }\n \n+    public static long dottedQuadToLong(String dottedQuad) throws RuntimeException {\n+        String[] quads = dottedQuad.split(\"\\\\.\");\n+        if (quads.length != 4) {\n+            throw new RuntimeException(\"Invalid IP Address format.\");\n+        }\n+        long ipAddress = 0;\n+        for (int i = 0; i < 4; i++) {\n+            int quad = Integer.parseInt(quads[i]);\n+            ipAddress += (long) (quad % 256) * (long) Math.pow(256, (double) (4 - i));\n+        }\n+        return ipAddress;\n+    }\n+\n+    public void updateHWID(String newHwid) {\n+        String[] split = newHwid.split(\"_\");\n+        if (split.length > 1 && split[1].length() == 8) {\n+            StringBuilder hwid = new StringBuilder();\n+            String convert = split[1];\n+\n+            int len = convert.length();\n+            for (int i = len - 2; i >= 0; i -= 2) {\n+                hwid.append(convert.substring(i, i + 2));\n+            }\n+            hwid.insert(4, \"-\");\n+\n+            this.hwid = hwid.toString();\n+\n+            PreparedStatement ps = null;\n+            Connection con = null;\n+            try {\n+                con = DatabaseConnection.getConnection();\n+                ps = con.prepareStatement(\"UPDATE accounts SET hwid = ? WHERE id = ?\");\n+                ps.setString(1, this.hwid);\n+                ps.setInt(2, accId);\n+                ps.executeUpdate();\n+                ps.close();\n+            } catch (SQLException e) {\n+                e.printStackTrace();\n+            } finally {\n+                try {\n+                    if (ps != null && !ps.isClosed()) {\n+                        ps.close();\n+                    }\n+                    if (con != null && !con.isClosed()) {\n                         con.close();\n-\t\t} catch (SQLException e) {\n+                    }\n+                } catch (SQLException e) {\n                     e.printStackTrace();\n-\t\t}\n-\t\tvotePoints = points;\n-\t\treturn votePoints;\n-\t}\n-\n-\tpublic void addVotePoints(int points) {\n-\t\tvotePoints += points;\n-\t\tsaveVotePoints();\n-\t}\n-\n-\tpublic void useVotePoints(int points){\n-\t\tif (points > votePoints){\n-\t\t\t//Should not happen, should probably log this\n-\t\t\treturn;\n-\t\t}\n-\t\tvotePoints -= points;\n-\t\tsaveVotePoints();\n-\t\tLogHelper.logLeaf(player, false, Integer.toString(points));\n-\t}\n-\n-\tprivate void saveVotePoints() {\n-\t\ttry {\n-\t\t\tConnection con = DatabaseConnection.getConnection();\n-\t\t\ttry (PreparedStatement ps = con.prepareStatement(\"UPDATE accounts SET votepoints = ? WHERE id = ?\")) {\n-\t\t\t\tps.setInt(1, votePoints);\n-\t\t\t\tps.setInt(2, accId);\n-\t\t\t\tps.executeUpdate();\n-\t\t\t}\n-                        \n-                        con.close();\n-\t\t} catch (SQLException e) {\n-\t\t\te.printStackTrace();\n-\t\t}\n-\t}\n-\n-\tpublic void lockClient() {\n-                lock.lock();\n-\t}\n-        \n-        public void unlockClient() {\n-                lock.unlock();\n-\t}\n-        \n-        public boolean tryacquireClient() {\n-                if (actionsSemaphore.tryAcquire()) {\n-                        lockClient();\n-                        return true;\n-                } else {\n-                        return false;\n                 }\n-\t}\n-        \n-        public void releaseClient() {\n-                unlockClient();\n-                actionsSemaphore.release();\n-        }\n-        \n-        public void lockEncoder() {\n-                encoderLock.lock();\n-\t}\n-        \n-        public void unlockEncoder() {\n-                encoderLock.unlock();\n-\t}\n-\n-\tprivate static class CharNameAndId {\n-\n-\t\tpublic String name;\n-\t\tpublic int id;\n-\n-\t\tpublic CharNameAndId(String name, int id) {\n-\t\t\tsuper();\n-\t\t\tthis.name = name;\n-\t\t\tthis.id = id;\n-\t\t}\n-\t}\n-\n-\tprivate static boolean checkHash(String hash, String type, String password) {\n-\t\ttry {\n-\t\t\tMessageDigest digester = MessageDigest.getInstance(type);\n-\t\t\tdigester.update(password.getBytes(\"UTF-8\"), 0, password.length());\n-                        return HexTool.toString(digester.digest()).replace(\" \", \"\").toLowerCase().equals(hash);\n-\t\t} catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {\n-\t\t\tthrow new RuntimeException(\"Encoding the string failed\", e);\n-\t\t}\n-\t}\n-\n-        public short getAvailableCharacterSlots() {\n-                return (short) Math.max(0, characterSlots - Server.getInstance().getAccountCharacterCount(accId));\n-\t}\n-        \n-        public short getAvailableCharacterWorldSlots() {\n-                return (short) Math.max(0, characterSlots - Server.getInstance().getAccountWorldCharacterCount(accId, world));\n-\t}\n-        \n-\tpublic short getCharacterSlots() {\n-\t\treturn characterSlots;\n-\t}\n-        \n-        public void setCharacterSlots(byte slots) {\n-                characterSlots = slots;\n-\t}\n-        \n-        public synchronized boolean gainCharacterSlot() {\n-\t\tif (characterSlots < 15) {\n-\t\t\tConnection con = null;\n-\t\t\ttry {\n-                                con = DatabaseConnection.getConnection();\n-                                \n-\t\t\t\ttry (PreparedStatement ps = con.prepareStatement(\"UPDATE accounts SET characterslots = ? WHERE id = ?\")) {\n-\t\t\t\t\tps.setInt(1, this.characterSlots += 1);\n-\t\t\t\t\tps.setInt(2, accId);\n-\t\t\t\t\tps.executeUpdate();\n-\t\t\t\t}\n-                                \n-                                con.close();\n-\t\t\t} catch (SQLException e) {\n-                                e.printStackTrace();\n-\t\t\t}\n-\t\t\treturn true;\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\tpublic final byte getGReason() {\n-\t\tConnection con = null;\n-\t\tPreparedStatement ps = null;\n-\t\tResultSet rs = null;\n-\t\ttry {\n-                        con = DatabaseConnection.getConnection();\n-\t\t\tps = con.prepareStatement(\"SELECT `greason` FROM `accounts` WHERE id = ?\");\n-\t\t\tps.setInt(1, accId);\n-\t\t\trs = ps.executeQuery();\n-\t\t\tif (rs.next()) {\n-\t\t\t\treturn rs.getByte(\"greason\");\n-\t\t\t}\n-\t\t} catch (SQLException e) {\n-\t\t\te.printStackTrace();\n-\t\t} finally {\n-\t\t\ttry {\n-\t\t\t\tif (ps != null) {\n-\t\t\t\t\tps.close();\n-\t\t\t\t}\n-\t\t\t\tif (rs != null) {\n-\t\t\t\t\trs.close();\n-\t\t\t\t}\n-                                if (con != null) {\n-\t\t\t\t\tcon.close();\n-\t\t\t\t}\n-\t\t\t} catch (SQLException e) {\n-                                e.printStackTrace();\n-\t\t\t}\n-\t\t}\n-\t\treturn 0;\n-\t}\n-\n-\tpublic byte getGender() {\n-\t\treturn gender;\n-\t}\n-\n-\tpublic void setGender(byte m) {\n-\t\tthis.gender = m;\n-                Connection con = null;\n-\t\ttry {\n-                        con = DatabaseConnection.getConnection();\n-\t\t\ttry (PreparedStatement ps = con.prepareStatement(\"UPDATE accounts SET gender = ? WHERE id = ?\")) {\n-\t\t\t\tps.setByte(1, gender);\n-\t\t\t\tps.setInt(2, accId);\n-\t\t\t\tps.executeUpdate();\n-\t\t\t}\n-                        \n-                        con.close();\n-\t\t} catch (SQLException e) {\n-                    e.printStackTrace();\n-\t\t}\n-\t}\n-        \n-        private void announceDisableServerMessage() {\n-            if(!this.getWorldServer().registerDisabledServerMessage(player.getId())) {\n-                announce(MaplePacketCreator.serverMessage(\"\"));\n             }\n+        } else {\n+            this.disconnect(false, false); // Invalid HWID...\n+        }\n+    }\n+\n+    public void updateMacs(String macData) {\n+        macs.addAll(Arrays.asList(macData.split(\", \")));\n+        StringBuilder newMacData = new StringBuilder();\n+        Iterator<String> iter = macs.iterator();\n+        PreparedStatement ps = null;\n+        while (iter.hasNext()) {\n+            String cur = iter.next();\n+            newMacData.append(cur);\n+            if (iter.hasNext()) {\n+                newMacData.append(\", \");\n+            }\n+        }\n+        Connection con = null;\n+        try {\n+            con = DatabaseConnection.getConnection();\n+            ps = con.prepareStatement(\"UPDATE accounts SET macs = ? WHERE id = ?\");\n+            ps.setString(1, newMacData.toString());\n+            ps.setInt(2, accId);\n+            ps.executeUpdate();\n+            ps.close();\n+        } catch (SQLException e) {\n+            e.printStackTrace();\n+        } finally {\n+            try {\n+                if (ps != null && !ps.isClosed()) {\n+                    ps.close();\n+                }\n+                if (con != null && !con.isClosed()) {\n+                    con.close();\n+                }\n+            } catch (SQLException ex) {\n+                ex.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    public void setAccID(int id) {\n+        this.accId = id;\n+    }\n+\n+    public int getAccID() {\n+        return accId;\n+    }\n+\n+    public void updateLoginState(int newstate) {\n+        // rules out possibility of multiple account entries\n+        if (newstate == LOGIN_LOGGEDIN) {\n+            MapleSessionCoordinator.getInstance().updateOnlineSession(this.getSession());\n+        }\n+\n+        try {\n+            Connection con = DatabaseConnection.getConnection();\n+            try (PreparedStatement ps = con.prepareStatement(\"UPDATE accounts SET loggedin = ?, lastlogin = ? WHERE id = ?\")) {\n+                                // using sql currenttime here could potentially break the login, thanks Arnah for pointing this out\n+\n+                ps.setInt(1, newstate);\n+                ps.setTimestamp(2, new java.sql.Timestamp(Server.getInstance().getCurrentTime()));\n+                ps.setInt(3, getAccID());\n+                ps.executeUpdate();\n+            }\n+            con.close();\n+        } catch (SQLException e) {\n+            e.printStackTrace();\n+        }\n+\n+        if (newstate == LOGIN_NOTLOGGEDIN) {\n+            loggedIn = false;\n+            serverTransition = false;\n+            setAccID(0);\n+        } else {\n+            serverTransition = (newstate == LOGIN_SERVER_TRANSITION);\n+            loggedIn = !serverTransition;\n+        }\n+    }\n+\n+    public int getLoginState() {  // 0 = LOGIN_NOTLOGGEDIN, 1= LOGIN_SERVER_TRANSITION, 2 = LOGIN_LOGGEDIN\n+        try {\n+            Connection con = DatabaseConnection.getConnection();\n+            PreparedStatement ps = con.prepareStatement(\"SELECT loggedin, lastlogin, birthday FROM accounts WHERE id = ?\");\n+            ps.setInt(1, getAccID());\n+            ResultSet rs = ps.executeQuery();\n+            if (!rs.next()) {\n+                rs.close();\n+                ps.close();\n+                throw new RuntimeException(\"getLoginState - MapleClient AccID: \" + getAccID());\n+            }\n+\n+            birthday = Calendar.getInstance();\n+            try {\n+                birthday.setTime(rs.getDate(\"birthday\"));\n+            } catch (SQLException e) {\n+            }\n+\n+            int state = rs.getInt(\"loggedin\");\n+            if (state == LOGIN_SERVER_TRANSITION) {\n+                if (rs.getTimestamp(\"lastlogin\").getTime() + 30000 < Server.getInstance().getCurrentTime()) {\n+                    state = LOGIN_NOTLOGGEDIN;\n+                    MapleSessionCoordinator.getInstance().closeSession(session, null);\n+                    updateLoginState(LOGIN_NOTLOGGEDIN);\n+                }\n+            }\n+            rs.close();\n+            ps.close();\n+            if (state == LOGIN_LOGGEDIN) {\n+                loggedIn = true;\n+            } else if (state == LOGIN_SERVER_TRANSITION) {\n+                ps = con.prepareStatement(\"UPDATE accounts SET loggedin = 0 WHERE id = ?\");\n+                ps.setInt(1, getAccID());\n+                ps.executeUpdate();\n+                ps.close();\n+            } else {\n+                loggedIn = false;\n+            }\n+\n+            con.close();\n+            return state;\n+        } catch (SQLException e) {\n+            loggedIn = false;\n+            e.printStackTrace();\n+            throw new RuntimeException(\"login state\");\n         }\n-        \n-        public void announceServerMessage() {\n-            announce(MaplePacketCreator.serverMessage(this.getChannelServer().getServerMessage()));\n-        }\n-        \n-        public synchronized void announceBossHpBar(MapleMonster mm, final int mobHash, final byte[] packet) {\n-                long timeNow = System.currentTimeMillis();\n-                int targetHash = player.getTargetHpBarHash();\n-                \n-                if(mobHash != targetHash) {\n-                        if(timeNow - player.getTargetHpBarTime() >= 5 * 1000) {\n-                                // is there a way to INTERRUPT this annoying thread running on the client that drops the boss bar after some time at every attack?\n-                                announceDisableServerMessage();\n-                                announce(packet);\n-                                \n-                                player.setTargetHpBarHash(mobHash);\n-                                player.setTargetHpBarTime(timeNow);\n+    }\n+\n+    public boolean checkBirthDate(Calendar date) {\n+        return date.get(Calendar.YEAR) == birthday.get(Calendar.YEAR) && date.get(Calendar.MONTH) == birthday.get(Calendar.MONTH) && date.get(Calendar.DAY_OF_MONTH) == birthday.get(Calendar.DAY_OF_MONTH);\n+    }\n+\n+    private void removePartyPlayer(World wserv) {\n+        MapleMap map = player.getMap();\n+        final MapleParty party = player.getParty();\n+        final int idz = player.getId();\n+        final MaplePartyCharacter chrp = new MaplePartyCharacter(player);\n+\n+        if (party != null) {\n+            chrp.setOnline(false);\n+            wserv.updateParty(party.getId(), PartyOperation.LOG_ONOFF, chrp);\n+            if (party.getLeader().getId() == idz && map != null) {\n+                MaplePartyCharacter lchr = null;\n+                for (MaplePartyCharacter pchr : party.getMembers()) {\n+                    if (pchr != null && pchr.getId() != idz && (lchr == null || lchr.getLevel() <= pchr.getLevel()) && map.getCharacterById(pchr.getId()) != null) {\n+                        lchr = pchr;\n+                    }\n+                }\n+                if (lchr != null) {\n+                    wserv.updateParty(party.getId(), PartyOperation.CHANGE_LEADER, lchr);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removePlayer(World wserv, boolean serverTransition) {\n+        try {\n+            player.setDisconnectedFromChannelWorld();\n+            player.notifyMapTransferToPartner(-1);\n+            player.cancelAllBuffs(true);\n+\n+            player.closePlayerInteractions();\n+            QuestScriptManager.getInstance().dispose(this);\n+\n+            if (!serverTransition) {    // thanks MedicOP for detecting an issue with party leader change on changing channels\n+                removePartyPlayer(wserv);\n+\n+                EventInstanceManager eim = player.getEventInstance();\n+                if (eim != null) {\n+                    eim.playerDisconnected(player);\n+                }\n+\n+                if (player.getMonsterCarnival() != null) {\n+                    player.getMonsterCarnival().playerDisconnected(getPlayer().getId());\n+                }\n+            }\n+\n+            if (player.getMap() != null) {\n+                int mapId = player.getMapId();\n+                player.getMap().removePlayer(player);\n+                if (GameConstants.isDojo(mapId)) {\n+                    this.getChannelServer().freeDojoSectionIfEmpty(mapId);\n+                }\n+            }\n+\n+        } catch (final Throwable t) {\n+            FilePrinter.printError(FilePrinter.ACCOUNT_STUCK, t);\n+        }\n+    }\n+\n+    public final void disconnect(final boolean shutdown, final boolean cashshop) {\n+        if (canDisconnect()) {\n+            ThreadManager.getInstance().newTask(new Runnable() {\n+                @Override\n+                public void run() {\n+                    disconnectInternal(shutdown, cashshop);\n+                }\n+            });\n+        }\n+    }\n+\n+    public final void forceDisconnect() {\n+        if (canDisconnect()) {\n+            disconnectInternal(true, false);\n+        }\n+    }\n+\n+    private synchronized boolean canDisconnect() {\n+        if (disconnecting) {\n+            return false;\n+        }\n+\n+        disconnecting = true;\n+        return true;\n+    }\n+\n+    private void disconnectInternal(boolean shutdown, boolean cashshop) {//once per MapleClient instance\n+        if (player != null && player.isLoggedin() && player.getClient() != null) {\n+            final int messengerid = player.getMessenger() == null ? 0 : player.getMessenger().getId();\n+            //final int fid = player.getFamilyId();\n+            final BuddyList bl = player.getBuddylist();\n+            final MapleMessengerCharacter chrm = new MapleMessengerCharacter(player, 0);\n+            final MapleGuildCharacter chrg = player.getMGC();\n+            final MapleGuild guild = player.getGuild();\n+\n+            player.cancelMagicDoor();\n+\n+            final World wserv = getWorldServer();   // obviously wserv is NOT null if this player was online on it\n+            try {\n+                removePlayer(wserv, this.serverTransition);\n+\n+                if (!(channel == -1 || shutdown)) {\n+                    if (!cashshop) {\n+                        if (!this.serverTransition) { // meaning not changing channels\n+                            if (messengerid > 0) {\n+                                wserv.leaveMessenger(messengerid, chrm);\n+                            }\n+                            /*      \n+                             if (fid > 0) {\n+                             final MapleFamily family = worlda.getFamily(fid);\n+                             family.\n+                             }\n+                             */\n+                            for (MapleQuestStatus status : player.getStartedQuests()) { //This is for those quests that you have to stay logged in for a certain amount of time\n+                                MapleQuest quest = status.getQuest();\n+                                if (quest.getTimeLimit() > 0) {\n+                                    MapleQuestStatus newStatus = new MapleQuestStatus(quest, MapleQuestStatus.Status.NOT_STARTED);\n+                                    newStatus.setForfeited(player.getQuest(quest).getForfeited() + 1);\n+                                    player.updateQuest(newStatus);\n+                                }\n+                            }\n+                            if (guild != null) {\n+                                final Server server = Server.getInstance();\n+                                server.setGuildMemberOnline(player, false, player.getClient().getChannel());\n+                                player.getClient().announce(MaplePacketCreator.showGuildInfo(player));\n+                            }\n+                            if (bl != null) {\n+                                wserv.loggedOff(player.getName(), player.getId(), channel, player.getBuddylist().getBuddyIds());\n+                            }\n                         }\n+                    } else {\n+                        if (!this.serverTransition) { // if dc inside of cash shop.\t                \n+                            if (bl != null) {\n+                                wserv.loggedOff(player.getName(), player.getId(), channel, player.getBuddylist().getBuddyIds());\n+                            }\n+                        }\n+                    }\n+                }\n+            } catch (final Exception e) {\n+                FilePrinter.printError(FilePrinter.ACCOUNT_STUCK, e);\n+            } finally {\n+                if (!this.serverTransition) {\n+                    if (chrg != null) {\n+                        chrg.setCharacter(null);\n+                    }\n+                    wserv.removePlayer(player);\n+                                        //getChannelServer().removePlayer(player); already being done\n+\n+                    player.saveCooldowns();\n+                    player.cancelAllDebuffs();\n+                    player.saveCharToDB(true);\n+\n+                    player.logOff();\n+                    clear();\n                 } else {\n-                        announceDisableServerMessage();\n-                        announce(packet);\n-                        \n-                        player.setTargetHpBarTime(timeNow);\n+                    getChannelServer().removePlayer(player);\n+\n+                    player.saveCooldowns();\n+                    player.cancelAllDebuffs();\n+                    player.saveCharToDB();\n                 }\n-\t}\n-        \n-        public synchronized void announce(final byte[] packet) {//MINA CORE IS A FUCKING BITCH AND I HATE IT <3\n-                session.write(packet);\n-\t}\n-\n-        public void announceHint(String msg, int length) {\n-                announce(MaplePacketCreator.sendHint(msg, length, 10));\n-                announce(MaplePacketCreator.enableActions());\n-        }\n-\n-\tpublic void changeChannel(int channel) {\n-\t\tServer server = Server.getInstance();\n-\t\tif (player.isBanned()) {\n-\t\t\tdisconnect(false, false);\n-\t\t\treturn;\n-\t\t}\n-\t\tif (!player.isAlive() || FieldLimit.CANNOTMIGRATE.check(player.getMap().getFieldLimit())) {\n-\t\t\tannounce(MaplePacketCreator.enableActions());\n-\t\t\treturn;\n-\t\t} else if(MapleMiniDungeonInfo.isDungeonMap(player.getMapId())) {\n-                        announce(MaplePacketCreator.serverNotice(5, \"Changing channels or entering Cash Shop or MTS are disabled when inside a Mini-Dungeon.\"));\n-                        announce(MaplePacketCreator.enableActions());\n-\t\t\treturn;\n+            }\n+        }\n+        if (!serverTransition && isLoggedIn()) {\n+            MapleSessionCoordinator.getInstance().closeSession(session, false);\n+            updateLoginState(MapleClient.LOGIN_NOTLOGGEDIN);\n+            session.removeAttribute(MapleClient.CLIENT_KEY); // prevents double dcing during login\n+\n+            clear();\n+        } else {\n+            if (session.containsAttribute(MapleClient.CLIENT_KEY)) {\n+                MapleSessionCoordinator.getInstance().closeSession(session, false);\n+                session.removeAttribute(MapleClient.CLIENT_KEY);\n+            }\n+\n+            engines.clear();\n+        }\n+    }\n+\n+    private void clear() {\n+        // player hard reference removal thanks to Steve (kaito1410)\n+        if (this.player != null) {\n+            this.player.empty(true); // clears schedules and stuff\n+        }\n+\n+        Server.getInstance().unregisterLoginState(this);\n+\n+        this.accountName = null;\n+        this.macs = null;\n+        this.hwid = null;\n+        this.birthday = null;\n+        this.engines = null;\n+        this.player = null;\n+        this.receive = null;\n+        this.send = null;\n+        //this.session = null;\n+    }\n+\n+    public int getChannel() {\n+        return channel;\n+    }\n+\n+    public Channel getChannelServer() {\n+        return Server.getInstance().getChannel(world, channel);\n+    }\n+\n+    public World getWorldServer() {\n+        return Server.getInstance().getWorld(world);\n+    }\n+\n+    public Channel getChannelServer(byte channel) {\n+        return Server.getInstance().getChannel(world, channel);\n+    }\n+\n+    public boolean deleteCharacter(int cid, int senderAccId) {\n+        try {\n+            return MapleCharacter.deleteCharFromDB(MapleCharacter.loadCharFromDB(cid, this, false), senderAccId);\n+        } catch (SQLException ex) {\n+            ex.printStackTrace();\n+            return false;\n+        }\n+    }\n+\n+    public String getAccountName() {\n+        return accountName;\n+    }\n+\n+    public void setAccountName(String a) {\n+        this.accountName = a;\n+    }\n+\n+    public void setChannel(int channel) {\n+        this.channel = channel;\n+    }\n+\n+    public int getWorld() {\n+        return world;\n+    }\n+\n+    public void setWorld(int world) {\n+        this.world = world;\n+    }\n+\n+    public void pongReceived() {\n+        lastPong = Server.getInstance().getCurrentTime();\n+    }\n+\n+    public void testPing(long timeThen) {\n+        try {\n+            if (lastPong < timeThen) {\n+                if (session != null && session.isConnected()) {\n+                    MapleSessionCoordinator.getInstance().closeSession(session, false);\n+                    updateLoginState(MapleClient.LOGIN_NOTLOGGEDIN);\n+                    session.removeAttribute(MapleClient.CLIENT_KEY);\n                 }\n-                \n-                String[] socket = Server.getInstance().getInetSocket(getWorld(), channel);\n-                if(socket == null) {\n-                        announce(MaplePacketCreator.serverNotice(1, \"Channel \" + channel + \" is currently disabled. Try another channel.\"));\n-                        announce(MaplePacketCreator.enableActions());\n-\t\t\treturn;\n+            }\n+        } catch (NullPointerException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    public String getHWID() {\n+        return hwid;\n+    }\n+\n+    public void setHWID(String hwid) {\n+        this.hwid = hwid;\n+    }\n+\n+    public Set<String> getMacs() {\n+        return Collections.unmodifiableSet(macs);\n+    }\n+\n+    public int getGMLevel() {\n+        return gmlevel;\n+    }\n+\n+    public void setGMLevel(int level) {\n+        gmlevel = level;\n+    }\n+\n+    public void setScriptEngine(String name, ScriptEngine e) {\n+        engines.put(name, e);\n+    }\n+\n+    public ScriptEngine getScriptEngine(String name) {\n+        return engines.get(name);\n+    }\n+\n+    public void removeScriptEngine(String name) {\n+        engines.remove(name);\n+    }\n+\n+    public NPCConversationManager getCM() {\n+        return NPCScriptManager.getInstance().getCM(this);\n+    }\n+\n+    public QuestActionManager getQM() {\n+        return QuestScriptManager.getInstance().getQM(this);\n+    }\n+\n+    public boolean acceptToS() {\n+        boolean disconnectForBeingAFaggot = false;\n+        if (accountName == null) {\n+            return true;\n+        }\n+        try {\n+            Connection con = DatabaseConnection.getConnection();\n+            PreparedStatement ps = con.prepareStatement(\"SELECT `tos` FROM accounts WHERE id = ?\");\n+            ps.setInt(1, accId);\n+            ResultSet rs = ps.executeQuery();\n+\n+            if (rs.next()) {\n+                if (rs.getByte(\"tos\") == 1) {\n+                    disconnectForBeingAFaggot = true;\n                 }\n-                \n-\t\tif (player.getTrade() != null) {\n-\t\t\tMapleTrade.cancelTrade(getPlayer());\n-\t\t}\n-\n-\t\tMapleHiredMerchant merchant = player.getHiredMerchant();\n-\t\tif (merchant != null) {\n-\t\t\tif (merchant.isOwner(getPlayer())) {\n-\t\t\t\tmerchant.setOpen(true);\n-\t\t\t} else {\n-\t\t\t\tmerchant.removeVisitor(getPlayer());\n-\t\t\t}\n-\t\t}\n-                player.unregisterChairBuff();\n-\t\tserver.getPlayerBuffStorage().addBuffsToStorage(player.getId(), player.getAllBuffs());\n-                server.getPlayerBuffStorage().addDiseasesToStorage(player.getId(), player.getAllDiseases());\n-                player.setDisconnectedFromChannelWorld();\n-                player.notifyMapTransferToPartner(-1);\n-\t\tplayer.cancelAllBuffs(true);\n-                player.cancelAllDebuffs();\n-                player.cancelBuffExpireTask();\n-                player.cancelDiseaseExpireTask();\n-                player.cancelSkillCooldownTask();\n-                player.cancelQuestExpirationTask();\n-\t\t//Cancelling magicdoor? Nope\n-\t\t//Cancelling mounts? Noty\n-\t\t\n-\t\tplayer.getInventory(MapleInventoryType.EQUIPPED).checked(false); //test\n-\t\tplayer.getMap().removePlayer(player);\n-                player.clearBanishPlayerData();\n-\t\tplayer.getClient().getChannelServer().removePlayer(player);\n-\t\tplayer.getClient().updateLoginState(MapleClient.LOGIN_SERVER_TRANSITION);\n-\t\ttry {\n-\t\t\tannounce(MaplePacketCreator.getChannelChange(InetAddress.getByName(socket[0]), Integer.parseInt(socket[1])));\n-\t\t} catch (IOException e) {\n-                    e.printStackTrace();\n-\t\t}\n-\t}\n-\n-\tpublic long getSessionId() {\n-\t\treturn this.sessionId;\n-\t}\n-\n-\tpublic void setSessionId(long sessionId) {\n-\t\tthis.sessionId = sessionId;\n-\t}  \n-\n-        public boolean canRequestCharlist(){\n-\t\treturn lastNpcClick + 877 < Server.getInstance().getCurrentTime();\n-\t}\n-        \n-\tpublic boolean canClickNPC(){\n-\t\treturn lastNpcClick + 500 < Server.getInstance().getCurrentTime();\n-\t}\n-\n-\tpublic void setClickedNPC(){\n-\t\tlastNpcClick = Server.getInstance().getCurrentTime();\n-\t}\n-\n-\tpublic void removeClickedNPC(){\n-\t\tlastNpcClick = 0;\n-\t}\n-        \n-        public int getVisibleWorlds(){\n-\t\treturn visibleWorlds;\n-\t}\n-        \n-        public void requestedServerlist(int worlds) {\n-                visibleWorlds = worlds;\n-                setClickedNPC();\n-        }\n-        \n-        public void closePlayerScriptInteractions() {\n-                this.removeClickedNPC();\n-                NPCScriptManager.getInstance().dispose(this);\n-        }\n-        \n-        public boolean attemptCsCoupon() {\n-                if (csattempt > 2) {\n-                        resetCsCoupon();\n-                        return false;\n+            }\n+            ps.close();\n+            rs.close();\n+            ps = con.prepareStatement(\"UPDATE accounts SET tos = 1 WHERE id = ?\");\n+            ps.setInt(1, accId);\n+            ps.executeUpdate();\n+            ps.close();\n+            con.close();\n+        } catch (SQLException e) {\n+            e.printStackTrace();\n+        }\n+        return disconnectForBeingAFaggot;\n+    }\n+\n+    public int getVotePoints() {\n+        int points = 0;\n+        try {\n+            Connection con = DatabaseConnection.getConnection();\n+            PreparedStatement ps = con.prepareStatement(\"SELECT `votepoints` FROM accounts WHERE id = ?\");\n+            ps.setInt(1, accId);\n+            ResultSet rs = ps.executeQuery();\n+\n+            if (rs.next()) {\n+                points = rs.getInt(\"votepoints\");\n+            }\n+            ps.close();\n+            rs.close();\n+\n+            con.close();\n+        } catch (SQLException e) {\n+            e.printStackTrace();\n+        }\n+        votePoints = points;\n+        return votePoints;\n+    }\n+\n+    public void addVotePoints(int points) {\n+        votePoints += points;\n+        saveVotePoints();\n+    }\n+\n+    public void useVotePoints(int points) {\n+        if (points > votePoints) {\n+            //Should not happen, should probably log this\n+            return;\n+        }\n+        votePoints -= points;\n+        saveVotePoints();\n+        LogHelper.logLeaf(player, false, Integer.toString(points));\n+    }\n+\n+    private void saveVotePoints() {\n+        try {\n+            Connection con = DatabaseConnection.getConnection();\n+            try (PreparedStatement ps = con.prepareStatement(\"UPDATE accounts SET votepoints = ? WHERE id = ?\")) {\n+                ps.setInt(1, votePoints);\n+                ps.setInt(2, accId);\n+                ps.executeUpdate();\n+            }\n+\n+            con.close();\n+        } catch (SQLException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    public void lockClient() {\n+        lock.lock();\n+    }\n+\n+    public void unlockClient() {\n+        lock.unlock();\n+    }\n+\n+    public boolean tryacquireClient() {\n+        if (actionsSemaphore.tryAcquire()) {\n+            lockClient();\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void releaseClient() {\n+        unlockClient();\n+        actionsSemaphore.release();\n+    }\n+\n+    public void lockEncoder() {\n+        encoderLock.lock();\n+    }\n+\n+    public void unlockEncoder() {\n+        encoderLock.unlock();\n+    }\n+\n+    private static class CharNameAndId {\n+\n+        public String name;\n+        public int id;\n+\n+        public CharNameAndId(String name, int id) {\n+            super();\n+            this.name = name;\n+            this.id = id;\n+        }\n+    }\n+\n+    private static boolean checkHash(String hash, String type, String password) {\n+        try {\n+            MessageDigest digester = MessageDigest.getInstance(type);\n+            digester.update(password.getBytes(\"UTF-8\"), 0, password.length());\n+            return HexTool.toString(digester.digest()).replace(\" \", \"\").toLowerCase().equals(hash);\n+        } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {\n+            throw new RuntimeException(\"Encoding the string failed\", e);\n+        }\n+    }\n+\n+    public short getAvailableCharacterSlots() {\n+        return (short) Math.max(0, characterSlots - Server.getInstance().getAccountCharacterCount(accId));\n+    }\n+\n+    public short getAvailableCharacterWorldSlots() {\n+        return (short) Math.max(0, characterSlots - Server.getInstance().getAccountWorldCharacterCount(accId, world));\n+    }\n+\n+    public short getCharacterSlots() {\n+        return characterSlots;\n+    }\n+\n+    public void setCharacterSlots(byte slots) {\n+        characterSlots = slots;\n+    }\n+\n+    public synchronized boolean gainCharacterSlot() {\n+        if (characterSlots < 15) {\n+            Connection con = null;\n+            try {\n+                con = DatabaseConnection.getConnection();\n+\n+                try (PreparedStatement ps = con.prepareStatement(\"UPDATE accounts SET characterslots = ? WHERE id = ?\")) {\n+                    ps.setInt(1, this.characterSlots += 1);\n+                    ps.setInt(2, accId);\n+                    ps.executeUpdate();\n                 }\n-                \n-                csattempt++;\n-                return true;\n+\n+                con.close();\n+            } catch (SQLException e) {\n+                e.printStackTrace();\n+            }\n+            return true;\n         }\n-        \n-        public void resetCsCoupon() {\n-                csattempt = 0;\n+        return false;\n+    }\n+\n+    public final byte getGReason() {\n+        Connection con = null;\n+        PreparedStatement ps = null;\n+        ResultSet rs = null;\n+        try {\n+            con = DatabaseConnection.getConnection();\n+            ps = con.prepareStatement(\"SELECT `greason` FROM `accounts` WHERE id = ?\");\n+            ps.setInt(1, accId);\n+            rs = ps.executeQuery();\n+            if (rs.next()) {\n+                return rs.getByte(\"greason\");\n+            }\n+        } catch (SQLException e) {\n+            e.printStackTrace();\n+        } finally {\n+            try {\n+                if (ps != null) {\n+                    ps.close();\n+                }\n+                if (rs != null) {\n+                    rs.close();\n+                }\n+                if (con != null) {\n+                    con.close();\n+                }\n+            } catch (SQLException e) {\n+                e.printStackTrace();\n+            }\n         }\n-        \n-        public void enableCSActions() {\n-                announce(MaplePacketCreator.enableCSUse(player));\n+        return 0;\n+    }\n+\n+    public byte getGender() {\n+        return gender;\n+    }\n+\n+    public void setGender(byte m) {\n+        this.gender = m;\n+        Connection con = null;\n+        try {\n+            con = DatabaseConnection.getConnection();\n+            try (PreparedStatement ps = con.prepareStatement(\"UPDATE accounts SET gender = ? WHERE id = ?\")) {\n+                ps.setByte(1, gender);\n+                ps.setInt(2, accId);\n+                ps.executeUpdate();\n+            }\n+\n+            con.close();\n+        } catch (SQLException e) {\n+            e.printStackTrace();\n         }\n-        \n-        public String getNibbleHWID() {\n-                return (String) session.getAttribute(MapleClient.CLIENT_NIBBLEHWID);\n+    }\n+\n+    private void announceDisableServerMessage() {\n+        if (!this.getWorldServer().registerDisabledServerMessage(player.getId())) {\n+            announce(MaplePacketCreator.serverMessage(\"\"));\n+        }\n+    }\n+\n+    public void announceServerMessage() {\n+        announce(MaplePacketCreator.serverMessage(this.getChannelServer().getServerMessage()));\n+    }\n+\n+    public synchronized void announceBossHpBar(MapleMonster mm, final int mobHash, final byte[] packet) {\n+        long timeNow = System.currentTimeMillis();\n+        int targetHash = player.getTargetHpBarHash();\n+\n+        if (mobHash != targetHash) {\n+            if (timeNow - player.getTargetHpBarTime() >= 5 * 1000) {\n+                // is there a way to INTERRUPT this annoying thread running on the client that drops the boss bar after some time at every attack?\n+                announceDisableServerMessage();\n+                announce(packet);\n+\n+                player.setTargetHpBarHash(mobHash);\n+                player.setTargetHpBarTime(timeNow);\n+            }\n+        } else {\n+            announceDisableServerMessage();\n+            announce(packet);\n+\n+            player.setTargetHpBarTime(timeNow);\n         }\n-        \n-        public boolean canBypassPin() {\n-                return MapleLoginBypassCoordinator.getInstance().canLoginBypass(getNibbleHWID(), accId, false);\n+    }\n+\n+    public synchronized void announce(final byte[] packet) {//MINA CORE IS A FUCKING BITCH AND I HATE IT <3\n+        session.write(packet);\n+    }\n+\n+    public void announceHint(String msg, int length) {\n+        announce(MaplePacketCreator.sendHint(msg, length, 10));\n+        announce(MaplePacketCreator.enableActions());\n+    }\n+\n+    public void changeChannel(int channel) {\n+        Server server = Server.getInstance();\n+        if (player.isBanned()) {\n+            disconnect(false, false);\n+            return;\n         }\n-        \n-        public boolean canBypassPic() {\n-                return MapleLoginBypassCoordinator.getInstance().canLoginBypass(getNibbleHWID(), accId, true);\n+        if (!player.isAlive() || FieldLimit.CANNOTMIGRATE.check(player.getMap().getFieldLimit())) {\n+            announce(MaplePacketCreator.enableActions());\n+            return;\n+        } else if (MapleMiniDungeonInfo.isDungeonMap(player.getMapId())) {\n+            announce(MaplePacketCreator.serverNotice(5, \"Changing channels or entering Cash Shop or MTS are disabled when inside a Mini-Dungeon.\"));\n+            announce(MaplePacketCreator.enableActions());\n+            return;\n         }\n+\n+        String[] socket = Server.getInstance().getInetSocket(getWorld(), channel);\n+        if (socket == null) {\n+            announce(MaplePacketCreator.serverNotice(1, \"Channel \" + channel + \" is currently disabled. Try another channel.\"));\n+            announce(MaplePacketCreator.enableActions());\n+            return;\n+        }\n+\n+        if (player.getTrade() != null) {\n+            MapleTrade.cancelTrade(getPlayer());\n+        }\n+\n+        MapleHiredMerchant merchant = player.getHiredMerchant();\n+        if (merchant != null) {\n+            if (merchant.isOwner(getPlayer())) {\n+                merchant.setOpen(true);\n+            } else {\n+                merchant.removeVisitor(getPlayer());\n+            }\n+        }\n+        player.unregisterChairBuff();\n+        server.getPlayerBuffStorage().addBuffsToStorage(player.getId(), player.getAllBuffs());\n+        server.getPlayerBuffStorage().addDiseasesToStorage(player.getId(), player.getAllDiseases());\n+        player.setDisconnectedFromChannelWorld();\n+        player.notifyMapTransferToPartner(-1);\n+        player.cancelAllBuffs(true);\n+        player.cancelAllDebuffs();\n+        player.cancelBuffExpireTask();\n+        player.cancelDiseaseExpireTask();\n+        player.cancelSkillCooldownTask();\n+        player.cancelQuestExpirationTask();\n+\t\t//Cancelling magicdoor? Nope\n+        //Cancelling mounts? Noty\n+\n+        player.getInventory(MapleInventoryType.EQUIPPED).checked(false); //test\n+        player.getMap().removePlayer(player);\n+        player.clearBanishPlayerData();\n+        player.getClient().getChannelServer().removePlayer(player);\n+        player.getClient().updateLoginState(MapleClient.LOGIN_SERVER_TRANSITION);\n+        try {\n+            announce(MaplePacketCreator.getChannelChange(InetAddress.getByName(socket[0]), Integer.parseInt(socket[1])));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    public long getSessionId() {\n+        return this.sessionId;\n+    }\n+\n+    public void setSessionId(long sessionId) {\n+        this.sessionId = sessionId;\n+    }\n+\n+    public boolean canRequestCharlist() {\n+        return lastNpcClick + 877 < Server.getInstance().getCurrentTime();\n+    }\n+\n+    public boolean canClickNPC() {\n+        return lastNpcClick + 500 < Server.getInstance().getCurrentTime();\n+    }\n+\n+    public void setClickedNPC() {\n+        lastNpcClick = Server.getInstance().getCurrentTime();\n+    }\n+\n+    public void removeClickedNPC() {\n+        lastNpcClick = 0;\n+    }\n+\n+    public int getVisibleWorlds() {\n+        return visibleWorlds;\n+    }\n+\n+    public void requestedServerlist(int worlds) {\n+        visibleWorlds = worlds;\n+        setClickedNPC();\n+    }\n+\n+    public void closePlayerScriptInteractions() {\n+        this.removeClickedNPC();\n+        NPCScriptManager.getInstance().dispose(this);\n+    }\n+\n+    public boolean attemptCsCoupon() {\n+        if (csattempt > 2) {\n+            resetCsCoupon();\n+            return false;\n+        }\n+\n+        csattempt++;\n+        return true;\n+    }\n+\n+    public void resetCsCoupon() {\n+        csattempt = 0;\n+    }\n+\n+    public void enableCSActions() {\n+        announce(MaplePacketCreator.enableCSUse(player));\n+    }\n+\n+    public String getNibbleHWID() {\n+        return (String) session.getAttribute(MapleClient.CLIENT_NIBBLEHWID);\n+    }\n+\n+    public boolean canBypassPin() {\n+        return MapleLoginBypassCoordinator.getInstance().canLoginBypass(getNibbleHWID(), accId, false);\n+    }\n+\n+    public boolean canBypassPic() {\n+        return MapleLoginBypassCoordinator.getInstance().canLoginBypass(getNibbleHWID(), accId, true);\n+    }\n }"}, {"sha": "f84ad4f1d901b0721d0f91682eda75148ae97144", "filename": "src/client/MapleDisease.java", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/client/MapleDisease.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/client/MapleDisease.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/client/MapleDisease.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -21,34 +21,34 @@\n */\n package client;\n \n-import java.util.ArrayList;\n-import java.util.List;\n+import tools.Randomizer;\n \n public enum MapleDisease {\n     NULL(0x0),\n-    SLOW(0x1),\n-    SEDUCE(0x80),\n+    SLOW(0x1, 126),\n+    SEDUCE(0x80, 128),\n     FISHABLE(0x100),\n     ZOMBIFY(0x4000),\n     CONFUSE(0x80000),\n-    STUN(0x2000000000000L),\n-    POISON(0x4000000000000L),\n-    SEAL(0x8000000000000L),\n-    DARKNESS(0x10000000000000L),\n-    WEAKEN(0x4000000000000000L),\n-    CURSE(0x8000000000000000L);\n+    STUN(0x2000000000000L, 123),\n+    POISON(0x4000000000000L, 125),\n+    SEAL(0x8000000000000L, 120),\n+    DARKNESS(0x10000000000000L, 121),\n+    WEAKEN(0x4000000000000000L, 122),\n+    CURSE(0x8000000000000000L, 124);\n     \n     private long i;\n     private boolean first;\n+    private int disease;\n     \n     private MapleDisease(long i) {\n         this.i = i;\n         this.first = false;\n     }\n \n-    private MapleDisease(long i, boolean first) {\n+    private MapleDisease(long i, int disease) {\n         this.i = i;\n-        this.first = first;\n+        this.disease = disease;\n     }\n     \n     public long getValue() {\n@@ -58,6 +58,10 @@ public long getValue() {\n     public boolean isFirst() {\n             return first;\n     }\n+\n+    public int getDisease() {\n+        return disease;\n+    }\n     \n     public static MapleDisease ordinal(int ord) {\n         try {\n@@ -66,4 +70,24 @@ public static MapleDisease ordinal(int ord) {\n             return NULL;\n         }\n     }\n+    \n+    public static final MapleDisease getRandom() {\n+        while (true) {\n+            for (MapleDisease dis : MapleDisease.values()) {\n+                if (Randomizer.nextInt(MapleDisease.values().length) == 0) {\n+                    return dis;\n+                }\n+            }\n+        }\n+    }\n+    \n+    public static final MapleDisease getBySkill(final int skill) {\n+        for (MapleDisease d : MapleDisease.values()) {\n+            if (d.getDisease() == skill && d.getDisease() != 0) {\n+                return d;\n+            }\n+        }\n+        return null;\n+    }\n+    \n }"}, {"sha": "96f2eb132afe545015ef96a0f56cc13ea755453c", "filename": "src/client/command/commands/gm5/DebugCommand.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/client/command/commands/gm5/DebugCommand.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/client/command/commands/gm5/DebugCommand.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/client/command/commands/gm5/DebugCommand.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -39,6 +39,7 @@\n import java.awt.*;\n import java.util.Arrays;\n import java.util.List;\n+import tools.packets.Wedding;\n \n public class DebugCommand extends Command {\n     private final static String debugTypes[] = {\"monster\", \"packet\", \"portal\", \"spawnpoint\", \"pos\", \"map\", \"mobsp\", \"event\", \"areas\", \"reactors\", \"servercoupons\", \"playercoupons\", \"timer\", \"marriage\", \"\"};"}, {"sha": "f583c24b05fbb880f41963177981da72becd10b5", "filename": "src/constants/LinguaConstants.java", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/constants/LinguaConstants.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/constants/LinguaConstants.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/constants/LinguaConstants.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -0,0 +1,74 @@\n+/*\n+ * To change this license header, choose License Headers in Project Properties.\n+ * To change this template file, choose Tools | Templates\n+ * and open the template in the editor.\n+ */\n+package constants;\n+\n+import client.MapleCharacter;\n+\n+/**\n+ *\n+ * @author Drago\n+ */\n+public class LinguaConstants {\n+\t// Portugues\n+    public static String CPQAzul;\n+    public static String CPQErro;\n+    public static String CPQEntrada;\n+    public static String CPQEscolha;\n+    public static String CPQVermelho;\n+    public static String CPQPlayerExit;\n+    public static String CPQEntradaLobby;\n+    public static String CPQInicioEscolha;\n+    public static String CPQTempoExtendido;\n+    public static String CPQLiderNaoEncontrado;\n+    public static String CPQInicioEscolhaEmEscolha;\n+\n+    public static LinguaConstants Linguas(MapleCharacter chr) {\n+        if (chr.getLingua() == 0) {\n+            LinguaConstants.CPQAzul = \"Maple Azul\";\n+            LinguaConstants.CPQVermelho = \"Maple Vermelho\";\n+            LinguaConstants.CPQTempoExtendido = \"O tempo foi estendido.\";\n+            LinguaConstants.CPQPlayerExit = \" deixou o Carnaval de Monstros.\";\n+            LinguaConstants.CPQErro = \"Ocorreu um problema. Favor recriar a sala.\";\n+            LinguaConstants.CPQLiderNaoEncontrado = \"N\ufffdo foi poss\ufffdvel encontrar o Lider.\";\n+            LinguaConstants.CPQInicioEscolha = \"Inscreva-se no Festival de Monstros!\\\\r\\\\n\";            \n+            LinguaConstants.CPQInicioEscolhaEmEscolha = \"O grupo esta respondendo um desafio no momento.\";\n+            LinguaConstants.CPQEscolha = \"N\ufffdo foi poss\ufffdvel encontrar um grupo nesta sala.\\\\r\\\\nProvavelmente o grupo foi desfeito dentro da sala!\";\n+            LinguaConstants.CPQEntradaLobby = \"[CPQ MapleStorySA] Agora voc\ufffd ir\ufffd receber desafios de outros grupos. Se voc\ufffd n\ufffdo aceitar um desafio em 3 minutos, voc\ufffd ser\ufffd levado para fora.\";\n+            LinguaConstants.CPQEntrada = \"Voc\ufffd pode selecionar \\\"Invocar Monstros\\\", \\\"Habilidade\\\", ou \\\"Protetor\\\" como sua t\ufffdtica durante o Carnaval dos Monstros. Use Tab a F1~F12 para acesso r\ufffdpido!\";\n+\n+            \n+            \n+        } else if (chr.getLingua() == 1) {\n+            LinguaConstants.CPQAzul = \"Maple Azul\";\n+            LinguaConstants.CPQVermelho = \"Maple Rojo\";\n+            LinguaConstants.CPQTempoExtendido = \"El tiempo se ha ampliado.\";\n+            LinguaConstants.CPQPlayerExit = \" ha dejado el Carnaval de Monstruos.\";\n+            LinguaConstants.CPQLiderNaoEncontrado = \"No se pudo encontrar el Lider.\";\n+            LinguaConstants.CPQInicioEscolha = \"\ufffdInscr\ufffdbete en el Festival de Monstruos!\\\\r\\\\n\";\n+            LinguaConstants.CPQErro = \"Se ha producido un problema. Por favor, volver a crear una sala.\";\n+            LinguaConstants.CPQInicioEscolhaEmEscolha = \"El grupo esta respondiendo un desaf\ufffdo en el momento.\";\n+            LinguaConstants.CPQEscolha = \"No se pudo encontrar un grupo en esta sala.\\\\r\\\\nProbablemente el grupo fue deshecho dentro de la sala!\";\n+            LinguaConstants.CPQEntradaLobby = \"[CPQ MapleStorySA] Ahora usted recibir\ufffd los retos de otros grupos. Si usted no acepta un desaf\ufffdo en 3 minutos, usted ser\ufffd llevado hacia fuera.\";\n+            LinguaConstants.CPQEntrada = \"Usted puede seleccionar \\\"Invocar Monstruos \\\", \\\"Habilidad \\\", o \\\"Protector \\\" como su t\ufffdctica durante el Carnaval de los Monstruos. Utilice Tab y F1 ~ F12 para acceso r\ufffdpido!\";\n+\n+            \n+        } else if (chr.getLingua() == 2) {\n+            LinguaConstants.CPQAzul = \"Maple Blue\";\n+            LinguaConstants.CPQVermelho = \"Maple Red\";\n+            LinguaConstants.CPQPlayerExit = \" left the Carnival of Monsters.\";\n+            LinguaConstants.CPQTempoExtendido = \"The time has been extended.\";\n+            LinguaConstants.CPQLiderNaoEncontrado = \"Could not find the Leader.\";\n+            LinguaConstants.CPQErro = \"There was a problem. Please re-create a room.\";\n+            LinguaConstants.CPQInicioEscolha = \"Sign up for the Monster Festival!\\\\r\\\\n\";\n+            LinguaConstants.CPQInicioEscolhaEmEscolha = \"The group is currently facing a challenge.\";\n+            LinguaConstants.CPQEscolha = \"We could not find a group in this room.\\\\r\\\\nProbably the group was scrapped inside the room!\";\n+            LinguaConstants.CPQEntradaLobby = \"[CPQ MapleStorySA] You will now receive challenges from other groups. If you do not accept a challenge within 3 minutes, you will be taken out.\";\n+            LinguaConstants.CPQEntrada = \"You can select \\\"Summon Monsters \\\", \\\"Ability \\\", or \\\"Protector \\\" as your tactic during the Monster Carnival. Use Tab and F1 ~ F12 for quick access!\";\n+            \n+        }\n+        return null;\n+    }\n+}"}, {"sha": "fd36f5b093ee6aaeb957d25f2b11d1f06a371686", "filename": "src/constants/ServerConstants.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/constants/ServerConstants.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/constants/ServerConstants.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/constants/ServerConstants.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -33,7 +33,7 @@\n     public static final int BYPASS_PIC_EXPIRATION = 20;         //Enables PIC bypass, which will remain active for that account by that client machine for N minutes. Set 0 to disable.\n     public static final int BYPASS_PIN_EXPIRATION = 15;         //Enables PIN bypass, which will remain active for that account by that client machine for N minutes. Set 0 to disable.\n     \n-    public static final boolean AUTOMATIC_REGISTER = true;      //Automatically register players when they login with a nonexistent username.\n+    public static final boolean AUTOMATIC_REGISTER = false;      //Automatically register players when they login with a nonexistent username.\n     public static final boolean BCRYPT_MIGRATION = true;        //Performs a migration from old SHA-1 and SHA-512 password to bcrypt.\n     public static final boolean COLLECTIVE_CHARSLOT = false;    //Available character slots are contabilized globally rather than per world server.\n     public static final boolean DETERRED_MULTICLIENT = false;   //Enables multi-client and suspicious remote IP detection on the login system.\n@@ -58,7 +58,7 @@\n     public static final boolean USE_CUSTOM_KEYSET = true;           //Enables auto-setup of the HeavenMS's custom keybindings when creating characters.\n     public static final boolean USE_DEBUG = false;                  //Will enable some text prints on the client, oriented for debugging purposes.\n     public static final boolean USE_DEBUG_SHOW_INFO_EQPEXP = false; //Prints on the cmd all equip exp gain info.\n-    public static       boolean USE_DEBUG_SHOW_RCVD_PACKET = false; //Prints on the cmd all received packet ids.\n+    public static       boolean USE_DEBUG_SHOW_RCVD_PACKET = true; //Prints on the cmd all received packet ids.\n     public static       boolean USE_DEBUG_SHOW_RCVD_MVLIFE = false; //Prints on the cmd all received move life content.\n     public static       boolean USE_SUPPLY_RATE_COUPONS = true;     //Allows rate coupons to be sold through the Cash Shop.\n     "}, {"sha": "b74df3538cb9cfd610b97a91364621a3c14a690f", "filename": "src/net/server/channel/handlers/ChangeMapHandler.java", "status": "modified", "additions": 138, "deletions": 139, "changes": 277, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/net/server/channel/handlers/ChangeMapHandler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/net/server/channel/handlers/ChangeMapHandler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/handlers/ChangeMapHandler.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -1,23 +1,23 @@\n /*\n-This file is part of the OdinMS Maple Story Server\n-Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n-Matthias Butz <matze@odinms.de>\n-Jan Christian Meyer <vimes@odinms.de>\n+ This file is part of the OdinMS Maple Story Server\n+ Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n+ Matthias Butz <matze@odinms.de>\n+ Jan Christian Meyer <vimes@odinms.de>\n \n-This program is free software: you can redistribute it and/or modify\n-it under the terms of the GNU Affero General Public License as\n-published by the Free Software Foundation version 3 as published by\n-the Free Software Foundation. You may not use, modify or distribute\n-this program under any other version of the GNU Affero General Public\n-License.\n+ This program is free software: you can redistribute it and/or modify\n+ it under the terms of the GNU Affero General Public License as\n+ published by the Free Software Foundation version 3 as published by\n+ the Free Software Foundation. You may not use, modify or distribute\n+ this program under any other version of the GNU Affero General Public\n+ License.\n \n-This program is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU Affero General Public License for more details.\n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU Affero General Public License for more details.\n \n-You should have received a copy of the GNU Affero General Public License\n-along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ You should have received a copy of the GNU Affero General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>.\n  */\n package net.server.channel.handlers;\n \n@@ -39,131 +39,130 @@\n \n public final class ChangeMapHandler extends AbstractMaplePacketHandler {\n \n-\t@Override\n-\tpublic final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c) {\n-\t\tMapleCharacter chr = c.getPlayer();\n+    @Override\n+    public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c) {\n+        MapleCharacter chr = c.getPlayer();\n \n-\t\tif (chr.isChangingMaps() || chr.isBanned()) {\n-                        if(chr.isChangingMaps()) {\n-                                FilePrinter.printError(FilePrinter.PORTAL_STUCK + chr.getName() + \".txt\", \"Player \" + chr.getName() + \" got stuck when changing maps. Timestamp: \" + Calendar.getInstance().getTime().toString() + \" Last visited mapids: \" + chr.getLastVisitedMapids());\n+        if (chr.isChangingMaps() || chr.isBanned()) {\n+            if (chr.isChangingMaps()) {\n+                FilePrinter.printError(FilePrinter.PORTAL_STUCK + chr.getName() + \".txt\", \"Player \" + chr.getName() + \" got stuck when changing maps. Timestamp: \" + Calendar.getInstance().getTime().toString() + \" Last visited mapids: \" + chr.getLastVisitedMapids());\n+            }\n+\n+            c.announce(MaplePacketCreator.enableActions());\n+            return;\n+        }\n+        if (chr.getTrade() != null) {\n+            MapleTrade.cancelTrade(chr);\n+        }\n+        if (slea.available() == 0) { //Cash Shop :)\n+            if (!chr.getCashShop().isOpened()) {\n+                c.disconnect(false, false);\n+                return;\n+            }\n+            String[] socket = c.getChannelServer().getIP().split(\":\");\n+            chr.getCashShop().open(false);\n+            c.updateLoginState(MapleClient.LOGIN_SERVER_TRANSITION);\n+            try {\n+                c.announce(MaplePacketCreator.getChannelChange(InetAddress.getByName(socket[0]), Integer.parseInt(socket[1])));\n+            } catch (UnknownHostException ex) {\n+                ex.printStackTrace();\n+            }\n+        } else {\n+            if (chr.getCashShop().isOpened()) {\n+                c.disconnect(false, false);\n+                return;\n+            }\n+            try {\n+                slea.readByte(); // 1 = from dying 0 = regular portals\n+                int targetid = slea.readInt();\n+                String startwp = slea.readMapleAsciiString();\n+                MaplePortal portal = chr.getMap().getPortal(startwp);\n+                slea.readByte();\n+                boolean wheel = slea.readShort() > 0;\n+                if (targetid != -1 && !chr.isAlive()) {\n+                    MapleMap map = chr.getMap();\n+                    if (wheel && chr.haveItemWithId(5510000, false)) {\n+                                                // thanks lucasziron for showing revivePlayer() also being triggered by Wheel\n+\n+                        MapleInventoryManipulator.removeById(c, MapleInventoryType.CASH, 5510000, 1, true, false);\n+                        chr.announce(MaplePacketCreator.showWheelsLeft(chr.getItemQuantity(5510000, false)));\n+\n+                        chr.updateHp(50);\n+                        chr.changeMap(map, map.findClosestPlayerSpawnpoint(chr.getPosition()));\n+                    } else {\n+                        boolean executeStandardPath = true;\n+                        if (chr.getEventInstance() != null) {\n+                            executeStandardPath = chr.getEventInstance().revivePlayer(chr);\n+                        }\n+                        if (executeStandardPath) {\n+                            chr.respawn(map.getReturnMapId());\n                         }\n-                    \n+                    }\n+                } else if (targetid != -1) {\n+                    if (chr.isGM()) {\n+                        MapleMap to = chr.getWarpMap(targetid);\n+                        chr.changeMap(to, to.getPortal(0));\n+                    } else {\n+                        final int divi = chr.getMapId() / 100;\n+                        boolean warp = false;\n+                        if (divi == 0) {\n+                            if (targetid == 10000) {\n+                                warp = true;\n+                            }\n+                        } else if (divi == 20100) {\n+                            if (targetid == 104000000) {\n+                                c.announce(MaplePacketCreator.lockUI(false));\n+                                c.announce(MaplePacketCreator.disableUI(false));\n+                                warp = true;\n+                            }\n+                        } else if (divi == 9130401) { // Only allow warp if player is already in Intro map, or else = hack\n+                            if (targetid == 130000000 || targetid / 100 == 9130401) { // Cygnus introduction\n+                                warp = true;\n+                            }\n+                        } else if (divi == 9140900) { // Aran Introduction\n+                            if (targetid == 914090011 || targetid == 914090012 || targetid == 914090013 || targetid == 140090000) {\n+                                warp = true;\n+                            }\n+                        } else if (divi / 10 == 1020) { // Adventurer movie clip Intro\n+                            if (targetid == 1020000) {\n+                                warp = true;\n+                            }\n+                        } else if (divi / 10 >= 980040 && divi / 10 <= 980045) {\n+                            if (targetid == 980040000) {\n+                                warp = true;\n+                            }\n+                        }\n+                        if (warp) {\n+                            final MapleMap to = chr.getWarpMap(targetid);\n+                            chr.changeMap(to, to.getPortal(0));\n+                        }\n+                    }\n+                }\n+                if (portal != null && !portal.getPortalStatus()) {\n+                    c.announce(MaplePacketCreator.blockedMessage(1));\n+                    c.announce(MaplePacketCreator.enableActions());\n+                    return;\n+                }\n+\n+                if (chr.getMapId() == 109040004) {\n+                    chr.getFitness().resetTimes();\n+                } else if (chr.getMapId() == 109030003 || chr.getMapId() == 109030103) {\n+                    chr.getOla().resetTimes();\n+                }\n+\n+                if (portal != null) {\n+                    if (portal.getPosition().distanceSq(chr.getPosition()) > 400000) {\n                         c.announce(MaplePacketCreator.enableActions());\n-\t\t\treturn;\n-\t\t}\n-\t\tif (chr.getTrade() != null) {\n-\t\t\tMapleTrade.cancelTrade(chr);\n-\t\t}\n-\t\tif (slea.available() == 0) { //Cash Shop :)\n-\t\t\tif(!chr.getCashShop().isOpened()) {\n-                                c.disconnect(false, false);\n-\t\t\t\treturn;           \n-\t\t\t}\n-\t\t\tString[] socket = c.getChannelServer().getIP().split(\":\");\n-\t\t\tchr.getCashShop().open(false);\n-\t\t\tc.updateLoginState(MapleClient.LOGIN_SERVER_TRANSITION);\n-\t\t\ttry {\n-\t\t\t\tc.announce(MaplePacketCreator.getChannelChange(InetAddress.getByName(socket[0]), Integer.parseInt(socket[1])));\n-\t\t\t} catch (UnknownHostException ex) {\n-                            ex.printStackTrace();\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif(chr.getCashShop().isOpened()) {\n-\t\t\t\tc.disconnect(false, false);\n-\t\t\t\treturn;           \n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tslea.readByte(); // 1 = from dying 0 = regular portals\n-\t\t\t\tint targetid = slea.readInt();\n-\t\t\t\tString startwp = slea.readMapleAsciiString();\n-\t\t\t\tMaplePortal portal = chr.getMap().getPortal(startwp);\n-\t\t\t\tslea.readByte();\n-\t\t\t\tboolean wheel = slea.readShort() > 0;\n-\t\t\t\tif (targetid != -1 && !chr.isAlive()) {\n-                                        MapleMap map = chr.getMap();\n-                                        if (wheel && chr.haveItemWithId(5510000, false)) {\n-                                                // thanks lucasziron for showing revivePlayer() also being triggered by Wheel\n-                                                \n-                                                MapleInventoryManipulator.removeById(c, MapleInventoryType.CASH, 5510000, 1, true, false);\n-                                                chr.announce(MaplePacketCreator.showWheelsLeft(chr.getItemQuantity(5510000, false)));\n+                        return;\n+                    }\n \n-                                                chr.updateHp(50);\n-                                                chr.changeMap(map, map.findClosestPlayerSpawnpoint(chr.getPosition()));\n-                                        } else {\n-                                                boolean executeStandardPath = true;\n-                                                if (chr.getEventInstance() != null) {\n-                                                        executeStandardPath = chr.getEventInstance().revivePlayer(chr);\n-                                                }\n-                                                if (executeStandardPath) {\n-                                                        chr.respawn(map.getReturnMapId());\n-                                                }\n-                                        }\n-\t\t\t\t} else if (targetid != -1) {\n-                                        if(chr.isGM()) {\n-                                                MapleMap to = chr.getWarpMap(targetid);\n-                                                chr.changeMap(to, to.getPortal(0));\n-                                        }\n-                                        else {\n-                                                final int divi = chr.getMapId() / 100;\n-                                                boolean warp = false;\n-                                                if (divi == 0) {\n-                                                        if (targetid == 10000) {\n-                                                                warp = true;\n-                                                        }\n-                                                } else if (divi == 20100) {\n-                                                        if (targetid == 104000000) {\n-                                                                c.announce(MaplePacketCreator.lockUI(false));\n-                                                                c.announce(MaplePacketCreator.disableUI(false));\n-                                                                warp = true;\n-                                                        }\n-                                                } else if (divi == 9130401) { // Only allow warp if player is already in Intro map, or else = hack\n-                                                        if (targetid == 130000000 || targetid / 100 == 9130401) { // Cygnus introduction\n-                                                                warp = true;\n-                                                        }\n-                                                } else if (divi == 9140900) { // Aran Introduction\n-                                                        if (targetid == 914090011 || targetid == 914090012 || targetid == 914090013 || targetid == 140090000) {\n-                                                                warp = true;\n-                                                        }\n-                                                } else if (divi / 10 == 1020) { // Adventurer movie clip Intro\n-                                                        if (targetid == 1020000) {\n-                                                                warp = true;\n-                                                        }\n-                                                } else if(divi / 10 >= 980040 && divi / 10 <= 980045) {\n-                                                        if(targetid == 980040000) {\n-                                                                warp = true;\n-                                                        }\n-                                                }\n-                                                if (warp) {\n-                                                        final MapleMap to = chr.getWarpMap(targetid);\n-                                                        chr.changeMap(to, to.getPortal(0));\n-                                                }\n-                                        }\n-\t\t\t\t}\n-\t\t\t\tif (portal != null && !portal.getPortalStatus()) {\n-\t\t\t\t\tc.announce(MaplePacketCreator.blockedMessage(1));\n-\t\t\t\t\tc.announce(MaplePacketCreator.enableActions());\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-                                \n-\t\t\t\tif (chr.getMapId() == 109040004) {\n-\t\t\t\t\tchr.getFitness().resetTimes();\n-\t\t\t\t} else if (chr.getMapId() == 109030003 || chr.getMapId() == 109030103) {\n-\t\t\t\t\tchr.getOla().resetTimes();\n-\t\t\t\t}\n-                                \n-\t\t\t\tif (portal != null) {\n-\t\t\t\t\tif(portal.getPosition().distanceSq(chr.getPosition()) > 400000) {\n-                                                c.announce(MaplePacketCreator.enableActions());\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t}\n-\t\t\t\t\t\n-\t\t\t\t\tportal.enterPortal(c);\n-\t\t\t\t} else {\n-                                        c.announce(MaplePacketCreator.enableActions());\n-\t\t\t\t}\n-\t\t\t} catch (Exception e) {\n-\t\t\t\te.printStackTrace();\n-\t\t\t}\n-\t\t}\n-\t}\n+                    portal.enterPortal(c);\n+                } else {\n+                    c.announce(MaplePacketCreator.enableActions());\n+                }\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n }"}, {"sha": "fe18b825321792a4802ce162622b3c9b7975d70a", "filename": "src/net/server/channel/handlers/MonsterCarnivalHandler.java", "status": "modified", "additions": 132, "deletions": 201, "changes": 333, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/net/server/channel/handlers/MonsterCarnivalHandler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/net/server/channel/handlers/MonsterCarnivalHandler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/handlers/MonsterCarnivalHandler.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -1,223 +1,154 @@\n /*\n-\tThis file is part of the OdinMS Maple Story Server\n-    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n-\t\t       Matthias Butz <matze@odinms.de>\n-\t\t       Jan Christian Meyer <vimes@odinms.de>\n+ This file is part of the OdinMS Maple Story Server\n+ Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n+ Matthias Butz <matze@odinms.de>\n+ Jan Christian Meyer <vimes@odinms.de>\n \n-    This program is free software: you can redistribute it and/or modify\n-    it under the terms of the GNU Affero General Public License as\n-    published by the Free Software Foundation version 3 as published by\n-    the Free Software Foundation. You may not use, modify or distribute\n-    this program under any other version of the GNU Affero General Public\n-    License.\n+ This program is free software: you can redistribute it and/or modify\n+ it under the terms of the GNU Affero General Public License as\n+ published by the Free Software Foundation version 3 as published by\n+ the Free Software Foundation. You may not use, modify or distribute\n+ this program under any other version of the GNU Affero General Public\n+ License.\n \n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU Affero General Public License for more details.\n-\n-    You should have received a copy of the GNU Affero General Public License\n-    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-*/\n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU Affero General Public License for more details.\n \n+ You should have received a copy of the GNU Affero General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n package net.server.channel.handlers;\n \n import client.MapleCharacter;\n import client.MapleClient;\n+import client.MapleDisease;\n import java.awt.Point;\n+import java.util.List;\n import net.AbstractMaplePacketHandler;\n-import server.partyquest.MonsterCarnival;\n+import net.server.world.MapleParty;\n+import net.server.world.MaplePartyCharacter;\n import server.life.MapleLifeFactory;\n-import server.maps.MapleReactor;\n-import server.maps.MapleReactorFactory;\n+import server.life.MapleMonster;\n+import server.partyquest.MapleCarnivalFactory;\n+import server.partyquest.MapleCarnivalFactory.MCSkill;\n import tools.MaplePacketCreator;\n+import tools.Pair;\n import tools.data.input.SeekableLittleEndianAccessor;\n \n+\n /**\n- *\n- * @author kevintjuh93\n- */\n-public final class MonsterCarnivalHandler extends AbstractMaplePacketHandler{\n-    public void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c) {\n-        MapleCharacter chr = c.getPlayer();\n-        MonsterCarnival carnival = chr.getCarnival();\n-        int tab = slea.readByte();\n-        int number = slea.readShort();\n-        if (carnival != null) {\n-            if (chr.getCarnivalParty() != carnival.getPartyRed() || chr.getCarnivalParty() != carnival.getPartyBlue()) {\n-                chr.getMap().broadcastMessage(MaplePacketCreator.leaveCPQ(chr));\n-                chr.changeMap(980000010);\n-            }\n-            if (chr.getCP() > getPrice(tab, number)) {\n-                if (tab == 0) { //SPAWNING\n-                    if (chr.getCarnivalParty().canSummon()) {\n-                        chr.getMap().spawnCPQMonster(MapleLifeFactory.getMonster(getMonster(number)), new Point(1, 1), carnival.oppositeTeam(chr.getCarnivalParty()).getTeam());\n-                        chr.getCarnivalParty().summon();\n-                    } else\n-                        chr.announce(MaplePacketCreator.CPQMessage((byte) 2));\n+    *@author Drago/Dragohe4rt\n+*/\n \n-                } else if (tab == 1) {\n+public final class MonsterCarnivalHandler extends AbstractMaplePacketHandler {\n \n-                } else if (tab == 2) {\n-                    int rid = 9980000 + chr.getTeam();\n-                        MapleReactor reactor = new MapleReactor(MapleReactorFactory.getReactor(rid), rid);\n-                        /*switch (number) {\n-                            case 0:\n-                                reactor.setMonsterStatus(tab, MonsterStatus.WEAPON_ATTACK_UP, MobSkillFactory.getMobSkill(150, 1));\n-                                break;\n-                            case 1:\n-                                reactor.setMonsterStatus(tab, MonsterStatus.WEAPON_DEFENSE_UP, MobSkillFactory.getMobSkill(151, 1));\n-                                break;\n-                            case 2:\n-                                reactor.setMonsterStatus(tab, MonsterStatus.MAGIC_ATTACK_UP, MobSkillFactory.getMobSkill(152, 1));\n-                                break;\n-                            case 3:\n-                                reactor.setMonsterStatus(tab, MonsterStatus.MAGIC_DEFENSE_UP, MobSkillFactory.getMobSkill(153, 1));\n-                                break;\n-                            case 4:\n-                                reactor.setMonsterStatus(tab, MonsterStatus.ACC, MobSkillFactory.getMobSkill(154, 1));\n-                                break;\n-                            case 5:\n-                                reactor.setMonsterStatus(tab, MonsterStatus.AVOID, MobSkillFactory.getMobSkill(155, 1));\n-                                break;\n-                            case 6:\n-                                reactor.setMonsterStatus(tab, MonsterStatus.SPEED, MobSkillFactory.getMobSkill(156, 1));\n-                                break;\n-                            case 7:\n-                                reactor.setMonsterStatus(tab, MonsterStatus.WEAPON_IMMUNITY, MobSkillFactory.getMobSkill(140, 1));\n-                                break;\n-                            case 8:\n-                                reactor.setMonsterStatus(tab, MonsterStatus.MAGIC_IMMUNITY, MobSkillFactory.getMobSkill(141, 1));\n-                                break;\n-                        } */\n-                        chr.getMap().spawnReactor(reactor);\n+    @Override\n+    public void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c) {\n+        try {\n+            int tab = slea.readByte();\n+            int num = slea.readByte();\n+            int neededCP = 0;\n+            if (tab == 0) { \n+                final List<Pair<Integer, Integer>> mobs = c.getPlayer().getMap().getMobsToSpawn();\n+                if (num >= mobs.size() || c.getPlayer().getCP() < mobs.get(num).right) {\n+                    c.announce(MaplePacketCreator.CPQMessage((byte) 1));\n+                    c.getSession().write(MaplePacketCreator.enableActions());\n+                    return;\n                 }\n-            } else {\n-                chr.getMap().broadcastMessage(MaplePacketCreator.CPQMessage((byte) 1));\n-            }\n-        } else {\n-            chr.announce(MaplePacketCreator.CPQMessage((byte) 5));\n-        }\n-        chr.announce(MaplePacketCreator.enableActions());\n-    }\n \n-    public int getMonster(int num) {\n-        int mid = 0;\n-        num++;\n-        switch (num) {\n-            case 1:\n-                mid = 9300127;\n-                break;\n-            case 2:\n-                mid = 9300128;\n-                break;\n-            case 3:\n-                mid = 9300129;\n-                break;\n-            case 4:\n-                mid = 9300130;\n-                break;\n-            case 5:\n-                mid = 9300131;\n-                break;\n-            case 6:\n-                mid = 9300132;\n-                break;\n-            case 7:\n-                mid = 9300133;\n-                break;\n-            case 8:\n-                mid = 9300134;\n-                break;\n-            case 9:\n-                mid = 9300135;\n-                break;\n-            case 10:\n-                mid = 9300136;\n-                break;\n+                final MapleMonster mob = MapleLifeFactory.getMonster(mobs.get(num).left);\n+                if (c.getPlayer().getMonsterCarnival() != null) {\n+                    Point spawnPos = c.getPlayer().getMap().getRandomSP(c.getPlayer().getTeam());\n+                    if (!c.getPlayer().getMonsterCarnival().canSummon() && c.getPlayer().getTeam() == 0 || !c.getPlayer().getMonsterCarnival().canSummons() && c.getPlayer().getTeam() == 1) {\n+                        c.announce(MaplePacketCreator.CPQMessage((byte) 2));\n+                        c.getSession().write(MaplePacketCreator.enableActions());\n+                        return;\n+                    }\n+                    mob.setPosition(spawnPos);\n+                    if (c.getPlayer().getTeam() == 0) {\n+                        c.getPlayer().getMonsterCarnival().summon();\n+                    } else {\n+                        c.getPlayer().getMonsterCarnival().summons();\n+                    }\n+                        c.getPlayer().getMap().addMonsterSpawn(mob, 1, c.getPlayer().getTeam());\n+                        c.getSession().write(MaplePacketCreator.enableActions());\n+                    }\n+                    neededCP = mobs.get(num).right;\n+                } else if (tab == 1) { //debuffs\n+                    final List<Integer> skillid = c.getPlayer().getMap().getSkillIds();\n+                    if (num >= skillid.size()) {\n+                        c.getPlayer().dropMessage(5, \"Ocorreu um erro.\");\n+                        c.getSession().write(MaplePacketCreator.enableActions());\n+                        return;\n+                    }\n+                    final MCSkill skil = MapleCarnivalFactory.getInstance().getSkill(skillid.get(num)); //ugh wtf\n+                    if (skil == null || c.getPlayer().getCP() < skil.cpLoss) {\n+                        c.announce(MaplePacketCreator.CPQMessage((byte) 1));\n+                        c.getSession().write(MaplePacketCreator.enableActions());\n+                        return;\n+                    }\n+                    final MapleDisease dis = skil.getDisease();\n+                    MapleParty inimigos = c.getPlayer().getParty().getEnemy();\n+                    if (skil.targetsAll) {\n+                        int chanceAcerto = 0;\n+                        if (dis.getDisease() == 121 || dis.getDisease() == 122 || dis.getDisease() == 125 || dis.getDisease() == 126) {\n+                            chanceAcerto = (int) (Math.random() * 100);\n+                        }\n+                        if (chanceAcerto <= 80) {\n+                            for (MaplePartyCharacter chrS : inimigos.getPartyMembers()) {\n+                                if (dis == null) {\n+                                    chrS.getPlayer().dispel();\n+                                } else {\n+                                    chrS.getPlayer().giveDebuff(dis, skil.getSkill());\n+                                }\n+                                if (!skil.targetsAll) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } else {\n+                        int amount = inimigos.getMembers().size() - 1;\n+                        int randd = (int) Math.floor(Math.random() * amount);\n+                        MapleCharacter chrApp = c.getChannelServer().getPlayerStorage().getCharacterById(inimigos.getMemberByPos(randd).getId());\n+                        if (chrApp != null && chrApp.getMap().isCPQMap()) {\n+                            if (dis == null) {\n+                                chrApp.dispel();\n+                            } else {\n+                                chrApp.giveDebuff(dis, skil.getSkill());\n+                            }\n+                        }\n+                    }\n+                    neededCP = skil.cpLoss;\n+                    c.getSession().write(MaplePacketCreator.enableActions());\n+                } else if (tab == 2) { //protectors\n+                    final MCSkill skil = MapleCarnivalFactory.getInstance().getGuardian(num);\n+                    if (skil == null || c.getPlayer().getCP() < skil.cpLoss) {\n+                        c.announce(MaplePacketCreator.CPQMessage((byte) 1));\n+                        c.getSession().write(MaplePacketCreator.enableActions());\n+                        return;\n+                    }\n+                    int success = c.getPlayer().getMap().spawnGuardian(c.getPlayer().getTeam(), num);\n+                    if (success == -1 || success == 0 || success == 2) {\n+                        if (success == -1) {\n+                            c.announce(MaplePacketCreator.CPQMessage((byte) 3));\n+                        } else if (success == 0) {\n+                            c.announce(MaplePacketCreator.CPQMessage((byte) 4));\n+                        } else if (success == 2) {\n+                            c.announce(MaplePacketCreator.CPQMessage((byte) 3));\n+                        }\n+                        c.getSession().write(MaplePacketCreator.enableActions());\n+                        return;\n+                    } else {\n+                        neededCP = skil.cpLoss;\n+                    }\n+                }\n+                c.getPlayer().gainCP(-neededCP);\n+                c.getPlayer().getMap().broadcastMessage(MaplePacketCreator.playerSummoned(c.getPlayer().getName(), tab, num));\n+            }catch (Exception e) {\n+            e.printStackTrace();\n         }\n-        return mid;\n-    }\n-\n-    public int getPrice(int num, int tab) {\n-        int price = 0;\n-        num++;\n-\n-        if (tab == 0) {\n-            switch (num) {\n-                case 1:\n-                case 2:\n-                    price = 7;\n-                    break;\n-                case 3:\n-                case 4:\n-                    price = 8;\n-                    break;\n-                case 5:\n-                case 6:\n-                    price = 9;\n-                    break;\n-                case 7:\n-                    price = 10;\n-                    break;\n-                case 8:\n-                    price = 11;\n-                    break;\n-                case 9:\n-                    price = 12;\n-                    break;\n-                case 10:\n-                    price = 30;\n-                    break;\n-            }\n-        } else if (tab == 1) {\n-            switch (num) {\n-                case 1:\n-                    price = 17;\n-                    break;\n-                case 2:\n-                case 4:\n-                    price = 19;\n-                    break;\n-                case 3:\n-                    price = 12;\n-                    break;\n-                case 5:\n-                    price = 16;\n-                    break;\n-                case 6:\n-                    price = 14;\n-                    break;\n-                case 7:\n-                    price = 22;\n-                    break;\n-                case 8:\n-                    price = 18;\n-                    break;\n-            }\n-        } else {\n-            switch (num) {\n-                case 1:\n-                case 3:\n-                    price = 17;\n-                    break;\n-                case 2:\n-                case 4:\n-                case 6:\n-                    price = 16;\n-                    break;\n-                case 5:\n-                    price = 13;\n-                    break;\n-                case 7:\n-                    price = 12;\n-                    break;\n-                case 8:\n-                case 9:\n-                    price = 35;\n-                    break;\n-            }\n         }\n-        return price;\n+\n     }\n-}"}, {"sha": "33a9f29648a3db549d60675a22f8468ec5f850f2", "filename": "src/net/server/channel/handlers/RingActionHandler.java", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/net/server/channel/handlers/RingActionHandler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/net/server/channel/handlers/RingActionHandler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/handlers/RingActionHandler.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -21,8 +21,6 @@\n */\n package net.server.channel.handlers;\n \n-//import java.sql.Connection;\n-//import java.sql.PreparedStatement;\n import client.MapleClient;\n import client.MapleCharacter;\n import client.inventory.MapleInventoryType;\n@@ -31,14 +29,10 @@\n import java.sql.PreparedStatement;\n import java.sql.ResultSet;\n import java.sql.SQLException;\n-import java.util.ArrayList;\n-import java.util.List;\n-//import tools.DatabaseConnection;\n import net.AbstractMaplePacketHandler;\n import client.inventory.manipulator.MapleInventoryManipulator;\n import tools.DatabaseConnection;\n import tools.data.input.SeekableLittleEndianAccessor;\n-//import scripting.npc.NPCScriptManager;\n import tools.Pair;\n import tools.MaplePacketCreator;\n import tools.packets.Wedding;\n@@ -52,6 +46,7 @@\n /**\n  * @author Jvlaple\n  * @author Ronan - major overhaul on Ring handling mechanics\n+ * @author Drago/Dragohe4rt on Wishlist\n  */\n public final class RingActionHandler extends AbstractMaplePacketHandler {\n     private static int getBoxId(int useItemId) {\n@@ -467,11 +462,16 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)\n                 \n                 break;\n                 \n-            case 9: // Groom and Bride's Wishlist\n-                short size = slea.readShort();\n-                List<String> itemnames = new ArrayList<>(size);\n-                for (int i = 0; i < size; i++) {\n-                    itemnames.add(slea.readMapleAsciiString());\n+            case 9: \n+                // By Drago/Dragohe4rt\n+                // Groom and Bride's Wishlist\n+                //short size = slea.readShort();\n+                int amount = slea.readShort();\n+                if (amount > 10) {\n+                    amount = 10;\n+                }\n+                for (int i = 0; i < amount; i++) {\n+                    c.getPlayer().setItens(slea.readMapleAsciiString());\n                 }\n                 \n                 //System.out.println(\"G&B WISHLIST: \" + itemnames);"}, {"sha": "301c3ce5db08fb2f8116ffa19977625e1cbce4d8", "filename": "src/net/server/channel/handlers/WeddingHandler.java", "status": "modified", "additions": 40, "deletions": 63, "changes": 103, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/net/server/channel/handlers/WeddingHandler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/net/server/channel/handlers/WeddingHandler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/handlers/WeddingHandler.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -10,84 +10,61 @@\n import client.inventory.MapleInventoryType;\n import client.MapleCharacter;\n import client.MapleClient;\n+import client.inventory.Equip;\n import constants.ItemConstants;\n-import tools.DatabaseConnection;\n-import java.sql.Connection;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.util.ArrayList;\n-import java.util.List;\n import net.AbstractMaplePacketHandler;\n import client.inventory.manipulator.MapleInventoryManipulator;\n+import net.server.channel.Channel;\n+import scripting.event.EventInstanceManager;\n import tools.MaplePacketCreator;\n import tools.data.input.SeekableLittleEndianAccessor;\n import tools.packets.Wedding;\n \n /**\n  *\n- * @author Eric\n+ * @author By Drago/Dragohe4rt\n  */\n public final class WeddingHandler extends AbstractMaplePacketHandler {\n-    /*\n-    public static final void OnWeddingProgress(byte action, MapleClient c) {\n-        // -- Pelvis Bebop: \n-        // 0x00: \"We are gathered here today...\"\n-        // 0x01: \"Very well! I pronounce you...\"\n-        // 0x02: \"You two truly are a sight to...\"\n-        // 0x03: Wedding Ceremony Ended, initialize the Wedding Effect upon the two married characters\n-        // -- High Priest John: (Unknown action bytes)\n-        // 0x00: \" \"\n-        // 0x01: \" \"\n-        // 0x02: \"Do you wish to bless this couple?...\"\n-        // 0x03: Wedding Ceremony Ended, initialize the Wedding Effect upon the two married characters\n-        if (c.getPlayer().getWedding() != null) {\n-            if (c.getPlayer().getGender() == 0 ? c.getPlayer().getWedding().isExistantGroom(c.getPlayer().getId()) : c.getPlayer().getWedding().isExistantBride(c.getPlayer().getId())) {\n-                c.getPlayer().getMap().broadcastMessage(Wedding.OnWeddingProgress(action == 2, c.getPlayer().getId(), c.getPlayer().getPartnerId(), (byte)(action+1)));\n-                c.getPlayer().getWedding().incrementStage();\n-                c.getPlayer().getPartner().getWedding().incrementStage(); // pls don't b a bitch and throw npe ):<\n-                if (action == 2) {\n-                    c.getPlayer().setMarried(true);\n-                    c.getChannelServer().getPlayerStorage().getCharacterById(c.getPlayer().getPartnerId()).setMarried(true);\n-                }\n-            }\n-        }\n-        c.announce(MaplePacketCreator.enableActions());\n-    }\n     \n-    public static final void OnWeddingGiftResult(SeekableLittleEndianAccessor slea, MapleClient c) {\n-        System.out.println(\"New WEDDING_GIFT_RESULT: \" + slea.toString());\n-        byte mode = slea.readByte();\n-        switch(mode) {\n-            case 0x06: // \"SEND ITEM\"\n-                short slot = slea.readShort(); // isn't this a byte? o.O\n-                int itemId = slea.readInt();\n-                short quantity = slea.readShort();\n-                if (c.getPlayer().getInventory(ItemConstants.getInventoryType(itemId)).getItem((byte)slot).getItemId() == itemId && c.getPlayer().getInventory(InventoryConstants.getInventoryType(itemId)).getItem((byte)slot).getQuantity() >= quantity) {\n-                    if (c.getPlayer().getWedding() == null) {\n-                        c.getPlayer().startWedding(); // TODO\n+    @Override\n+    public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c) {\n+        MapleCharacter chr = c.getPlayer();\n+        final byte mode = slea.readByte();\n+        Channel cs = c.getChannelServer();\n+        \n+        if (mode == 6) { //additem\n+            short slot = slea.readShort();\n+            int itemid = slea.readInt();\n+            short quantity = slea.readShort();\n+            EventInstanceManager eim = c.getPlayer().getEventInstance();\n+            if (eim != null) {\n+                String name = eim.getProperty(\"brideId\");\n+                MapleCharacter chrs = cs.getPlayerStorage().getCharacterById(Integer.parseInt(name));\n+                //MapleCharacter chrs = cs.getPlayerStorage().getCharacterById(3);\n+                MapleInventoryType type = ItemConstants.getInventoryType(itemid);\n+                Item item = chr.getInventory(type).getItem((byte) slot);\n+                if (itemid == item.getItemId() && quantity <= item.getQuantity()) {\n+                    if(!(item instanceof Equip)) {\n+                        item = new Item(itemid, slot, quantity);\n                     }\n-                    List<String> itemnames = new ArrayList<>();\n-                    Item item = c.getPlayer().getInventory(ItemConstants.getInventoryType(itemId)).getItem((byte)slot);\n-                    boolean bride = false;\n-                    c.getPlayer().getWedding().registerWishlistItem(item, bride);\n-                    c.announce(Wedding.OnWeddingGiftResult((byte)11, itemnames, c.getPlayer().getWedding().getWishlistItems(bride))); // todo: remove item from inventory if success\n+                    chrs.setEquips(item);\n+                    MapleInventoryManipulator.removeById(chr.getClient(), type, itemid, quantity, false, false);\n+                    c.announce(Wedding.OnWeddingGiftResult((byte) 0xB, chrs.getItens(), chrs.getItem()));\n                 }\n-            case 0x08: // \"EXIT\"\n-                if (slea.available() != 0) {\n-                    System.out.println(\"WEDDING_GIFT_RESULT: \" + slea.toString());\n-                }\n-                c.announce(MaplePacketCreator.enableActions());\n-                break;\n-            default: {\n-                System.out.println(\"Unknown Mode Found: \" + mode + \" : \" + slea.toString());\n             }\n+        } else if (mode == 7) { // noiva abre e pega itens\n+            byte inventId = slea.readByte();\n+            int itemPos = slea.readByte();\n+            MapleInventoryType inv = MapleInventoryType.getByType(inventId);\n+            Item item = chr.getItemid(itemPos);\n+            c.getAbstractPlayerInteraction().gainItem(item.getItemId(), item.getQuantity());\n+            chr.removeItem(item);\n+            c.announce(Wedding.OnWeddingGiftResult((byte) 0xF, chr.getItens(), chr.getItem()));\n+        } else if (mode == 8) { // sair update?\n+            \n+            c.announce(MaplePacketCreator.enableActions());\n+        } else {\n+            System.out.println(mode);\n         }\n     }\n-    */\n-    \n-    @Override\n-    public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c) {\n-        c.announce(MaplePacketCreator.enableActions());\n-    }\n }\n\\ No newline at end of file"}, {"sha": "a3f155d8ccad1e951851e7d7efbf15dff077c66e", "filename": "src/net/server/world/MapleParty.java", "status": "modified", "additions": 85, "deletions": 63, "changes": 148, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/net/server/world/MapleParty.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/net/server/world/MapleParty.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/world/MapleParty.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -1,24 +1,24 @@\n /*\n-\tThis file is part of the OdinMS Maple Story Server\n-    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n-\t\t       Matthias Butz <matze@odinms.de>\n-\t\t       Jan Christian Meyer <vimes@odinms.de>\n-\n-    This program is free software: you can redistribute it and/or modify\n-    it under the terms of the GNU Affero General Public License as\n-    published by the Free Software Foundation version 3 as published by\n-    the Free Software Foundation. You may not use, modify or distribute\n-    this program under any other version of the GNU Affero General Public\n-    License.\n-\n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU Affero General Public License for more details.\n-\n-    You should have received a copy of the GNU Affero General Public License\n-    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-*/\n+ This file is part of the OdinMS Maple Story Server\n+ Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n+ Matthias Butz <matze@odinms.de>\n+ Jan Christian Meyer <vimes@odinms.de>\n+\n+ This program is free software: you can redistribute it and/or modify\n+ it under the terms of the GNU Affero General Public License as\n+ published by the Free Software Foundation version 3 as published by\n+ the Free Software Foundation. You may not use, modify or distribute\n+ this program under any other version of the GNU Affero General Public\n+ License.\n+\n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU Affero General Public License for more details.\n+\n+ You should have received a copy of the GNU Affero General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n package net.server.world;\n \n import client.MapleClient;\n@@ -37,19 +37,20 @@\n import server.maps.MapleDoor;\n \n public class MapleParty {\n+\n     private int id;\n-    \n+    private MapleParty enemy = null;\n     private int leaderId;\n     private List<MaplePartyCharacter> members = new LinkedList<>();\n     private List<MaplePartyCharacter> pqMembers = null;\n-    \n+\n     private Map<Integer, Integer> histMembers = new HashMap<>();\n     private int nextEntry = 0;\n-    \n+\n     private Map<Integer, MapleDoor> doors = new HashMap<>();\n-    \n+\n     private MonitoredReentrantLock lock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.PARTY, true);\n-    \n+\n     public MapleParty(int id, MaplePartyCharacter chrfor) {\n         this.leaderId = chrfor.getId();\n         this.id = id;\n@@ -103,7 +104,7 @@ public void updateMember(MaplePartyCharacter member) {\n             lock.unlock();\n         }\n     }\n-    \n+\n     public MaplePartyCharacter getMemberById(int id) {\n         lock.lock();\n         try {\n@@ -126,7 +127,7 @@ public MaplePartyCharacter getMemberById(int id) {\n             lock.unlock();\n         }\n     }\n-    \n+\n     public List<MaplePartyCharacter> getPartyMembers() {\n         lock.lock();\n         try {\n@@ -135,33 +136,33 @@ public MaplePartyCharacter getMemberById(int id) {\n             lock.unlock();\n         }\n     }\n-    \n+\n     // used whenever entering PQs: will draw every party member that can attempt a target PQ while ingnoring those unfit.\n     public Collection<MaplePartyCharacter> getEligibleMembers() {\n         return Collections.unmodifiableList(pqMembers);\n     }\n-    \n+\n     public void setEligibleMembers(List<MaplePartyCharacter> eliParty) {\n         pqMembers = eliParty;\n     }\n-    \n+\n     public int getId() {\n         return id;\n     }\n \n     public void setId(int id) {\n         this.id = id;\n     }\n-    \n+\n     public int getLeaderId() {\n         return leaderId;\n     }\n \n     public MaplePartyCharacter getLeader() {\n         lock.lock();\n         try {\n-            for(MaplePartyCharacter mpc: members) {\n-                if(mpc.getId() == leaderId) {\n+            for (MaplePartyCharacter mpc : members) {\n+                if (mpc.getId() == leaderId) {\n                     return mpc;\n                 }\n             }\n@@ -171,45 +172,53 @@ public MaplePartyCharacter getLeader() {\n             lock.unlock();\n         }\n     }\n-    \n+\n+    public MapleParty getEnemy() {\n+        return enemy;\n+    }\n+\n+    public void setEnemy(MapleParty enemy) {\n+        this.enemy = enemy;\n+    }\n+\n     public List<Integer> getMembersSortedByHistory() {\n         List<Entry<Integer, Integer>> histList;\n-        \n+\n         lock.lock();\n         try {\n             histList = new LinkedList<>(histMembers.entrySet());\n         } finally {\n             lock.unlock();\n         }\n-        \n-        Collections.sort(histList, new Comparator<Entry<Integer, Integer>>()\n-            {\n-                @Override\n-                public int compare( Entry<Integer, Integer> o1, Entry<Integer, Integer> o2 )\n-                {\n-                    return ( o1.getValue() ).compareTo( o2.getValue() );\n-                }\n-            });\n-        \n+\n+        Collections.sort(histList, new Comparator<Entry<Integer, Integer>>() {\n+            @Override\n+            public int compare(Entry<Integer, Integer> o1, Entry<Integer, Integer> o2) {\n+                return (o1.getValue()).compareTo(o2.getValue());\n+            }\n+        });\n+\n         List<Integer> histSort = new LinkedList<>();\n-        for(Entry<Integer, Integer> e : histList) {\n+        for (Entry<Integer, Integer> e : histList) {\n             histSort.add(e.getKey());\n         }\n-        \n+\n         return histSort;\n     }\n-    \n+\n     public byte getPartyDoor(int cid) {\n         List<Integer> histList = getMembersSortedByHistory();\n         byte slot = 0;\n-        for(Integer e: histList) {\n-            if(e == cid) break;\n+        for (Integer e : histList) {\n+            if (e == cid) {\n+                break;\n+            }\n             slot++;\n         }\n \n         return slot;\n     }\n-    \n+\n     public void addDoor(Integer owner, MapleDoor door) {\n         lock.lock();\n         try {\n@@ -218,43 +227,45 @@ public void addDoor(Integer owner, MapleDoor door) {\n             lock.unlock();\n         }\n     }\n-    \n+\n     public void removeDoor(Integer owner) {\n-    \tlock.lock();\n+        lock.lock();\n         try {\n             this.doors.remove(owner);\n         } finally {\n             lock.unlock();\n         }\n     }\n-    \n+\n     public Map<Integer, MapleDoor> getDoors() {\n-    \tlock.lock();\n+        lock.lock();\n         try {\n             return Collections.unmodifiableMap(doors);\n         } finally {\n             lock.unlock();\n         }\n     }\n-    \n+\n     public void assignNewLeader(MapleClient c) {\n         World world = c.getWorldServer();\n         MaplePartyCharacter newLeadr = null;\n-        \n+\n         lock.lock();\n         try {\n-            for(MaplePartyCharacter mpc : members) {\n-                if(mpc.getId() != leaderId && (newLeadr == null || newLeadr.getLevel() < mpc.getLevel())) {\n+            for (MaplePartyCharacter mpc : members) {\n+                if (mpc.getId() != leaderId && (newLeadr == null || newLeadr.getLevel() < mpc.getLevel())) {\n                     newLeadr = mpc;\n                 }\n             }\n         } finally {\n             lock.unlock();\n         }\n \n-        if(newLeadr != null) world.updateParty(this.getId(), PartyOperation.CHANGE_LEADER, newLeadr);\n+        if (newLeadr != null) {\n+            world.updateParty(this.getId(), PartyOperation.CHANGE_LEADER, newLeadr);\n+        }\n     }\n-    \n+\n     public void disposeLocks() {\n         LockCollector.getInstance().registerDisposeAction(new Runnable() {\n             @Override\n@@ -263,11 +274,11 @@ public void run() {\n             }\n         });\n     }\n-    \n+\n     private void emptyLocks() {\n         lock = lock.dispose();\n     }\n-    \n+\n     @Override\n     public int hashCode() {\n         final int prime = 31;\n@@ -276,6 +287,17 @@ public int hashCode() {\n         return result;\n     }\n \n+    public MaplePartyCharacter getMemberByPos(int pos) {\n+        int i = 0;\n+        for (MaplePartyCharacter chr : members) {\n+            if (pos == i) {\n+                return chr;\n+            }\n+            i++;\n+        }\n+        return null;\n+    }\n+\n     @Override\n     public boolean equals(Object obj) {\n         if (this == obj) {"}, {"sha": "d2c4096c51d7c6ecd85f34f1f1e0290df90ed4b0", "filename": "src/net/server/world/MaplePartyCharacter.java", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/net/server/world/MaplePartyCharacter.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/net/server/world/MaplePartyCharacter.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/world/MaplePartyCharacter.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -141,4 +141,100 @@ public boolean equals(Object obj) {\n     public int getWorld() {\n         return world;\n     }\n+    \n+    public String getJobNameById(int job) {\n+        switch (job) {\n+            case 0:\n+                return \"Aprendiz\";\n+            case 100:\n+                return \"Guerreiro\";// Warrior\n+            case 110:\n+                return \"Soldado\";\n+            case 111:\n+                return \"Templario\";\n+            case 112:\n+                return \"Heroi\";\n+            case 120:\n+                return \"Escudeiro\";\n+            case 121:\n+                return \"Cavaleiro Branco\";\n+            case 122:\n+                return \"Paladino\";\n+            case 130:\n+                return \"Lanceiro\";\n+            case 131:\n+                return \"Cavaleiro Draconiano\";\n+            case 132:\n+                return \"Cavaleiro Negro\";\n+\n+            case 200:\n+                return \"Bruxo\";\n+            case 210:\n+                return \"Feiticeiro (Fogo, Veneno)\";\n+            case 211:\n+                return \"Mago (Fogo, Veneno)\";\n+            case 212:\n+                return \"Arquimago (Fogo, Veneno)\";\n+            case 220:\n+                return \"Feiticeiro (Gelo, Raio)\";\n+            case 221:\n+                return \"Mago (Gelo, Raio)\";\n+            case 222:\n+                return \"Arquimago (Gelo, Raio)\";\n+            case 230:\n+                return \"Cl\ufffdrigo\";\n+            case 231:\n+                return \"Sacerdote\";\n+            case 232:\n+                return \"Sumo Sacerdote\";\n+\n+            case 300:\n+                return \"Arqueiro\";\n+            case 310:\n+                return \"Ca\ufffdador\";\n+            case 311:\n+                return \"Rastreador\";\n+            case 312:\n+                return \"Mestre Arqueiro\";\n+            case 320:\n+                return \"Balestreiro\";\n+            case 321:\n+                return \"Atirador\";\n+            case 322:\n+                return \"Atirador De Elite\";\n+\n+            case 400:\n+                return \"Gatuno\";\n+            case 410:\n+                return \"Mercenario\";\n+            case 411:\n+                return \"Andarilho\";\n+            case 412:\n+                return \"Lorde Negro\";\n+            case 420:\n+                return \"Arruaceiro\";\n+            case 421:\n+                return \"Mestre Arruaceiro\";\n+            case 422:\n+                return \"Mestre Das Sombras\";\n+\n+            case 500:\n+                return \"Pirata\";\n+            case 510:\n+                return \"Lutador\";\n+            case 511:\n+                return \"Saqueador\";\n+            case 512:\n+                return \"Foragido\";\n+            case 520:\n+                return \"Pistoleiro\";\n+            case 521:\n+                return \"Bucaneiro\";\n+            case 522:\n+                return \"Captain\";\n+\n+            default:\n+                return \"Unknown Job\";\n+        }\n+    }\n }"}, {"sha": "83952bff2e0ae10122c89ac3c83270b98227d97b", "filename": "src/scripting/AbstractPlayerInteraction.java", "status": "modified", "additions": 944, "deletions": 936, "changes": 1880, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/scripting/AbstractPlayerInteraction.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/scripting/AbstractPlayerInteraction.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/scripting/AbstractPlayerInteraction.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -73,1024 +73,1032 @@\n \n public class AbstractPlayerInteraction {\n \n-\tpublic MapleClient c;\n-\n-\tpublic AbstractPlayerInteraction(MapleClient c) {\n-\t\tthis.c = c;\n-\t}\n-\n-\tpublic MapleClient getClient() {\n-\t\treturn c;\n-\t}\n-\n-\tpublic MapleCharacter getPlayer() {\n-\t\treturn c.getPlayer();\n-\t}\n-        \n-        public MapleCharacter getChar() {\n-\t\treturn c.getPlayer();\n-\t}\n-        \n-        public MapleMap getMap() {\n-                return c.getPlayer().getMap();\n-        }\n-        \n-        public static int getHourOfDay() {\n-                return Calendar.getInstance().get(Calendar.HOUR_OF_DAY);\n-        }\n-        \n-        public int getMarketPortalId(int mapId) {\n-            return getMarketPortalId(getWarpMap(mapId));\n-        }\n-        \n-        private static int getMarketPortalId(MapleMap map) {\n-            return (map.findMarketPortal() != null) ? map.findMarketPortal().getId() : map.getRandomPlayerSpawnpoint().getId();\n-        }\n-        \n-\tpublic void warp(int mapid) {\n-\t\tgetPlayer().changeMap(mapid);\n-\t}\n+    public MapleClient c;\n \n-\tpublic void warp(int map, int portal) {\n-\t\tgetPlayer().changeMap(map, portal);\n-\t}\n+    public AbstractPlayerInteraction(MapleClient c) {\n+        this.c = c;\n+    }\n \n-\tpublic void warp(int map, String portal) {\n-\t\tgetPlayer().changeMap(map, portal);\n-\t}\n+    public MapleClient getClient() {\n+        return c;\n+    }\n \n-\tpublic void warpMap(int map) {\n-\t\tgetPlayer().getMap().warpEveryone(map);\n-\t}\n+    public MapleCharacter getPlayer() {\n+        return c.getPlayer();\n+    }\n \n-        public void warpParty(int id) {\n-                warpParty(id, 0);\n-        }\n-        \n-        public void warpParty(int id, int portalId) {\n-                int mapid = getMapId();\n-                warpParty(id, portalId, mapid, mapid);\n+    public MapleCharacter getChar() {\n+        return c.getPlayer();\n+    }\n+\n+    public MapleMap getMap() {\n+        return c.getPlayer().getMap();\n+    }\n+\n+    public static int getHourOfDay() {\n+        return Calendar.getInstance().get(Calendar.HOUR_OF_DAY);\n+    }\n+\n+    public int getMarketPortalId(int mapId) {\n+        return getMarketPortalId(getWarpMap(mapId));\n+    }\n+\n+    private static int getMarketPortalId(MapleMap map) {\n+        return (map.findMarketPortal() != null) ? map.findMarketPortal().getId() : map.getRandomPlayerSpawnpoint().getId();\n+    }\n+\n+    public void warp(int mapid) {\n+        getPlayer().changeMap(mapid);\n+    }\n+\n+    public void warp(int map, int portal) {\n+        getPlayer().changeMap(map, portal);\n+    }\n+\n+    public void warp(int map, String portal) {\n+        getPlayer().changeMap(map, portal);\n+    }\n+\n+    public void warpMap(int map) {\n+        getPlayer().getMap().warpEveryone(map);\n+    }\n+\n+    public void warpParty(int id) {\n+        warpParty(id, 0);\n+    }\n+\n+    public void warpParty(int id, int portalId) {\n+        int mapid = getMapId();\n+        warpParty(id, portalId, mapid, mapid);\n+    }\n+\n+    public void warpParty(int id, int fromMinId, int fromMaxId) {\n+        warpParty(id, 0, fromMinId, fromMaxId);\n+    }\n+\n+    public void warpParty(int id, int portalId, int fromMinId, int fromMaxId) {\n+        for (MapleCharacter mc : getPartyMembers()) {\n+            if (mc.getMapId() >= fromMinId && mc.getMapId() <= fromMaxId) {\n+                mc.changeMap(id, portalId);\n+            }\n         }\n-        \n-        public void warpParty(int id, int fromMinId, int fromMaxId) {\n-                warpParty(id, 0, fromMinId, fromMaxId);\n+    }\n+\n+    public List<MapleCharacter> getPartyMembers() {\n+        if (getPlayer().getParty() == null) {\n+            return null;\n         }\n-        \n-\tpublic void warpParty(int id, int portalId, int fromMinId, int fromMaxId) {\n-                for (MapleCharacter mc : getPartyMembers()) {\n-                        if(mc.getMapId() >= fromMinId && mc.getMapId() <= fromMaxId) {\n-                                mc.changeMap(id, portalId);\n-                        }\n+        List<MapleCharacter> chars = new LinkedList<>();\n+        for (Channel channel : Server.getInstance().getChannelsFromWorld(getPlayer().getWorld())) {\n+            for (MapleCharacter chr : channel.getPartyMembers(getPlayer().getParty())) {\n+                if (chr != null) {\n+                    chars.add(chr);\n                 }\n-\t}\n-\n-\tpublic List<MapleCharacter> getPartyMembers() {\n-\t\tif (getPlayer().getParty() == null) {\n-\t\t\treturn null;\n-\t\t}\n-\t\tList<MapleCharacter> chars = new LinkedList<>();\n-\t\tfor (Channel channel : Server.getInstance().getChannelsFromWorld(getPlayer().getWorld())) {\n-\t\t\tfor (MapleCharacter chr : channel.getPartyMembers(getPlayer().getParty())) {\n-\t\t\t\tif (chr != null) {\n-\t\t\t\t\tchars.add(chr);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn chars;\n-\t}\n-\n-\tpublic MapleMap getWarpMap(int map) {\n-\t\treturn getPlayer().getWarpMap(map);\n-\t}\n-\n-\tpublic MapleMap getMap(int map) {\n-\t\treturn getWarpMap(map);\n-\t}\n-        \n-        public int countAllMonstersOnMap(int map) {\n-                return getMap(map).countMonsters();\n+            }\n         }\n-        \n-        public int countMonster() {\n-            return getPlayer().getMap().countMonsters();\n+        return chars;\n+    }\n+\n+    public MapleMap getWarpMap(int map) {\n+        return getPlayer().getWarpMap(map);\n+    }\n+\n+    public MapleMap getMap(int map) {\n+        return getWarpMap(map);\n+    }\n+\n+    public int countAllMonstersOnMap(int map) {\n+        return getMap(map).countMonsters();\n+    }\n+\n+    public int countMonster() {\n+        return getPlayer().getMap().countMonsters();\n+    }\n+\n+    public void resetMapObjects(int mapid) {\n+        getWarpMap(mapid).resetMapObjects();\n+    }\n+\n+    public EventManager getEventManager(String event) {\n+        return getClient().getEventManager(event);\n+    }\n+\n+    public EventInstanceManager getEventInstance() {\n+        return getPlayer().getEventInstance();\n+    }\n+\n+    public MapleInventory getInventory(int type) {\n+        return getPlayer().getInventory(MapleInventoryType.getByType((byte) type));\n+    }\n+\n+    public MapleInventory getInventory(MapleInventoryType type) {\n+        return getPlayer().getInventory(type);\n+    }\n+\n+    public boolean hasItem(int itemid) {\n+        return haveItem(itemid, 1);\n+    }\n+\n+    public boolean hasItem(int itemid, int quantity) {\n+        return haveItem(itemid, quantity);\n+    }\n+\n+    public boolean haveItem(int itemid) {\n+        return haveItem(itemid, 1);\n+    }\n+\n+    public boolean haveItem(int itemid, int quantity) {\n+        return getPlayer().getItemQuantity(itemid, false) >= quantity;\n+    }\n+\n+    public int getItemQuantity(int itemid) {\n+        return getPlayer().getItemQuantity(itemid, false);\n+    }\n+\n+    public boolean haveItemWithId(int itemid) {\n+        return haveItemWithId(itemid, false);\n+    }\n+\n+    public boolean haveItemWithId(int itemid, boolean checkEquipped) {\n+        return getPlayer().haveItemWithId(itemid, checkEquipped);\n+    }\n+\n+    public boolean canHold(int itemid) {\n+        return canHold(itemid, 1);\n+    }\n+\n+    public boolean canHold(int itemid, int quantity) {\n+        return canHoldAll(Collections.singletonList(itemid), Collections.singletonList(quantity), true);\n+    }\n+\n+    public boolean canHold(int itemid, int quantity, int removeItemid, int removeQuantity) {\n+        return canHoldAllAfterRemoving(Collections.singletonList(itemid), Collections.singletonList(quantity), Collections.singletonList(removeItemid), Collections.singletonList(removeQuantity));\n+    }\n+\n+    private static List<Integer> convertToIntegerArray(List<Double> list) {\n+        List<Integer> intList = new LinkedList<>();\n+        for (Double d : list) {\n+            intList.add(d.intValue());\n         }\n-        \n-        public void resetMapObjects(int mapid) {\n-                getWarpMap(mapid).resetMapObjects();\n+\n+        return intList;\n+    }\n+\n+    public boolean canHoldAll(List<Double> itemids) {\n+        List<Double> quantity = new LinkedList<>();\n+        for (int i = 0; i < itemids.size(); i++) {\n+            quantity.add(1.0);\n         }\n \n-\tpublic EventManager getEventManager(String event) {\n-\t\treturn getClient().getEventManager(event);\n-\t}\n-        \n-        public EventInstanceManager getEventInstance() {\n-\t\treturn getPlayer().getEventInstance();\n-\t}\n-        \n-        public MapleInventory getInventory(int type) {\n-                return getPlayer().getInventory(MapleInventoryType.getByType((byte) type));\n+        return canHoldAll(itemids, quantity);\n+    }\n+\n+    public boolean canHoldAll(List<Double> itemids, List<Double> quantity) {\n+        return canHoldAll(convertToIntegerArray(itemids), convertToIntegerArray(quantity), true);\n+    }\n+\n+    private boolean canHoldAll(List<Integer> itemids, List<Integer> quantity, boolean isInteger) {\n+        int size = Math.min(itemids.size(), quantity.size());\n+\n+        List<Pair<Item, MapleInventoryType>> addedItems = new LinkedList<>();\n+        for (int i = 0; i < size; i++) {\n+            Item it = new Item(itemids.get(i), (short) 0, quantity.get(i).shortValue());\n+            addedItems.add(new Pair<>(it, ItemConstants.getInventoryType(itemids.get(i))));\n         }\n-        \n-        public MapleInventory getInventory(MapleInventoryType type) {\n-                return getPlayer().getInventory(type);\n+\n+        return MapleInventory.checkSpots(c.getPlayer(), addedItems, false);\n+    }\n+\n+    private static List<Pair<Item, MapleInventoryType>> prepareProofInventoryItems(List<Pair<Integer, Integer>> items) {\n+        List<Pair<Item, MapleInventoryType>> addedItems = new LinkedList<>();\n+        for (Pair<Integer, Integer> p : items) {\n+            Item it = new Item(p.getLeft(), (short) 0, p.getRight().shortValue());\n+            addedItems.add(new Pair<>(it, MapleInventoryType.CANHOLD));\n         }\n-        \n-\tpublic boolean hasItem(int itemid) {\n-\t\treturn haveItem(itemid, 1);\n-\t}\n-\n-\tpublic boolean hasItem(int itemid, int quantity) {\n-\t\treturn haveItem(itemid, quantity);\n-\t}\n-\n-\tpublic boolean haveItem(int itemid) {\n-\t\treturn haveItem(itemid, 1);\n-\t}\n-\n-\tpublic boolean haveItem(int itemid, int quantity) {\n-\t\treturn getPlayer().getItemQuantity(itemid, false) >= quantity;\n-\t}\n-        \n-        public int getItemQuantity(int itemid) {\n-                return getPlayer().getItemQuantity(itemid, false);\n+\n+        return addedItems;\n+    }\n+\n+    private static List<List<Pair<Integer, Integer>>> prepareInventoryItemList(List<Integer> itemids, List<Integer> quantity) {\n+        int size = Math.min(itemids.size(), quantity.size());\n+\n+        List<List<Pair<Integer, Integer>>> invList = new ArrayList<>(6);\n+        for (int i = MapleInventoryType.UNDEFINED.getType(); i < MapleInventoryType.CASH.getType(); i++) {\n+            invList.add(new LinkedList<Pair<Integer, Integer>>());\n         }\n \n-        public boolean haveItemWithId(int itemid) {\n-                return haveItemWithId(itemid, false);\n+        for (int i = 0; i < size; i++) {\n+            int itemid = itemids.get(i);\n+            invList.get(ItemConstants.getInventoryType(itemid).getType()).add(new Pair<>(itemid, quantity.get(i)));\n         }\n-        \n-        public boolean haveItemWithId(int itemid, boolean checkEquipped) {\n-                return getPlayer().haveItemWithId(itemid, checkEquipped);\n+\n+        return invList;\n+    }\n+\n+    public boolean canHoldAllAfterRemoving(List<Integer> toAddItemids, List<Integer> toAddQuantity, List<Integer> toRemoveItemids, List<Integer> toRemoveQuantity) {\n+        List<List<Pair<Integer, Integer>>> toAddItemList = prepareInventoryItemList(toAddItemids, toAddQuantity);\n+        List<List<Pair<Integer, Integer>>> toRemoveItemList = prepareInventoryItemList(toRemoveItemids, toRemoveQuantity);\n+\n+        MapleInventoryProof prfInv = (MapleInventoryProof) this.getInventory(MapleInventoryType.CANHOLD);\n+        prfInv.lockInventory();\n+        try {\n+            for (int i = MapleInventoryType.EQUIP.getType(); i < MapleInventoryType.CASH.getType(); i++) {\n+                List<Pair<Integer, Integer>> toAdd = toAddItemList.get(i);\n+\n+                if (!toAdd.isEmpty()) {\n+                    List<Pair<Integer, Integer>> toRemove = toRemoveItemList.get(i);\n+\n+                    MapleInventory inv = this.getInventory(i);\n+                    prfInv.cloneContents(inv);\n+\n+                    for (Pair<Integer, Integer> p : toRemove) {\n+                        MapleInventoryManipulator.removeById(c, MapleInventoryType.CANHOLD, p.getLeft(), p.getRight(), false, false);\n+                    }\n+\n+                    List<Pair<Item, MapleInventoryType>> addItems = prepareProofInventoryItems(toAdd);\n+\n+                    boolean canHold = MapleInventory.checkSpots(c.getPlayer(), addItems, true);\n+                    if (!canHold) {\n+                        return false;\n+                    }\n+                }\n+            }\n+        } finally {\n+            prfInv.flushContents();\n+            prfInv.unlockInventory();\n         }\n-        \n-\tpublic boolean canHold(int itemid) {\n-                return canHold(itemid, 1);\n+\n+        return true;\n+    }\n+\n+        //---- \\/ \\/ \\/ \\/ \\/ \\/ \\/  NOT TESTED  \\/ \\/ \\/ \\/ \\/ \\/ \\/ \\/ \\/ ----\n+    public final MapleQuestStatus getQuestRecord(final int id) {\n+        return c.getPlayer().getQuestNAdd(MapleQuest.getInstance(id));\n+    }\n+\n+    public final MapleQuestStatus getQuestNoRecord(final int id) {\n+        return c.getPlayer().getQuestNoAdd(MapleQuest.getInstance(id));\n+    }\n+\n+        //---- /\\ /\\ /\\ /\\ /\\ /\\ /\\  NOT TESTED  /\\ /\\ /\\ /\\ /\\ /\\ /\\ /\\ /\\ ----\n+    public void openNpc(int npcid) {\n+        openNpc(npcid, null);\n+    }\n+\n+    public void openNpc(int npcid, String script) {\n+        if (c.getCM() != null) {\n+            return;\n         }\n-        \n-        public boolean canHold(int itemid, int quantity) {\n-                return canHoldAll(Collections.singletonList(itemid), Collections.singletonList(quantity), true);\n+\n+        c.removeClickedNPC();\n+        NPCScriptManager.getInstance().dispose(c);\n+        NPCScriptManager.getInstance().start(c, npcid, script, null);\n+    }\n+\n+    public void updateQuest(int questid, int data) {\n+        MapleQuestStatus status = c.getPlayer().getQuest(MapleQuest.getInstance(questid));\n+        updateQuest(questid, status.getAnyProgressKey(), data);\n+    }\n+\n+    public void updateQuest(int questid, String data) {\n+        MapleQuestStatus status = c.getPlayer().getQuest(MapleQuest.getInstance(questid));\n+        updateQuest(questid, status.getAnyProgressKey(), data);\n+    }\n+\n+    public void updateQuest(int questid, int pid, int data) {\n+        updateQuest(questid, pid, String.valueOf(data));\n+    }\n+\n+    public void updateQuest(int questid, int pid, String data) {\n+        MapleQuestStatus status = c.getPlayer().getQuest(MapleQuest.getInstance(questid));\n+        status.setStatus(MapleQuestStatus.Status.STARTED);\n+        status.setProgress(pid, data);//override old if exists\n+        c.getPlayer().updateQuest(status);\n+    }\n+\n+    public int getQuestStatus(int id) {\n+        return c.getPlayer().getQuest(MapleQuest.getInstance(id)).getStatus().getId();\n+    }\n+\n+    private MapleQuestStatus.Status getQuestStat(int id) {\n+        return c.getPlayer().getQuest(MapleQuest.getInstance(id)).getStatus();\n+    }\n+\n+    public boolean isQuestCompleted(int quest) {\n+        try {\n+            return getQuestStat(quest) == MapleQuestStatus.Status.COMPLETED;\n+        } catch (NullPointerException e) {\n+            e.printStackTrace();\n+            return false;\n         }\n-        \n-        public boolean canHold(int itemid, int quantity, int removeItemid, int removeQuantity) {\n-                return canHoldAllAfterRemoving(Collections.singletonList(itemid), Collections.singletonList(quantity), Collections.singletonList(removeItemid), Collections.singletonList(removeQuantity));\n+    }\n+\n+    public boolean isQuestActive(int quest) {\n+        return isQuestStarted(quest);\n+    }\n+\n+    public boolean isQuestStarted(int quest) {\n+        try {\n+            return getQuestStat(quest) == MapleQuestStatus.Status.STARTED;\n+        } catch (NullPointerException e) {\n+            e.printStackTrace();\n+            return false;\n         }\n-        \n-        private static List<Integer> convertToIntegerArray(List<Double> list) {\n-                List<Integer> intList = new LinkedList<>();\n-                for(Double d: list) intList.add(d.intValue());\n+    }\n+\n+    public void setQuestProgress(int qid, int progress) {\n+        MapleQuestStatus status = c.getPlayer().getQuest(MapleQuest.getInstance(qid));\n+        status.setProgress(status.getAnyProgressKey(), String.valueOf(progress));\n+    }\n \n-                return intList;\n+    public void setQuestProgress(int qid, int pid, int progress) {\n+        MapleQuestStatus status = c.getPlayer().getQuest(MapleQuest.getInstance(qid));\n+        status.setProgress(pid, String.valueOf(progress));\n+    }\n+\n+    public void setStringQuestProgress(int qid, int pid, String progress) {\n+        MapleQuestStatus status = c.getPlayer().getQuest(MapleQuest.getInstance(qid));\n+        status.setProgress(pid, progress);\n+    }\n+\n+    public int getQuestProgress(int qid) {\n+        MapleQuestStatus status = c.getPlayer().getQuest(MapleQuest.getInstance(qid));\n+        String progress = status.getProgress(status.getAnyProgressKey());\n+\n+        if (progress.isEmpty()) {\n+            return 0;\n         }\n-        \n-        public boolean canHoldAll(List<Double> itemids) {\n-                List<Double> quantity = new LinkedList<>();\n-                for (int i = 0; i < itemids.size(); i++) {\n-                        quantity.add(1.0);\n-                }\n-            \n-                return canHoldAll(itemids, quantity);\n+        return Integer.parseInt(progress);\n+    }\n+\n+    public int getQuestProgress(int qid, int pid) {\n+        if (getPlayer().getQuest(MapleQuest.getInstance(qid)).getProgress(pid).isEmpty()) {\n+            return 0;\n         }\n-        \n-        public boolean canHoldAll(List<Double> itemids, List<Double> quantity) {\n-                return canHoldAll(convertToIntegerArray(itemids), convertToIntegerArray(quantity), true);\n+        return Integer.parseInt(getPlayer().getQuest(MapleQuest.getInstance(qid)).getProgress(pid));\n+    }\n+\n+    public String getStringQuestProgress(int qid, int pid) {\n+        if (getPlayer().getQuest(MapleQuest.getInstance(qid)).getProgress(pid).isEmpty()) {\n+            return \"\";\n         }\n-        \n-        private boolean canHoldAll(List<Integer> itemids, List<Integer> quantity, boolean isInteger) {\n-            int size = Math.min(itemids.size(), quantity.size());\n-            \n-            List<Pair<Item, MapleInventoryType>> addedItems = new LinkedList<>();\n-            for(int i = 0; i < size; i++) {\n-                Item it = new Item(itemids.get(i), (short) 0, quantity.get(i).shortValue());\n-                addedItems.add(new Pair<>(it, ItemConstants.getInventoryType(itemids.get(i))));\n-            }\n-            \n-            return MapleInventory.checkSpots(c.getPlayer(), addedItems, false);\n+        return getPlayer().getQuest(MapleQuest.getInstance(qid)).getProgress(pid);\n+    }\n+\n+    public void resetAllQuestProgress(int qid) {\n+        getPlayer().getQuest(MapleQuest.getInstance(qid)).resetAllProgress();\n+        getClient().announce(MaplePacketCreator.updateQuest(getPlayer().getQuest(MapleQuest.getInstance(qid)), false));\n+    }\n+\n+    public void resetQuestProgress(int qid, int pid) {\n+        getPlayer().getQuest(MapleQuest.getInstance(qid)).resetProgress(pid);\n+        getClient().announce(MaplePacketCreator.updateQuest(getPlayer().getQuest(MapleQuest.getInstance(qid)), false));\n+    }\n+\n+    public Item evolvePet(byte slot, int afterId) {\n+        MaplePet evolved = null;\n+        MaplePet target;\n+\n+        long period = (long) 90 * 24 * 60 * 60 * 1000;    //refreshes expiration date: 90 days\n+\n+        target = getPlayer().getPet(slot);\n+        if (target == null) {\n+            getPlayer().message(\"Pet could not be evolved...\");\n+            return (null);\n         }\n-        \n-        private static List<Pair<Item, MapleInventoryType>> prepareProofInventoryItems(List<Pair<Integer, Integer>> items) {\n-            List<Pair<Item, MapleInventoryType>> addedItems = new LinkedList<>();\n-            for(Pair<Integer, Integer> p : items) {\n-                Item it = new Item(p.getLeft(), (short) 0, p.getRight().shortValue());\n-                addedItems.add(new Pair<>(it, MapleInventoryType.CANHOLD));\n-            }\n+\n+        Item tmp = gainItem(afterId, (short) 1, false, true, period, target);\n+\n+        /*\n+         evolved = MaplePet.loadFromDb(tmp.getItemId(), tmp.getPosition(), tmp.getPetId());\n             \n-            return addedItems;\n-        }\n-        \n-        private static List<List<Pair<Integer, Integer>>> prepareInventoryItemList(List<Integer> itemids, List<Integer> quantity) {\n-            int size = Math.min(itemids.size(), quantity.size());\n+         evolved = tmp.getPet();\n+         if(evolved == null) {\n+         getPlayer().message(\"Pet structure non-existent for \" + tmp.getItemId() + \"...\");\n+         return(null);\n+         }\n+         else if(tmp.getPetId() == -1) {\n+         getPlayer().message(\"Pet id -1\");\n+         return(null);\n+         }\n             \n-            List<List<Pair<Integer, Integer>>> invList = new ArrayList<>(6);\n-            for(int i = MapleInventoryType.UNDEFINED.getType(); i < MapleInventoryType.CASH.getType(); i++) {\n-                invList.add(new LinkedList<Pair<Integer, Integer>>());\n-            }\n+         getPlayer().addPet(evolved);\n             \n-            for(int i = 0; i < size; i++) {\n-                int itemid = itemids.get(i);\n-                invList.get(ItemConstants.getInventoryType(itemid).getType()).add(new Pair<>(itemid, quantity.get(i)));\n+         getPlayer().getMap().broadcastMessage(c.getPlayer(), MaplePacketCreator.showPet(c.getPlayer(), evolved, false, false), true);\n+         c.announce(MaplePacketCreator.petStatUpdate(c.getPlayer()));\n+         c.announce(MaplePacketCreator.enableActions());\n+         chr.getClient().getWorldServer().registerPetHunger(chr, chr.getPetIndex(evolved));\n+         */\n+        MapleInventoryManipulator.removeFromSlot(c, MapleInventoryType.CASH, target.getPosition(), (short) 1, false);\n+\n+        return evolved;\n+    }\n+\n+    public void gainItem(int id, short quantity) {\n+        gainItem(id, quantity, false, true);\n+    }\n+\n+    public void gainItem(int id, short quantity, boolean show) {//this will fk randomStats equip :P\n+        gainItem(id, quantity, false, show);\n+    }\n+\n+    public void gainItem(int id, boolean show) {\n+        gainItem(id, (short) 1, false, show);\n+    }\n+\n+    public void gainItem(int id) {\n+        gainItem(id, (short) 1, false, true);\n+    }\n+\n+    public Item gainItem(int id, short quantity, boolean randomStats, boolean showMessage) {\n+        return gainItem(id, quantity, randomStats, showMessage, -1);\n+    }\n+\n+    public Item gainItem(int id, short quantity, boolean randomStats, boolean showMessage, long expires) {\n+        return gainItem(id, quantity, randomStats, showMessage, expires, null);\n+    }\n+\n+    public Item gainItem(int id, short quantity, boolean randomStats, boolean showMessage, long expires, MaplePet from) {\n+        Item item = null;\n+        MaplePet evolved;\n+        int petId = -1;\n+\n+        if (quantity >= 0) {\n+            if (ItemConstants.isPet(id)) {\n+                petId = MaplePet.createPet(id);\n+\n+                if (from != null) {\n+                    evolved = MaplePet.loadFromDb(id, (short) 0, petId);\n+\n+                    Point pos = getPlayer().getPosition();\n+                    pos.y -= 12;\n+                    evolved.setPos(pos);\n+                    evolved.setFh(getPlayer().getMap().getFootholds().findBelow(evolved.getPos()).getId());\n+                    evolved.setStance(0);\n+                    evolved.setSummoned(true);\n+\n+                    evolved.setName(from.getName().compareTo(MapleItemInformationProvider.getInstance().getName(from.getItemId())) != 0 ? from.getName() : MapleItemInformationProvider.getInstance().getName(id));\n+                    evolved.setCloseness(from.getCloseness());\n+                    evolved.setFullness(from.getFullness());\n+                    evolved.setLevel(from.getLevel());\n+                    evolved.setExpiration(System.currentTimeMillis() + expires);\n+                    evolved.saveToDb();\n+                }\n+\n+                //MapleInventoryManipulator.addById(c, id, (short) 1, null, petId, expires == -1 ? -1 : System.currentTimeMillis() + expires);\n             }\n-            \n-            return invList;\n-        }\n-        \n-        public boolean canHoldAllAfterRemoving(List<Integer> toAddItemids, List<Integer> toAddQuantity, List<Integer> toRemoveItemids, List<Integer> toRemoveQuantity) {\n-            List<List<Pair<Integer, Integer>>> toAddItemList = prepareInventoryItemList(toAddItemids, toAddQuantity);\n-            List<List<Pair<Integer, Integer>>> toRemoveItemList = prepareInventoryItemList(toRemoveItemids, toRemoveQuantity);\n-            \n-            MapleInventoryProof prfInv = (MapleInventoryProof) this.getInventory(MapleInventoryType.CANHOLD);\n-            prfInv.lockInventory();\n-            try {\n-                for(int i = MapleInventoryType.EQUIP.getType(); i < MapleInventoryType.CASH.getType(); i++) {\n-                    List<Pair<Integer, Integer>> toAdd = toAddItemList.get(i);\n-                    \n-                    if(!toAdd.isEmpty()) {\n-                        List<Pair<Integer, Integer>> toRemove = toRemoveItemList.get(i);\n-                        \n-                        MapleInventory inv = this.getInventory(i);\n-                        prfInv.cloneContents(inv);\n-                        \n-                        for(Pair<Integer, Integer> p : toRemove) {\n-                            MapleInventoryManipulator.removeById(c, MapleInventoryType.CANHOLD, p.getLeft(), p.getRight(), false, false);\n-                        }\n-                        \n-                        List<Pair<Item, MapleInventoryType>> addItems = prepareProofInventoryItems(toAdd);\n-                        \n-                        boolean canHold = MapleInventory.checkSpots(c.getPlayer(), addItems, true);\n-                        if(!canHold) {\n-                            return false;\n+\n+            MapleItemInformationProvider ii = MapleItemInformationProvider.getInstance();\n+\n+            if (ItemConstants.getInventoryType(id).equals(MapleInventoryType.EQUIP)) {\n+                item = ii.getEquipById(id);\n+\n+                if (item != null) {\n+                    Equip it = (Equip) item;\n+                    if (ItemConstants.isAccessory(item.getItemId()) && it.getUpgradeSlots() <= 0) {\n+                        it.setUpgradeSlots(3);\n+                    }\n+\n+                    if (ServerConstants.USE_ENHANCED_CRAFTING == true && c.getPlayer().getCS() == true) {\n+                        Equip eqp = (Equip) item;\n+                        if (!(c.getPlayer().isGM() && ServerConstants.USE_PERFECT_GM_SCROLL)) {\n+                            eqp.setUpgradeSlots((byte) (eqp.getUpgradeSlots() + 1));\n                         }\n+                        item = MapleItemInformationProvider.getInstance().scrollEquipWithId(item, 2049100, true, 2049100, c.getPlayer().isGM());\n                     }\n                 }\n-            } finally {\n-                prfInv.flushContents();\n-                prfInv.unlockInventory();\n+            } else {\n+                item = new Item(id, (short) 0, quantity, petId);\n             }\n-            \n-            return true;\n+\n+            if (expires >= 0) {\n+                item.setExpiration(System.currentTimeMillis() + expires);\n+            }\n+\n+            if (!MapleInventoryManipulator.checkSpace(c, id, quantity, \"\")) {\n+                c.getPlayer().dropMessage(1, \"Your inventory is full. Please remove an item from your \" + ItemConstants.getInventoryType(id).name() + \" inventory.\");\n+                return null;\n+            }\n+            if (ItemConstants.getInventoryType(id) == MapleInventoryType.EQUIP) {\n+                if (randomStats) {\n+                    MapleInventoryManipulator.addFromDrop(c, ii.randomizeStats((Equip) item), false, petId);\n+                } else {\n+                    MapleInventoryManipulator.addFromDrop(c, (Equip) item, false, petId);\n+                }\n+            } else {\n+                MapleInventoryManipulator.addFromDrop(c, item, false, petId);\n+            }\n+        } else {\n+            MapleInventoryManipulator.removeById(c, ItemConstants.getInventoryType(id), id, -quantity, true, false);\n         }\n-     \n-        //---- \\/ \\/ \\/ \\/ \\/ \\/ \\/  NOT TESTED  \\/ \\/ \\/ \\/ \\/ \\/ \\/ \\/ \\/ ----\n-        \n-        public final MapleQuestStatus getQuestRecord(final int id) {\n-            return c.getPlayer().getQuestNAdd(MapleQuest.getInstance(id));\n+        if (showMessage) {\n+            c.announce(MaplePacketCreator.getShowItemGain(id, quantity, true));\n         }\n \n-        public final MapleQuestStatus getQuestNoRecord(final int id) {\n-            return c.getPlayer().getQuestNoAdd(MapleQuest.getInstance(id));\n-        }\n-        \n-        //---- /\\ /\\ /\\ /\\ /\\ /\\ /\\  NOT TESTED  /\\ /\\ /\\ /\\ /\\ /\\ /\\ /\\ /\\ ----\n+        return item;\n+    }\n \n-\tpublic void openNpc(int npcid) {\n-\t\topenNpc(npcid, null);\n-\t}\n+    public void gainFame(int delta) {\n+        getPlayer().gainFame(delta);\n+    }\n \n-\tpublic void openNpc(int npcid, String script) {\n-                if(c.getCM() != null) return;\n-            \n-\t\tc.removeClickedNPC();\n-\t\tNPCScriptManager.getInstance().dispose(c);\n-\t\tNPCScriptManager.getInstance().start(c, npcid, script, null);\n-\t}\n-\n-        public void updateQuest(int questid, int data) {\n-            MapleQuestStatus status = c.getPlayer().getQuest(MapleQuest.getInstance(questid));\n-            updateQuest(questid, status.getAnyProgressKey(), data);\n-        }\n-        \n-        public void updateQuest(int questid, String data) {\n-            MapleQuestStatus status = c.getPlayer().getQuest(MapleQuest.getInstance(questid));\n-            updateQuest(questid, status.getAnyProgressKey(), data);\n+    public void changeMusic(String songName) {\n+        getPlayer().getMap().broadcastMessage(MaplePacketCreator.musicChange(songName));\n+    }\n+\n+    public void playerMessage(int type, String message) {\n+        c.announce(MaplePacketCreator.serverNotice(type, message));\n+    }\n+\n+    public void message(String message) {\n+        getPlayer().message(message);\n+    }\n+\n+    public void mapMessage(int type, String message) {\n+        getPlayer().getMap().broadcastMessage(MaplePacketCreator.serverNotice(type, message));\n+    }\n+\n+    public void mapEffect(String path) {\n+        c.announce(MaplePacketCreator.mapEffect(path));\n+    }\n+\n+    public void mapSound(String path) {\n+        c.announce(MaplePacketCreator.mapSound(path));\n+    }\n+\n+    public void displayAranIntro() {\n+        String intro = \"\";\n+        switch (c.getPlayer().getMapId()) {\n+            case 914090010:\n+                intro = \"Effect/Direction1.img/aranTutorial/Scene0\";\n+                break;\n+            case 914090011:\n+                intro = \"Effect/Direction1.img/aranTutorial/Scene1\" + (c.getPlayer().getGender() == 0 ? \"0\" : \"1\");\n+                break;\n+            case 914090012:\n+                intro = \"Effect/Direction1.img/aranTutorial/Scene2\" + (c.getPlayer().getGender() == 0 ? \"0\" : \"1\");\n+                break;\n+            case 914090013:\n+                intro = \"Effect/Direction1.img/aranTutorial/Scene3\";\n+                break;\n+            case 914090100:\n+                intro = \"Effect/Direction1.img/aranTutorial/HandedPoleArm\" + (c.getPlayer().getGender() == 0 ? \"0\" : \"1\");\n+                break;\n+            case 914090200:\n+                intro = \"Effect/Direction1.img/aranTutorial/Maha\";\n+                break;\n         }\n-        \n-        public void updateQuest(int questid, int pid, int data) {\n-            updateQuest(questid, pid, String.valueOf(data));\n+        showIntro(intro);\n+    }\n+\n+    public void showIntro(String path) {\n+        c.announce(MaplePacketCreator.showIntro(path));\n+    }\n+\n+    public void showInfo(String path) {\n+        c.announce(MaplePacketCreator.showInfo(path));\n+        c.announce(MaplePacketCreator.enableActions());\n+    }\n+\n+    public void guildMessage(int type, String message) {\n+        if (getGuild() != null) {\n+            getGuild().guildMessage(MaplePacketCreator.serverNotice(type, message));\n         }\n-        \n-\tpublic void updateQuest(int questid, int pid, String data) {\n-\t\tMapleQuestStatus status = c.getPlayer().getQuest(MapleQuest.getInstance(questid));\n-\t\tstatus.setStatus(MapleQuestStatus.Status.STARTED);\n-\t\tstatus.setProgress(pid, data);//override old if exists\n-\t\tc.getPlayer().updateQuest(status);\n-\t}\n-\n-\tpublic int getQuestStatus(int id) {\n-\t\treturn c.getPlayer().getQuest(MapleQuest.getInstance(id)).getStatus().getId();\n-\t}\n-        \n-        private MapleQuestStatus.Status getQuestStat(int id) {\n-                return c.getPlayer().getQuest(MapleQuest.getInstance(id)).getStatus();\n+    }\n+\n+    public MapleGuild getGuild() {\n+        try {\n+            return Server.getInstance().getGuild(getPlayer().getGuildId(), getPlayer().getWorld(), null);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n         }\n-        \n-\tpublic boolean isQuestCompleted(int quest) {\n-\t\ttry {\n-\t\t\treturn getQuestStat(quest) == MapleQuestStatus.Status.COMPLETED;\n-\t\t} catch (NullPointerException e) {\n-                        e.printStackTrace();\n-\t\t\treturn false;\n-\t\t}\n-\t}\n-\n-        public boolean isQuestActive(int quest) {\n-            return isQuestStarted(quest);\n+        return null;\n+    }\n+\n+    public MapleParty getParty() {\n+        return getPlayer().getParty();\n+    }\n+\n+    public boolean isLeader() {\n+        return isPartyLeader();\n+    }\n+\n+    public boolean isGuildLeader() {\n+        return getPlayer().isGuildLeader();\n+    }\n+\n+    public boolean isPartyLeader() {\n+        if (getParty() == null) {\n+            return false;\n         }\n-        \n-\tpublic boolean isQuestStarted(int quest) {\n-\t\ttry {\n-\t\t\treturn getQuestStat(quest) == MapleQuestStatus.Status.STARTED;\n-\t\t} catch (NullPointerException e) {\n-                        e.printStackTrace();\n-\t\t\treturn false;\n-\t\t}\n-\t}\n-        \n-        public void setQuestProgress(int qid, int progress) {\n-                MapleQuestStatus status = c.getPlayer().getQuest(MapleQuest.getInstance(qid));\n-                status.setProgress(status.getAnyProgressKey(), String.valueOf(progress));\n+\n+        return getParty().getLeaderId() == getPlayer().getId();\n+    }\n+\n+    public boolean isEventLeader() {\n+        return getEventInstance() != null && getPlayer().getId() == getEventInstance().getLeaderId();\n+    }\n+\n+    public void givePartyItems(int id, short quantity, List<MapleCharacter> party) {\n+        for (MapleCharacter chr : party) {\n+            MapleClient cl = chr.getClient();\n+            if (quantity >= 0) {\n+                MapleInventoryManipulator.addById(cl, id, quantity);\n+            } else {\n+                MapleInventoryManipulator.removeById(cl, ItemConstants.getInventoryType(id), id, -quantity, true, false);\n+            }\n+            cl.announce(MaplePacketCreator.getShowItemGain(id, quantity, true));\n         }\n-        \n-        public void setQuestProgress(int qid, int pid, int progress) {\n-                MapleQuestStatus status = c.getPlayer().getQuest(MapleQuest.getInstance(qid));\n-                status.setProgress(pid, String.valueOf(progress));\n-\t}\n-        \n-        public void setStringQuestProgress(int qid, int pid, String progress) {\n-                MapleQuestStatus status = c.getPlayer().getQuest(MapleQuest.getInstance(qid));\n-                status.setProgress(pid, progress);\n+    }\n+\n+    public void removeHPQItems() {\n+        int[] items = {4001095, 4001096, 4001097, 4001098, 4001099, 4001100, 4001101};\n+        for (int i = 0; i < items.length; i++) {\n+            removePartyItems(items[i]);\n         }\n-        \n-        public int getQuestProgress(int qid) {\n-                MapleQuestStatus status = c.getPlayer().getQuest(MapleQuest.getInstance(qid));\n-                String progress = status.getProgress(status.getAnyProgressKey());\n-            \n-                if(progress.isEmpty()) return 0;\n-                return Integer.parseInt(progress);\n+    }\n+\n+    public void removePartyItems(int id) {\n+        if (getParty() == null) {\n+            removeAll(id);\n+            return;\n         }\n-        \n-        public int getQuestProgress(int qid, int pid) {\n-                if(getPlayer().getQuest(MapleQuest.getInstance(qid)).getProgress(pid).isEmpty()) return 0;\n-\t\treturn Integer.parseInt(getPlayer().getQuest(MapleQuest.getInstance(qid)).getProgress(pid));\n-\t}\n-        \n-        public String getStringQuestProgress(int qid, int pid) {\n-                if(getPlayer().getQuest(MapleQuest.getInstance(qid)).getProgress(pid).isEmpty()) return \"\";\n-                return getPlayer().getQuest(MapleQuest.getInstance(qid)).getProgress(pid);\n+        for (MaplePartyCharacter chr : getParty().getMembers()) {\n+            if (chr != null && chr.isOnline() && chr.getPlayer().getClient() != null) {\n+                removeAll(id, chr.getPlayer().getClient());\n+            }\n         }\n-        \n-        public void resetAllQuestProgress(int qid) {\n-                getPlayer().getQuest(MapleQuest.getInstance(qid)).resetAllProgress();\n-                getClient().announce(MaplePacketCreator.updateQuest(getPlayer().getQuest(MapleQuest.getInstance(qid)), false));\n+    }\n+\n+    public void giveCharacterExp(int amount, MapleCharacter chr) {\n+        chr.gainExp((amount * chr.getExpRate()), true, true);\n+    }\n+\n+    public void givePartyExp(int amount, List<MapleCharacter> party) {\n+        for (MapleCharacter chr : party) {\n+            giveCharacterExp(amount, chr);\n         }\n-        \n-        public void resetQuestProgress(int qid, int pid) {\n-                getPlayer().getQuest(MapleQuest.getInstance(qid)).resetProgress(pid);\n-                getClient().announce(MaplePacketCreator.updateQuest(getPlayer().getQuest(MapleQuest.getInstance(qid)), false));\n+    }\n+\n+    public void givePartyExp(String PQ) {\n+        givePartyExp(PQ, true);\n+    }\n+\n+    public void givePartyExp(String PQ, boolean instance) {\n+\t\t//1 player  =  +0% bonus (100)\n+        //2 players =  +0% bonus (100)\n+        //3 players =  +0% bonus (100)\n+        //4 players = +10% bonus (110)\n+        //5 players = +20% bonus (120)\n+        //6 players = +30% bonus (130)\n+        MapleParty party = getPlayer().getParty();\n+        int size = party.getMembers().size();\n+\n+        if (instance) {\n+            for (MaplePartyCharacter member : party.getMembers()) {\n+                if (member == null || !member.isOnline() || member.getPlayer().getEventInstance() == null) {\n+                    size--;\n+                }\n+            }\n         }\n-        \n-        public Item evolvePet(byte slot, int afterId) {\n-            MaplePet evolved = null;\n-            MaplePet target;\n-            \n-            long period = (long) 90 * 24 * 60 * 60 * 1000;    //refreshes expiration date: 90 days\n-            \n-            target = getPlayer().getPet(slot);\n-            if(target == null) {\n-                getPlayer().message(\"Pet could not be evolved...\");\n-                return(null);\n+\n+        int bonus = size < 4 ? 100 : 70 + (size * 10);\n+        for (MaplePartyCharacter member : party.getMembers()) {\n+            if (member == null || !member.isOnline()) {\n+                continue;\n             }\n-            \n-            Item tmp = gainItem(afterId, (short) 1, false, true, period, target);\n-            \n-            /*\n-            evolved = MaplePet.loadFromDb(tmp.getItemId(), tmp.getPosition(), tmp.getPetId());\n-            \n-            evolved = tmp.getPet();\n-            if(evolved == null) {\n-                getPlayer().message(\"Pet structure non-existent for \" + tmp.getItemId() + \"...\");\n-                return(null);\n+            MapleCharacter player = member.getPlayer();\n+            if (instance && player.getEventInstance() == null) {\n+                continue; // They aren't in the instance, don't give EXP.\n             }\n-            else if(tmp.getPetId() == -1) {\n-                getPlayer().message(\"Pet id -1\");\n-                return(null);\n+            int base = PartyQuest.getExp(PQ, player.getLevel());\n+            int exp = base * bonus / 100;\n+            player.gainExp(exp, true, true);\n+            if (ServerConstants.PQ_BONUS_EXP_RATE > 0 && System.currentTimeMillis() <= ServerConstants.EVENT_END_TIMESTAMP) {\n+                player.gainExp((int) (exp * ServerConstants.PQ_BONUS_EXP_RATE), true, true);\n             }\n-            \n-            getPlayer().addPet(evolved);\n-            \n-            getPlayer().getMap().broadcastMessage(c.getPlayer(), MaplePacketCreator.showPet(c.getPlayer(), evolved, false, false), true);\n-            c.announce(MaplePacketCreator.petStatUpdate(c.getPlayer()));\n-            c.announce(MaplePacketCreator.enableActions());\n-            chr.getClient().getWorldServer().registerPetHunger(chr, chr.getPetIndex(evolved));\n-            */\n-            \n-            MapleInventoryManipulator.removeFromSlot(c, MapleInventoryType.CASH, target.getPosition(), (short) 1, false);\n-            \n-            return evolved;\n         }\n-        \n-\tpublic void gainItem(int id, short quantity) {\n-\t\tgainItem(id, quantity, false, true);\n-\t}\n-\n-\tpublic void gainItem(int id, short quantity, boolean show) {//this will fk randomStats equip :P\n-\t\tgainItem(id, quantity, false, show);\n-\t}\n-\n-\tpublic void gainItem(int id, boolean show) {\n-\t\tgainItem(id, (short) 1, false, show);\n-\t}\n+    }\n \n-\tpublic void gainItem(int id) {\n-\t\tgainItem(id, (short) 1, false, true);\n-\t}   \n+    public void removeFromParty(int id, List<MapleCharacter> party) {\n+        for (MapleCharacter chr : party) {\n+            MapleInventoryType type = ItemConstants.getInventoryType(id);\n+            MapleInventory iv = chr.getInventory(type);\n+            int possesed = iv.countById(id);\n+            if (possesed > 0) {\n+                MapleInventoryManipulator.removeById(c, ItemConstants.getInventoryType(id), id, possesed, true, false);\n+                chr.announce(MaplePacketCreator.getShowItemGain(id, (short) -possesed, true));\n+            }\n+        }\n+    }\n \n-\tpublic Item gainItem(int id, short quantity, boolean randomStats, boolean showMessage) {\n-\t\treturn gainItem(id, quantity, randomStats, showMessage, -1);\n-\t}\n+    public void removeAll(int id) {\n+        removeAll(id, c);\n+    }\n \n-        public Item gainItem(int id, short quantity, boolean randomStats, boolean showMessage, long expires) {\n-            return gainItem(id, quantity, randomStats, showMessage, expires, null);\n-        }\n-        \n-        public Item gainItem(int id, short quantity, boolean randomStats, boolean showMessage, long expires, MaplePet from) {\n-\t\tItem item = null;\n-                MaplePet evolved;\n-                int petId = -1;\n-                \n-                if (quantity >= 0) {\n-                        if (ItemConstants.isPet(id)) {\n-                                petId = MaplePet.createPet(id);\n-\n-                                if(from != null) {\n-                                        evolved = MaplePet.loadFromDb(id, (short) 0, petId);\n-\n-                                        Point pos = getPlayer().getPosition();\n-                                        pos.y -= 12;\n-                                        evolved.setPos(pos);\n-                                        evolved.setFh(getPlayer().getMap().getFootholds().findBelow(evolved.getPos()).getId());\n-                                        evolved.setStance(0);\n-                                        evolved.setSummoned(true);\n-\n-                                        evolved.setName(from.getName().compareTo(MapleItemInformationProvider.getInstance().getName(from.getItemId())) != 0 ? from.getName() : MapleItemInformationProvider.getInstance().getName(id));\n-                                        evolved.setCloseness(from.getCloseness());\n-                                        evolved.setFullness(from.getFullness());\n-                                        evolved.setLevel(from.getLevel());\n-                                        evolved.setExpiration(System.currentTimeMillis() + expires);\n-                                        evolved.saveToDb();\n-                                }\n-\n-                                //MapleInventoryManipulator.addById(c, id, (short) 1, null, petId, expires == -1 ? -1 : System.currentTimeMillis() + expires);\n-                        }\n-                    \n-\t\t\tMapleItemInformationProvider ii = MapleItemInformationProvider.getInstance();\n-\n-\t\t\tif (ItemConstants.getInventoryType(id).equals(MapleInventoryType.EQUIP)) {\n-\t\t\t\titem = ii.getEquipById(id);\n-                                \n-                                if(item != null) {\n-                                    Equip it = (Equip)item;\n-                                    if(ItemConstants.isAccessory(item.getItemId()) && it.getUpgradeSlots() <= 0) it.setUpgradeSlots(3);\n-                                \n-                                    if(ServerConstants.USE_ENHANCED_CRAFTING == true && c.getPlayer().getCS() == true) {\n-                                        Equip eqp = (Equip)item;\n-                                        if(!(c.getPlayer().isGM() && ServerConstants.USE_PERFECT_GM_SCROLL)) {\n-                                            eqp.setUpgradeSlots((byte)(eqp.getUpgradeSlots() + 1));\n-                                        }\n-                                        item = MapleItemInformationProvider.getInstance().scrollEquipWithId(item, 2049100, true, 2049100, c.getPlayer().isGM());\n-                                    }\n-                                }\n-\t\t\t} else {\n-\t\t\t\titem = new Item(id, (short) 0, quantity, petId);\n-\t\t\t}\n-\n-\t\t\tif(expires >= 0)\n-\t\t\t\titem.setExpiration(System.currentTimeMillis() + expires);\n-\n-\t\t\tif (!MapleInventoryManipulator.checkSpace(c, id, quantity, \"\")) {\n-\t\t\t\tc.getPlayer().dropMessage(1, \"Your inventory is full. Please remove an item from your \" + ItemConstants.getInventoryType(id).name() + \" inventory.\");\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t\tif (ItemConstants.getInventoryType(id) == MapleInventoryType.EQUIP) {\n-\t\t\t\tif (randomStats) {\n-\t\t\t\t\tMapleInventoryManipulator.addFromDrop(c, ii.randomizeStats((Equip) item), false, petId);\n-\t\t\t\t} else {\n-\t\t\t\t\tMapleInventoryManipulator.addFromDrop(c, (Equip) item, false, petId);\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tMapleInventoryManipulator.addFromDrop(c, item, false, petId);\n-\t\t\t}\n-\t\t} else {\n-\t\t\tMapleInventoryManipulator.removeById(c, ItemConstants.getInventoryType(id), id, -quantity, true, false);\n-\t\t}\n-\t\tif (showMessage) {\n-\t\t\tc.announce(MaplePacketCreator.getShowItemGain(id, quantity, true));\n-\t\t}\n-\n-\t\treturn item;\n-\t}\n-        \n-        public void gainFame(int delta) {\n-                getPlayer().gainFame(delta);\n+    public void removeAll(int id, MapleClient cl) {\n+        MapleInventoryType invType = ItemConstants.getInventoryType(id);\n+        int possessed = cl.getPlayer().getInventory(invType).countById(id);\n+        if (possessed > 0) {\n+            MapleInventoryManipulator.removeById(cl, ItemConstants.getInventoryType(id), id, possessed, true, false);\n+            cl.announce(MaplePacketCreator.getShowItemGain(id, (short) -possessed, true));\n         }\n \n-\tpublic void changeMusic(String songName) {\n-\t\tgetPlayer().getMap().broadcastMessage(MaplePacketCreator.musicChange(songName));\n-\t}\n-\n-\tpublic void playerMessage(int type, String message) {\n-\t\tc.announce(MaplePacketCreator.serverNotice(type, message));\n-\t}\n-\n-\tpublic void message(String message) {\n-\t\tgetPlayer().message(message);\n-\t}\n-\n-\tpublic void mapMessage(int type, String message) {\n-\t\tgetPlayer().getMap().broadcastMessage(MaplePacketCreator.serverNotice(type, message));\n-\t}\n-\n-\tpublic void mapEffect(String path) {\n-\t\tc.announce(MaplePacketCreator.mapEffect(path));\n-\t}\n-\n-\tpublic void mapSound(String path) {\n-\t\tc.announce(MaplePacketCreator.mapSound(path));\n-\t}\n-\n-\tpublic void displayAranIntro() {\n-\t\tString intro = \"\";\n-\t\tswitch (c.getPlayer().getMapId()) {\n-\t\tcase 914090010:\n-\t\t\tintro = \"Effect/Direction1.img/aranTutorial/Scene0\";\n-\t\t\tbreak;\n-\t\tcase 914090011:\n-\t\t\tintro = \"Effect/Direction1.img/aranTutorial/Scene1\" + (c.getPlayer().getGender() == 0 ? \"0\" : \"1\");\n-\t\t\tbreak;\n-\t\tcase 914090012:\n-\t\t\tintro = \"Effect/Direction1.img/aranTutorial/Scene2\" + (c.getPlayer().getGender() == 0 ? \"0\" : \"1\");\n-\t\t\tbreak;\n-\t\tcase 914090013:\n-\t\t\tintro = \"Effect/Direction1.img/aranTutorial/Scene3\";\n-\t\t\tbreak;\n-\t\tcase 914090100:\n-\t\t\tintro = \"Effect/Direction1.img/aranTutorial/HandedPoleArm\" + (c.getPlayer().getGender() == 0 ? \"0\" : \"1\");\n-\t\t\tbreak;\n-\t\tcase 914090200:\n-\t\t\tintro = \"Effect/Direction1.img/aranTutorial/Maha\";\n-\t\t\tbreak;\n-\t\t}\n-\t\tshowIntro(intro);\n-\t}\n-\n-\n-\n-\tpublic void showIntro(String path) {\n-\t\tc.announce(MaplePacketCreator.showIntro(path));\n-\t}\n-\n-\tpublic void showInfo(String path) {\n-\t\tc.announce(MaplePacketCreator.showInfo(path));\n-\t\tc.announce(MaplePacketCreator.enableActions());\n-\t}\n-\n-\tpublic void guildMessage(int type, String message) {\n-\t\tif (getGuild() != null) {\n-\t\t\tgetGuild().guildMessage(MaplePacketCreator.serverNotice(type, message));\n-\t\t}\n-\t}\n-\n-\tpublic MapleGuild getGuild() {\n-\t\ttry {\n-\t\t\treturn Server.getInstance().getGuild(getPlayer().getGuildId(), getPlayer().getWorld(), null);\n-\t\t} catch (Exception e) {\n-                        e.printStackTrace();\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tpublic MapleParty getParty() {\n-\t\treturn getPlayer().getParty();\n-\t}\n-        \n-        public boolean isLeader() {\n-                return isPartyLeader();\n-        }\n-        \n-        public boolean isGuildLeader() {\n-                return getPlayer().isGuildLeader();\n+        if (invType == MapleInventoryType.EQUIP) {\n+            if (cl.getPlayer().getInventory(MapleInventoryType.EQUIPPED).countById(id) > 0) {\n+                MapleInventoryManipulator.removeById(cl, MapleInventoryType.EQUIPPED, id, 1, true, false);\n+                cl.announce(MaplePacketCreator.getShowItemGain(id, (short) -1, true));\n+            }\n         }\n+    }\n \n-        public boolean isPartyLeader() {\n-\t\tif(getParty() == null)\n-\t\t\treturn false;\n-\t\t\n-                return getParty().getLeaderId() == getPlayer().getId();\n-\t}\n-        \n-        public boolean isEventLeader() {\n-\t\treturn getEventInstance() != null && getPlayer().getId() == getEventInstance().getLeaderId();\n-\t}\n-        \n-        public void givePartyItems(int id, short quantity, List<MapleCharacter> party) {\n-\t\tfor (MapleCharacter chr : party) {\n-\t\t\tMapleClient cl = chr.getClient();\n-\t\t\tif (quantity >= 0) {\n-\t\t\t\tMapleInventoryManipulator.addById(cl, id, quantity);\n-\t\t\t} else {\n-\t\t\t\tMapleInventoryManipulator.removeById(cl, ItemConstants.getInventoryType(id), id, -quantity, true, false);\n-\t\t\t}\n-\t\t\tcl.announce(MaplePacketCreator.getShowItemGain(id, quantity, true));\n-\t\t}\n-\t}\n-\n-\tpublic void removeHPQItems() {\n-\t\tint[] items = {4001095, 4001096, 4001097, 4001098, 4001099, 4001100, 4001101};\n-\t\tfor (int i = 0; i < items.length; i ++) {\n-\t\t\tremovePartyItems(items[i]);\n-\t\t}\n-\t}\n-\n-\tpublic void removePartyItems(int id) {\n-\t\tif (getParty() == null) {\n-\t\t\tremoveAll(id);\n-\t\t\treturn;\n-\t\t}\n-\t\tfor (MaplePartyCharacter chr : getParty().getMembers()) {\n-\t\t\tif (chr != null && chr.isOnline() && chr.getPlayer().getClient() != null){\n-\t\t\t\tremoveAll(id, chr.getPlayer().getClient());\n-\t\t\t}\n-\t\t}\n-\t}\n-        \n-        public void giveCharacterExp(int amount, MapleCharacter chr) {\n-                chr.gainExp((amount * chr.getExpRate()), true, true);\n-        }\n+    public int getMapId() {\n+        return c.getPlayer().getMap().getId();\n+    }\n+\n+    public int getPlayerCount(int mapid) {\n+        return c.getChannelServer().getMapFactory().getMap(mapid).getCharacters().size();\n+    }\n \n-\tpublic void givePartyExp(int amount, List<MapleCharacter> party) {\n-\t\tfor (MapleCharacter chr : party) {\n-\t\t\tgiveCharacterExp(amount, chr);\n-\t\t}\n-\t}\n-        \n-\tpublic void givePartyExp(String PQ) {\n-\t\tgivePartyExp(PQ, true);\n-\t}\n+    public void showInstruction(String msg, int width, int height) {\n+        c.announce(MaplePacketCreator.sendHint(msg, width, height));\n+        c.announce(MaplePacketCreator.enableActions());\n+    }\n \n+    public void disableMinimap() {\n+        c.announce(MaplePacketCreator.disableMinimap());\n+    }\n \n-\tpublic void givePartyExp(String PQ, boolean instance) {\n-\t\t//1 player  =  +0% bonus (100)\n-\t\t//2 players =  +0% bonus (100)\n-\t\t//3 players =  +0% bonus (100)\n-\t\t//4 players = +10% bonus (110)\n-\t\t//5 players = +20% bonus (120)\n-\t\t//6 players = +30% bonus (130)\n-\t\tMapleParty party = getPlayer().getParty();\n-\t\tint size = party.getMembers().size();\n-\n-\t\tif(instance) {\n-\t\t\tfor(MaplePartyCharacter member: party.getMembers()) {\n-\t\t\t\tif(member == null || !member.isOnline() || member.getPlayer().getEventInstance() == null){\n-\t\t\t\t\tsize--;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tint bonus = size < 4 ? 100 : 70 + (size * 10);\n-\t\tfor (MaplePartyCharacter member : party.getMembers()) {\n-\t\t\tif(member == null || !member.isOnline()){\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tMapleCharacter player = member.getPlayer();\n-\t\t\tif(instance && player.getEventInstance() == null){\n-\t\t\t\tcontinue; // They aren't in the instance, don't give EXP.\n-\t\t\t}\n-\t\t\tint base = PartyQuest.getExp(PQ, player.getLevel());\n-\t\t\tint exp = base * bonus / 100;\n-\t\t\tplayer.gainExp(exp, true, true);\n-\t\t\tif(ServerConstants.PQ_BONUS_EXP_RATE > 0 && System.currentTimeMillis() <= ServerConstants.EVENT_END_TIMESTAMP) {\n-\t\t\t\tplayer.gainExp((int) (exp * ServerConstants.PQ_BONUS_EXP_RATE), true, true);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void removeFromParty(int id, List<MapleCharacter> party) {\n-\t\tfor (MapleCharacter chr : party) {\n-\t\t\tMapleInventoryType type = ItemConstants.getInventoryType(id);\n-\t\t\tMapleInventory iv = chr.getInventory(type);\n-\t\t\tint possesed = iv.countById(id);\n-\t\t\tif (possesed > 0) {\n-\t\t\t\tMapleInventoryManipulator.removeById(c, ItemConstants.getInventoryType(id), id, possesed, true, false);\n-\t\t\t\tchr.announce(MaplePacketCreator.getShowItemGain(id, (short) -possesed, true));\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void removeAll(int id) {\n-\t\tremoveAll(id, c);\n-\t}\n-\n-\tpublic void removeAll(int id, MapleClient cl) {\n-\t\tMapleInventoryType invType = ItemConstants.getInventoryType(id);\n-\t\tint possessed = cl.getPlayer().getInventory(invType).countById(id);\n-\t\tif (possessed > 0) {\n-\t\t\tMapleInventoryManipulator.removeById(cl, ItemConstants.getInventoryType(id), id, possessed, true, false);\n-\t\t\tcl.announce(MaplePacketCreator.getShowItemGain(id, (short) -possessed, true));\n-\t\t}\n-\t\t\n-\t\tif(invType == MapleInventoryType.EQUIP) {\n-\t\t\tif(cl.getPlayer().getInventory(MapleInventoryType.EQUIPPED).countById(id) > 0) {\n-\t\t\t\tMapleInventoryManipulator.removeById(cl, MapleInventoryType.EQUIPPED, id, 1, true, false);\n-\t\t\t\tcl.announce(MaplePacketCreator.getShowItemGain(id, (short) -1, true));\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic int getMapId() {\n-\t\treturn c.getPlayer().getMap().getId();\n-\t}\n-\n-\tpublic int getPlayerCount(int mapid) {\n-\t\treturn c.getChannelServer().getMapFactory().getMap(mapid).getCharacters().size();\n-\t}\n-\n-\tpublic void showInstruction(String msg, int width, int height) {\n-\t\tc.announce(MaplePacketCreator.sendHint(msg, width, height));\n-\t\tc.announce(MaplePacketCreator.enableActions());\n-\t}\n-\n-\tpublic void disableMinimap() {\n-\t\tc.announce(MaplePacketCreator.disableMinimap());\n-\t}\n-\n-        public boolean isAllReactorState(final int reactorId, final int state) {\n-                return c.getPlayer().getMap().isAllReactorState(reactorId, state);\n+    public boolean isAllReactorState(final int reactorId, final int state) {\n+        return c.getPlayer().getMap().isAllReactorState(reactorId, state);\n+    }\n+\n+    public void resetMap(int mapid) {\n+        getMap(mapid).resetReactors();\n+        getMap(mapid).killAllMonsters();\n+        for (MapleMapObject i : getMap(mapid).getMapObjectsInRange(c.getPlayer().getPosition(), Double.POSITIVE_INFINITY, Arrays.asList(MapleMapObjectType.ITEM))) {\n+            getMap(mapid).removeMapObject(i);\n+            getMap(mapid).broadcastMessage(MaplePacketCreator.removeItemFromMap(i.getObjectId(), 0, c.getPlayer().getId()));\n         }\n-        \n-\tpublic void resetMap(int mapid) {\n-\t\tgetMap(mapid).resetReactors();\n-\t\tgetMap(mapid).killAllMonsters();\n-\t\tfor (MapleMapObject i : getMap(mapid).getMapObjectsInRange(c.getPlayer().getPosition(), Double.POSITIVE_INFINITY, Arrays.asList(MapleMapObjectType.ITEM))) {\n-\t\t\tgetMap(mapid).removeMapObject(i);\n-\t\t\tgetMap(mapid).broadcastMessage(MaplePacketCreator.removeItemFromMap(i.getObjectId(), 0, c.getPlayer().getId()));\n-\t\t}\n-\t}\n-\n-\tpublic void useItem(int id) {\n-\t\tMapleItemInformationProvider.getInstance().getItemEffect(id).applyTo(c.getPlayer());\n-\t\tc.announce(MaplePacketCreator.getItemMessage(id));//Useful shet :3\n-\t}\n-\n-\tpublic void cancelItem(final int id) {\n-\t\tgetPlayer().cancelEffect(MapleItemInformationProvider.getInstance().getItemEffect(id), false, -1);\n-\t}  \n-\n-\tpublic void teachSkill(int skillid, byte level, byte masterLevel, long expiration) {\n-\t    teachSkill(skillid, level, masterLevel, expiration, false);\n-    }\n-\n-\tpublic void teachSkill(int skillid, byte level, byte masterLevel, long expiration, boolean force) {\n-\t    Skill skill = SkillFactory.getSkill(skillid);\n-\t    \n-\t    if (!force && level > -1) {\n+    }\n+\n+    public void useItem(int id) {\n+        MapleItemInformationProvider.getInstance().getItemEffect(id).applyTo(c.getPlayer());\n+        c.announce(MaplePacketCreator.getItemMessage(id));//Useful shet :3\n+    }\n+\n+    public void cancelItem(final int id) {\n+        getPlayer().cancelEffect(MapleItemInformationProvider.getInstance().getItemEffect(id), false, -1);\n+    }\n+\n+    public void teachSkill(int skillid, byte level, byte masterLevel, long expiration) {\n+        teachSkill(skillid, level, masterLevel, expiration, false);\n+    }\n+\n+    public void teachSkill(int skillid, byte level, byte masterLevel, long expiration, boolean force) {\n+        Skill skill = SkillFactory.getSkill(skillid);\n+\n+        if (!force && level > -1) {\n             MapleCharacter.SkillEntry skillEntry = getPlayer().getSkills().get(skill);\n \n             if (skillEntry != null) {\n                 getPlayer().changeSkillLevel(skill, (byte) Math.max(skillEntry.skillevel, level), Math.max(skillEntry.masterlevel, masterLevel), expiration == -1 ? -1 : Math.max(skillEntry.expiration, expiration));\n                 return;\n             }\n         }\n-        \n+\n         getPlayer().changeSkillLevel(skill, level, masterLevel, expiration);\n-\t}\n-\n-\tpublic void removeEquipFromSlot(short slot) {\n-\t\tItem tempItem = c.getPlayer().getInventory(MapleInventoryType.EQUIPPED).getItem(slot);\n-\t\tMapleInventoryManipulator.removeFromSlot(c, MapleInventoryType.EQUIPPED, slot, tempItem.getQuantity(), false, false);\n-\t}\n-\n-\tpublic void gainAndEquip(int itemid, short slot) {\n-\t\tfinal Item old = c.getPlayer().getInventory(MapleInventoryType.EQUIPPED).getItem(slot);\n-\t\tif (old != null) {\n-\t\t\tMapleInventoryManipulator.removeFromSlot(c, MapleInventoryType.EQUIPPED, slot, old.getQuantity(), false, false);\n-\t\t}\n-\t\tfinal Item newItem = MapleItemInformationProvider.getInstance().getEquipById(itemid);\n-\t\tnewItem.setPosition(slot);\n-\t\tc.getPlayer().getInventory(MapleInventoryType.EQUIPPED).addItemFromDB(newItem);\n-\t\tc.announce(MaplePacketCreator.modifyInventory(false, Collections.singletonList(new ModifyInventory(0, newItem))));\n-\t}\n-        \n-        public static void spawnNpc(int npcId, Point pos, MapleMap map) {\n-                MapleNPC npc = MapleLifeFactory.getNPC(npcId);\n-                if (npc != null) {\n-                        npc.setPosition(pos);\n-                        npc.setCy(pos.y);\n-                        npc.setRx0(pos.x + 50);\n-                        npc.setRx1(pos.x - 50);\n-                        npc.setFh(map.getFootholds().findBelow(pos).getId());\n-                        map.addMapObject(npc);\n-                        map.broadcastMessage(MaplePacketCreator.spawnNPC(npc));\n-                }\n-        }\n-        \n-\tpublic void spawnMonster(int id, int x, int y) {\n-\t\tMapleMonster monster = MapleLifeFactory.getMonster(id);\n-\t\tmonster.setPosition(new Point(x, y));\n-\t\tgetPlayer().getMap().spawnMonster(monster);\n-\t}\n-        \n-\tpublic static MapleMonster getMonsterLifeFactory(int mid) {\n-\t\treturn MapleLifeFactory.getMonster(mid);\n-\t}\n-        \n-        public static MobSkill getMobSkill(int skill, int level) {\n-\t\treturn MobSkillFactory.getMobSkill(skill, level);\n-\t}\n-\n-\tpublic void spawnGuide() {\n-\t\tc.announce(MaplePacketCreator.spawnGuide(true));\n-\t}\n-\n-\tpublic void removeGuide() {\n-\t\tc.announce(MaplePacketCreator.spawnGuide(false));\n-\t}\n-\n-\tpublic void displayGuide(int num) {\n-\t\tc.announce(MaplePacketCreator.showInfo(\"UI/tutorial.img/\" + num));\n-\t}\n-\n-\tpublic void goDojoUp() {\n-\t\tc.announce(MaplePacketCreator.dojoWarpUp());\n-\t}\n-        \n-        public void resetDojoEnergy() {\n-                c.getPlayer().setDojoEnergy(0);\n+    }\n+\n+    public void removeEquipFromSlot(short slot) {\n+        Item tempItem = c.getPlayer().getInventory(MapleInventoryType.EQUIPPED).getItem(slot);\n+        MapleInventoryManipulator.removeFromSlot(c, MapleInventoryType.EQUIPPED, slot, tempItem.getQuantity(), false, false);\n+    }\n+\n+    public void gainAndEquip(int itemid, short slot) {\n+        final Item old = c.getPlayer().getInventory(MapleInventoryType.EQUIPPED).getItem(slot);\n+        if (old != null) {\n+            MapleInventoryManipulator.removeFromSlot(c, MapleInventoryType.EQUIPPED, slot, old.getQuantity(), false, false);\n         }\n-        \n-        public void resetPartyDojoEnergy() {\n-                for(MapleCharacter pchr: c.getPlayer().getPartyMembersOnSameMap()) {\n-                        pchr.setDojoEnergy(0);\n-                }\n+        final Item newItem = MapleItemInformationProvider.getInstance().getEquipById(itemid);\n+        newItem.setPosition(slot);\n+        c.getPlayer().getInventory(MapleInventoryType.EQUIPPED).addItemFromDB(newItem);\n+        c.announce(MaplePacketCreator.modifyInventory(false, Collections.singletonList(new ModifyInventory(0, newItem))));\n+    }\n+\n+    public static void spawnNpc(int npcId, Point pos, MapleMap map) {\n+        MapleNPC npc = MapleLifeFactory.getNPC(npcId);\n+        if (npc != null) {\n+            npc.setPosition(pos);\n+            npc.setCy(pos.y);\n+            npc.setRx0(pos.x + 50);\n+            npc.setRx1(pos.x - 50);\n+            npc.setFh(map.getFootholds().findBelow(pos).getId());\n+            map.addMapObject(npc);\n+            map.broadcastMessage(MaplePacketCreator.spawnNPC(npc));\n         }\n+    }\n+\n+    public void spawnMonster(int id, int x, int y) {\n+        MapleMonster monster = MapleLifeFactory.getMonster(id);\n+        monster.setPosition(new Point(x, y));\n+        getPlayer().getMap().spawnMonster(monster);\n+    }\n+\n+    public static MapleMonster getMonsterLifeFactory(int mid) {\n+        return MapleLifeFactory.getMonster(mid);\n+    }\n+\n+    public static MobSkill getMobSkill(int skill, int level) {\n+        return MobSkillFactory.getMobSkill(skill, level);\n+    }\n+\n+    public void spawnGuide() {\n+        c.announce(MaplePacketCreator.spawnGuide(true));\n+    }\n+\n+    public void removeGuide() {\n+        c.announce(MaplePacketCreator.spawnGuide(false));\n+    }\n+\n+    public void displayGuide(int num) {\n+        c.announce(MaplePacketCreator.showInfo(\"UI/tutorial.img/\" + num));\n+    }\n+\n+    public void goDojoUp() {\n+        c.announce(MaplePacketCreator.dojoWarpUp());\n+    }\n+\n+    public void resetDojoEnergy() {\n+        c.getPlayer().setDojoEnergy(0);\n+    }\n \n-\tpublic void enableActions() {\n-\t\tc.announce(MaplePacketCreator.enableActions());\n-\t}\n-\n-\tpublic void showEffect(String effect){\n-\t\tc.announce(MaplePacketCreator.showEffect(effect));\n-\t}\n-\n-\tpublic void dojoEnergy() {\n-\t\tc.announce(MaplePacketCreator.getEnergy(\"energy\", getPlayer().getDojoEnergy()));\n-\t}\n-\n-\tpublic void talkGuide(String message) {\n-\t\tc.announce(MaplePacketCreator.talkGuide(message));\n-\t}\n-\n-\tpublic void guideHint(int hint) {\n-\t\tc.announce(MaplePacketCreator.guideHint(hint));\n-\t}\n-\n-\tpublic void updateAreaInfo(Short area, String info) {\n-\t\tc.getPlayer().updateAreaInfo(area, info);\n-\t\tc.announce(MaplePacketCreator.enableActions());//idk, nexon does the same :P\n-\t}\n-\n-\tpublic boolean containsAreaInfo(short area, String info) {\n-\t\treturn c.getPlayer().containsAreaInfo(area, info);\n-\t}\n-\n-\tpublic void earnTitle(String msg) {\n-\t\tc.announce(MaplePacketCreator.earnTitleMessage(msg));\n-\t}\n-\n-\tpublic void showInfoText(String msg) {\n-\t\tc.announce(MaplePacketCreator.showInfoText(msg));\n-\t}\n-\n-\tpublic void openUI(byte ui) {\n-\t\tc.announce(MaplePacketCreator.openUI(ui));\n-\t}\n-\n-\tpublic void lockUI() {\n-\t\tc.announce(MaplePacketCreator.disableUI(true));\n-\t\tc.announce(MaplePacketCreator.lockUI(true));\n-\t}\n-\n-\tpublic void unlockUI() {\n-\t\tc.announce(MaplePacketCreator.disableUI(false));\n-\t\tc.announce(MaplePacketCreator.lockUI(false));\n-\t}\n-\n-\tpublic void playSound(String sound) {\n-\t\tgetPlayer().getMap().broadcastMessage(MaplePacketCreator.environmentChange(sound, 4));\n-\t}\n-\n-\tpublic void environmentChange(String env, int mode) {\n-\t\tgetPlayer().getMap().broadcastMessage(MaplePacketCreator.environmentChange(env, mode));\n-\t}\n-        \n-        public String numberWithCommas(int number) {\n-                return GameConstants.numberWithCommas(number);\n+    public void resetPartyDojoEnergy() {\n+        for (MapleCharacter pchr : c.getPlayer().getPartyMembersOnSameMap()) {\n+            pchr.setDojoEnergy(0);\n         }\n+    }\n+\n+    public void enableActions() {\n+        c.announce(MaplePacketCreator.enableActions());\n+    }\n \n-\tpublic Pyramid getPyramid() {\n-\t\treturn (Pyramid) getPlayer().getPartyQuest();\n-\t}\n-\n-\tpublic void createExpedition(MapleExpeditionType type) {\n-\t\tMapleExpedition exped = new MapleExpedition(getPlayer(), type);\n-\t\tgetPlayer().getClient().getChannelServer().getExpeditions().add(exped);\n-\t}\n-\n-\tpublic void endExpedition(MapleExpedition exped) {\n-\t\texped.dispose(true);\n-\t\tgetPlayer().getClient().getChannelServer().getExpeditions().remove(exped);\n-\t}\n-\n-\tpublic MapleExpedition getExpedition(MapleExpeditionType type) {\n-\t\tfor (MapleExpedition exped : getPlayer().getClient().getChannelServer().getExpeditions()) {\n-\t\t\tif (exped.getType().equals(type)) {\n-\t\t\t\treturn exped;\n-\t\t\t}\n-\t\t}\n-\t\treturn null;\n-\t}\n-        \n-        public long getJailTimeLeft() {\n-                return getPlayer().getJailExpirationTimeLeft();\n+    public void showEffect(String effect) {\n+        c.announce(MaplePacketCreator.showEffect(effect));\n+    }\n+\n+    public void dojoEnergy() {\n+        c.announce(MaplePacketCreator.getEnergy(\"energy\", getPlayer().getDojoEnergy()));\n+    }\n+\n+    public void talkGuide(String message) {\n+        c.announce(MaplePacketCreator.talkGuide(message));\n+    }\n+\n+    public void guideHint(int hint) {\n+        c.announce(MaplePacketCreator.guideHint(hint));\n+    }\n+\n+    public void updateAreaInfo(Short area, String info) {\n+        c.getPlayer().updateAreaInfo(area, info);\n+        c.announce(MaplePacketCreator.enableActions());//idk, nexon does the same :P\n+    }\n+\n+    public boolean containsAreaInfo(short area, String info) {\n+        return c.getPlayer().containsAreaInfo(area, info);\n+    }\n+\n+    public void earnTitle(String msg) {\n+        c.announce(MaplePacketCreator.earnTitleMessage(msg));\n+    }\n+\n+    public void showInfoText(String msg) {\n+        c.announce(MaplePacketCreator.showInfoText(msg));\n+    }\n+\n+    public void openUI(byte ui) {\n+        c.announce(MaplePacketCreator.openUI(ui));\n+    }\n+\n+    public void lockUI() {\n+        c.announce(MaplePacketCreator.disableUI(true));\n+        c.announce(MaplePacketCreator.lockUI(true));\n+    }\n+\n+    public void unlockUI() {\n+        c.announce(MaplePacketCreator.disableUI(false));\n+        c.announce(MaplePacketCreator.lockUI(false));\n+    }\n+\n+    public void playSound(String sound) {\n+        getPlayer().getMap().broadcastMessage(MaplePacketCreator.environmentChange(sound, 4));\n+    }\n+\n+    public void environmentChange(String env, int mode) {\n+        getPlayer().getMap().broadcastMessage(MaplePacketCreator.environmentChange(env, mode));\n+    }\n+\n+    public String numberWithCommas(int number) {\n+        return GameConstants.numberWithCommas(number);\n+    }\n+\n+    public Pyramid getPyramid() {\n+        return (Pyramid) getPlayer().getPartyQuest();\n+    }\n+\n+    public void createExpedition(MapleExpeditionType type) {\n+        MapleExpedition exped = new MapleExpedition(getPlayer(), type);\n+        getPlayer().getClient().getChannelServer().getExpeditions().add(exped);\n+    }\n+\n+    public void endExpedition(MapleExpedition exped) {\n+        exped.dispose(true);\n+        getPlayer().getClient().getChannelServer().getExpeditions().remove(exped);\n+    }\n+\n+    public MapleExpedition getExpedition(MapleExpeditionType type) {\n+        for (MapleExpedition exped : getPlayer().getClient().getChannelServer().getExpeditions()) {\n+            if (exped.getType().equals(type)) {\n+                return exped;\n+            }\n         }\n-        \n-        public List<MaplePet> getDriedPets() {\n-                List<MaplePet> list = new LinkedList<>();\n-            \n-                long curTime = System.currentTimeMillis();\n-                for(Item it : getPlayer().getInventory(MapleInventoryType.CASH).list()) {\n-                        if(ItemConstants.isPet(it.getItemId()) && it.getExpiration() < curTime) {\n-                                MaplePet pet = it.getPet();\n-                                if (pet != null) {\n-                                        list.add(pet);\n-                                }\n-                        }\n+        return null;\n+    }\n+\n+    public long getJailTimeLeft() {\n+        return getPlayer().getJailExpirationTimeLeft();\n+    }\n+\n+    public List<MaplePet> getDriedPets() {\n+        List<MaplePet> list = new LinkedList<>();\n+\n+        long curTime = System.currentTimeMillis();\n+        for (Item it : getPlayer().getInventory(MapleInventoryType.CASH).list()) {\n+            if (ItemConstants.isPet(it.getItemId()) && it.getExpiration() < curTime) {\n+                MaplePet pet = it.getPet();\n+                if (pet != null) {\n+                    list.add(pet);\n                 }\n-                \n-                return list;\n-        }\n-        \n-        public boolean startDungeonInstance(int dungeonid) {\n-                return c.getChannelServer().addMiniDungeon(dungeonid);\n+            }\n         }\n-        \n-        public boolean canGetFirstJob(int jobType) {\n-                if (ServerConstants.USE_AUTOASSIGN_STARTERS_AP) {\n-                        return true;\n-                }\n-                \n-                MapleCharacter chr = this.getPlayer();\n-                \n-                switch(jobType) {\n-                    case 1:\n-                        return chr.getStr() >= 35;\n-                        \n-                    case 2:\n-                        return chr.getInt() >= 20;\n-                        \n-                    case 3:\n-                    case 4:\n-                        return chr.getDex() >= 25;\n-                        \n-                    case 5:\n-                        return chr.getDex() >= 20;\n-                        \n-                    default:\n-                        return true;\n-                }\n+\n+        return list;\n+    }\n+\n+    public boolean startDungeonInstance(int dungeonid) {\n+        return c.getChannelServer().addMiniDungeon(dungeonid);\n+    }\n+\n+    public boolean canGetFirstJob(int jobType) {\n+        if (ServerConstants.USE_AUTOASSIGN_STARTERS_AP) {\n+            return true;\n         }\n-        \n-        public static String getFirstJobStatRequirement(int jobType) {\n-                switch(jobType) {\n-                    case 1:\n-                        return \"STR \" + 35;\n-                        \n-                    case 2:\n-                        return \"INT \" + 20;\n-                        \n-                    case 3:\n-                    case 4:\n-                        return \"DEX \" + 25;\n-                        \n-                    case 5:\n-                        return \"DEX \" + 20;\n-                }\n-                \n-                return null;\n+\n+        MapleCharacter chr = this.getPlayer();\n+\n+        switch (jobType) {\n+            case 1:\n+                return chr.getStr() >= 35;\n+\n+            case 2:\n+                return chr.getInt() >= 20;\n+\n+            case 3:\n+            case 4:\n+                return chr.getDex() >= 25;\n+\n+            case 5:\n+                return chr.getDex() >= 20;\n+\n+            default:\n+                return true;\n         }\n-        \n-        public void npcTalk(int npcid, String message) {\n-                c.announce(MaplePacketCreator.getNPCTalk(npcid, (byte) 0, message, \"00 00\", (byte) 0));\n+    }\n+\n+    public static String getFirstJobStatRequirement(int jobType) {\n+        switch (jobType) {\n+            case 1:\n+                return \"STR \" + 35;\n+\n+            case 2:\n+                return \"INT \" + 20;\n+\n+            case 3:\n+            case 4:\n+                return \"DEX \" + 25;\n+\n+            case 5:\n+                return \"DEX \" + 20;\n         }\n \n+        return null;\n+    }\n+\n+    public void npcTalk(int npcid, String message) {\n+        c.announce(MaplePacketCreator.getNPCTalk(npcid, (byte) 0, message, \"00 00\", (byte) 0));\n+    }\n+\n     public long getCurrentTime() {\n-\t    return System.currentTimeMillis();\n-    }    \n+        return System.currentTimeMillis();\n+    }\n }"}, {"sha": "2d7d16d9055eea8230a05b08567622a04697fb3a", "filename": "src/scripting/event/EventScriptManager.java", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/scripting/event/EventScriptManager.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/scripting/event/EventScriptManager.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/scripting/event/EventScriptManager.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -1,24 +1,24 @@\n /*\n-\tThis file is part of the OdinMS Maple Story Server\n-    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n-\t\t       Matthias Butz <matze@odinms.de>\n-\t\t       Jan Christian Meyer <vimes@odinms.de>\n-\n-    This program is free software: you can redistribute it and/or modify\n-    it under the terms of the GNU Affero General Public License as\n-    published by the Free Software Foundation version 3 as published by\n-    the Free Software Foundation. You may not use, modify or distribute\n-    this program under any other version of the GNU Affero General Public\n-    License.\n-\n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU Affero General Public License for more details.\n-\n-    You should have received a copy of the GNU Affero General Public License\n-    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-*/\n+ This file is part of the OdinMS Maple Story Server\n+ Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n+ Matthias Butz <matze@odinms.de>\n+ Jan Christian Meyer <vimes@odinms.de>\n+\n+ This program is free software: you can redistribute it and/or modify\n+ it under the terms of the GNU Affero General Public License as\n+ published by the Free Software Foundation version 3 as published by\n+ the Free Software Foundation. You may not use, modify or distribute\n+ this program under any other version of the GNU Affero General Public\n+ License.\n+\n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU Affero General Public License for more details.\n+\n+ You should have received a copy of the GNU Affero General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n package scripting.event;\n \n import java.util.LinkedHashMap;\n@@ -38,8 +38,9 @@\n  * @author Matze\n  */\n public class EventScriptManager extends AbstractScriptManager {\n-    \n+\n     private class EventEntry {\n+\n         public EventEntry(Invocable iv, EventManager em) {\n             this.iv = iv;\n             this.em = em;\n@@ -78,27 +79,29 @@ public void init() {\n             }\n         }\n     }\n-    \n+\n     private void reloadScripts() {\n-        if (events.isEmpty()) return;\n-        \n+        if (events.isEmpty()) {\n+            return;\n+        }\n+\n         Channel cserv = events.values().iterator().next().em.getChannelServer();\n         for (Entry<String, EventEntry> entry : events.entrySet()) {\n             String script = entry.getKey();\n             Invocable iv = getInvocable(\"event/\" + script + \".js\", null);\n             events.put(script, new EventEntry(iv, new EventManager(cserv, iv, script)));\n         }\n     }\n-    \n+\n     public void reload() {\n-    \tcancel();\n+        cancel();\n         reloadScripts();\n-    \tinit();\n+        init();\n     }\n \n     public void cancel() {\n         for (EventEntry entry : events.values()) {\n             entry.em.cancel();\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "a9b1f4b4217ee502fd3314533720ee2929b3a66f", "filename": "src/scripting/event/worker/EventScriptScheduler.java", "status": "modified", "additions": 54, "deletions": 51, "changes": 105, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/scripting/event/worker/EventScriptScheduler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/scripting/event/worker/EventScriptScheduler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/scripting/event/worker/EventScriptScheduler.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -1,22 +1,22 @@\n /*\n-    This file is part of the HeavenMS MapleStory Server\n-    Copyleft (L) 2016 - 2018 RonanLana\n-\n-    This program is free software: you can redistribute it and/or modify\n-    it under the terms of the GNU Affero General Public License as\n-    published by the Free Software Foundation version 3 as published by\n-    the Free Software Foundation. You may not use, modify or distribute\n-    this program under any other version of the GNU Affero General Public\n-    License.\n-\n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU Affero General Public License for more details.\n-\n-    You should have received a copy of the GNU Affero General Public License\n-    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-*/\n+ This file is part of the HeavenMS MapleStory Server\n+ Copyleft (L) 2016 - 2018 RonanLana\n+\n+ This program is free software: you can redistribute it and/or modify\n+ it under the terms of the GNU Affero General Public License as\n+ published by the Free Software Foundation version 3 as published by\n+ the Free Software Foundation. You may not use, modify or distribute\n+ this program under any other version of the GNU Affero General Public\n+ License.\n+\n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU Affero General Public License for more details.\n+\n+ You should have received a copy of the GNU Affero General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n package scripting.event.worker;\n \n import constants.ServerConstants;\n@@ -39,81 +39,84 @@\n  * @author Ronan\n  */\n public class EventScriptScheduler {\n+\n     private boolean disposed = false;\n     private int idleProcs = 0;\n     private Map<Runnable, Long> registeredEntries = new HashMap<>();\n-    \n+\n     private ScheduledFuture<?> schedulerTask = null;\n     private MonitoredReentrantLock schedulerLock;\n     private Runnable monitorTask = new Runnable() {\n-                                        @Override\n-                                        public void run() {\n-                                            runBaseSchedule();\n-                                        }\n-                                    };\n-    \n+        @Override\n+        public void run() {\n+            runBaseSchedule();\n+        }\n+    };\n+\n     public EventScriptScheduler() {\n         schedulerLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.EM_SCHDL, true);\n     }\n-    \n+\n     private void runBaseSchedule() {\n         List<Runnable> toRemove;\n         Map<Runnable, Long> registeredEntriesCopy;\n-        \n+\n         schedulerLock.lock();\n         try {\n-            if(registeredEntries.isEmpty()) {\n+            if (registeredEntries.isEmpty()) {\n                 idleProcs++;\n-                \n-                if(idleProcs >= ServerConstants.MOB_STATUS_MONITOR_LIFE) {\n-                    if(schedulerTask != null) {\n+\n+                if (idleProcs >= ServerConstants.MOB_STATUS_MONITOR_LIFE) {\n+                    if (schedulerTask != null) {\n                         schedulerTask.cancel(false);\n                         schedulerTask = null;\n                     }\n                 }\n-                \n+\n                 return;\n             }\n-            \n+\n             idleProcs = 0;\n             registeredEntriesCopy = new HashMap<>(registeredEntries);\n         } finally {\n             schedulerLock.unlock();\n         }\n-        \n+\n         long timeNow = Server.getInstance().getCurrentTime();\n         toRemove = new LinkedList<>();\n-        for(Entry<Runnable, Long> rmd : registeredEntriesCopy.entrySet()) {\n-            if(rmd.getValue() < timeNow) {\n+        for (Entry<Runnable, Long> rmd : registeredEntriesCopy.entrySet()) {\n+            if (rmd.getValue() < timeNow) {\n                 Runnable r = rmd.getKey();\n-                \n+\n                 r.run();  // runs the scheduled action\n                 toRemove.add(r);\n             }\n         }\n-        \n-        if(!toRemove.isEmpty()) {\n+\n+        if (!toRemove.isEmpty()) {\n             schedulerLock.lock();\n             try {\n-                for(Runnable r : toRemove) {\n+                for (Runnable r : toRemove) {\n                     registeredEntries.remove(r);\n                 }\n             } finally {\n                 schedulerLock.unlock();\n             }\n         }\n     }\n-    \n+\n     public void registerEntry(final Runnable scheduledAction, final long duration) {\n-        \n+\n         ThreadManager.getInstance().newTask(new Runnable() {\n             @Override\n             public void run() {\n                 schedulerLock.lock();\n                 try {\n                     idleProcs = 0;\n-                    if(schedulerTask == null) {\n-                        if(disposed) return;\n+                    if (schedulerTask == null) {\n+                        if (disposed) {\n+                            return;\n+                        }\n \n                         schedulerTask = TimerManager.getInstance().register(monitorTask, ServerConstants.MOB_STATUS_MONITOR_PROC, ServerConstants.MOB_STATUS_MONITOR_PROC);\n                     }\n@@ -125,9 +128,9 @@ public void run() {\n             }\n         });\n     }\n-    \n+\n     public void cancelEntry(final Runnable scheduledAction) {\n-        \n+\n         ThreadManager.getInstance().newTask(new Runnable() {\n             @Override\n             public void run() {\n@@ -140,15 +143,15 @@ public void run() {\n             }\n         });\n     }\n-    \n+\n     public void dispose() {\n-        \n+\n         ThreadManager.getInstance().newTask(new Runnable() {\n             @Override\n             public void run() {\n                 schedulerLock.lock();\n                 try {\n-                    if(schedulerTask != null) {\n+                    if (schedulerTask != null) {\n                         schedulerTask.cancel(false);\n                         schedulerTask = null;\n                     }\n@@ -163,7 +166,7 @@ public void run() {\n             }\n         });\n     }\n-    \n+\n     private void disposeLocks() {\n         LockCollector.getInstance().registerDisposeAction(new Runnable() {\n             @Override\n@@ -172,7 +175,7 @@ public void run() {\n             }\n         });\n     }\n-    \n+\n     private void emptyLocks() {\n         schedulerLock = schedulerLock.dispose();\n     }"}, {"sha": "206a7105bc51dde74f631e46f2b97ee3a0f2a13c", "filename": "src/scripting/item/ItemScriptMethods.java", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/scripting/item/ItemScriptMethods.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/scripting/item/ItemScriptMethods.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/scripting/item/ItemScriptMethods.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -0,0 +1,35 @@\n+/*\n+\tThis file is part of the OdinMS Maple Story Server\n+    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n+\t\t       Matthias Butz <matze@odinms.de>\n+\t\t       Jan Christian Meyer <vimes@odinms.de>\n+\n+    This program is free software: you can redistribute it and/or modify\n+    it under the terms of the GNU Affero General Public License as\n+    published by the Free Software Foundation version 3 as published by\n+    the Free Software Foundation. You may not use, modify or distribute\n+    this program under any other version of the GNU Affero General Public\n+    License.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU Affero General Public License for more details.\n+\n+    You should have received a copy of the GNU Affero General Public License\n+    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+*/\n+package scripting.item;\n+\n+import client.MapleClient;\n+import scripting.AbstractPlayerInteraction;\n+\n+/**\n+ *\n+ * @author kevintjuh93\n+ */\n+public class ItemScriptMethods extends AbstractPlayerInteraction {\n+    public ItemScriptMethods(MapleClient c) {\n+    \tsuper(c);\n+    }\n+}"}, {"sha": "c2353f3e45b5dc1cbcb20d5717cdc4961ddde492", "filename": "src/scripting/npc/NPCConversationManager.java", "status": "modified", "additions": 905, "deletions": 519, "changes": 1424, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/scripting/npc/NPCConversationManager.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/scripting/npc/NPCConversationManager.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/scripting/npc/NPCConversationManager.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -1,23 +1,23 @@\n /*\n-This file is part of the OdinMS Maple Story Server\n-Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n-Matthias Butz <matze@odinms.de>\n-Jan Christian Meyer <vimes@odinms.de>\n-\n-This program is free software: you can redistribute it and/or modify\n-it under the terms of the GNU Affero General Public License as\n-published by the Free Software Foundation version 3 as published by\n-the Free Software Foundation. You may not use, modify or distribute\n-this program under any other version of the GNU Affero General Public\n-License.\n-\n-This program is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU Affero General Public License for more details.\n-\n-You should have received a copy of the GNU Affero General Public License\n-along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ This file is part of the OdinMS Maple Story Server\n+ Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n+ Matthias Butz <matze@odinms.de>\n+ Jan Christian Meyer <vimes@odinms.de>\n+\n+ This program is free software: you can redistribute it and/or modify\n+ it under the terms of the GNU Affero General Public License as\n+ published by the Free Software Foundation version 3 as published by\n+ the Free Software Foundation. You may not use, modify or distribute\n+ this program under any other version of the GNU Affero General Public\n+ License.\n+\n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU Affero General Public License for more details.\n+\n+ You should have received a copy of the GNU Affero General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>.\n  */\n package scripting.npc;\n \n@@ -58,538 +58,924 @@\n import client.inventory.ItemFactory;\n import client.inventory.MaplePet;\n import constants.ItemConstants;\n+import constants.LinguaConstants;\n import java.awt.Point;\n import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import net.server.channel.Channel;\n+import scripting.event.EventInstanceManager;\n import server.MapleSkillbookInformationProvider;\n import server.MapleSkillbookInformationProvider.SkillBookEntry;\n+import server.TimerManager;\n import server.maps.MapleMapObject;\n import server.maps.MapleMapObjectType;\n+import server.partyquest.MonsterCarnival;\n+import tools.FilePrinter;\n+import tools.packets.Wedding;\n \n /**\n  *\n  * @author Matze\n  */\n public class NPCConversationManager extends AbstractPlayerInteraction {\n-\tprivate int npc;\n-        private int npcOid;\n-\tprivate String scriptName;\n-\tprivate String getText;\n-        private boolean itemScript;\n-        \n-        public NPCConversationManager(MapleClient c, int npc, String scriptName) {\n-               this(c, npc, -1, scriptName, false);\n-        }\n-        \n-\tpublic NPCConversationManager(MapleClient c, int npc, int oid, String scriptName, boolean itemScript) {\n-\t\tsuper(c);\n-\t\tthis.npc = npc;\n-                this.npcOid = oid;\n-\t\tthis.scriptName = scriptName;\n-                this.itemScript = itemScript;\n-\t}\n-\n-\tpublic int getNpc() {\n-\t\treturn npc;\n-\t}\n-        \n-        public int getNpcObjectId() {\n-\t\treturn npcOid;\n-\t}\n-\n-\tpublic String getScriptName() {\n-\t\treturn scriptName;\n-\t}\n-        \n-        public boolean isItemScript() {\n-                return itemScript;\n-        }\n-        \n-        public void resetItemScript() {\n-                this.itemScript = false;\n-        }\n-\n-\tpublic void dispose() {\n-\t\tNPCScriptManager.getInstance().dispose(this);\n-                getClient().announce(MaplePacketCreator.enableActions());\n-\t}\n-\n-\tpublic void sendNext(String text) {\n-\t\tgetClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 0, text, \"00 01\", (byte) 0));\n-\t}\n-\n-\tpublic void sendPrev(String text) {\n-\t\tgetClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 0, text, \"01 00\", (byte) 0));\n-\t}\n-\n-\tpublic void sendNextPrev(String text) {\n-\t\tgetClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 0, text, \"01 01\", (byte) 0));\n-\t}\n-\n-\tpublic void sendOk(String text) {\n-\t\tgetClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 0, text, \"00 00\", (byte) 0));\n-\t}\n-\n-\tpublic void sendYesNo(String text) {\n-\t\tgetClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 1, text, \"\", (byte) 0));\n-\t}\n-\n-\tpublic void sendAcceptDecline(String text) {\n-\t\tgetClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 0x0C, text, \"\", (byte) 0));\n-\t}\n-\n-\tpublic void sendSimple(String text) {\n-\t\tgetClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 4, text, \"\", (byte) 0));\n-\t}\n-\n-\tpublic void sendNext(String text, byte speaker) {\n-\t\tgetClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 0, text, \"00 01\", speaker));\n-\t}\n-\n-\tpublic void sendPrev(String text, byte speaker) {\n-\t\tgetClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 0, text, \"01 00\", speaker));\n-\t}\n-\n-\tpublic void sendNextPrev(String text, byte speaker) {\n-\t\tgetClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 0, text, \"01 01\", speaker));\n-\t}\n-\n-\tpublic void sendOk(String text, byte speaker) {\n-\t\tgetClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 0, text, \"00 00\", speaker));\n-\t}\n-\n-\tpublic void sendYesNo(String text, byte speaker) {\n-\t\tgetClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 1, text, \"\", speaker));\n-\t}\n-\n-\tpublic void sendAcceptDecline(String text, byte speaker) {\n-\t\tgetClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 0x0C, text, \"\", speaker));\n-\t}\n-\n-\tpublic void sendSimple(String text, byte speaker) {\n-\t\tgetClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 4, text, \"\", speaker));\n-\t}\n-\n-\tpublic void sendStyle(String text, int styles[]) {\n-\t\tgetClient().announce(MaplePacketCreator.getNPCTalkStyle(npc, text, styles));\n-\t}\n-\n-\tpublic void sendGetNumber(String text, int def, int min, int max) {\n-\t\tgetClient().announce(MaplePacketCreator.getNPCTalkNum(npc, text, def, min, max));\n-\t}\n-\n-\tpublic void sendGetText(String text) {\n-\t\tgetClient().announce(MaplePacketCreator.getNPCTalkText(npc, text, \"\"));\n-\t}\n-\n-\t/*\n-\t * 0 = ariant colliseum\n-\t * 1 = Dojo\n-\t * 2 = Carnival 1\n-\t * 3 = Carnival 2\n-\t * 4 = Ghost Ship PQ?\n-\t * 5 = Pyramid PQ\n-\t * 6 = Kerning Subway\n-\t */\n-\tpublic void sendDimensionalMirror(String text) {\n-\t\tgetClient().announce(MaplePacketCreator.getDimensionalMirror(text));\n-\t}\n-\n-\tpublic void setGetText(String text) {\n-\t\tthis.getText = text;\n-\t}\n-\n-\tpublic String getText() {\n-\t\treturn this.getText;\n-\t}\n-\n-\tpublic int getJobId() {\n-\t\treturn getPlayer().getJob().getId();\n-\t}\n-\n-\tpublic MapleJob getJob(){\n-\t\treturn getPlayer().getJob();\n-\t}\n-\n-\tpublic void startQuest(short id) {\n-\t\ttry {\n-\t\t\tMapleQuest.getInstance(id).forceStart(getPlayer(), npc);\n-\t\t} catch (NullPointerException ex) {\n-                        ex.printStackTrace();\n-\t\t}\n-\t}\n-\n-\tpublic void completeQuest(short id) {\n-\t\ttry {\n-\t\t\tMapleQuest.getInstance(id).forceComplete(getPlayer(), npc);\n-\t\t} catch (NullPointerException ex) {\n-                        ex.printStackTrace();\n-\t\t}\n-\t}\n-\n-        public boolean forceStartQuest(int id) {\n-                return MapleQuest.getInstance(id).forceStart(getPlayer(), npc);\n-        }\n-\n-        public boolean forceCompleteQuest(int id) {\n-                return MapleQuest.getInstance(id).forceComplete(getPlayer(), npc);\n-        }\n-        \n-\tpublic void startQuest(int id) {\n-\t\ttry {\n-\t\t\tMapleQuest.getInstance(id).forceStart(getPlayer(), npc);\n-\t\t} catch (NullPointerException ex) {\n-                        ex.printStackTrace();\n-\t\t}\n-\t}\n-\n-\tpublic void completeQuest(int id) {\n-\t\ttry {\n-\t\t\tMapleQuest.getInstance(id).forceComplete(getPlayer(), npc);\n-\t\t} catch (NullPointerException ex) {\n-                        ex.printStackTrace();\n-\t\t}\n-\t}\n-        \n-        public void startQuest(short id, int npcId) {\n-                try {\n-                        MapleQuest.getInstance(id).forceStart(getPlayer(), npcId);\n-                } catch (NullPointerException ex) {\n-                        ex.printStackTrace();\n+\n+    private int npc;\n+    private int npcOid;\n+    private String scriptName;\n+    private String getText;\n+    private boolean itemScript;\n+    private List<MaplePartyCharacter> otherParty;\n+\n+    public NPCConversationManager(MapleClient c, int npc, String scriptName) {\n+        this(c, npc, -1, scriptName, false);\n+    }\n+\n+    public NPCConversationManager(MapleClient c, int npc, List<MaplePartyCharacter> otherParty, boolean test) {\n+        super(c);\n+        this.c = c;\n+        this.npc = npc;\n+        this.otherParty = otherParty;\n+    }\n+\n+    public NPCConversationManager(MapleClient c, int npc, int oid, String scriptName, boolean itemScript) {\n+        super(c);\n+        this.npc = npc;\n+        this.npcOid = oid;\n+        this.scriptName = scriptName;\n+        this.itemScript = itemScript;\n+    }\n+\n+    public int getNpc() {\n+        return npc;\n+    }\n+\n+    public int getNpcObjectId() {\n+        return npcOid;\n+    }\n+\n+    public String getScriptName() {\n+        return scriptName;\n+    }\n+\n+    public boolean isItemScript() {\n+        return itemScript;\n+    }\n+\n+    public void resetItemScript() {\n+        this.itemScript = false;\n+    }\n+\n+    public void dispose() {\n+        NPCScriptManager.getInstance().dispose(this);\n+        getClient().announce(MaplePacketCreator.enableActions());\n+    }\n+\n+    public void sendNext(String text) {\n+        getClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 0, text, \"00 01\", (byte) 0));\n+    }\n+\n+    public void sendPrev(String text) {\n+        getClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 0, text, \"01 00\", (byte) 0));\n+    }\n+\n+    public void sendNextPrev(String text) {\n+        getClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 0, text, \"01 01\", (byte) 0));\n+    }\n+\n+    public void sendOk(String text) {\n+        getClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 0, text, \"00 00\", (byte) 0));\n+    }\n+\n+    public void sendYesNo(String text) {\n+        getClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 1, text, \"\", (byte) 0));\n+    }\n+\n+    public void sendAcceptDecline(String text) {\n+        getClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 0x0C, text, \"\", (byte) 0));\n+    }\n+\n+    public void sendSimple(String text) {\n+        getClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 4, text, \"\", (byte) 0));\n+    }\n+\n+    public void sendNext(String text, byte speaker) {\n+        getClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 0, text, \"00 01\", speaker));\n+    }\n+\n+    public void sendPrev(String text, byte speaker) {\n+        getClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 0, text, \"01 00\", speaker));\n+    }\n+\n+    public void sendNextPrev(String text, byte speaker) {\n+        getClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 0, text, \"01 01\", speaker));\n+    }\n+\n+    public void sendOk(String text, byte speaker) {\n+        getClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 0, text, \"00 00\", speaker));\n+    }\n+\n+    public void sendYesNo(String text, byte speaker) {\n+        getClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 1, text, \"\", speaker));\n+    }\n+\n+    public void sendAcceptDecline(String text, byte speaker) {\n+        getClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 0x0C, text, \"\", speaker));\n+    }\n+\n+    public void sendSimple(String text, byte speaker) {\n+        getClient().announce(MaplePacketCreator.getNPCTalk(npc, (byte) 4, text, \"\", speaker));\n+    }\n+\n+    public void sendStyle(String text, int styles[]) {\n+        getClient().announce(MaplePacketCreator.getNPCTalkStyle(npc, text, styles));\n+    }\n+\n+    public void sendGetNumber(String text, int def, int min, int max) {\n+        getClient().announce(MaplePacketCreator.getNPCTalkNum(npc, text, def, min, max));\n+    }\n+\n+    public void sendGetText(String text) {\n+        getClient().announce(MaplePacketCreator.getNPCTalkText(npc, text, \"\"));\n+    }\n+\n+    /*\n+     * 0 = ariant colliseum\n+     * 1 = Dojo\n+     * 2 = Carnival 1\n+     * 3 = Carnival 2\n+     * 4 = Ghost Ship PQ?\n+     * 5 = Pyramid PQ\n+     * 6 = Kerning Subway\n+     */\n+    public void sendDimensionalMirror(String text) {\n+        getClient().announce(MaplePacketCreator.getDimensionalMirror(text));\n+    }\n+\n+    public void setGetText(String text) {\n+        this.getText = text;\n+    }\n+\n+    public String getText() {\n+        return this.getText;\n+    }\n+\n+    public int getJobId() {\n+        return getPlayer().getJob().getId();\n+    }\n+\n+    public MapleJob getJob() {\n+        return getPlayer().getJob();\n+    }\n+\n+    public void startQuest(short id) {\n+        try {\n+            MapleQuest.getInstance(id).forceStart(getPlayer(), npc);\n+        } catch (NullPointerException ex) {\n+            ex.printStackTrace();\n+        }\n+    }\n+\n+    public void completeQuest(short id) {\n+        try {\n+            MapleQuest.getInstance(id).forceComplete(getPlayer(), npc);\n+        } catch (NullPointerException ex) {\n+            ex.printStackTrace();\n+        }\n+    }\n+\n+    public boolean forceStartQuest(int id) {\n+        return MapleQuest.getInstance(id).forceStart(getPlayer(), npc);\n+    }\n+\n+    public boolean forceCompleteQuest(int id) {\n+        return MapleQuest.getInstance(id).forceComplete(getPlayer(), npc);\n+    }\n+\n+    public void startQuest(int id) {\n+        try {\n+            MapleQuest.getInstance(id).forceStart(getPlayer(), npc);\n+        } catch (NullPointerException ex) {\n+            ex.printStackTrace();\n+        }\n+    }\n+\n+    public void completeQuest(int id) {\n+        try {\n+            MapleQuest.getInstance(id).forceComplete(getPlayer(), npc);\n+        } catch (NullPointerException ex) {\n+            ex.printStackTrace();\n+        }\n+    }\n+\n+    public void startQuest(short id, int npcId) {\n+        try {\n+            MapleQuest.getInstance(id).forceStart(getPlayer(), npcId);\n+        } catch (NullPointerException ex) {\n+            ex.printStackTrace();\n+        }\n+    }\n+\n+    public void startQuest(int id, int npcId) {\n+        try {\n+            MapleQuest.getInstance(id).forceStart(getPlayer(), npcId);\n+        } catch (NullPointerException ex) {\n+            ex.printStackTrace();\n+        }\n+    }\n+\n+    public void completeQuest(short id, int npcId) {\n+        try {\n+            MapleQuest.getInstance(id).forceComplete(getPlayer(), npcId);\n+        } catch (NullPointerException ex) {\n+            ex.printStackTrace();\n+        }\n+    }\n+\n+    public void completeQuest(int id, int npcId) {\n+        try {\n+            MapleQuest.getInstance(id).forceComplete(getPlayer(), npcId);\n+        } catch (NullPointerException ex) {\n+            ex.printStackTrace();\n+        }\n+    }\n+\n+    public int getMeso() {\n+        return getPlayer().getMeso();\n+    }\n+\n+    public void gainMeso(int gain) {\n+        getPlayer().gainMeso(gain);\n+    }\n+\n+    public void gainExp(int gain) {\n+        getPlayer().gainExp(gain, true, true);\n+    }\n+\n+    public int getLevel() {\n+        return getPlayer().getLevel();\n+    }\n+\n+    @Override\n+    public void showEffect(String effect) {\n+        getPlayer().getMap().broadcastMessage(MaplePacketCreator.environmentChange(effect, 3));\n+    }\n+\n+    public void setHair(int hair) {\n+        getPlayer().setHair(hair);\n+        getPlayer().updateSingleStat(MapleStat.HAIR, hair);\n+        getPlayer().equipChanged();\n+    }\n+\n+    public void setFace(int face) {\n+        getPlayer().setFace(face);\n+        getPlayer().updateSingleStat(MapleStat.FACE, face);\n+        getPlayer().equipChanged();\n+    }\n+\n+    public void setSkin(int color) {\n+        getPlayer().setSkinColor(MapleSkinColor.getById(color));\n+        getPlayer().updateSingleStat(MapleStat.SKIN, color);\n+        getPlayer().equipChanged();\n+    }\n+\n+    public int itemQuantity(int itemid) {\n+        return getPlayer().getInventory(ItemConstants.getInventoryType(itemid)).countById(itemid);\n+    }\n+\n+    public void displayGuildRanks() {\n+        MapleGuild.displayGuildRanks(getClient(), npc);\n+    }\n+\n+    public boolean canSpawnPlayerNpc(int mapid) {\n+        MapleCharacter chr = getPlayer();\n+        return !ServerConstants.PLAYERNPC_AUTODEPLOY && chr.getLevel() >= chr.getMaxClassLevel() && !chr.isGM() && MaplePlayerNPC.canSpawnPlayerNpc(chr.getName(), mapid);\n+    }\n+\n+    public MaplePlayerNPC getPlayerNPCByScriptid(int scriptId) {\n+        for (MapleMapObject pnpcObj : getPlayer().getMap().getMapObjectsInRange(new Point(0, 0), Double.POSITIVE_INFINITY, Arrays.asList(MapleMapObjectType.PLAYER_NPC))) {\n+            MaplePlayerNPC pn = (MaplePlayerNPC) pnpcObj;\n+\n+            if (pn.getScriptId() == scriptId) {\n+                return pn;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public MapleParty getParty() {\n+        return getPlayer().getParty();\n+    }\n+\n+    @Override\n+    public void resetMap(int mapid) {\n+        getClient().getChannelServer().getMapFactory().getMap(mapid).resetReactors();\n+    }\n+\n+    public void gainCloseness(int closeness) {\n+        for (MaplePet pet : getPlayer().getPets()) {\n+            if (pet != null) {\n+                pet.gainClosenessFullness(getPlayer(), closeness, 0, 0);\n+            }\n+        }\n+    }\n+\n+    public String getName() {\n+        return getPlayer().getName();\n+    }\n+\n+    public int getGender() {\n+        return getPlayer().getGender();\n+    }\n+\n+    public void changeJobById(int a) {\n+        getPlayer().changeJob(MapleJob.getById(a));\n+    }\n+\n+    public void changeJob(MapleJob job) {\n+        getPlayer().changeJob(job);\n+    }\n+\n+    public MapleJob getJobName(int id) {\n+        return MapleJob.getById(id);\n+    }\n+\n+    public MapleStatEffect getItemEffect(int itemId) {\n+        return MapleItemInformationProvider.getInstance().getItemEffect(itemId);\n+    }\n+\n+    public void resetStats() {\n+        getPlayer().resetStats();\n+    }\n+\n+    public void openShopNPC(int id) {\n+        MapleShopFactory.getInstance().getShop(id).sendShop(c);\n+    }\n+\n+    public void maxMastery() {\n+        for (MapleData skill_ : MapleDataProviderFactory.getDataProvider(new File(System.getProperty(\"wzpath\") + \"/\" + \"String.wz\")).getData(\"Skill.img\").getChildren()) {\n+            try {\n+                Skill skill = SkillFactory.getSkill(Integer.parseInt(skill_.getName()));\n+                getPlayer().changeSkillLevel(skill, (byte) 0, skill.getMaxLevel(), -1);\n+            } catch (NumberFormatException nfe) {\n+                nfe.printStackTrace();\n+                break;\n+            } catch (NullPointerException npe) {\n+                npe.printStackTrace();\n+                continue;\n+            }\n+        }\n+    }\n+\n+    public void doGachapon() {\n+        int[] maps = {100000000, 101000000, 102000000, 103000000, 105040300, 800000000, 809000101, 809000201, 600000000, 120000000};\n+\n+        MapleGachaponItem item = MapleGachapon.getInstance().process(npc);\n+\n+        Item itemGained = gainItem(item.getId(), (short) (item.getId() / 10000 == 200 ? 100 : 1), true, true); // For normal potions, make it give 100.\n+\n+        sendNext(\"You have obtained a #b#t\" + item.getId() + \"##k.\");\n+\n+        String map = c.getChannelServer().getMapFactory().getMap(maps[(getNpc() != 9100117 && getNpc() != 9100109) ? (getNpc() - 9100100) : getNpc() == 9100109 ? 8 : 9]).getMapName();\n+\n+        LogHelper.logGacha(getPlayer(), item.getId(), map);\n+\n+        if (item.getTier() > 0) { //Uncommon and Rare\n+            Server.getInstance().broadcastMessage(c.getWorld(), MaplePacketCreator.gachaponMessage(itemGained, map, getPlayer()));\n+        }\n+    }\n+\n+    public void upgradeAlliance() {\n+        MapleAlliance alliance = Server.getInstance().getAlliance(c.getPlayer().getGuild().getAllianceId());\n+        alliance.increaseCapacity(1);\n+\n+        Server.getInstance().allianceMessage(alliance.getId(), MaplePacketCreator.getGuildAlliances(alliance, c.getWorld()), -1, -1);\n+        Server.getInstance().allianceMessage(alliance.getId(), MaplePacketCreator.allianceNotice(alliance.getId(), alliance.getNotice()), -1, -1);\n+    }\n+\n+    public void disbandAlliance(MapleClient c, int allianceId) {\n+        MapleAlliance.disbandAlliance(allianceId);\n+    }\n+\n+    public boolean canBeUsedAllianceName(String name) {\n+        return MapleAlliance.canBeUsedAllianceName(name);\n+    }\n+\n+    public MapleAlliance createAlliance(String name) {\n+        return MapleAlliance.createAlliance(getParty(), name);\n+    }\n+\n+    public int getAllianceCapacity() {\n+        return Server.getInstance().getAlliance(getPlayer().getGuild().getAllianceId()).getCapacity();\n+    }\n+\n+    public boolean hasMerchant() {\n+        return getPlayer().hasMerchant();\n+    }\n+\n+    public boolean hasMerchantItems() {\n+        try {\n+            if (!ItemFactory.MERCHANT.loadItems(getPlayer().getId(), false).isEmpty()) {\n+                return true;\n+            }\n+        } catch (SQLException e) {\n+            e.printStackTrace();\n+            return false;\n+        }\n+        if (getPlayer().getMerchantMeso() == 0) {\n+            return false;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    public void showFredrick() {\n+        c.announce(MaplePacketCreator.getFredrick(getPlayer()));\n+    }\n+\n+    public int partyMembersInMap() {\n+        int inMap = 0;\n+        for (MapleCharacter char2 : getPlayer().getMap().getCharacters()) {\n+            if (char2.getParty() == getPlayer().getParty()) {\n+                inMap++;\n+            }\n+        }\n+        return inMap;\n+    }\n+\n+    public MapleEvent getEvent() {\n+        return c.getChannelServer().getEvent();\n+    }\n+\n+    public void divideTeams() {\n+        if (getEvent() != null) {\n+            getPlayer().setTeam(getEvent().getLimit() % 2); //muhaha :D\n+        }\n+    }\n+\n+    public MapleCharacter getMapleCharacter(String player) {\n+        MapleCharacter target = Server.getInstance().getWorld(c.getWorld()).getChannel(c.getChannel()).getPlayerStorage().getCharacterByName(player);\n+        return target;\n+    }\n+\n+    public void logLeaf(String prize) {\n+        LogHelper.logLeaf(getPlayer(), true, prize);\n+    }\n+\n+    public boolean createPyramid(String mode, boolean party) {//lol\n+        PyramidMode mod = PyramidMode.valueOf(mode);\n+\n+        MapleParty partyz = getPlayer().getParty();\n+        MapleMapFactory mf = c.getChannelServer().getMapFactory();\n+\n+        MapleMap map = null;\n+        int mapid = 926010100;\n+        if (party) {\n+            mapid += 10000;\n+        }\n+        mapid += (mod.getMode() * 1000);\n+\n+        for (byte b = 0; b < 5; b++) {//They cannot warp to the next map before the timer ends (:\n+            map = mf.getMap(mapid + b);\n+            if (map.getCharacters().size() > 0) {\n+                continue;\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        if (map == null) {\n+            return false;\n+        }\n+\n+        if (!party) {\n+            partyz = new MapleParty(-1, new MaplePartyCharacter(getPlayer()));\n+        }\n+        Pyramid py = new Pyramid(partyz, mod, map.getId());\n+        getPlayer().setPartyQuest(py);\n+        py.warp(mapid);\n+        dispose();\n+        return true;\n+    }\n+\n+    public boolean itemExists(int itemid) {\n+        return MapleItemInformationProvider.getInstance().getName(itemid) != null;\n+    }\n+\n+    public int getCosmeticItem(int itemid) {\n+        if (itemExists(itemid)) {\n+            return itemid;\n+        }\n+\n+        int baseid;\n+        if (itemid < 30000) {\n+            baseid = (itemid / 1000) * 1000 + (itemid % 100);\n+        } else {\n+            baseid = (itemid / 10) * 10;\n+        }\n+\n+        return itemid != baseid && itemExists(baseid) ? baseid : -1;\n+    }\n+\n+    private int getEquippedItemid(int itemid) {\n+        if (itemid < 30000) {\n+            return getPlayer().getFace();\n+        } else {\n+            return getPlayer().getHair();\n+        }\n+    }\n+\n+    public boolean isCosmeticEquipped(int itemid) {\n+        return getEquippedItemid(itemid) == itemid;\n+    }\n+\n+    public boolean isUsingOldPqNpcStyle() {\n+        return ServerConstants.USE_OLD_GMS_STYLED_PQ_NPCS && this.getPlayer().getParty() != null;\n+    }\n+\n+    public Object[] getAvailableMasteryBooks() {\n+        return MapleItemInformationProvider.getInstance().usableMasteryBooks(this.getPlayer()).toArray();\n+    }\n+\n+    public Object[] getAvailableSkillBooks() {\n+        return MapleItemInformationProvider.getInstance().usableSkillBooks(this.getPlayer()).toArray();\n+    }\n+\n+    public Object[] getNamesWhoDropsItem(Integer itemId) {\n+        return MapleItemInformationProvider.getInstance().getWhoDrops(itemId).toArray();\n+    }\n+\n+    public String getSkillBookInfo(int itemid) {\n+        SkillBookEntry sbe = MapleSkillbookInformationProvider.getInstance().getSkillbookAvailability(itemid);\n+        return sbe != SkillBookEntry.UNAVAILABLE ? \"    Obtainable through #rquestline#k.\" : \"\";\n+    }\n+\n+    \n+    // By Drago/Dragohe4rt CPQ + WED\n+    \n+    public int calcAvgLvl(int map) {\n+        int num = 0;\n+        int avg = 0;\n+        for (MapleMapObject mmo\n+                : c.getChannelServer().getMapFactory().getMap(map).getAllPlayer()) {\n+            avg += ((MapleCharacter) mmo).getLevel();\n+            num++;\n+        }\n+        avg /= num;\n+        return avg;\n+    }\n+\n+    public void sendCPQMapLists() {\n+        String msg = LinguaConstants.Linguas(getPlayer()).CPQInicioEscolha;\n+        for (int i = 0; i < 6; i++) {\n+            if (fieldTaken(i)) {\n+                if (fieldLobbied(i)) {\n+                    msg += \"#b#L\" + i + \"#Map \" + (i + 1) + \" (n\ufffdvel: \"\n+                            + calcAvgLvl(980000100 + i * 100) + \" / \"\n+                            + getPlayerCount(980000100 + i * 100) + \"x\"\n+                            + getPlayerCount(980000100 + i * 100) + \")  #l\\\\r\\\\n\";\n+                } else {\n+                    continue;\n                 }\n+            } else {\n+                if (i == 0 || i == 1 || i == 2 || i == 3) {\n+                    msg += \"#b#L\" + i + \"#Map \" + (i + 1) + \" (2x2) #l\\\\r\\\\n\";\n+                } else {\n+                    msg += \"#b#L\" + i + \"#Map \" + (i + 1) + \" (3x3) #l\\\\r\\\\n\";\n+                }\n+            }\n+        }\n+        sendSimple(msg);\n+    }\n+\n+    public boolean fieldTaken(int field) {\n+        if (!c.getChannelServer().getMapFactory().getMap(980000100 + field * 100).getAllPlayer().isEmpty()) {\n+            return true;\n+        }\n+        if (!c.getChannelServer().getMapFactory().getMap(980000101 + field * 100).getAllPlayer().isEmpty()) {\n+            return true;\n+        }\n+        if (!c.getChannelServer().getMapFactory().getMap(980000102 + field * 100).getAllPlayer().isEmpty()) {\n+            return true;\n         }\n-        \n-        public void startQuest(int id, int npcId) {\n-                try {\n-                        MapleQuest.getInstance(id).forceStart(getPlayer(), npcId);\n-                } catch (NullPointerException ex) {\n-                        ex.printStackTrace();\n+        return false;\n+    }\n+\n+    public boolean fieldLobbied(int field) {\n+        if (!c.getChannelServer().getMapFactory().getMap(980000100 + field * 100).getAllPlayer().isEmpty()) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public void cpqLobby(int field) {\n+        try {\n+            final MapleMap map, mapsaida;\n+            Channel cs = c.getChannelServer();\n+            map = cs.getMapFactory().getMap(980000100 + 100 * field);\n+            mapsaida = cs.getMapFactory().getMap(980000000);\n+            for (MaplePartyCharacter mpc : c.getPlayer().getParty().getMembers()) {\n+                final MapleCharacter mc;\n+                mc = cs.getPlayerStorage().getCharacterByName(mpc.getName());\n+                if (mc != null) {\n+                    mc.changeMap(map, map.getPortal(0));\n+                    mc.getClient().getSession().write(MaplePacketCreator.serverNotice(6, LinguaConstants.Linguas(mc).CPQEntradaLobby));\n+                    TimerManager tMan = TimerManager.getInstance();\n+                    tMan.schedule(new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            mapClock(3 * 60);\n+                        }\n+                    }, 1500);\n                 }\n+                mc.timer = TimerManager.getInstance().schedule(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        mc.changeMap(mapsaida, mapsaida.getPortal(0));\n+                    }\n+                }, 3 * 60 * 1000);\n+            }\n+        } catch (Exception ex) {\n+            ex.printStackTrace();\n         }\n-        \n-        public void completeQuest(short id, int npcId) {\n-                try {\n-                        MapleQuest.getInstance(id).forceComplete(getPlayer(), npcId);\n-                } catch (NullPointerException ex) {\n-                        ex.printStackTrace();\n+    }\n+\n+    public MapleCharacter getChrById(int id) {\n+        Channel cs = c.getChannelServer();\n+        return cs.getPlayerStorage().getCharacterById(id);\n+    }\n+\n+    public void cancelarSaida() {\n+        Channel cs = c.getChannelServer();\n+        for (MaplePartyCharacter mpc : c.getPlayer().getParty().getMembers()) {\n+            MapleCharacter mc = cs.getPlayerStorage().getCharacterByName(mpc.getName());\n+            if (mc.timer != null) {\n+                mc.timer.cancel(true);\n+                mc.timer = null;\n+            }\n+        }\n+    }\n+\n+    public void startCPQ(final MapleCharacter challenger, int field) {\n+        try {\n+            cancelarSaida();\n+            if (challenger != null) {\n+                if (challenger.getParty() == null) {\n+                    throw new RuntimeException(\"N\u00e3o existe oponente!\");\n+                }\n+                for (MaplePartyCharacter mpc : challenger.getParty().getMembers()) {\n+                    MapleCharacter mc = c.getChannelServer().getPlayerStorage().getCharacterByName(mpc.getName());\n+                    if (mc != null) {\n+                        mc.changeMap(getPlayer().getMap(), getPlayer().getMap().getPortal(0));\n+                        TimerManager tMan = TimerManager.getInstance();\n+                        tMan.schedule(new Runnable() {\n+                            @Override\n+                            public void run() {\n+                                mapClock(10);\n+                            }\n+                        }, 1500);\n+                    }\n                 }\n+                for (MaplePartyCharacter mpc : getPlayer().getParty().getMembers()) {\n+                    MapleCharacter mc = c.getChannelServer().getPlayerStorage().getCharacterByName(mpc.getName());\n+                    if (mc != null) {\n+                        TimerManager tMan = TimerManager.getInstance();\n+                        tMan.schedule(new Runnable() {\n+                            @Override\n+                            public void run() {\n+                                mapClock(10);\n+                            }\n+                        }, 1500);\n+                    }\n+                }\n+            }\n+            final int mapid = c.getPlayer().getMapId() + 1;\n+            TimerManager tMan = TimerManager.getInstance();\n+            tMan.schedule(new Runnable() {\n+                @Override\n+                public void run() {\n+                    Channel cs = c.getChannelServer();\n+                    for (MaplePartyCharacter mpc : getPlayer().getParty().getMembers()) {\n+                        MapleCharacter mc = cs.getPlayerStorage().getCharacterByName(mpc.getName());\n+                        mc.setMonsterCarnival(null);\n+                    }\n+                    for (MaplePartyCharacter mpc : challenger.getParty().getMembers()) {\n+                        MapleCharacter mc = cs.getPlayerStorage().getCharacterByName(mpc.getName());\n+                        mc.setMonsterCarnival(null);\n+                    }\n+                    new MonsterCarnival(getPlayer().getParty(), challenger.getParty(), mapid, true);\n+                }\n+            }, 11000);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n         }\n-        \n-        public void completeQuest(int id, int npcId) {\n-                try {\n-                        MapleQuest.getInstance(id).forceComplete(getPlayer(), npcId);\n-                } catch (NullPointerException ex) {\n-                        ex.printStackTrace();\n+    }\n+\n+    public void startCPQ2(final MapleCharacter challenger, int field) {\n+        try {\n+            cancelarSaida();\n+            if (challenger != null) {\n+                if (challenger.getParty() == null) {\n+                    throw new RuntimeException(\"N\ufffdo existe oponente!\");\n+                }\n+                for (MaplePartyCharacter mpc : challenger.getParty().getMembers()) {\n+                    MapleCharacter mc = c.getChannelServer().getPlayerStorage().getCharacterByName(mpc.getName());\n+                    if (mc != null) {\n+                        mc.changeMap(getPlayer().getMap(), getPlayer().getMap().getPortal(0));\n+                        mapClock(10);\n+                    }\n                 }\n+            }\n+            final int mapid = c.getPlayer().getMapId() + 100;\n+            TimerManager tMan = TimerManager.getInstance();\n+            tMan.schedule(new Runnable() {\n+                @Override\n+                public void run() {\n+                    Channel cs = c.getChannelServer();\n+                    for (MaplePartyCharacter mpc : getPlayer().getParty().getMembers()) {\n+                        MapleCharacter mc = cs.getPlayerStorage().getCharacterByName(mpc.getName());\n+                        mc.setMonsterCarnival(null);\n+                    }\n+                    for (MaplePartyCharacter mpc : challenger.getParty().getMembers()) {\n+                        MapleCharacter mc = cs.getPlayerStorage().getCharacterByName(mpc.getName());\n+                        mc.setMonsterCarnival(null);\n+                    }\n+                    new MonsterCarnival(getPlayer().getParty(), challenger.getParty(), mapid, false);\n+                }\n+            }, 10000);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n         }\n-        \n-\tpublic int getMeso() {\n-\t\treturn getPlayer().getMeso();\n-\t}\n-\n-\tpublic void gainMeso(int gain) {\n-\t\tgetPlayer().gainMeso(gain);\n-\t}\n-\n-\tpublic void gainExp(int gain) {\n-\t\tgetPlayer().gainExp(gain, true, true);\n-\t}\n-\n-\tpublic int getLevel() {\n-\t\treturn getPlayer().getLevel();\n-\t}\n-\n-        @Override\n-\tpublic void showEffect(String effect) {\n-\t\tgetPlayer().getMap().broadcastMessage(MaplePacketCreator.environmentChange(effect, 3));\n-\t}\n-\n-\tpublic void setHair(int hair) {\n-\t\tgetPlayer().setHair(hair);\n-\t\tgetPlayer().updateSingleStat(MapleStat.HAIR, hair);\n-\t\tgetPlayer().equipChanged();\n-\t}\n-\n-\tpublic void setFace(int face) {\n-\t\tgetPlayer().setFace(face);\n-\t\tgetPlayer().updateSingleStat(MapleStat.FACE, face);\n-\t\tgetPlayer().equipChanged();\n-\t}\n-\n-\tpublic void setSkin(int color) {\n-\t\tgetPlayer().setSkinColor(MapleSkinColor.getById(color));\n-\t\tgetPlayer().updateSingleStat(MapleStat.SKIN, color);\n-\t\tgetPlayer().equipChanged();\n-\t}\n-\n-\tpublic int itemQuantity(int itemid) {\n-\t\treturn getPlayer().getInventory(ItemConstants.getInventoryType(itemid)).countById(itemid);\n-\t}\n-\n-\tpublic void displayGuildRanks() {\n-\t\tMapleGuild.displayGuildRanks(getClient(), npc);\n-\t}\n-        \n-        public boolean canSpawnPlayerNpc(int mapid) {\n-                MapleCharacter chr = getPlayer();\n-                return !ServerConstants.PLAYERNPC_AUTODEPLOY && chr.getLevel() >= chr.getMaxClassLevel() && !chr.isGM() && MaplePlayerNPC.canSpawnPlayerNpc(chr.getName(), mapid);\n-        }\n-        \n-        public MaplePlayerNPC getPlayerNPCByScriptid(int scriptId) {\n-                for(MapleMapObject pnpcObj : getPlayer().getMap().getMapObjectsInRange(new Point(0, 0), Double.POSITIVE_INFINITY, Arrays.asList(MapleMapObjectType.PLAYER_NPC))) {\n-                        MaplePlayerNPC pn = (MaplePlayerNPC) pnpcObj;\n-\n-                        if(pn.getScriptId() == scriptId) {\n-                                return pn;\n-                        }\n+    }\n+\n+    public void sendCPQMapLists2() {\n+        String msg = LinguaConstants.Linguas(getPlayer()).CPQInicioEscolha;\n+        for (int i = 0; i < 3; i++) {\n+            if (fieldTaken2(i)) {\n+                if (fieldLobbied2(i)) {\n+                    msg += \"#b#L\" + i + \"#Map \" + (i + 1) + \" (N\ufffdvel: \"\n+                            + calcAvgLvl(980031000 + i * 1000) + \"#l\\\\r\\\\n\";\n+                } else {\n+                    continue;\n                 }\n-                \n-                return null;\n+            } else {\n+                if (i == 0 || i == 1) {\n+                    msg += \"#b#L\" + i + \"#Map \" + (i + 1) + \" (2x2) #l\\\\r\\\\n\";\n+                } else {\n+                    msg += \"#b#L\" + i + \"#Map \" + (i + 1) + \" (3x3) #l\\\\r\\\\n\";\n+                }\n+            }\n         }\n+        sendSimple(msg);\n+    }\n \n-\t@Override\n-\tpublic MapleParty getParty() {\n-\t\treturn getPlayer().getParty();\n-\t}\n-\n-\t@Override\n-\tpublic void resetMap(int mapid) {\n-\t\tgetClient().getChannelServer().getMapFactory().getMap(mapid).resetReactors();\n-\t}\n+    public boolean fieldTaken2(int field) {\n+        if (!c.getChannelServer().getMapFactory().getMap(980031000 + field * 1000).getAllPlayer().isEmpty()) {\n+            return true;\n+        }\n+        if (!c.getChannelServer().getMapFactory().getMap(980031000 + field * 1000).getAllPlayer().isEmpty()) {\n+            return true;\n+        }\n+        if (!c.getChannelServer().getMapFactory().getMap(980031000 + field * 1000).getAllPlayer().isEmpty()) {\n+            return true;\n+        }\n+        return false;\n+    }\n \n-\tpublic void gainCloseness(int closeness) {\n-\t\tfor (MaplePet pet : getPlayer().getPets()) {\n-                        if(pet != null) {\n-                                pet.gainClosenessFullness(getPlayer(), closeness, 0, 0);\n+    public boolean fieldLobbied2(int field) {\n+        if (!c.getChannelServer().getMapFactory().getMap(980031000 + field * 1000).getAllPlayer().isEmpty()) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public void cpqLobby2(int field) {\n+        try {\n+            final MapleMap map, mapsaida;\n+            Channel cs = c.getChannelServer();\n+            mapsaida = cs.getMapFactory().getMap(980030000);\n+            map = cs.getMapFactory().getMap(980031000 + 1000 * field);\n+            for (MaplePartyCharacter mpc : c.getPlayer().getParty().getMembers()) {\n+                final MapleCharacter mc;\n+                mc = cs.getPlayerStorage().getCharacterByName(mpc.getName());\n+                if (mc != null) {\n+                    mc.changeMap(map, map.getPortal(0));\n+                    mc.getClient().getSession().write(MaplePacketCreator.serverNotice(6, LinguaConstants.Linguas(mc).CPQEntradaLobby));\n+                    TimerManager tMan = TimerManager.getInstance();\n+                    tMan.schedule(new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            mapClock(3 * 60);\n                         }\n-\t\t}\n-\t}\n-\n-\tpublic String getName() {\n-\t\treturn getPlayer().getName();\n-\t}\n-\n-\tpublic int getGender() {\n-\t\treturn getPlayer().getGender();\n-\t}\n-\n-\tpublic void changeJobById(int a) {\n-\t\tgetPlayer().changeJob(MapleJob.getById(a));\n-\t}\n-\n-\tpublic void changeJob(MapleJob job) {\n-\t\tgetPlayer().changeJob(job);\n-\t}\n-\n-\tpublic MapleJob getJobName(int id) {\n-\t\treturn MapleJob.getById(id);\n-\t}\n-\n-\tpublic MapleStatEffect getItemEffect(int itemId) {\n-\t\treturn MapleItemInformationProvider.getInstance().getItemEffect(itemId);\n-\t}\n-\n-\tpublic void resetStats() {\n-\t\tgetPlayer().resetStats();\n-\t}\n-        \n-        public void openShopNPC(int id) {\n-            MapleShopFactory.getInstance().getShop(id).sendShop(c);\n-        }\n-\n-\tpublic void maxMastery() {\n-\t\tfor (MapleData skill_ : MapleDataProviderFactory.getDataProvider(new File(System.getProperty(\"wzpath\") + \"/\" + \"String.wz\")).getData(\"Skill.img\").getChildren()) {\n-\t\t\ttry {\n-\t\t\t\tSkill skill = SkillFactory.getSkill(Integer.parseInt(skill_.getName()));\n-\t\t\t\tgetPlayer().changeSkillLevel(skill, (byte) 0, skill.getMaxLevel(), -1);\n-\t\t\t} catch (NumberFormatException nfe) {\n-                                nfe.printStackTrace();\n-\t\t\t\tbreak;\n-\t\t\t} catch (NullPointerException npe) {\n-                                npe.printStackTrace();\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void doGachapon() {\n-\t\tint[] maps = {100000000, 101000000, 102000000, 103000000, 105040300, 800000000, 809000101, 809000201, 600000000, 120000000};\n-\n-\t\tMapleGachaponItem item = MapleGachapon.getInstance().process(npc);\n-\n-\t\tItem itemGained = gainItem(item.getId(), (short) (item.getId() / 10000 == 200 ? 100 : 1), true, true); // For normal potions, make it give 100.\n-\n-\t\tsendNext(\"You have obtained a #b#t\" + item.getId() + \"##k.\");\n-\t\t\n-\t\tString map = c.getChannelServer().getMapFactory().getMap(maps[(getNpc() != 9100117 && getNpc() != 9100109) ? (getNpc() - 9100100) : getNpc() == 9100109 ? 8 : 9]).getMapName();\n-\t\t\n-\t\tLogHelper.logGacha(getPlayer(), item.getId(), map);\n-\t\t\n-\t\tif (item.getTier() > 0){ //Uncommon and Rare\n-\t\t\tServer.getInstance().broadcastMessage(c.getWorld(), MaplePacketCreator.gachaponMessage(itemGained, map, getPlayer()));\n-\t\t}\n-\t}\n-        \n-        public void upgradeAlliance() {\n-                MapleAlliance alliance = Server.getInstance().getAlliance(c.getPlayer().getGuild().getAllianceId());\n-                alliance.increaseCapacity(1);\n-                \n-                Server.getInstance().allianceMessage(alliance.getId(), MaplePacketCreator.getGuildAlliances(alliance, c.getWorld()), -1, -1);\n-                Server.getInstance().allianceMessage(alliance.getId(), MaplePacketCreator.allianceNotice(alliance.getId(), alliance.getNotice()), -1, -1);\n-        }\n-\n-\tpublic void disbandAlliance(MapleClient c, int allianceId) {\n-\t\tMapleAlliance.disbandAlliance(allianceId);\n-\t}\n-\n-\tpublic boolean canBeUsedAllianceName(String name) {\n-                return MapleAlliance.canBeUsedAllianceName(name);\n-\t}\n-        \n-        public MapleAlliance createAlliance(String name) {\n-            return MapleAlliance.createAlliance(getParty(), name);\n-        }\n-        \n-        public int getAllianceCapacity() {\n-                return Server.getInstance().getAlliance(getPlayer().getGuild().getAllianceId()).getCapacity();\n-        }\n-\n-\tpublic boolean hasMerchant() {\n-\t\treturn getPlayer().hasMerchant();\n-\t}\n-\n-\tpublic boolean hasMerchantItems() {\n-\t\ttry {\n-\t\t\tif (!ItemFactory.MERCHANT.loadItems(getPlayer().getId(), false).isEmpty()) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t} catch (SQLException e) {\n-                        e.printStackTrace();\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (getPlayer().getMerchantMeso() == 0) {\n-\t\t\treturn false;\n-\t\t} else {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\tpublic void showFredrick() {\n-\t\tc.announce(MaplePacketCreator.getFredrick(getPlayer()));\n-\t}\n-\n-\tpublic int partyMembersInMap() {\n-\t\tint inMap = 0;\n-\t\tfor (MapleCharacter char2 : getPlayer().getMap().getCharacters()) {\n-\t\t\tif (char2.getParty() == getPlayer().getParty()) {\n-\t\t\t\tinMap++;\n-\t\t\t}\n-\t\t}\n-\t\treturn inMap;\n-\t}\n-\n-\tpublic MapleEvent getEvent() {\n-\t\treturn c.getChannelServer().getEvent();\n-\t}\n-\n-\tpublic void divideTeams() {\n-\t\tif (getEvent() != null) {\n-\t\t\tgetPlayer().setTeam(getEvent().getLimit() % 2); //muhaha :D\n-\t\t}\n-\t}\n-\n-\tpublic MapleCharacter getMapleCharacter(String player) {\n-\t\tMapleCharacter target =  Server.getInstance().getWorld(c.getWorld()).getChannel(c.getChannel()).getPlayerStorage().getCharacterByName(player);\n-\t\treturn target;\n-\t}\n-\n-\tpublic void logLeaf(String prize) {\n-\t\tLogHelper.logLeaf(getPlayer(), true, prize);\n-\t}\n-\n-\tpublic boolean createPyramid(String mode, boolean party) {//lol\n-\t\tPyramidMode mod = PyramidMode.valueOf(mode);\n-\n-\t\tMapleParty partyz = getPlayer().getParty();\n-\t\tMapleMapFactory mf = c.getChannelServer().getMapFactory();\n-\n-\t\tMapleMap map = null;\n-\t\tint mapid = 926010100;\n-\t\tif (party) {\n-\t\t\tmapid += 10000;\n-\t\t}\n-\t\tmapid += (mod.getMode() * 1000);\n-\n-\t\tfor (byte b = 0; b < 5; b++) {//They cannot warp to the next map before the timer ends (:\n-\t\t\tmap = mf.getMap(mapid + b);\n-\t\t\tif (map.getCharacters().size() > 0) {\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (map == null) {\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tif (!party) {\n-\t\t\tpartyz = new MapleParty(-1, new MaplePartyCharacter(getPlayer()));\n-\t\t}\n-\t\tPyramid py = new Pyramid(partyz, mod, map.getId());\n-\t\tgetPlayer().setPartyQuest(py);\n-\t\tpy.warp(mapid);\n-\t\tdispose();\n-\t\treturn true;\n-\t}\n-        \n-        public boolean itemExists(int itemid) {\n-                return MapleItemInformationProvider.getInstance().getName(itemid) != null;\n-        }\n-        \n-        public int getCosmeticItem(int itemid) {\n-                if (itemExists(itemid)) return itemid;\n-                \n-                int baseid;\n-                if (itemid < 30000) {\n-                        baseid = (itemid / 1000) * 1000 + (itemid % 100);\n-                } else {\n-                        baseid = (itemid / 10) * 10;\n+                    }, 1500);\n                 }\n-                \n-                return itemid != baseid && itemExists(baseid) ? baseid : -1;\n+                mc.timer = TimerManager.getInstance().schedule(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        mc.changeMap(mapsaida, mapsaida.getPortal(0));\n+                    }\n+                }, 3 * 60 * 1000);\n+            }\n+        } catch (Exception ex) {\n+            ex.printStackTrace();\n         }\n-        \n-        private int getEquippedItemid(int itemid) {\n-                if (itemid < 30000) {\n-                        return getPlayer().getFace();\n-                } else {\n-                        return getPlayer().getHair();\n-                }\n+    }\n+\n+    public void challengeParty2(int field) {\n+        MapleCharacter leader = null;\n+        MapleMap map = c.getChannelServer().getMapFactory().getMap(980031000 + 1000 * field);\n+        for (MapleMapObject mmo : map.getAllPlayer()) {\n+            MapleCharacter mc = (MapleCharacter) mmo;\n+            if (mc.getParty() == null) {\n+                sendOk(LinguaConstants.Linguas(mc).CPQEscolha);\n+                return;\n+            }\n+            if (mc.getParty().getLeader().getId() == mc.getId()) {\n+                leader = mc;\n+                break;\n+            }\n         }\n-        \n-        public boolean isCosmeticEquipped(int itemid) {\n-                return getEquippedItemid(itemid) == itemid;\n+        if (leader != null) {\n+            if (!leader.isChallenged()) {\n+                List<MaplePartyCharacter> members = new LinkedList<>();\n+                for (MaplePartyCharacter fucker : c.getPlayer().getParty().getMembers()) {\n+                    members.add(fucker);\n+                }\n+                NPCScriptManager.getInstance().start(\"cpqchallenge2\", leader.getClient(), npc, members);\n+            } else {\n+                sendOk(LinguaConstants.Linguas(leader).CPQInicioEscolhaEmEscolha);\n+            }\n+        } else {\n+            sendOk(LinguaConstants.Linguas(leader).CPQLiderNaoEncontrado);\n         }\n-        \n-        public boolean isUsingOldPqNpcStyle() {\n-                return ServerConstants.USE_OLD_GMS_STYLED_PQ_NPCS && this.getPlayer().getParty() != null;\n+    }\n+\n+    public void mapClock(int time) {\n+        //getPlayer().getMap().broadcastMessage(MaplePacketCreator.serverNotice(type, message));\n+        getPlayer().getMap().broadcastMessage(MaplePacketCreator.getClock(time));\n+    }\n+\n+    public void challengeParty(int field) {\n+        MapleCharacter leader = null;\n+        MapleMap map = c.getChannelServer().getMapFactory().getMap(980000100 + 100 * field);\n+        if (map.getAllPlayer().size() != getPlayer().getParty().getMembers().size()) {\n+            sendOk(\"erro\");\n+            return;\n         }\n-        \n-        public Object[] getAvailableMasteryBooks() {\n-                return MapleItemInformationProvider.getInstance().usableMasteryBooks(this.getPlayer()).toArray();\n+        for (MapleMapObject mmo : map.getAllPlayer()) {\n+            MapleCharacter mc = (MapleCharacter) mmo;\n+            if (mc.getParty() == null) {\n+                sendOk(LinguaConstants.Linguas(mc).CPQEscolha);\n+                return;\n+            }\n+            if (mc.getParty().getLeader().getId() == mc.getId()) {\n+                leader = mc;\n+                break;\n+            }\n         }\n-        \n-        public Object[] getAvailableSkillBooks() {\n-                return MapleItemInformationProvider.getInstance().usableSkillBooks(this.getPlayer()).toArray();\n+        if (leader != null) {\n+            if (!leader.isChallenged()) {\n+                List<MaplePartyCharacter> members = new LinkedList<>();\n+                for (MaplePartyCharacter fucker : c.getPlayer().getParty().getMembers()) {\n+                    members.add(fucker);\n+                }\n+                NPCScriptManager.getInstance().start(\"cpqchallenge\", leader.getClient(), npc, members);\n+            } else {\n+                sendOk(LinguaConstants.Linguas(leader).CPQInicioEscolhaEmEscolha);\n+            }\n+        } else {\n+            sendOk(LinguaConstants.Linguas(leader).CPQLiderNaoEncontrado);\n         }\n-        \n-        public Object[] getNamesWhoDropsItem(Integer itemId) {\n-                return MapleItemInformationProvider.getInstance().getWhoDrops(itemId).toArray();\n+    }\n+\n+    public MapleCharacter getCharByName(String namee) {\n+        try {\n+            return getClient().getChannelServer().getPlayerStorage().getCharacterByName(namee);\n+        } catch (Exception e) {\n+            return null;\n         }\n-        \n-        public String getSkillBookInfo(int itemid) {\n-                SkillBookEntry sbe = MapleSkillbookInformationProvider.getInstance().getSkillbookAvailability(itemid);\n-                return sbe != SkillBookEntry.UNAVAILABLE ? \"    Obtainable through #rquestline#k.\" : \"\";\n+    }\n+\n+    public void enviarLista() {\n+        EventInstanceManager eim = getEventInstance();\n+        if(eim != null) {\n+            String name = eim.getProperty(\"brideId\");\n+            MapleCharacter chr = getChrById(Integer.parseInt(name));\n+            //MapleCharacter chr = getChrById(3);\n+            if (chr != null) {\n+                if (chr.getId() == getPlayer().getId()) {\n+                    getPlayer().announce(Wedding.OnWeddingGiftResult((byte) 0xA, chr.getItens(), chr.getItem()));\n+                } else {\n+                    getPlayer().announce(Wedding.OnWeddingGiftResult((byte) 0x09, chr.getItens(), chr.getItem()));\n+                }\n+            }\n         }\n-        \n+    }\n+    \n+    public void criarLista() {\n+        getClient().getSession().write(Wedding.sendWishList());\n+    }\n+\n }"}, {"sha": "ecda65e399393f3efbe0fe13af2eafec859afade", "filename": "src/scripting/npc/NPCScriptManager.java", "status": "modified", "additions": 59, "deletions": 14, "changes": 73, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/scripting/npc/NPCScriptManager.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/scripting/npc/NPCScriptManager.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/scripting/npc/NPCScriptManager.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -26,10 +26,12 @@\n \n import java.lang.reflect.UndeclaredThrowableException;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n \n import javax.script.Invocable;\n import javax.script.ScriptException;\n+import net.server.world.MaplePartyCharacter;\n \n import scripting.AbstractScriptManager;\n import server.MapleItemInformationProvider.ScriptedItem;\n@@ -43,43 +45,86 @@\n public class NPCScriptManager extends AbstractScriptManager {\n \n     private static NPCScriptManager instance = new NPCScriptManager();\n-    \n+\n     public static NPCScriptManager getInstance() {\n         return instance;\n     }\n-    \n+\n     private Map<MapleClient, NPCConversationManager> cms = new HashMap<>();\n     private Map<MapleClient, Invocable> scripts = new HashMap<>();\n-    \n+\n     public boolean isNpcScriptAvailable(MapleClient c, String fileName) {\n         Invocable iv = null;\n         if (fileName != null) {\n             iv = getInvocable(\"npc/\" + fileName + \".js\", c);\n         }\n-        \n+\n         return iv != null;\n     }\n-    \n+\n     public boolean start(MapleClient c, int npc, MapleCharacter chr) {\n         return start(c, npc, -1, chr);\n     }\n-    \n+\n     public boolean start(MapleClient c, int npc, int oid, MapleCharacter chr) {\n         return start(c, npc, oid, null, chr);\n     }\n-    \n+\n     public boolean start(MapleClient c, int npc, String fileName, MapleCharacter chr) {\n         return start(c, npc, -1, fileName, chr);\n     }\n-    \n+\n     public boolean start(MapleClient c, int npc, int oid, String fileName, MapleCharacter chr) {\n         return start(c, npc, oid, fileName, chr, false, \"cm\");\n     }\n-    \n+\n     public boolean start(MapleClient c, ScriptedItem scriptItem, MapleCharacter chr) {\n         return start(c, scriptItem.getNpc(), -1, scriptItem.getScript(), chr, true, \"im\");\n     }\n \n+    public void start(String filename, MapleClient c, int npc, List<MaplePartyCharacter> chrs) {\n+        try {\n+            NPCConversationManager cm = new NPCConversationManager(c, npc, chrs, true);\n+            cm.dispose();\n+            if (cms.containsKey(c)) {\n+                return;\n+            }\n+            cms.put(c, cm);\n+            Invocable iv = null;\n+            iv = getInvocable(\"npc/\" + filename + \".js\", c);\n+            NPCScriptManager npcsm = NPCScriptManager.getInstance();\n+\n+            if (iv == null || NPCScriptManager.getInstance() == null) {\n+                c.getPlayer().dropMessage(1, npc + \"\");\n+                cm.dispose();\n+                return;\n+            }\n+            if (iv == null || npcsm == null) {\n+                c.getPlayer().dropMessage(1, npc + \"\");\n+                cm.dispose();\n+                return;\n+            }\n+            engine.put(\"cm\", cm);\n+            scripts.put(c, iv);\n+            try {\n+                iv.invokeFunction(\"start\", chrs);\n+            } catch (final NoSuchMethodException nsme) {\n+                try {\n+                    iv.invokeFunction(\"start\", chrs);\n+                } catch (final NoSuchMethodException nsma) {\n+                    nsma.printStackTrace();\n+                }\n+            }\n+\n+        } catch (final UndeclaredThrowableException ute) {\n+            FilePrinter.printError(FilePrinter.NPC + npc + \".txt\", ute);\n+            dispose(c);\n+        } catch (final Exception e) {\n+            FilePrinter.printError(FilePrinter.NPC + npc + \".txt\", e);\n+            dispose(c);\n+        }\n+    }\n+\n     private boolean start(MapleClient c, int npc, int oid, String fileName, MapleCharacter chr, boolean itemScript, String engineName) {\n         try {\n             NPCConversationManager cm = new NPCConversationManager(c, npc, oid, fileName, itemScript);\n@@ -121,17 +166,17 @@ private boolean start(MapleClient c, int npc, int oid, String fileName, MapleCha\n             } else {\n                 c.announce(MaplePacketCreator.enableActions());\n             }\n-            \n+\n             return true;\n         } catch (final UndeclaredThrowableException | ScriptException ute) {\n             FilePrinter.printError(FilePrinter.NPC + npc + \".txt\", ute);\n             dispose(c);\n-            \n+\n             return false;\n         } catch (final Exception e) {\n             FilePrinter.printError(FilePrinter.NPC + npc + \".txt\", e);\n             dispose(c);\n-            \n+\n             return false;\n         }\n     }\n@@ -157,9 +202,9 @@ public void dispose(NPCConversationManager cm) {\n         c.getPlayer().setNpcCooldown(System.currentTimeMillis());\n         cms.remove(c);\n         scripts.remove(c);\n-        \n+\n         String scriptFolder = (cm.isItemScript() ? \"item\" : \"npc\");\n-        if(cm.getScriptName() != null) {\n+        if (cm.getScriptName() != null) {\n             resetContext(scriptFolder + \"/\" + cm.getScriptName() + \".js\", c);\n         } else {\n             resetContext(scriptFolder + \"/\" + cm.getNpc() + \".js\", c);"}, {"sha": "267282c7d9820ccc3bcc05a2e5f3dccec102e2d6", "filename": "src/scripting/reactor/ReactorActionManager.java", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/scripting/reactor/ReactorActionManager.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/scripting/reactor/ReactorActionManager.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/scripting/reactor/ReactorActionManager.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -47,6 +47,8 @@\n import server.maps.MapleMap;\n import server.maps.MapleReactor;\n import server.maps.ReactorDropEntry;\n+import server.partyquest.MapleCarnivalFactory;\n+import server.partyquest.MapleCarnivalFactory.MCSkill;\n import tools.MaplePacketCreator;\n \n /**\n@@ -311,4 +313,20 @@ public void run() {\n             }\n         }, timestamp);\n     }\n+    \n+    public void dispelAllMonsters(int num, int team) { //dispels all mobs, cpq\n+        final MCSkill skil = MapleCarnivalFactory.getInstance().getGuardian(num);\n+        if (skil != null) {\n+            for (MapleMonster mons : getMap().getMonsters()) {\n+                if(mons.getTeam() == team) {\n+                    mons.dispelSkill(skil.getSkill());\n+                }\n+            }\n+        }\n+        if (team == 0) {\n+            getPlayer().getMap().getRedTeamBuffs().remove(skil);\n+        } else {\n+            getPlayer().getMap().getBlueTeamBuffs().remove(skil);\n+        }\n+    }\n }\n\\ No newline at end of file"}, {"sha": "be3e956bbd33f6247b9ac98988dbb85d152b0566", "filename": "src/server/MapleStatEffect.java", "status": "modified", "additions": 219, "deletions": 153, "changes": 372, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/MapleStatEffect.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/MapleStatEffect.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/MapleStatEffect.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -50,7 +50,6 @@\n import client.MapleDisease;\n import client.MapleJob;\n import client.MapleMount;\n-import client.MapleStat;\n import client.Skill;\n import client.SkillFactory;\n import client.inventory.Item;\n@@ -111,6 +110,10 @@\n import constants.skills.ThunderBreaker;\n import constants.skills.WhiteKnight;\n import constants.skills.WindArcher;\n+import net.server.world.MapleParty;\n+import net.server.world.MaplePartyCharacter;\n+import server.partyquest.MapleCarnivalFactory;\n+import server.partyquest.MapleCarnivalFactory.MCSkill;\n \n /**\n  * @author Matze\n@@ -129,6 +132,8 @@\n     private boolean overTime, repeatEffect;\n     private int sourceid;\n     private int moveTo;\n+    private int cp, nuffSkill;\n+    private List<MapleDisease> cureDebuffs;\n     private boolean skill;\n     private List<Pair<MapleBuffStat, Integer>> statups;\n     private Map<MonsterStatus, Integer> monsterStatus;\n@@ -155,17 +160,15 @@ private static void addBuffStatPairToListIfNotZero(List<Pair<MapleBuffStat, Inte\n     }\n \n     private static byte mapProtection(int sourceid) {\n-        if(sourceid == 2022001 || sourceid == 2022186) {\n+        if (sourceid == 2022001 || sourceid == 2022186) {\n             return 1;   //elnath cold\n-        }\n-        \n-        else if(sourceid == 2022040) {\n+        } else if (sourceid == 2022040) {\n             return 2;   //aqua road underwater\n+        } else {\n+            return 0;\n         }\n-        \n-        else return 0;\n     }\n-    \n+\n     private static MapleStatEffect loadFromData(MapleData source, int sourceid, boolean skill, boolean overTime) {\n         MapleStatEffect ret = new MapleStatEffect();\n         ret.duration = MapleDataTool.getIntConvert(\"time\", source, -1);\n@@ -177,6 +180,27 @@ private static MapleStatEffect loadFromData(MapleData source, int sourceid, bool\n         ret.hpCon = (short) MapleDataTool.getInt(\"hpCon\", source, 0);\n         int iprop = MapleDataTool.getInt(\"prop\", source, 100);\n         ret.prop = iprop / 100.0;\n+\n+        ret.cp = MapleDataTool.getInt(\"cp\", source, 0);\n+        List<MapleDisease> cure = new ArrayList<MapleDisease>(5);\n+        if (MapleDataTool.getInt(\"poison\", source, 0) > 0) {\n+            cure.add(MapleDisease.POISON);\n+        }\n+        if (MapleDataTool.getInt(\"seal\", source, 0) > 0) {\n+            cure.add(MapleDisease.SEAL);\n+        }\n+        if (MapleDataTool.getInt(\"darkness\", source, 0) > 0) {\n+            cure.add(MapleDisease.DARKNESS);\n+        }\n+        if (MapleDataTool.getInt(\"weakness\", source, 0) > 0) {\n+            cure.add(MapleDisease.WEAKEN);\n+        }\n+        if (MapleDataTool.getInt(\"curse\", source, 0) > 0) {\n+            cure.add(MapleDisease.CURSE);\n+        }\n+        ret.cureDebuffs = cure;\n+        ret.nuffSkill = MapleDataTool.getInt(\"nuffSkill\", source, 0);\n+\n         ret.mobCount = MapleDataTool.getInt(\"mobCount\", source, 1);\n         ret.cooldown = MapleDataTool.getInt(\"cooltime\", source, 0);\n         ret.morphId = MapleDataTool.getInt(\"morph\", source, 0);\n@@ -192,41 +216,41 @@ private static MapleStatEffect loadFromData(MapleData source, int sourceid, bool\n             ret.duration *= 1000; // items have their times stored in ms, of course\n             ret.overTime = overTime;\n         }\n-        \n+\n         ArrayList<Pair<MapleBuffStat, Integer>> statups = new ArrayList<>();\n         ret.watk = (short) MapleDataTool.getInt(\"pad\", source, 0);\n         ret.wdef = (short) MapleDataTool.getInt(\"pdd\", source, 0);\n         ret.matk = (short) MapleDataTool.getInt(\"mad\", source, 0);\n         ret.mdef = (short) MapleDataTool.getInt(\"mdd\", source, 0);\n         ret.acc = (short) MapleDataTool.getIntConvert(\"acc\", source, 0);\n         ret.avoid = (short) MapleDataTool.getInt(\"eva\", source, 0);\n-        \n+\n         ret.speed = (short) MapleDataTool.getInt(\"speed\", source, 0);\n         ret.jump = (short) MapleDataTool.getInt(\"jump\", source, 0);\n-        \n+\n         ret.mapProtection = mapProtection(sourceid);\n         addBuffStatPairToListIfNotZero(statups, MapleBuffStat.MAP_PROTECTION, Integer.valueOf(ret.mapProtection));\n-                    \n+\n         if (ret.overTime && ret.getSummonMovementType() == null) {\n-            if(!skill) {\n-                if(isPyramidBuff(sourceid)) {\n+            if (!skill) {\n+                if (isPyramidBuff(sourceid)) {\n                     ret.berserk = MapleDataTool.getInt(\"berserk\", source, 0);\n                     ret.booster = MapleDataTool.getInt(\"booster\", source, 0);\n-                    \n+\n                     addBuffStatPairToListIfNotZero(statups, MapleBuffStat.BERSERK, Integer.valueOf(ret.berserk));\n                     addBuffStatPairToListIfNotZero(statups, MapleBuffStat.BOOSTER, Integer.valueOf(ret.booster));\n-                    \n-                } else if(isDojoBuff(sourceid) || isHpMpRecovery(sourceid)) {\n+\n+                } else if (isDojoBuff(sourceid) || isHpMpRecovery(sourceid)) {\n                     ret.mhpR = (byte) MapleDataTool.getInt(\"mhpR\", source, 0);\n                     ret.mhpRRate = (short) (MapleDataTool.getInt(\"mhpRRate\", source, 0) * 100);\n                     ret.mmpR = (byte) MapleDataTool.getInt(\"mmpR\", source, 0);\n                     ret.mmpRRate = (short) (MapleDataTool.getInt(\"mmpRRate\", source, 0) * 100);\n \n                     addBuffStatPairToListIfNotZero(statups, MapleBuffStat.HPREC, Integer.valueOf(ret.mhpR));\n                     addBuffStatPairToListIfNotZero(statups, MapleBuffStat.MPREC, Integer.valueOf(ret.mmpR));\n-                    \n-                } else if(isRateCoupon(sourceid)) {\n-                    switch(MapleDataTool.getInt(\"expR\", source, 0)) {\n+\n+                } else if (isRateCoupon(sourceid)) {\n+                    switch (MapleDataTool.getInt(\"expR\", source, 0)) {\n                         case 1:\n                             addBuffStatPairToListIfNotZero(statups, MapleBuffStat.COUPON_EXP1, 1);\n                             break;\n@@ -244,7 +268,7 @@ private static MapleStatEffect loadFromData(MapleData source, int sourceid, bool\n                             break;\n                     }\n \n-                    switch(MapleDataTool.getInt(\"drpR\", source, 0)) {\n+                    switch (MapleDataTool.getInt(\"drpR\", source, 0)) {\n                         case 1:\n                             addBuffStatPairToListIfNotZero(statups, MapleBuffStat.COUPON_DRP1, 1);\n                             break;\n@@ -257,18 +281,18 @@ private static MapleStatEffect loadFromData(MapleData source, int sourceid, bool\n                             addBuffStatPairToListIfNotZero(statups, MapleBuffStat.COUPON_DRP3, 1);\n                             break;\n                     }\n-                } else if(isExpIncrease(sourceid)) {\n+                } else if (isExpIncrease(sourceid)) {\n                     addBuffStatPairToListIfNotZero(statups, MapleBuffStat.EXP_INCREASE, MapleDataTool.getInt(\"expinc\", source, 0));\n                 }\n             } else {\n-                if(isMapChair(sourceid)) {\n+                if (isMapChair(sourceid)) {\n                     addBuffStatPairToListIfNotZero(statups, MapleBuffStat.MAP_CHAIR, 1);\n-                } else if((sourceid == Beginner.NIMBLE_FEET || sourceid == Noblesse.NIMBLE_FEET || sourceid == Evan.NIMBLE_FEET || sourceid == Legend.AGILE_BODY) && ServerConstants.USE_ULTRA_NIMBLE_FEET == true) {\n-                    ret.jump = (short)(ret.speed * 4);\n+                } else if ((sourceid == Beginner.NIMBLE_FEET || sourceid == Noblesse.NIMBLE_FEET || sourceid == Evan.NIMBLE_FEET || sourceid == Legend.AGILE_BODY) && ServerConstants.USE_ULTRA_NIMBLE_FEET == true) {\n+                    ret.jump = (short) (ret.speed * 4);\n                     ret.speed *= 15;\n                 }\n             }\n-            \n+\n             addBuffStatPairToListIfNotZero(statups, MapleBuffStat.WATK, Integer.valueOf(ret.watk));\n             addBuffStatPairToListIfNotZero(statups, MapleBuffStat.WDEF, Integer.valueOf(ret.wdef));\n             addBuffStatPairToListIfNotZero(statups, MapleBuffStat.MATK, Integer.valueOf(ret.matk));\n@@ -278,26 +302,26 @@ private static MapleStatEffect loadFromData(MapleData source, int sourceid, bool\n             addBuffStatPairToListIfNotZero(statups, MapleBuffStat.SPEED, Integer.valueOf(ret.speed));\n             addBuffStatPairToListIfNotZero(statups, MapleBuffStat.JUMP, Integer.valueOf(ret.jump));\n         }\n-        \n+\n         MapleData ltd = source.getChildByPath(\"lt\");\n         if (ltd != null) {\n             ret.lt = (Point) ltd.getData();\n             ret.rb = (Point) source.getChildByPath(\"rb\").getData();\n-            \n-            if(ServerConstants.USE_MAXRANGE_ECHO_OF_HERO && (sourceid == Beginner.ECHO_OF_HERO || sourceid == Noblesse.ECHO_OF_HERO || sourceid == Legend.ECHO_OF_HERO || sourceid == Evan.ECHO_OF_HERO)) {\n+\n+            if (ServerConstants.USE_MAXRANGE_ECHO_OF_HERO && (sourceid == Beginner.ECHO_OF_HERO || sourceid == Noblesse.ECHO_OF_HERO || sourceid == Legend.ECHO_OF_HERO || sourceid == Evan.ECHO_OF_HERO)) {\n                 ret.lt = new Point(Integer.MIN_VALUE, Integer.MIN_VALUE);\n                 ret.rb = new Point(Integer.MAX_VALUE, Integer.MAX_VALUE);\n             }\n         }\n-        \n+\n         int x = MapleDataTool.getInt(\"x\", source, 0);\n-        \n-        if((sourceid == Beginner.RECOVERY || sourceid == Noblesse.RECOVERY || sourceid == Evan.RECOVERY || sourceid == Legend.RECOVERY) && ServerConstants.USE_ULTRA_RECOVERY == true) {\n+\n+        if ((sourceid == Beginner.RECOVERY || sourceid == Noblesse.RECOVERY || sourceid == Evan.RECOVERY || sourceid == Legend.RECOVERY) && ServerConstants.USE_ULTRA_RECOVERY == true) {\n             x *= 10;\n         }\n         ret.x = x;\n         ret.y = MapleDataTool.getInt(\"y\", source, 0);\n-        \n+\n         ret.damage = MapleDataTool.getIntConvert(\"damage\", source, 100);\n         ret.fixdamage = MapleDataTool.getIntConvert(\"fixdamage\", source, -1);\n         ret.attackCount = MapleDataTool.getIntConvert(\"attackCount\", source, 1);\n@@ -416,16 +440,16 @@ private static MapleStatEffect loadFromData(MapleData source, int sourceid, bool\n                     break;\n                 case BlazeWizard.ELEMENTAL_RESET:\n                 case Evan.ELEMENTAL_RESET:\n-                \tstatups.add(new Pair<>(MapleBuffStat.ELEMENTAL_RESET, Integer.valueOf(x)));\n-                \tbreak;\n+                    statups.add(new Pair<>(MapleBuffStat.ELEMENTAL_RESET, Integer.valueOf(x)));\n+                    break;\n                 case Evan.MAGIC_SHIELD:\n                     statups.add(new Pair<>(MapleBuffStat.MAGIC_SHIELD, Integer.valueOf(x)));\n                     break;\n                 case Evan.MAGIC_RESISTANCE:\n                     statups.add(new Pair<>(MapleBuffStat.MAGIC_RESISTANCE, Integer.valueOf(x)));\n                     break;\n                 case Evan.SLOW:\n-                \tstatups.add(new Pair<>(MapleBuffStat.SLOW, Integer.valueOf(x)));\n+                    statups.add(new Pair<>(MapleBuffStat.SLOW, Integer.valueOf(x)));\n                 // BOWMAN\n                 case Priest.MYSTIC_DOOR:\n                 case Hunter.SOUL_ARROW:\n@@ -474,7 +498,7 @@ private static MapleStatEffect loadFromData(MapleData source, int sourceid, bool\n                     break;\n                 case ChiefBandit.PICKPOCKET:\n                     statups.add(new Pair<>(MapleBuffStat.PICKPOCKET, Integer.valueOf(x)));\n-                    break;                \n+                    break;\n                 case NightLord.SHADOW_STARS:\n                     statups.add(new Pair<>(MapleBuffStat.SHADOW_CLAW, Integer.valueOf(0)));\n                     break;\n@@ -605,7 +629,7 @@ private static MapleStatEffect loadFromData(MapleData source, int sourceid, bool\n                 case Buccaneer.BARRAGE:\n                 case Gunslinger.BLANK_SHOT:\n                 case DawnWarrior.COMA:\n-                case ThunderBreaker.BARRAGE: \n+                case ThunderBreaker.BARRAGE:\n                 case Aran.ROLLING_SPIN:\n                 case Evan.FIRE_BREATH:\n                 case Evan.BLAZE:\n@@ -633,7 +657,7 @@ private static MapleStatEffect loadFromData(MapleData source, int sourceid, bool\n                 case ILWizard.SLOW:\n                 case BlazeWizard.SLOW:\n                     monsterStatus.put(MonsterStatus.SPEED, Integer.valueOf(ret.x));\n-                    break;    \n+                    break;\n                 case FPWizard.POISON_BREATH:\n                 case FPMage.ELEMENT_COMPOSITION:\n                     monsterStatus.put(MonsterStatus.POISON, Integer.valueOf(1));\n@@ -655,7 +679,7 @@ private static MapleStatEffect loadFromData(MapleData source, int sourceid, bool\n                     monsterStatus.put(MonsterStatus.FREEZE, Integer.valueOf(1));\n                     break;\n                 case Evan.PHANTOM_IMPRINT:\n-                \tmonsterStatus.put(MonsterStatus.PHANTOM_IMPRINT, Integer.valueOf(x));\n+                    monsterStatus.put(MonsterStatus.PHANTOM_IMPRINT, Integer.valueOf(x));\n                 //ARAN\n                 case Aran.COMBO_ABILITY:\n                     statups.add(new Pair<>(MapleBuffStat.ARAN_COMBO, Integer.valueOf(100)));\n@@ -723,19 +747,19 @@ public void applyPassive(MapleCharacter applyto, MapleMapObject obj, int attack)\n     public boolean applyEchoOfHero(MapleCharacter applyfrom) {\n         Map<Integer, MapleCharacter> mapPlayers = applyfrom.getMap().getMapPlayers();\n         mapPlayers.remove(applyfrom.getId());\n-        \n+\n         boolean hwResult = applyTo(applyfrom);\n         for (MapleCharacter chr : mapPlayers.values()) {    // Echo of Hero not buffing players in the map detected thanks to Masterrulax\n             applyTo(applyfrom, chr, false, null, false, 1);\n         }\n-        \n+\n         return hwResult;\n     }\n-    \n+\n     public boolean applyTo(MapleCharacter chr) {\n         return applyTo(chr, chr, true, null, false, 1);\n     }\n-    \n+\n     public boolean applyTo(MapleCharacter chr, boolean useMaxRange) {\n         return applyTo(chr, chr, true, null, useMaxRange, 1);\n     }\n@@ -750,16 +774,16 @@ private boolean applyTo(MapleCharacter applyfrom, MapleCharacter applyto, boolea\n             applyto.toggleHide(false);\n             return true;\n         }\n-        \n+\n         if (primary && isHeal()) {\n             affectedPlayers = applyBuff(applyfrom, useMaxRange);\n         }\n-        \n+\n         int hpchange = calcHPChange(applyfrom, primary, affectedPlayers);\n         int mpchange = calcMPChange(applyfrom, primary);\n         if (primary) {\n             if (itemConNo != 0) {\n-                if(!applyto.getClient().getAbstractPlayerInteraction().hasItem(itemCon, itemConNo)) {\n+                if (!applyto.getClient().getAbstractPlayerInteraction().hasItem(itemCon, itemConNo)) {\n                     applyto.announce(MaplePacketCreator.enableActions());\n                     return false;\n                 }\n@@ -771,7 +795,7 @@ private boolean applyTo(MapleCharacter applyfrom, MapleCharacter applyto, boolea\n                 applyto.broadcastStance(applyto.isFacingLeft() ? 5 : 4);\n             }\n         }\n-        \n+\n         if (isDispel() && makeChanceResult()) {\n             applyto.dispelDebuffs();\n         } else if (isCureAllAbnormalStatus()) {\n@@ -784,24 +808,26 @@ private boolean applyTo(MapleCharacter applyfrom, MapleCharacter applyto, boolea\n         /*if (applyfrom.getMp() < getMpCon()) {\n          AutobanFactory.MPCON.addPoint(applyfrom.getAutobanManager(), \"mpCon hack for skill:\" + sourceid + \"; Player MP: \" + applyto.getMp() + \" MP Needed: \" + getMpCon());\n          } */\n-        \n+\n         if (!applyto.applyHpMpChange(hpCon, hpchange, mpchange)) {\n             applyto.announce(MaplePacketCreator.enableActions());\n             return false;\n         }\n-        \n+\n         if (moveTo != -1) {\n             if (moveTo != applyto.getMapId()) {\n                 MapleMap target;\n                 MaplePortal pt;\n-                \n+\n                 if (moveTo == 999999999) {\n-                    if(sourceid != 2030100) {\n+                    if (sourceid != 2030100) {\n                         target = applyto.getMap().getReturnMap();\n                         pt = target.getRandomPlayerSpawnpoint();\n                     } else {\n-                        if(!applyto.canRecoverLastBanish()) return false;\n-                    \n+                        if (!applyto.canRecoverLastBanish()) {\n+                            return false;\n+                        }\n+\n                         Pair<Integer, Integer> lastBanishInfo = applyto.getLastBanishData();\n                         target = applyto.getWarpMap(lastBanishInfo.getLeft());\n                         pt = target.getPortal(lastBanishInfo.getRight());\n@@ -810,12 +836,12 @@ private boolean applyTo(MapleCharacter applyfrom, MapleCharacter applyto, boolea\n                     target = applyto.getClient().getWorldServer().getChannel(applyto.getClient().getChannel()).getMapFactory().getMap(moveTo);\n                     int targetid = target.getId() / 10000000;\n                     if (targetid != 60 && applyto.getMapId() / 10000000 != 61 && targetid != applyto.getMapId() / 10000000 && targetid != 21 && targetid != 20 && targetid != 12 && (applyto.getMapId() / 10000000 != 10 && applyto.getMapId() / 10000000 != 12)) {\n-                    \treturn false;\n+                        return false;\n                     }\n-                    \n+\n                     pt = target.getRandomPlayerSpawnpoint();\n                 }\n-                \n+\n                 applyto.changeMap(target, pt);\n             } else {\n                 return false;\n@@ -842,15 +868,15 @@ private boolean applyTo(MapleCharacter applyfrom, MapleCharacter applyto, boolea\n         SummonMovementType summonMovementType = getSummonMovementType();\n         if (overTime || isCygnusFA() || summonMovementType != null) {\n             if (summonMovementType != null && pos != null) {\n-                if(summonMovementType.getValue() == summonMovementType.STATIONARY.getValue()) {\n+                if (summonMovementType.getValue() == summonMovementType.STATIONARY.getValue()) {\n                     applyto.cancelBuffStats(MapleBuffStat.PUPPET);\n                 } else {\n                     applyto.cancelBuffStats(MapleBuffStat.SUMMON);\n                 }\n-                \n+\n                 applyto.announce(MaplePacketCreator.enableActions());\n             }\n-            \n+\n             applyBuffEffect(applyfrom, applyto, primary);\n         }\n \n@@ -863,7 +889,7 @@ private boolean applyTo(MapleCharacter applyfrom, MapleCharacter applyto, boolea\n                 applyMonsterBuff(applyfrom);\n             }\n         }\n-        \n+\n         if (this.getFatigue() != 0) {\n             applyto.getMount().setTiredness(applyto.getMount().getTiredness() + this.getFatigue());\n         }\n@@ -880,25 +906,29 @@ private boolean applyTo(MapleCharacter applyfrom, MapleCharacter applyto, boolea\n         if (isMagicDoor() && !FieldLimit.DOOR.check(applyto.getMap().getFieldLimit())) { // Magic Door\n             int y = applyto.getFh();\n             if (y == 0) {\n-                    y = applyto.getPosition().y;\n+                y = applyto.getPosition().y;\n             }\n             Point doorPosition = new Point(applyto.getPosition().x, y);\n             MapleDoor door = new MapleDoor(applyto, doorPosition);\n-            \n-            if(door.getOwnerId() >= 0) {\n+\n+            if (door.getOwnerId() >= 0) {\n                 applyto.applyPartyDoor(door, false);\n \n                 door.getTarget().spawnDoor(door.getAreaDoor());\n                 door.getTown().spawnDoor(door.getTownDoor());\n-                \n+\n                 applyto.disableDoorSpawn();\n             } else {\n                 MapleInventoryManipulator.addFromDrop(applyto.getClient(), new Item(4006000, (short) 0, (short) 1), false);\n-                \n-                if(door.getOwnerId() == -3) applyto.dropMessage(5, \"Mystic Door cannot be cast far from a spawn point. Nearest one is at \" + door.getDoorStatus().getRight() + \"pts \" + door.getDoorStatus().getLeft());\n-                else if(door.getOwnerId() == -2) applyto.dropMessage(5, \"Mystic Door cannot be cast on a slope, try elsewhere.\");\n-                else applyto.dropMessage(5, \"There are no door portals available for the town at this moment. Try again later.\");\n-                \n+\n+                if (door.getOwnerId() == -3) {\n+                    applyto.dropMessage(5, \"Mystic Door cannot be cast far from a spawn point. Nearest one is at \" + door.getDoorStatus().getRight() + \"pts \" + door.getDoorStatus().getLeft());\n+                } else if (door.getOwnerId() == -2) {\n+                    applyto.dropMessage(5, \"Mystic Door cannot be cast on a slope, try elsewhere.\");\n+                } else {\n+                    applyto.dropMessage(5, \"There are no door portals available for the town at this moment. Try again later.\");\n+                }\n+\n                 applyto.cancelBuffStats(MapleBuffStat.SOULARROW);  // cancel door buff\n             }\n         } else if (isMist()) {\n@@ -907,14 +937,51 @@ private boolean applyTo(MapleCharacter applyfrom, MapleCharacter applyto, boolea\n             applyfrom.getMap().spawnMist(mist, getDuration(), mist.isPoisonMist(), false, mist.isRecoveryMist());\n         } else if (isTimeLeap()) {\n             applyto.removeAllCooldownsExcept(Buccaneer.TIME_LEAP, true);\n+        } else if (cp != 0 && applyto.getMonsterCarnival() != null) {\n+            applyto.gainCP(cp);\n+        } else if (nuffSkill != 0 && applyto.getParty() != null && applyto.getMap().isCPQMap()) {\n+            final MCSkill skil = MapleCarnivalFactory.getInstance().getSkill(nuffSkill);\n+            if (skil != null) {\n+                final MapleDisease dis = skil.getDisease();\n+                MapleParty inimigos = applyfrom.getParty().getEnemy();\n+                if (nuffSkill == 8) {\n+                    int amount = inimigos.getMembers().size() - 1;\n+                    int randd = (int) Math.floor(Math.random() * amount);\n+                    MapleCharacter chrApp = applyfrom.getClient().getChannelServer().getPlayerStorage().getCharacterById(inimigos.getMemberByPos(randd).getId());\n+                    if (chrApp != null && chrApp.getMap().isCPQMap()) {\n+                        chrApp.dispel();\n+                    }\n+                } else {\n+                    for (MaplePartyCharacter chrsInimigos : inimigos.getPartyMembers()) {\n+                        MapleCharacter chrApp = chrsInimigos.getPlayer();\n+                        if (chrApp != null && chrApp.getMap().isCPQMap()) {\n+                            if (dis == null) {\n+                                chrApp.dispel();\n+                            } else if (skil.getSkill() != null) {\n+                                chrApp.giveDebuff(dis, skil.getSkill());\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        } else if (cureDebuffs.size() > 0) {\n+            for (final MapleDisease debuff : cureDebuffs) {\n+                if (applyfrom.getParty() != null) {\n+                    for (MaplePartyCharacter chrs : applyfrom.getParty().getPartyMembers()) {\n+                        chrs.getPlayer().dispelDebuff(debuff);\n+                    }\n+                } else {\n+                    applyfrom.dispelDebuff(debuff);\n+                }\n+            }\n         }\n-        \n+\n         return true;\n     }\n \n     private int applyBuff(MapleCharacter applyfrom, boolean useMaxRange) {\n         int affectedc = 1;\n-        \n+\n         if (isPartyBuff() && (applyfrom.getParty() != null || isGmBuff())) {\n             Rectangle bounds = (!useMaxRange) ? calculateBoundingBox(applyfrom.getPosition(), applyfrom.isFacingLeft()) : new Rectangle(Integer.MIN_VALUE / 2, Integer.MIN_VALUE / 2, Integer.MAX_VALUE, Integer.MAX_VALUE);\n             List<MapleMapObject> affecteds = applyfrom.getMap().getMapObjectsInRect(bounds, Arrays.asList(MapleMapObjectType.PLAYER));\n@@ -933,15 +1000,15 @@ private int applyBuff(MapleCharacter applyfrom, boolean useMaxRange) {\n                     }\n                 }\n             }\n-            \n+\n             affectedc += affectedp.size();   // used for heal\n             for (MapleCharacter affected : affectedp) {\n                 applyTo(applyfrom, affected, false, null, useMaxRange, affectedc);\n                 affected.announce(MaplePacketCreator.showOwnBuffEffect(sourceid, 2));\n                 affected.getMap().broadcastMessage(affected, MaplePacketCreator.showBuffeffect(affected.getId(), sourceid, 2), false);\n             }\n         }\n-        \n+\n         return affectedc;\n     }\n \n@@ -952,15 +1019,15 @@ private void applyMonsterBuff(MapleCharacter applyfrom) {\n         int i = 0;\n         for (MapleMapObject mo : affected) {\n             MapleMonster monster = (MapleMonster) mo;\n-            if (isDispel()) { \n-        \t\tmonster.debuffMob(skill_.getId());\n+            if (isDispel()) {\n+                monster.debuffMob(skill_.getId());\n             } else {\n-                    if (makeChanceResult()) {\n-                            monster.applyStatus(applyfrom, new MonsterStatusEffect(getMonsterStati(), skill_, null, false), isPoison(), getDuration());\n-                            if (isCrash()) {\n-                                    monster.debuffMob(skill_.getId());\n-                            }\n+                if (makeChanceResult()) {\n+                    monster.applyStatus(applyfrom, new MonsterStatusEffect(getMonsterStati(), skill_, null, false), isPoison(), getDuration());\n+                    if (isCrash()) {\n+                        monster.debuffMob(skill_.getId());\n                     }\n+                }\n             }\n             i++;\n             if (i >= mobCount) {\n@@ -982,17 +1049,17 @@ private Rectangle calculateBoundingBox(Point posFrom, boolean facingLeft) {\n         Rectangle bounds = new Rectangle(mylt.x, mylt.y, myrb.x - mylt.x, myrb.y - mylt.y);\n         return bounds;\n     }\n-    \n+\n     public int getBuffLocalDuration() {\n         return !ServerConstants.USE_BUFF_EVERLASTING ? duration : Integer.MAX_VALUE;\n     }\n-    \n+\n     public void silentApplyBuff(MapleCharacter chr, long localStartTime) {\n         int localDuration = getBuffLocalDuration();\n         localDuration = alchemistModifyVal(chr, localDuration, false);\n         //CancelEffectAction cancelAction = new CancelEffectAction(chr, this, starttime);\n         //ScheduledFuture<?> schedule = TimerManager.getInstance().schedule(cancelAction, ((starttime + localDuration) - Server.getInstance().getCurrentTime()));\n-        \n+\n         chr.registerEffect(this, localStartTime, localStartTime + localDuration, true);\n         SummonMovementType summonMovementType = getSummonMovementType();\n         if (summonMovementType != null) {\n@@ -1016,22 +1083,22 @@ public final void applyComboBuff(final MapleCharacter applyto, int combo) {\n //\tfinal ScheduledFuture<?> schedule = TimerManager.getInstance().schedule(cancelAction, ((starttime + 99999) - Server.getInstance().getCurrentTime()));\n         applyto.registerEffect(this, starttime, Long.MAX_VALUE, false);\n     }\n-    \n+\n     public final void applyBeaconBuff(final MapleCharacter applyto, int objectid) { // thanks Thora & Hyun for reporting an issue with homing beacon autoflagging mobs when changing maps\n         final List<Pair<MapleBuffStat, Integer>> stat = Collections.singletonList(new Pair<>(MapleBuffStat.HOMING_BEACON, objectid));\n         applyto.announce(MaplePacketCreator.giveBuff(1, sourceid, stat));\n \n         final long starttime = Server.getInstance().getCurrentTime();\n         applyto.registerEffect(this, starttime, Long.MAX_VALUE, false);\n     }\n-    \n+\n     public void updateBuffEffect(MapleCharacter target, List<Pair<MapleBuffStat, Integer>> activeStats, long starttime) {\n         int localDuration = getBuffLocalDuration();\n         localDuration = alchemistModifyVal(target, localDuration, false);\n-        \n+\n         long leftDuration = (starttime + localDuration) - Server.getInstance().getCurrentTime();\n-        if(leftDuration > 0) {\n-            target.announce(MaplePacketCreator.giveBuff((skill ? sourceid : -sourceid), (int)leftDuration, activeStats));\n+        if (leftDuration > 0) {\n+            target.announce(MaplePacketCreator.giveBuff((skill ? sourceid : -sourceid), (int) leftDuration, activeStats));\n         }\n     }\n \n@@ -1067,7 +1134,7 @@ private void applyBuffEffect(MapleCharacter applyfrom, MapleCharacter applyto, b\n                 if (applyto.getMount() == null) {\n                     applyto.mount(ridingMountId, sourceid);\n                 }\n-                \n+\n                 applyto.getClient().getWorldServer().registerMountHunger(applyto);\n             }\n             if (sourceid == Corsair.BATTLE_SHIP) {\n@@ -1089,8 +1156,8 @@ private void applyBuffEffect(MapleCharacter applyfrom, MapleCharacter applyto, b\n             localsourceid = ridingMountId;\n             localstatups = Collections.singletonList(new Pair<>(MapleBuffStat.MONSTER_RIDING, 0));\n         } else if (isSkillMorph()) {\n-            for(int i = 0; i < localstatups.size(); i++) {\n-                if(localstatups.get(i).getLeft().equals(MapleBuffStat.MORPH)) {\n+            for (int i = 0; i < localstatups.size(); i++) {\n+                if (localstatups.get(i).getLeft().equals(MapleBuffStat.MORPH)) {\n                     localstatups.set(i, new Pair<>(MapleBuffStat.MORPH, getMorph(applyto)));\n                     break;\n                 }\n@@ -1110,7 +1177,7 @@ private void applyBuffEffect(MapleCharacter applyfrom, MapleCharacter applyto, b\n                 buff = MaplePacketCreator.givePirateBuff(statups, sourceid, seconds);\n                 mbuff = MaplePacketCreator.giveForeignPirateBuff(applyto.getId(), sourceid, seconds, localstatups);\n             } else if (isInfusion()) {\n-            \tbuff = MaplePacketCreator.givePirateBuff(localstatups, sourceid, seconds);\n+                buff = MaplePacketCreator.givePirateBuff(localstatups, sourceid, seconds);\n                 mbuff = MaplePacketCreator.giveForeignPirateBuff(applyto.getId(), sourceid, seconds, localstatups);\n             } else if (isDs()) {\n                 List<Pair<MapleBuffStat, Integer>> dsstat = Collections.singletonList(new Pair<>(MapleBuffStat.DARKSIGHT, 0));\n@@ -1125,10 +1192,10 @@ private void applyBuffEffect(MapleCharacter applyfrom, MapleCharacter applyto, b\n                     if (applyto.getBattleshipHp() <= 0) {\n                         applyto.resetBattleshipHp();\n                     }\n-                    \n+\n                     localstatups = statups;\n                 }\n-                \n+\n                 buff = MaplePacketCreator.giveBuff(localsourceid, localDuration, localstatups);\n                 mbuff = MaplePacketCreator.showMonsterRiding(applyto.getId(), givemount);\n                 localDuration = duration;\n@@ -1144,15 +1211,15 @@ private void applyBuffEffect(MapleCharacter applyfrom, MapleCharacter applyto, b\n                 List<Pair<MapleBuffStat, Integer>> stat = Collections.singletonList(new Pair<>(MapleBuffStat.MORPH, Integer.valueOf(getMorph(applyto))));\n                 mbuff = MaplePacketCreator.giveForeignBuff(applyto.getId(), stat);\n             }\n-            \n+\n             if (buff != null) {\n-            \tif (!hasNoIcon()) { //Thanks flav for such a simple release! :)\n+                if (!hasNoIcon()) { //Thanks flav for such a simple release! :)\n                     applyto.announce(buff);\n-            \t} else {\n+                } else {\n                     System.out.println(\"<Error> NO buff icon for id \" + sourceid);\n                 }\n             }\n-            \n+\n             long starttime = Server.getInstance().getCurrentTime();\n             //CancelEffectAction cancelAction = new CancelEffectAction(applyto, this, starttime);\n             //ScheduledFuture<?> schedule = TimerManager.getInstance().schedule(cancelAction, localDuration);\n@@ -1273,7 +1340,7 @@ private boolean isGmBuff() {\n             case Beginner.ECHO_OF_HERO:\n             case Noblesse.ECHO_OF_HERO:\n             case Legend.ECHO_OF_HERO:\n-            case Evan.ECHO_OF_HERO:\t\n+            case Evan.ECHO_OF_HERO:\n             case SuperGM.HEAL_PLUS_DISPEL:\n             case SuperGM.HASTE:\n             case SuperGM.HOLY_SYMBOL:\n@@ -1346,45 +1413,44 @@ public boolean isBerserk() {\n     public boolean isRecovery() {\n         return sourceid == Beginner.RECOVERY || sourceid == Noblesse.RECOVERY || sourceid == Legend.RECOVERY || sourceid == Evan.RECOVERY;\n     }\n-    \n+\n     public boolean isMapChair() {\n         return sourceid == Beginner.MAP_CHAIR || sourceid == Noblesse.MAP_CHAIR || sourceid == Legend.MAP_CHAIR;\n     }\n-    \n+\n     public static boolean isMapChair(int sourceid) {\n         return sourceid == Beginner.MAP_CHAIR || sourceid == Noblesse.MAP_CHAIR || sourceid == Legend.MAP_CHAIR;\n     }\n-    \n-    \n+\n     public boolean isDojoBuff() {\n         return sourceid >= 2022359 && sourceid <= 2022421;\n     }\n-    \n+\n     public static boolean isDojoBuff(int sourceid) {\n         return sourceid >= 2022359 && sourceid <= 2022421;\n     }\n-    \n+\n     public static boolean isHpMpRecovery(int sourceid) {\n         return sourceid == 2022198 || sourceid == 2022337;\n     }\n-    \n+\n     public static boolean isPyramidBuff(int sourceid) {\n         return sourceid >= 2022585 && sourceid <= 2022617;\n     }\n-    \n+\n     public static boolean isRateCoupon(int sourceid) {\n         int itemType = sourceid / 1000;\n         return itemType == 5211 || itemType == 5360;\n     }\n-    \n+\n     public static boolean isExpIncrease(int sourceid) {\n         return sourceid >= 2022450 && sourceid <= 2022452;\n     }\n-    \n+\n     private boolean isDs() {\n         return skill && (sourceid == Rogue.DARK_SIGHT || sourceid == NightWalker.DARK_SIGHT);\n     }\n-    \n+\n     private boolean isWw() {\n         return skill && (sourceid == WindArcher.WIND_WALK);\n     }\n@@ -1412,11 +1478,11 @@ private boolean isChakra() {\n     private boolean isCouponBuff() {\n         return isRateCoupon(sourceid);\n     }\n-    \n+\n     private boolean isMysticDoor() {\n         return skill && sourceid == Priest.MYSTIC_DOOR;\n     }\n-    \n+\n     public boolean isMonsterRiding() {\n         return skill && (sourceid % 10000000 == 1004 || sourceid == Corsair.BATTLE_SHIP || sourceid == Beginner.SPACESHIP || sourceid == Noblesse.SPACESHIP\n                 || sourceid == Beginner.YETI_MOUNT1 || sourceid == Beginner.YETI_MOUNT2 || sourceid == Beginner.WITCH_BROOMSTICK || sourceid == Beginner.BALROG_MOUNT\n@@ -1431,11 +1497,11 @@ public boolean isMagicDoor() {\n     public boolean isPoison() {\n         return skill && (sourceid == FPMage.POISON_MIST || sourceid == FPWizard.POISON_BREATH || sourceid == FPMage.ELEMENT_COMPOSITION || sourceid == NightWalker.POISON_BOMB || sourceid == BlazeWizard.FLAME_GEAR);\n     }\n-    \n+\n     public boolean isMorph() {\n         return morphId > 0;\n     }\n-    \n+\n     public boolean isMorphWithoutAttack() {\n         return morphId > 0 && morphId < 100; // Every morph item I have found has been under 100, pirate skill transforms start at 1000.\n     }\n@@ -1453,23 +1519,25 @@ private boolean isShadowClaw() {\n     }\n \n     private boolean isCrash() {\n-    \treturn skill && (sourceid == DragonKnight.POWER_CRASH || sourceid == Crusader.ARMOR_CRASH || sourceid == WhiteKnight.MAGIC_CRASH);\n+        return skill && (sourceid == DragonKnight.POWER_CRASH || sourceid == Crusader.ARMOR_CRASH || sourceid == WhiteKnight.MAGIC_CRASH);\n     }\n-    \n+\n     private boolean isDispel() {\n         return skill && (sourceid == Priest.DISPEL || sourceid == SuperGM.HEAL_PLUS_DISPEL);\n     }\n \n     private boolean isCureAllAbnormalStatus() {\n         if (skill) {\n             return isHerosWill(sourceid);\n-        } else if (sourceid == 2022544) return true;\n-        \n+        } else if (sourceid == 2022544) {\n+            return true;\n+        }\n+\n         return false;\n     }\n-    \n+\n     public static boolean isHerosWill(int skillid) {\n-        switch(skillid) {\n+        switch (skillid) {\n             case Hero.HEROS_WILL:\n             case Paladin.HEROS_WILL:\n             case DarkKnight.HEROS_WILL:\n@@ -1504,7 +1572,7 @@ private boolean isInfusion() {\n     private boolean isCygnusFA() {\n         return skill && (sourceid == DawnWarrior.FINAL_ATTACK || sourceid == WindArcher.FINAL_ATTACK);\n     }\n-    \n+\n     private boolean isHyperBody() {\n         return skill && (sourceid == Spearman.HYPER_BODY || sourceid == GM.HYPER_BODY || sourceid == SuperGM.HYPER_BODY);\n     }\n@@ -1561,25 +1629,24 @@ private SummonMovementType getSummonMovementType() {\n         return null;\n     }\n \n-    \n     public boolean hasNoIcon() {\n         return (sourceid == 3111002 || sourceid == 3211002 || + // puppet, puppet\n-                sourceid == 3211005 || +                        // golden eagle\n+                sourceid == 3211005 || + // golden eagle\n                 sourceid == 2121005 || sourceid == 2221005 || + // elquines, ifrit\n                 sourceid == 2321003 || sourceid == 3121006 || + // bahamut, phoenix\n                 sourceid == 3221005 || sourceid == 3111005 || + // frostprey, silver hawk\n                 sourceid == 2311006 || sourceid == 5220002 || + // summon dragon, wrath of the octopi\n                 sourceid == 5211001 || sourceid == 5211002); // octopus, gaviota\n     }\n-    \n+\n     public boolean isSkill() {\n         return skill;\n     }\n \n     public int getSourceId() {\n         return sourceid;\n     }\n-    \n+\n     public int getBuffSourceId() {\n         return skill ? sourceid : -sourceid;\n     }\n@@ -1589,52 +1656,51 @@ public boolean makeChanceResult() {\n     }\n \n     /*\n-    private static class CancelEffectAction implements Runnable {\n-\n-        private MapleStatEffect effect;\n-        private WeakReference<MapleCharacter> target;\n-        private long startTime;\n-\n-        public CancelEffectAction(MapleCharacter target, MapleStatEffect effect, long startTime) {\n-            this.effect = effect;\n-            this.target = new WeakReference<>(target);\n-            this.startTime = startTime;\n-        }\n-\n-        @Override\n-        public void run() {\n-            MapleCharacter realTarget = target.get();\n-            if (realTarget != null) {\n-                realTarget.cancelEffect(effect, false, startTime);\n-            }\n-        }\n-    }\n-    */\n-\n+     private static class CancelEffectAction implements Runnable {\n+\n+     private MapleStatEffect effect;\n+     private WeakReference<MapleCharacter> target;\n+     private long startTime;\n+\n+     public CancelEffectAction(MapleCharacter target, MapleStatEffect effect, long startTime) {\n+     this.effect = effect;\n+     this.target = new WeakReference<>(target);\n+     this.startTime = startTime;\n+     }\n+\n+     @Override\n+     public void run() {\n+     MapleCharacter realTarget = target.get();\n+     if (realTarget != null) {\n+     realTarget.cancelEffect(effect, false, startTime);\n+     }\n+     }\n+     }\n+     */\n     public short getHp() {\n         return hp;\n     }\n \n     public short getMp() {\n         return mp;\n     }\n-    \n+\n     public double getHpRate() {\n         return hpR;\n     }\n \n     public double getMpRate() {\n         return mpR;\n     }\n-    \n+\n     public byte getHpR() {\n         return mhpR;\n     }\n \n     public byte getMpR() {\n         return mmpR;\n     }\n-    \n+\n     public short getHpRRate() {\n         return mhpRRate;\n     }\n@@ -1654,7 +1720,7 @@ public short getMpCon() {\n     public short getMatk() {\n         return matk;\n     }\n-    \n+\n     public short getWatk() {\n         return watk;\n     }\n@@ -1714,4 +1780,4 @@ public int getCooldown() {\n     public Map<MonsterStatus, Integer> getMonsterStati() {\n         return monsterStatus;\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "00286db8df5375b9146e47ca6651c42a4fc5501a", "filename": "src/server/life/MapleMonster.java", "status": "modified", "additions": 377, "deletions": 327, "changes": 704, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/life/MapleMonster.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/life/MapleMonster.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/life/MapleMonster.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -75,6 +75,7 @@\n import server.maps.MapleSummon;\n \n public class MapleMonster extends AbstractLoadedMapleLife {\n+\n     private ChangeableStats ostats = null;  //unused, v83 WZs offers no support for changeable stats.\n     private MapleMonsterStats stats;\n     private AtomicInteger hp = new AtomicInteger(1);\n@@ -117,11 +118,11 @@ public MapleMonster(MapleMonster monster) {\n         super(monster);\n         initWithStats(monster.stats);\n     }\n-    \n+\n     public void lockMonster() {\n         externalLock.lock();\n     }\n-    \n+\n     public void unlockMonster() {\n         externalLock.unlock();\n     }\n@@ -131,7 +132,7 @@ private void initWithStats(MapleMonsterStats stats) {\n         this.stats = stats;\n         hp.set(stats.getHp());\n         mp = stats.getMp();\n-        \n+\n         maxHpPlusHeal.set(hp.get());\n     }\n \n@@ -142,84 +143,86 @@ public void disableDrops() {\n     public void enableDrops() {\n         this.dropsDisabled = false;\n     }\n-    \n+\n     public boolean dropsDisabled() {\n         return dropsDisabled;\n     }\n \n     public void setMap(MapleMap map) {\n         this.map = map;\n     }\n-    \n+\n     public int getParentMobOid() {\n         return parentMobOid;\n     }\n \n     public void setParentMobOid(int parentMobId) {\n         this.parentMobOid = parentMobId;\n     }\n-    \n+\n     public int countAvailableMobSummons(int limit, int skillLimit) {    // limit prop for summons has another conotation, found thanks to MedicOP\n         Set<Integer> calledOids = this.calledMobOids;\n-        if(calledOids != null) {\n+        if (calledOids != null) {\n             limit -= calledOids.size();\n         }\n-        \n+\n         return Math.min(limit, skillLimit - this.calledMobCount);\n     }\n-    \n+\n     public void addSummonedMob(MapleMonster mob) {\n         Set<Integer> calledOids = this.calledMobOids;\n         if (calledOids == null) {\n             calledOids = Collections.synchronizedSet(new HashSet<Integer>());\n             this.calledMobOids = calledOids;\n         }\n-        \n+\n         calledOids.add(mob.getObjectId());\n         mob.setSummonerMob(this);\n         this.calledMobCount += 1;\n     }\n-    \n+\n     private void removeSummonedMob(int mobOid) {\n         Set<Integer> calledOids = this.calledMobOids;\n         if (calledOids != null) {\n             calledOids.remove(mobOid);\n         }\n     }\n-    \n+\n     private void setSummonerMob(MapleMonster mob) {\n         this.callerMob = new WeakReference<>(mob);\n     }\n-    \n+\n     private void dispatchClearSummons() {\n         MapleMonster caller = this.callerMob.get();\n         if (caller != null) {\n             caller.removeSummonedMob(this.getObjectId());\n         }\n-        \n+\n         this.calledMobOids = null;\n     }\n-    \n+\n     public void pushRemoveAfterAction(Runnable run) {\n         this.removeAfterAction = run;\n     }\n-    \n+\n     public Runnable popRemoveAfterAction() {\n         Runnable r = this.removeAfterAction;\n         this.removeAfterAction = null;\n-        \n+\n         return r;\n     }\n-    \n+\n     public int getHp() {\n         return hp.get();\n     }\n-    \n+\n     public synchronized void addHp(int hp) {\n-        if(this.hp.get() <= 0) return;\n+        if (this.hp.get() <= 0) {\n+            return;\n+        }\n         this.hp.addAndGet(hp);\n     }\n-    \n+\n     public void setStartingHp(int hp) {\n         this.hp.set(hp);\n     }\n@@ -298,20 +301,22 @@ private byte getTagBgColor() {\n     public void setHpZero() {     // force HP = 0\n         applyAndGetHpDamage(Integer.MAX_VALUE, false);\n     }\n-    \n+\n     private boolean applyAnimationIfRoaming(int attackPos, MobSkill skill) {   // roam: not casting attack or skill animations\n-        if(!animationLock.tryLock()) return false;\n-    \n+        if (!animationLock.tryLock()) {\n+            return false;\n+        }\n+\n         try {\n             long animationTime;\n-        \n-            if(skill == null) {\n+\n+            if (skill == null) {\n                 animationTime = MapleMonsterInformationProvider.getInstance().getMobAttackAnimationTime(this.getId(), attackPos);\n             } else {\n                 animationTime = MapleMonsterInformationProvider.getInstance().getMobSkillAnimationTime(skill);\n             }\n \n-            if(animationTime > 0) {\n+            if (animationTime > 0) {\n                 return map.getChannelServer().registerMobOnAnimationEffect(map.getId(), this.hashCode(), animationTime);\n             } else {\n                 return true;\n@@ -320,37 +325,39 @@ private boolean applyAnimationIfRoaming(int attackPos, MobSkill skill) {   // ro\n             animationLock.unlock();\n         }\n     }\n-    \n+\n     public synchronized Integer applyAndGetHpDamage(int delta, boolean stayAlive) {\n         int curHp = hp.get();\n         if (curHp <= 0) {       // this monster is already dead\n             return null;\n         }\n-        \n-        if(delta >= 0) {\n-            if(stayAlive) curHp--;\n+\n+        if (delta >= 0) {\n+            if (stayAlive) {\n+                curHp--;\n+            }\n             int trueDamage = Math.min(curHp, delta);\n-            \n+\n             hp.addAndGet(-trueDamage);\n             return trueDamage;\n         } else {\n             int trueHeal = -delta;\n             int hp2Heal = curHp + trueHeal;\n             int maxHp = getMaxHp();\n-            \n+\n             if (hp2Heal > maxHp) {\n                 trueHeal -= (hp2Heal - maxHp);\n             }\n-            \n+\n             hp.addAndGet(trueHeal);\n             return trueHeal;\n         }\n     }\n-    \n+\n     public synchronized void disposeMapObject() {     // mob is no longer associated with the map it was in\n         hp.set(-1);\n     }\n-    \n+\n     public void broadcastMobHpBar(MapleCharacter from) {\n         if (hasBossHPBar()) {\n             from.setPlayerAggro(this.hashCode());\n@@ -370,39 +377,38 @@ public void broadcastMobHpBar(MapleCharacter from) {\n             }\n         }\n     }\n-    \n+\n     public boolean damage(MapleCharacter attacker, int damage, boolean stayAlive) {\n         boolean lastHit = false;\n-        \n+\n         this.lockMonster();\n         try {\n             if (!this.isAlive()) {\n                 return false;\n             }\n \n             /* pyramid not implemented\n-            Pair<Integer, Integer> cool = this.getStats().getCool();\n-            if (cool != null) {\n-                Pyramid pq = (Pyramid) chr.getPartyQuest();\n-                if (pq != null) {\n-                    if (damage > 0) {\n-                        if (damage >= cool.getLeft()) {\n-                            if ((Math.random() * 100) < cool.getRight()) {\n-                                pq.cool();\n-                            } else {\n-                                pq.kill();\n-                            }\n-                        } else {\n-                            pq.kill();\n-                        }\n-                    } else {\n-                        pq.miss();\n-                    }\n-                    killed = true;\n-                }\n-            }\n-            */\n-\n+             Pair<Integer, Integer> cool = this.getStats().getCool();\n+             if (cool != null) {\n+             Pyramid pq = (Pyramid) chr.getPartyQuest();\n+             if (pq != null) {\n+             if (damage > 0) {\n+             if (damage >= cool.getLeft()) {\n+             if ((Math.random() * 100) < cool.getRight()) {\n+             pq.cool();\n+             } else {\n+             pq.kill();\n+             }\n+             } else {\n+             pq.kill();\n+             }\n+             } else {\n+             pq.miss();\n+             }\n+             killed = true;\n+             }\n+             }\n+             */\n             if (damage > 0) {\n                 this.applyDamage(attacker, damage, stayAlive);\n                 if (!this.isAlive()) {  // monster just died\n@@ -412,10 +418,10 @@ public boolean damage(MapleCharacter attacker, int damage, boolean stayAlive) {\n         } finally {\n             this.unlockMonster();\n         }\n-        \n+\n         return lastHit;\n     }\n-    \n+\n     /**\n      *\n      * @param from the player that dealt the damage\n@@ -427,8 +433,10 @@ private void applyDamage(MapleCharacter from, int damage, boolean stayAlive) {\n         if (trueDamage == null) {\n             return;\n         }\n-        \n-        if(ServerConstants.USE_DEBUG) from.dropMessage(5, \"Hitted MOB \" + this.getId() + \", OID \" + this.getObjectId());\n+\n+        if (ServerConstants.USE_DEBUG) {\n+            from.dropMessage(5, \"Hitted MOB \" + this.getId() + \", OID \" + this.getObjectId());\n+        }\n         dispatchMonsterDamaged(from, trueDamage);\n \n         if (!takenDamage.containsKey(from.getId())) {\n@@ -439,20 +447,24 @@ private void applyDamage(MapleCharacter from, int damage, boolean stayAlive) {\n \n         broadcastMobHpBar(from);\n     }\n-    \n+\n     public void heal(int hp, int mp) {\n         Integer hpHealed = applyAndGetHpDamage(-hp, false);\n-        if(hpHealed == null) return;\n-        \n+        if (hpHealed == null) {\n+            return;\n+        }\n+\n         int mp2Heal = getMp() + mp;\n         int maxMp = getMaxMp();\n         if (mp2Heal >= maxMp) {\n             mp2Heal = maxMp;\n         }\n         setMp(mp2Heal);\n-        \n-        if(hp > 0) getMap().broadcastMessage(MaplePacketCreator.healMonster(getObjectId(), hp, getHp(), getMaxHp()));\n-        \n+\n+        if (hp > 0) {\n+            getMap().broadcastMessage(MaplePacketCreator.healMonster(getObjectId(), hp, getHp(), getMaxHp()));\n+        }\n+\n         maxHpPlusHeal.addAndGet(hpHealed);\n         dispatchMonsterHealed(hpHealed);\n     }\n@@ -464,24 +476,26 @@ public boolean isAttackedBy(MapleCharacter chr) {\n     private void distributeExperienceToParty(int pid, float exp, int killer, int killerLevel, Set<MapleCharacter> underleveled, int minThresholdLevel) {\n         List<MapleCharacter> members = new LinkedList<>();\n         MapleCharacter pchar = getMap().getAnyCharacterFromParty(pid);\n-        if(pchar != null) {\n-            for(MapleCharacter chr : pchar.getPartyMembersOnSameMap()) {\n+        if (pchar != null) {\n+            for (MapleCharacter chr : pchar.getPartyMembersOnSameMap()) {\n                 members.add(chr);\n             }\n         } else {\n             MapleCharacter chr = getMap().getCharacterById(killer);\n-            if(chr == null) return;\n-            \n+            if (chr == null) {\n+                return;\n+            }\n+\n             members.add(chr);\n         }\n-        \n+\n         List<MapleCharacter> expSharers = new LinkedList<>();\n         int expSharersLevel = 0;\n         for (MapleCharacter mc : members) {\n             if (mc.getLevel() >= minThresholdLevel) {    //NO EXP WILL BE GIVEN for those who are underleveled!\n                 if (Math.abs(killerLevel - mc.getLevel()) < ServerConstants.MIN_RANGELEVEL_TO_EXP_LEECH) {\n                     // thanks Thora for pointing out leech level limitation\n-                    \n+\n                     expSharersLevel += mc.getLevel();\n                     expSharers.add(mc);\n                 }\n@@ -505,38 +519,38 @@ private void distributeExperienceToParty(int pid, float exp, int killer, int kil\n     }\n \n     private int calcThresholdLevel(boolean isPqMob) {\n-        if(!ServerConstants.USE_ENFORCE_MOB_LEVEL_RANGE) {\n+        if (!ServerConstants.USE_ENFORCE_MOB_LEVEL_RANGE) {\n             return 0;\n         } else if (isPqMob) {\n             double thresholdLevel = getLevel();\n             thresholdLevel /= 32.55916838;\n             thresholdLevel = Math.log(thresholdLevel) / 0.02058204546;\n-            \n+\n             return (int) Math.ceil(thresholdLevel);\n         } else {\n             return getLevel() - (!isBoss() ? ServerConstants.MIN_UNDERLEVEL_TO_EXP_GAIN : 2 * ServerConstants.MIN_UNDERLEVEL_TO_EXP_GAIN);\n         }\n     }\n-    \n+\n     private void distributeExperience(int killerId) {\n         if (isAlive()) {\n             return;\n         }\n-        \n+\n         EventInstanceManager eim = getMap().getEventInstance();\n         int minThresholdLevel = calcThresholdLevel(eim != null), killerLevel = Integer.MAX_VALUE;\n         int exp = getExp();\n         long totalHealth = maxHpPlusHeal.get();\n         Map<Integer, Float> expDist = new HashMap<>();\n         Map<Integer, Float> partyExp = new HashMap<>();\n-        \n+\n         float exp8perHp = (0.8f * exp) / totalHealth;   // 80% of pool is split amongst all the damagers\n         float exp2 = (0.2f * exp);                      // 20% of pool goes to the killer or his/her party\n-        \n+\n         for (Entry<Integer, AtomicInteger> damage : takenDamage.entrySet()) {\n             expDist.put(damage.getKey(), exp8perHp * damage.getValue().get());\n         }\n-        \n+\n         Set<MapleCharacter> underleveled = new HashSet<>();\n         Collection<MapleCharacter> mapChrs = map.getCharacters();\n         for (MapleCharacter mc : mapChrs) {\n@@ -548,18 +562,18 @@ private void distributeExperience(int killerId) {\n                     if (eim != null) {\n                         eim.monsterKilled(mc, this);\n                     }\n-                    \n+\n                     killerLevel = mc.getLevel();\n                     xp += exp2;\n                 }\n-                \n+\n                 MapleParty p = mc.getParty();\n                 if (p != null) {\n                     int pID = p.getId();\n                     float pXP = xp + (partyExp.containsKey(pID) ? partyExp.get(pID) : 0);\n                     partyExp.put(pID, pXP);\n                 } else {\n-                    if(mc.getLevel() >= minThresholdLevel) {\n+                    if (mc.getLevel() >= minThresholdLevel) {\n                         //NO EXP WILL BE GIVEN for those who are underleveled!\n                         giveExpToCharacter(mc, xp, isKiller, 1);\n                     } else {\n@@ -568,10 +582,10 @@ private void distributeExperience(int killerId) {\n                 }\n             }\n         }\n-        \n-        if(!expDist.isEmpty()) {    // locate on world server the partyid of the missing characters\n+\n+        if (!expDist.isEmpty()) {    // locate on world server the partyid of the missing characters\n             World wserv = map.getWorldServer();\n-            \n+\n             for (Entry<Integer, Float> ed : expDist.entrySet()) {\n                 boolean isKiller = (ed.getKey() == killerId);\n                 float xp = ed.getValue();\n@@ -586,29 +600,29 @@ private void distributeExperience(int killerId) {\n                 }\n             }\n         }\n-        \n+\n         for (Entry<Integer, Float> party : partyExp.entrySet()) {\n             distributeExperienceToParty(party.getKey(), party.getValue(), killerId, killerLevel, underleveled, minThresholdLevel);\n         }\n-        \n-        for(MapleCharacter mc : underleveled) {\n+\n+        for (MapleCharacter mc : underleveled) {\n             mc.showUnderleveledInfo(this);\n         }\n     }\n \n     private void giveExpToCharacter(MapleCharacter attacker, float exp, boolean isKiller, int numExpSharers) {\n         //PARTY BONUS: 2p -> +2% , 3p -> +4% , 4p -> +6% , 5p -> +8% , 6p -> +10%\n         final float partyModifier = numExpSharers <= 1 ? 0.0f : 0.02f * (numExpSharers - 1);\n-        \n+\n         int partyExp = 0;\n         if (attacker.getHp() > 0) {\n             exp *= attacker.getExpRate();\n-            \n+\n             Integer expBonus = attacker.getBuffedValue(MapleBuffStat.EXP_INCREASE);\n             if (expBonus != null) {     // exp increase buff found thanks to HighKey21\n                 exp += expBonus;\n             }\n-            \n+\n             int personalExp = (int) exp;\n             if (exp <= Integer.MAX_VALUE) {  // assuming no negative xp here\n                 if (partyModifier > 0.0f) {\n@@ -630,7 +644,7 @@ private void giveExpToCharacter(MapleCharacter attacker, float exp, boolean isKi\n             } else {\n                 personalExp = Integer.MAX_VALUE;\n             }\n-            \n+\n             attacker.gainExp(personalExp, partyExp, true, false, isKiller);\n             attacker.increaseEquipExp(personalExp);\n             attacker.updateQuestMobCount(getId());\n@@ -639,7 +653,7 @@ private void giveExpToCharacter(MapleCharacter attacker, float exp, boolean isKi\n \n     public MapleCharacter killBy(final MapleCharacter killer) {\n         distributeExperience(killer != null ? killer.getId() : 0);\n-        \n+\n         final Pair<MapleCharacter, Boolean> lastController = aggroRemoveController();\n         final List<Integer> toSpawn = this.getRevives();\n         if (toSpawn != null) {\n@@ -669,22 +683,22 @@ public MapleCharacter killBy(final MapleCharacter killer) {\n                     }\n                 }\n             }\n-            \n-            if(toSpawn.size() > 0) {\n+\n+            if (toSpawn.size() > 0) {\n                 final EventInstanceManager eim = this.getMap().getEventInstance();\n-                \n+\n                 TimerManager.getInstance().schedule(new Runnable() {\n                     @Override\n                     public void run() {\n                         MapleCharacter controller = lastController.getLeft();\n                         boolean aggro = lastController.getRight();\n-                        \n+\n                         for (Integer mid : toSpawn) {\n                             final MapleMonster mob = MapleLifeFactory.getMonster(mid);\n                             mob.setPosition(getPosition());\n                             mob.setFh(getFh());\n                             mob.setParentMobOid(getObjectId());\n-                            \n+\n                             if (dropsDisabled()) {\n                                 mob.disableDrops();\n                             }\n@@ -693,30 +707,30 @@ public void run() {\n                             if (mob.getId() >= 8810010 && mob.getId() <= 8810017 && reviveMap.isHorntailDefeated()) {\n                                 boolean htKilled = false;\n                                 MapleMonster ht = reviveMap.getMonsterById(8810018);\n-                                \n-                                if(ht != null) {\n+\n+                                if (ht != null) {\n                                     ht.lockMonster();\n                                     try {\n                                         htKilled = ht.isAlive();\n                                         ht.setHpZero();\n                                     } finally {\n                                         ht.unlockMonster();\n                                     }\n-                                    \n-                                    if(htKilled) {\n+\n+                                    if (htKilled) {\n                                         reviveMap.killMonster(ht, killer, true);\n                                         ht.broadcastMobHpBar(killer);\n                                     }\n                                 }\n-                                \n-                                for(int i = 8810017; i >= 8810010; i--) {\n+\n+                                for (int i = 8810017; i >= 8810010; i--) {\n                                     reviveMap.killMonster(reviveMap.getMonsterById(i), killer, true);\n                                 }\n                             } else if (controller != null) {\n                                 mob.aggroSwitchController(controller, aggro);\n                             }\n-                            \n-                            if(eim != null) {\n+\n+                            if (eim != null) {\n                                 eim.reviveMonster(mob);\n                             }\n                         }\n@@ -726,32 +740,32 @@ public void run() {\n         } else {  // is this even necessary?\n             System.out.println(\"[CRITICAL LOSS] toSpawn is null for \" + this.getName());\n         }\n-        \n+\n         MapleCharacter looter = map.getCharacterById(getHighestDamagerId());\n         return looter != null ? looter : killer;\n     }\n-    \n+\n     private void dispatchUpdateQuestMobCount() {\n         Set<Integer> attackerChrids = takenDamage.keySet();\n-        if(!attackerChrids.isEmpty()) {\n+        if (!attackerChrids.isEmpty()) {\n             Map<Integer, MapleCharacter> mapChars = map.getMapPlayers();\n-            if(!mapChars.isEmpty()) {\n+            if (!mapChars.isEmpty()) {\n                 int mobid = getId();\n-                \n+\n                 for (Integer chrid : attackerChrids) {\n                     MapleCharacter chr = mapChars.get(chrid);\n \n-                    if(chr != null && chr.isLoggedinWorld()) {\n+                    if (chr != null && chr.isLoggedinWorld()) {\n                         chr.updateQuestMobCount(mobid);\n                     }\n                 }\n             }\n         }\n     }\n-    \n+\n     public void dispatchMonsterKilled(boolean hasKiller) {\n         processMonsterKilled(hasKiller);\n-        \n+\n         EventInstanceManager eim = getMap().getEventInstance();\n         if (eim != null) {\n             if (!this.getStats().isFriendly()) {\n@@ -761,27 +775,27 @@ public void dispatchMonsterKilled(boolean hasKiller) {\n             }\n         }\n     }\n-    \n+\n     private synchronized void processMonsterKilled(boolean hasKiller) {\n-        if(!hasKiller) {    // players won't gain EXP from a mob that has no killer, but a quest count they should\n+        if (!hasKiller) {    // players won't gain EXP from a mob that has no killer, but a quest count they should\n             dispatchUpdateQuestMobCount();\n         }\n-        \n+\n         this.aggroClearDamages();\n         this.dispatchClearSummons();\n-        \n+\n         MonsterListener[] listenersList;\n         statiLock.lock();\n         try {\n             listenersList = listeners.toArray(new MonsterListener[listeners.size()]);\n         } finally {\n             statiLock.unlock();\n         }\n-        \n+\n         for (MonsterListener listener : listenersList) {\n             listener.monsterKilled(getAnimationTime(\"die1\"));\n         }\n-        \n+\n         statiLock.lock();\n         try {\n             stati.clear();\n@@ -791,7 +805,7 @@ private synchronized void processMonsterKilled(boolean hasKiller) {\n             statiLock.unlock();\n         }\n     }\n-    \n+\n     private void dispatchMonsterDamaged(MapleCharacter from, int trueDmg) {\n         MonsterListener[] listenersList;\n         statiLock.lock();\n@@ -800,12 +814,12 @@ private void dispatchMonsterDamaged(MapleCharacter from, int trueDmg) {\n         } finally {\n             statiLock.unlock();\n         }\n-        \n+\n         for (MonsterListener listener : listenersList) {\n             listener.monsterDamaged(from, trueDmg);\n         }\n     }\n-    \n+\n     private void dispatchMonsterHealed(int trueHeal) {\n         MonsterListener[] listenersList;\n         statiLock.lock();\n@@ -814,7 +828,7 @@ private void dispatchMonsterHealed(int trueHeal) {\n         } finally {\n             statiLock.unlock();\n         }\n-        \n+\n         for (MonsterListener listener : listenersList) {\n             listener.monsterHealed(trueHeal);\n         }\n@@ -835,7 +849,7 @@ public int getHighestDamagerId() {\n     public boolean isAlive() {\n         return this.hp.get() > 0;\n     }\n-    \n+\n     public void addListener(MonsterListener listener) {\n         statiLock.lock();\n         try {\n@@ -852,23 +866,27 @@ public MapleCharacter getController() {\n     private void setController(MapleCharacter controller) {\n         this.controller = new WeakReference<>(controller);\n     }\n-    \n+\n     public boolean isControllerHasAggro() {\n         return fake ? false : controllerHasAggro;\n     }\n \n     private void setControllerHasAggro(boolean controllerHasAggro) {\n-        if (!fake) this.controllerHasAggro = controllerHasAggro;\n+        if (!fake) {\n+            this.controllerHasAggro = controllerHasAggro;\n+        }\n     }\n \n     public boolean isControllerKnowsAboutAggro() {\n         return fake ? false : controllerKnowsAboutAggro;\n     }\n \n     private void setControllerKnowsAboutAggro(boolean controllerKnowsAboutAggro) {\n-        if (!fake) this.controllerKnowsAboutAggro = controllerKnowsAboutAggro;\n+        if (!fake) {\n+            this.controllerKnowsAboutAggro = controllerKnowsAboutAggro;\n+        }\n     }\n-    \n+\n     private void setControllerHasPuppet(boolean controllerHasPuppet) {\n         this.controllerHasPuppet = controllerHasPuppet;\n     }\n@@ -880,7 +898,7 @@ private void setControllerHasPuppet(boolean controllerHasPuppet) {\n     public boolean hasBossHPBar() {\n         return isBoss() && getTagColor() > 0;\n     }\n-    \n+\n     @Override\n     public void sendSpawnData(MapleClient client) {\n         if (hp.get() <= 0) { // mustn't monsterLock this function\n@@ -891,7 +909,7 @@ public void sendSpawnData(MapleClient client) {\n         } else {\n             client.announce(MaplePacketCreator.spawnMonster(this, false));\n         }\n-        \n+\n         statiLock.lock();\n         try {\n             if (stati.size() > 0) {\n@@ -902,7 +920,7 @@ public void sendSpawnData(MapleClient client) {\n         } finally {\n             statiLock.unlock();\n         }\n-        \n+\n         if (hasBossHPBar()) {\n             client.announceBossHpBar(this, this.hashCode(), makeBossHPBarPacket());\n         }\n@@ -931,10 +949,10 @@ public ElementalEffectiveness getElementalEffectiveness(Element e) {\n         } finally {\n             statiLock.unlock();\n         }\n-        \n+\n         return getMonsterEffectiveness(e);\n     }\n-    \n+\n     private ElementalEffectiveness getMonsterEffectiveness(Element e) {\n         monsterLock.lock();\n         try {\n@@ -946,31 +964,31 @@ private ElementalEffectiveness getMonsterEffectiveness(Element e) {\n \n     private MapleCharacter getActiveController() {\n         MapleCharacter chr = getController();\n-        \n+\n         if (chr != null && chr.isLoggedinWorld() && chr.getMap() == this.getMap()) {\n             return chr;\n         } else {\n             return null;\n         }\n     }\n-    \n+\n     private void broadcastMonsterStatusMessage(byte[] packet) {\n         map.broadcastMessage(packet, getPosition());\n-        \n+\n         MapleCharacter chrController = getActiveController();\n         if (chrController != null && !chrController.isMapObjectVisible(MapleMonster.this)) {\n             chrController.announce(packet);\n         }\n     }\n-    \n+\n     private int broadcastStatusEffect(final MonsterStatusEffect status) {\n         int animationTime = status.getSkill().getAnimationTime();\n         byte[] packet = MaplePacketCreator.applyMonsterStatus(getObjectId(), status, null);\n         broadcastMonsterStatusMessage(packet);\n-        \n+\n         return animationTime;\n     }\n-    \n+\n     public boolean applyStatus(MapleCharacter from, final MonsterStatusEffect status, boolean poison, long duration) {\n         return applyStatus(from, status, poison, duration, false);\n     }\n@@ -1020,7 +1038,7 @@ public boolean applyStatus(MapleCharacter from, final MonsterStatusEffect status\n \n         final Channel ch = map.getChannelServer();\n         final int mapid = map.getId();\n-        if(statis.size() > 0) {\n+        if (statis.size() > 0) {\n             statiLock.lock();\n             try {\n                 for (MonsterStatus stat : statis.keySet()) {\n@@ -1036,7 +1054,7 @@ public boolean applyStatus(MapleCharacter from, final MonsterStatusEffect status\n                 statiLock.unlock();\n             }\n         }\n-        \n+\n         final Runnable cancelTask = new Runnable() {\n \n             @Override\n@@ -1045,7 +1063,7 @@ public void run() {\n                     byte[] packet = MaplePacketCreator.cancelMonsterStatus(getObjectId(), status.getStati());\n                     broadcastMonsterStatusMessage(packet);\n                 }\n-                \n+\n                 statiLock.lock();\n                 try {\n                     for (MonsterStatus stat : status.getStati().keySet()) {\n@@ -1054,21 +1072,21 @@ public void run() {\n                 } finally {\n                     statiLock.unlock();\n                 }\n-                \n+\n                 setVenomMulti(0);\n             }\n         };\n-        \n+\n         Runnable overtimeAction = null;\n         int overtimeDelay = -1;\n-        \n+\n         int animationTime;\n         if (poison) {\n             int poisonLevel = from.getSkillLevel(status.getSkill());\n             int poisonDamage = Math.min(Short.MAX_VALUE, (int) (getMaxHp() / (70.0 - poisonLevel) + 0.999));\n             status.setValue(MonsterStatus.POISON, Integer.valueOf(poisonDamage));\n             animationTime = broadcastStatusEffect(status);\n-            \n+\n             overtimeAction = new DamageTask(poisonDamage, from, status, 0);\n             overtimeDelay = 1000;\n         } else if (venom) {\n@@ -1095,35 +1113,35 @@ public void run() {\n                 status.setValue(MonsterStatus.VENOMOUS_WEAPON, Integer.valueOf(poisonDamage));\n                 status.setValue(MonsterStatus.POISON, Integer.valueOf(poisonDamage));\n                 animationTime = broadcastStatusEffect(status);\n-                \n+\n                 overtimeAction = new DamageTask(poisonDamage, from, status, 0);\n                 overtimeDelay = 1000;\n             } else {\n                 return false;\n             }\n             /*\n-        } else if (status.getSkill().getId() == Hermit.SHADOW_WEB || status.getSkill().getId() == NightWalker.SHADOW_WEB) { //Shadow Web\n-            int webDamage = (int) (getMaxHp() / 50.0 + 0.999);\n-            status.setValue(MonsterStatus.SHADOW_WEB, Integer.valueOf(webDamage));\n-            animationTime = broadcastStatusEffect(status);\n+             } else if (status.getSkill().getId() == Hermit.SHADOW_WEB || status.getSkill().getId() == NightWalker.SHADOW_WEB) { //Shadow Web\n+             int webDamage = (int) (getMaxHp() / 50.0 + 0.999);\n+             status.setValue(MonsterStatus.SHADOW_WEB, Integer.valueOf(webDamage));\n+             animationTime = broadcastStatusEffect(status);\n             \n-            overtimeAction = new DamageTask(webDamage, from, status, 1);\n-            overtimeDelay = 3500;\n-            */\n+             overtimeAction = new DamageTask(webDamage, from, status, 1);\n+             overtimeDelay = 3500;\n+             */\n         } else if (status.getSkill().getId() == 4121004 || status.getSkill().getId() == 4221004) { // Ninja Ambush\n             final Skill skill = SkillFactory.getSkill(status.getSkill().getId());\n             final byte level = from.getSkillLevel(skill);\n             final int damage = (int) ((from.getStr() + from.getLuk()) * ((3.7 * skill.getEffect(level).getDamage()) / 100));\n-            \n+\n             status.setValue(MonsterStatus.NINJA_AMBUSH, Integer.valueOf(damage));\n             animationTime = broadcastStatusEffect(status);\n-            \n+\n             overtimeAction = new DamageTask(damage, from, status, 2);\n             overtimeDelay = 1000;\n         } else {\n             animationTime = broadcastStatusEffect(status);\n         }\n-        \n+\n         statiLock.lock();\n         try {\n             for (MonsterStatus stat : status.getStati().keySet()) {\n@@ -1133,10 +1151,23 @@ public void run() {\n         } finally {\n             statiLock.unlock();\n         }\n-        \n+\n         ch.registerMobStatus(mapid, status, cancelTask, duration + animationTime - 100, overtimeAction, overtimeDelay);\n         return true;\n     }\n+    \n+    public final void dispelSkill(final MobSkill skillId) {\n+        List<MonsterStatus> toCancel = new ArrayList<MonsterStatus>();\n+        for (Entry<MonsterStatus, MonsterStatusEffect> effects : stati.entrySet()) {\n+            MonsterStatusEffect mse = effects.getValue();\n+            if (mse.getMobSkill() != null && mse.getMobSkill().getSkillId() == skillId.getSkillId()) { //not checking for level.\n+                toCancel.add(effects.getKey());\n+            }\n+        }\n+        for (MonsterStatus stat : toCancel) {\n+            debuffMobStat(stat);\n+        }\n+    }\n \n     public void applyMonsterBuff(final Map<MonsterStatus, Integer> stats, final int x, int skillId, long duration, MobSkill skill, final List<Integer> reflection) {\n         final Runnable cancelTask = new Runnable() {\n@@ -1146,7 +1177,7 @@ public void run() {\n                 if (isAlive()) {\n                     byte[] packet = MaplePacketCreator.cancelMonsterStatus(getObjectId(), stats);\n                     broadcastMonsterStatusMessage(packet);\n-                    \n+\n                     statiLock.lock();\n                     try {\n                         for (final MonsterStatus stat : stats.keySet()) {\n@@ -1161,7 +1192,7 @@ public void run() {\n         final MonsterStatusEffect effect = new MonsterStatusEffect(stats, null, skill, true);\n         byte[] packet = MaplePacketCreator.applyMonsterStatus(getObjectId(), effect, reflection);\n         broadcastMonsterStatusMessage(packet);\n-        \n+\n         statiLock.lock();\n         try {\n             for (MonsterStatus stat : stats.keySet()) {\n@@ -1171,21 +1202,21 @@ public void run() {\n         } finally {\n             statiLock.unlock();\n         }\n-        \n+\n         map.getChannelServer().registerMobStatus(map.getId(), effect, cancelTask, duration);\n     }\n-    \n+\n     public void refreshMobPosition() {\n         resetMobPosition(getPosition());\n     }\n-    \n+\n     public void resetMobPosition(Point newPoint) {\n         aggroRemoveController();\n-        \n+\n         setPosition(newPoint);\n         map.broadcastMessage(MaplePacketCreator.moveMonster(this.getObjectId(), false, -1, 0, 0, 0, this.getPosition(), this.getIdleMovement()));\n         map.moveMonster(this, this.getPosition());\n-        \n+\n         aggroUpdateController();\n     }\n \n@@ -1197,36 +1228,44 @@ private void debuffMobStat(MonsterStatus stat) {\n         } finally {\n             statiLock.unlock();\n         }\n-        \n+\n         if (oldEffect != null) {\n             byte[] packet = MaplePacketCreator.cancelMonsterStatus(getObjectId(), oldEffect.getStati());\n             broadcastMonsterStatusMessage(packet);\n         }\n     }\n-    \n+\n     public void debuffMob(int skillid) {\n         MonsterStatus[] statups = {MonsterStatus.WEAPON_ATTACK_UP, MonsterStatus.WEAPON_DEFENSE_UP, MonsterStatus.MAGIC_ATTACK_UP, MonsterStatus.MAGIC_DEFENSE_UP};\n         statiLock.lock();\n         try {\n-            if(skillid == Hermit.SHADOW_MESO) {\n+            if (skillid == Hermit.SHADOW_MESO) {\n                 debuffMobStat(statups[1]);\n                 debuffMobStat(statups[3]);\n-            } else if(skillid == Priest.DISPEL) {\n-                for(MonsterStatus ms : statups) {\n+            } else if (skillid == Priest.DISPEL) {\n+                for (MonsterStatus ms : statups) {\n                     debuffMobStat(ms);\n                 }\n             } else {    // is a crash skill\n                 int i = (skillid == Crusader.ARMOR_CRASH ? 1 : (skillid == WhiteKnight.MAGIC_CRASH ? 2 : 0));\n                 debuffMobStat(statups[i]);\n \n-                if(ServerConstants.USE_ANTI_IMMUNITY_CRASH) {\n+                if (ServerConstants.USE_ANTI_IMMUNITY_CRASH) {\n                     if (skillid == Crusader.ARMOR_CRASH) {\n-                        if(!isBuffed(MonsterStatus.WEAPON_REFLECT)) debuffMobStat(MonsterStatus.WEAPON_IMMUNITY);\n-                        if(!isBuffed(MonsterStatus.MAGIC_REFLECT)) debuffMobStat(MonsterStatus.MAGIC_IMMUNITY);\n+                        if (!isBuffed(MonsterStatus.WEAPON_REFLECT)) {\n+                            debuffMobStat(MonsterStatus.WEAPON_IMMUNITY);\n+                        }\n+                        if (!isBuffed(MonsterStatus.MAGIC_REFLECT)) {\n+                            debuffMobStat(MonsterStatus.MAGIC_IMMUNITY);\n+                        }\n                     } else if (skillid == WhiteKnight.MAGIC_CRASH) {\n-                        if(!isBuffed(MonsterStatus.MAGIC_REFLECT)) debuffMobStat(MonsterStatus.MAGIC_IMMUNITY);\n+                        if (!isBuffed(MonsterStatus.MAGIC_REFLECT)) {\n+                            debuffMobStat(MonsterStatus.MAGIC_IMMUNITY);\n+                        }\n                     } else {\n-                        if(!isBuffed(MonsterStatus.WEAPON_REFLECT)) debuffMobStat(MonsterStatus.WEAPON_IMMUNITY);\n+                        if (!isBuffed(MonsterStatus.WEAPON_REFLECT)) {\n+                            debuffMobStat(MonsterStatus.WEAPON_IMMUNITY);\n+                        }\n                     }\n                 }\n             }\n@@ -1265,84 +1304,83 @@ public boolean isFake() {\n     public MapleMap getMap() {\n         return map;\n     }\n-    \n+\n     public MapleMonsterAggroCoordinator getMapAggroCoordinator() {\n         return map.getAggroCoordinator();\n     }\n-    \n+\n     public List<Pair<Integer, Integer>> getSkills() {\n         return stats.getSkills();\n     }\n \n     public boolean hasSkill(int skillId, int level) {\n         return stats.hasSkill(skillId, level);\n     }\n-    \n+\n     public int getSkillPos(int skillId, int level) {\n         int pos = 0;\n         for (Pair<Integer, Integer> ms : this.getSkills()) {\n             if (ms.getLeft() == skillId && ms.getRight() == level) {\n                 return pos;\n             }\n-            \n+\n             pos++;\n         }\n-        \n+\n         return -1;\n     }\n-    \n+\n     public boolean canUseSkill(MobSkill toUse) {\n         if (toUse == null) {\n             return false;\n         }\n-        \n+\n         int useSkillid = toUse.getSkillId();\n         if (useSkillid >= 143 && useSkillid <= 145) {\n             if (this.isBuffed(MonsterStatus.WEAPON_REFLECT) || this.isBuffed(MonsterStatus.MAGIC_REFLECT)) {\n                 return false;\n             }\n         }\n-        \n+\n         monsterLock.lock();\n         try {\n             /*\n-            for (Pair<Integer, Integer> skill : usedSkills) {\n-                if (skill.getLeft() == useSkillid && skill.getRight() == toUse.getSkillLevel()) {\n-                    return false;\n-                }\n-            }\n-            */\n-            \n+             for (Pair<Integer, Integer> skill : usedSkills) {\n+             if (skill.getLeft() == useSkillid && skill.getRight() == toUse.getSkillLevel()) {\n+             return false;\n+             }\n+             }\n+             */\n+\n             int mpCon = toUse.getMpCon();\n             if (mp < mpCon) {\n                 return false;\n             }\n-            \n+\n             /*\n-            if (!this.applyAnimationIfRoaming(-1, toUse)) {\n-                return false;\n-            }\n-            */\n-            \n+             if (!this.applyAnimationIfRoaming(-1, toUse)) {\n+             return false;\n+             }\n+             */\n             this.usedSkill(toUse);\n         } finally {\n             monsterLock.unlock();\n         }\n-        \n+\n         return true;\n     }\n \n     private void usedSkill(MobSkill skill) {\n         final int skillId = skill.getSkillId(), level = skill.getSkillLevel();\n         long cooltime = skill.getCoolTime();\n-        \n+\n         monsterLock.lock();\n         try {\n             mp -= skill.getMpCon();\n-            \n+\n             Pair<Integer, Integer> skillKey = new Pair<>(skillId, level);\n             this.usedSkills.add(skillKey);\n-            \n+\n             Integer useCount = this.skillsUsed.remove(skillKey);\n             if (useCount != null) {\n                 this.skillsUsed.put(skillKey, useCount + 1);\n@@ -1352,7 +1390,7 @@ private void usedSkill(MobSkill skill) {\n         } finally {\n             monsterLock.unlock();\n         }\n-        \n+\n         final MapleMonster mons = this;\n         MapleMap mmap = mons.getMap();\n         Runnable r = new Runnable() {\n@@ -1361,7 +1399,7 @@ public void run() {\n                 mons.clearSkill(skillId, level);\n             }\n         };\n-        \n+\n         mmap.getChannelServer().registerMobClearSkillAction(mmap.getId(), r, cooltime);\n     }\n \n@@ -1382,39 +1420,38 @@ private void clearSkill(int skillId, int level) {\n             monsterLock.unlock();\n         }\n     }\n-    \n+\n     public int canUseAttack(int attackPos, boolean isSkill) {\n         monsterLock.lock();\n         try {\n             /*\n-            if (usedAttacks.contains(attackPos)) {\n-                return -1;\n-            }\n-            */\n-            \n+             if (usedAttacks.contains(attackPos)) {\n+             return -1;\n+             }\n+             */\n+\n             Pair<Integer, Integer> attackInfo = MapleMonsterInformationProvider.getInstance().getMobAttackInfo(this.getId(), attackPos);\n             if (attackInfo == null) {\n                 return -1;\n             }\n-            \n+\n             int mpCon = attackInfo.getLeft();\n             if (mp < mpCon) {\n                 return -1;\n             }\n-            \n+\n             /*\n-            if (!this.applyAnimationIfRoaming(attackPos, null)) {\n-                return -1;\n-            }\n-            */\n-            \n+             if (!this.applyAnimationIfRoaming(attackPos, null)) {\n+             return -1;\n+             }\n+             */\n             usedAttack(attackPos, mpCon, attackInfo.getRight());\n             return 1;\n         } finally {\n             monsterLock.unlock();\n         }\n     }\n-    \n+\n     private void usedAttack(final int attackPos, int mpCon, int cooltime) {\n         monsterLock.lock();\n         try {\n@@ -1435,7 +1472,7 @@ public void run() {\n             monsterLock.unlock();\n         }\n     }\n-    \n+\n     private void clearAttack(int attackPos) {\n         monsterLock.lock();\n         try {\n@@ -1444,7 +1481,7 @@ private void clearAttack(int attackPos) {\n             monsterLock.unlock();\n         }\n     }\n-    \n+\n     public int getNoSkills() {\n         return this.stats.getNoSkills();\n     }\n@@ -1476,11 +1513,11 @@ private DamageTask(int dealDamage, MapleCharacter chr, MonsterStatusEffect statu\n         @Override\n         public void run() {\n             int curHp = hp.get();\n-            if(curHp <= 1) {\n+            if (curHp <= 1) {\n                 map.getChannelServer().interruptMobStatus(map.getId(), status);\n                 return;\n             }\n-            \n+\n             int damage = dealDamage;\n             if (damage >= curHp) {\n                 damage = curHp - 1;\n@@ -1495,11 +1532,11 @@ public void run() {\n                 } finally {\n                     unlockMonster();\n                 }\n-                \n+\n                 if (type == 1) {\n                     map.broadcastMessage(MaplePacketCreator.damageMonster(getObjectId(), damage), getPosition());\n                 } else if (type == 2) {\n-                    if(damage < dealDamage) {    // ninja ambush (type 2) is already displaying DOT to the caster\n+                    if (damage < dealDamage) {    // ninja ambush (type 2) is already displaying DOT to the caster\n                         map.broadcastMessage(MaplePacketCreator.damageMonster(getObjectId(), damage), getPosition());\n                     }\n                 }\n@@ -1526,7 +1563,7 @@ public void setTempEffectiveness(Element e, ElementalEffectiveness ee, long mill\n             final ElementalEffectiveness fEE = stats.getEffectiveness(e);\n             if (!fEE.equals(ElementalEffectiveness.WEAK)) {\n                 stats.setEffectiveness(e, ee);\n-                \n+\n                 MapleMap mmap = this.getMap();\n                 Runnable r = new Runnable() {\n                     @Override\n@@ -1540,7 +1577,7 @@ public void run() {\n                         }\n                     }\n                 };\n-                \n+\n                 mmap.getChannelServer().registerMobClearSkillAction(mmap.getId(), r, milli);\n             }\n         } finally {\n@@ -1581,7 +1618,7 @@ public int getPADamage() {\n             statiLock.unlock();\n         }\n     }\n-    \n+\n     public MonsterStatusEffect getStati(MonsterStatus ms) {\n         statiLock.lock();\n         try {\n@@ -1590,11 +1627,10 @@ public MonsterStatusEffect getStati(MonsterStatus ms) {\n             statiLock.unlock();\n         }\n     }\n-    \n+\n     // ---- one can always have fun trying these pieces of codes below in-game rofl ----\n-    \n     public final ChangeableStats getChangedStats() {\n-\treturn ostats;\n+        return ostats;\n     }\n \n     public final int getMobMaxHp() {\n@@ -1603,13 +1639,13 @@ public final int getMobMaxHp() {\n         }\n         return stats.getHp();\n     }\n-    \n+\n     public final void setOverrideStats(final OverrideMonsterStats ostats) {\n         this.ostats = new ChangeableStats(stats, ostats);\n         this.hp.set(ostats.getHp());\n         this.mp = ostats.getMp();\n     }\n-\t\n+\n     public final void changeLevel(final int newLevel) {\n         changeLevel(newLevel, true);\n     }\n@@ -1622,31 +1658,36 @@ public final void changeLevel(final int newLevel, boolean pqMob) {\n         this.hp.set(ostats.getHp());\n         this.mp = ostats.getMp();\n     }\n-    \n+\n     private float getDifficultyRate(final int difficulty) {\n-        switch(difficulty) {\n-            case 6: return(7.7f);\n-            case 5: return(5.6f);\n-            case 4: return(3.2f);\n-            case 3: return(2.1f);\n-            case 2: return(1.4f);\n+        switch (difficulty) {\n+            case 6:\n+                return (7.7f);\n+            case 5:\n+                return (5.6f);\n+            case 4:\n+                return (3.2f);\n+            case 3:\n+                return (2.1f);\n+            case 2:\n+                return (1.4f);\n         }\n-        \n-        return(1.0f);\n+\n+        return (1.0f);\n     }\n-    \n+\n     private void changeLevelByDifficulty(final int difficulty, boolean pqMob) {\n-        changeLevel((int)(this.getLevel() * getDifficultyRate(difficulty)), pqMob);\n+        changeLevel((int) (this.getLevel() * getDifficultyRate(difficulty)), pqMob);\n     }\n-    \n+\n     public final void changeDifficulty(final int difficulty, boolean pqMob) {\n         changeLevelByDifficulty(difficulty, pqMob);\n     }\n-    \n+\n     private boolean isPuppetInVicinity(MapleSummon summon) {\n         return summon.getPosition().distanceSq(this.getPosition()) < 177777;\n     }\n-    \n+\n     public boolean isCharacterPuppetInVicinity(MapleCharacter chr) {\n         MapleStatEffect mse = chr.getBuffEffect(MapleBuffStat.PUPPET);\n         if (mse != null) {\n@@ -1661,31 +1702,31 @@ public boolean isCharacterPuppetInVicinity(MapleCharacter chr) {\n                 map.getAggroCoordinator().removePuppetAggro(chr.getId());\n             }\n         }\n-        \n+\n         return false;\n     }\n-    \n+\n     public boolean isLeadingPuppetInVicinity() {\n         MapleCharacter chrController = this.getActiveController();\n-        \n+\n         if (chrController != null) {\n             if (this.isCharacterPuppetInVicinity(chrController)) {\n                 return true;\n             }\n         }\n-        \n+\n         return false;\n     }\n-    \n+\n     private MapleCharacter getNextControllerCandidate() {\n         int mincontrolled = Integer.MAX_VALUE;\n         MapleCharacter newController = null;\n-        \n+\n         int mincontrolleddead = Integer.MAX_VALUE;\n         MapleCharacter newControllerDead = null;\n-        \n+\n         MapleCharacter newControllerWithPuppet = null;\n-        \n+\n         for (MapleCharacter chr : getMap().getAllPlayers()) {\n             if (!chr.isHidden()) {\n                 int ctrlMonsSize = chr.getNumControlledMonsters();\n@@ -1706,7 +1747,7 @@ private MapleCharacter getNextControllerCandidate() {\n                 }\n             }\n         }\n-        \n+\n         if (newControllerWithPuppet != null) {\n             return newControllerWithPuppet;\n         } else if (newController != null) {\n@@ -1715,39 +1756,39 @@ private MapleCharacter getNextControllerCandidate() {\n             return newControllerDead;\n         }\n     }\n-    \n+\n     /**\n      * Removes controllability status from the current controller of this mob.\n-     * \n+     *\n      */\n     private Pair<MapleCharacter, Boolean> aggroRemoveController() {\n         MapleCharacter chrController;\n         boolean hadAggro;\n-        \n+\n         aggroUpdateLock.lock();\n         try {\n             chrController = getActiveController();\n             hadAggro = isControllerHasAggro();\n-            \n+\n             this.setController(null);\n             this.setControllerHasAggro(false);\n             this.setControllerKnowsAboutAggro(false);\n         } finally {\n             aggroUpdateLock.unlock();\n         }\n-        \n+\n         if (chrController != null) { // this can/should only happen when a hidden gm attacks the monster\n             chrController.announce(MaplePacketCreator.stopControllingMonster(this.getObjectId()));\n             chrController.stopControllingMonster(this);\n         }\n-        \n+\n         return new Pair<>(chrController, hadAggro);\n     }\n-    \n+\n     /**\n      * Pass over the mob controllability and updates aggro status on the new\n      * player controller.\n-     * \n+     *\n      */\n     public void aggroSwitchController(MapleCharacter newController, boolean immediateAggro) {\n         if (aggroUpdateLock.tryLock()) {\n@@ -1756,90 +1797,90 @@ public void aggroSwitchController(MapleCharacter newController, boolean immediat\n                 if (prevController == newController) {\n                     return;\n                 }\n-                \n+\n                 aggroRemoveController();\n                 if (!(newController != null && newController.isLoggedinWorld() && newController.getMap() == this.getMap())) {\n                     return;\n                 }\n-                \n+\n                 this.setController(newController);\n                 this.setControllerHasAggro(immediateAggro);\n                 this.setControllerKnowsAboutAggro(false);\n                 this.setControllerHasPuppet(false);\n             } finally {\n                 aggroUpdateLock.unlock();\n             }\n-            \n+\n             this.aggroUpdatePuppetVisibility();\n             newController.announce(MaplePacketCreator.controlMonster(this, false, immediateAggro));\n             newController.controlMonster(this);\n         }\n     }\n-    \n+\n     public void aggroAddPuppet(MapleCharacter player) {\n         MapleMonsterAggroCoordinator mmac = map.getAggroCoordinator();\n         mmac.addPuppetAggro(player);\n-        \n+\n         aggroUpdatePuppetController(player);\n-        \n+\n         if (this.isControllerHasAggro()) {\n             this.aggroUpdatePuppetVisibility();\n         }\n     }\n-    \n+\n     public void aggroRemovePuppet(MapleCharacter player) {\n         MapleMonsterAggroCoordinator mmac = map.getAggroCoordinator();\n         mmac.removePuppetAggro(player.getId());\n-        \n+\n         aggroUpdatePuppetController(null);\n-        \n+\n         if (this.isControllerHasAggro()) {\n             this.aggroUpdatePuppetVisibility();\n         }\n     }\n-    \n+\n     /**\n      * Automagically finds a new controller for the given monster from the chars\n      * on the map it is from...\n-     * \n+     *\n      */\n     public void aggroUpdateController() {\n         MapleCharacter chrController = this.getActiveController();\n         if (chrController != null && chrController.isAlive()) {\n             return;\n         }\n-        \n+\n         MapleCharacter newController = getNextControllerCandidate();\n         if (newController == null) {    // was a new controller found? (if not no one is on the map)\n             return;\n         }\n-        \n+\n         this.aggroSwitchController(newController, false);\n     }\n-    \n+\n     /**\n-     * Finds a new controller for the given monster from the chars with deployed puppet\n-     * nearby on the map it is from...\n-     * \n+     * Finds a new controller for the given monster from the chars with deployed\n+     * puppet nearby on the map it is from...\n+     *\n      */\n     private void aggroUpdatePuppetController(MapleCharacter newController) {\n         MapleCharacter chrController = this.getActiveController();\n         boolean updateController = false;\n-        \n+\n         if (chrController != null && chrController.isAlive()) {\n             if (isCharacterPuppetInVicinity(chrController)) {\n                 return;\n             }\n         } else {\n             updateController = true;\n         }\n-        \n+\n         if (newController == null || !isCharacterPuppetInVicinity(newController)) {\n             MapleMonsterAggroCoordinator mmac = map.getAggroCoordinator();\n-            \n+\n             List<Integer> puppetOwners = mmac.getPuppetAggroList();\n             List<Integer> toRemovePuppets = new LinkedList<>();\n-        \n+\n             for (Integer cid : puppetOwners) {\n                 MapleCharacter chr = map.getCharacterById(cid);\n \n@@ -1856,35 +1897,35 @@ private void aggroUpdatePuppetController(MapleCharacter newController) {\n             for (Integer cid : toRemovePuppets) {\n                 mmac.removePuppetAggro(cid);\n             }\n-            \n+\n             if (newController == null) {    // was a new controller found? (if not there's no puppet nearby)\n                 if (updateController) {\n                     aggroUpdateController();\n                 }\n-                \n+\n                 return;\n             }\n         } else if (chrController == newController) {\n             this.aggroUpdatePuppetVisibility();\n         }\n-        \n+\n         this.aggroSwitchController(newController, this.isControllerHasAggro());\n     }\n-    \n+\n     /**\n      * Ensures controllability removal of the current player controller, and\n      * fetches for any player on the map to start controlling in place.\n-     * \n+     *\n      */\n     public void aggroRedirectController() {\n         this.aggroRemoveController();   // don't care if new controller not found, at least remove current controller\n         this.aggroUpdateController();\n     }\n-    \n+\n     /**\n      * Returns the current aggro status on the specified player, or null if the\n      * specified player is currently not this mob's controller.\n-     * \n+     *\n      */\n     public Boolean aggroMoveLifeUpdate(MapleCharacter player) {\n         MapleCharacter chrController = getController();\n@@ -1893,37 +1934,37 @@ public Boolean aggroMoveLifeUpdate(MapleCharacter player) {\n             if (aggro) {\n                 this.setControllerKnowsAboutAggro(true);\n             }\n-            \n+\n             return aggro;\n         } else {\n             return null;\n         }\n     }\n-    \n+\n     /**\n      * Refreshes auto aggro for the player passed as parameter, does nothing if\n      * there is already an active controller for this mob.\n-     * \n+     *\n      */\n     public void aggroAutoAggroUpdate(MapleCharacter player) {\n         MapleCharacter chrController = this.getActiveController();\n-        \n+\n         if (chrController == null) {\n             this.aggroSwitchController(player, true);\n         } else if (chrController.getId() == player.getId()) {\n             this.setControllerHasAggro(true);\n         }\n     }\n-    \n+\n     /**\n-     * Applied damage input for this mob, enough damage taken implies\n-     * an aggro target update for the attacker shortly.\n-     * \n+     * Applied damage input for this mob, enough damage taken implies an aggro\n+     * target update for the attacker shortly.\n+     *\n      */\n     public void aggroMonsterDamage(MapleCharacter attacker, int damage) {\n         MapleMonsterAggroCoordinator mmac = this.getMapAggroCoordinator();\n         mmac.addAggroDamage(this, attacker.getId(), damage);\n-        \n+\n         MapleCharacter chrController = this.getController();    // aggro based on DPS rather than first-come-first-served, now live after suggestions thanks to MedicOP, Thora, Vcoc\n         if (chrController != attacker) {\n             if (this.getMapAggroCoordinator().isLeadingCharacterAggro(this, attacker)) {\n@@ -1932,53 +1973,57 @@ public void aggroMonsterDamage(MapleCharacter attacker, int damage) {\n                 this.setControllerHasAggro(true);\n                 this.aggroUpdatePuppetVisibility();\n             }\n-            \n+\n             /*\n-            For some reason, some mobs loses aggro on controllers if other players also attacks them.\n-            Maybe it was intended by Nexon to interchange controllers at every attack...\n+             For some reason, some mobs loses aggro on controllers if other players also attacks them.\n+             Maybe it was intended by Nexon to interchange controllers at every attack...\n             \n-            else if (chrController != null) {\n-                chrController.announce(MaplePacketCreator.stopControllingMonster(this.getObjectId()));\n-                chrController.announce(MaplePacketCreator.controlMonster(this, false, true));\n-            }\n-            */\n+             else if (chrController != null) {\n+             chrController.announce(MaplePacketCreator.stopControllingMonster(this.getObjectId()));\n+             chrController.announce(MaplePacketCreator.controlMonster(this, false, true));\n+             }\n+             */\n         } else {\n             this.setControllerHasAggro(true);\n             this.aggroUpdatePuppetVisibility();\n         }\n     }\n-    \n+\n     private void aggroRefreshPuppetVisibility(MapleCharacter chrController, MapleSummon puppet) {\n         // lame patch for client to redirect all aggro to the puppet\n-        \n+\n         List<MapleMonster> puppetControlled = new LinkedList<>();\n         for (MapleMonster mob : chrController.getControlledMonsters()) {\n             if (mob.isPuppetInVicinity(puppet)) {\n                 puppetControlled.add(mob);\n             }\n         }\n-        \n+\n         for (MapleMonster mob : puppetControlled) {\n             chrController.announce(MaplePacketCreator.stopControllingMonster(mob.getObjectId()));\n         }\n         chrController.announce(MaplePacketCreator.removeSummon(puppet, false));\n-        \n+\n         for (MapleMonster mob : puppetControlled) {\n             chrController.announce(MaplePacketCreator.controlMonster(mob, false, mob.isControllerHasAggro()));\n         }\n         chrController.announce(MaplePacketCreator.spawnSummon(puppet, false));\n     }\n-    \n+\n     public void aggroUpdatePuppetVisibility() {\n-        if (!availablePuppetUpdate) return;\n-        \n+        if (!availablePuppetUpdate) {\n+            return;\n+        }\n+\n         availablePuppetUpdate = false;\n         Runnable r = new Runnable() {\n             @Override\n             public void run() {\n                 try {\n                     MapleCharacter chrController = MapleMonster.this.getActiveController();\n-                    if (chrController == null) return;\n+                    if (chrController == null) {\n+                        return;\n+                    }\n \n                     MapleStatEffect puppetEffect = chrController.getBuffEffect(MapleBuffStat.PUPPET);\n                     if (puppetEffect != null) {\n@@ -2002,22 +2047,23 @@ public void run() {\n                 }\n             }\n         };\n-        \n+\n         // had to schedule this since mob wouldn't stick to puppet aggro who knows why\n         this.getMap().getChannelServer().registerOverallAction(this.getMap().getId(), r, ServerConstants.UPDATE_INTERVAL);\n     }\n-    \n+\n     /**\n-     * Clears all applied damage input for this mob, doesn't refresh target aggro.\n-     * \n+     * Clears all applied damage input for this mob, doesn't refresh target\n+     * aggro.\n+     *\n      */\n     public void aggroClearDamages() {\n         this.getMapAggroCoordinator().removeAggroEntries(this);\n     }\n \n     /**\n      * Clears this mob aggro on the current controller.\n-     * \n+     *\n      */\n     public void aggroResetAggro() {\n         aggroUpdateLock.lock();\n@@ -2028,12 +2074,12 @@ public void aggroResetAggro() {\n             aggroUpdateLock.unlock();\n         }\n     }\n-    \n+\n     public void dispose() {\n         this.getMap().dismissRemoveAfter(this);\n         disposeLocks();\n     }\n-    \n+\n     private void disposeLocks() {\n         LockCollector.getInstance().registerDisposeAction(new Runnable() {\n             @Override\n@@ -2042,11 +2088,15 @@ public void run() {\n             }\n         });\n     }\n-    \n+\n     private void emptyLocks() {\n         externalLock = externalLock.dispose();\n         monsterLock = monsterLock.dispose();\n         statiLock = statiLock.dispose();\n         animationLock = animationLock.dispose();\n     }\n+\n+    public final int getRemoveAfter() {\n+        return stats.removeAfter();\n+    }\n }"}, {"sha": "4854d125be31c2d38918d9e19a8f6d4aa7586370", "filename": "src/server/life/MapleMonsterInformationProvider.java", "status": "modified", "additions": 292, "deletions": 290, "changes": 582, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/life/MapleMonsterInformationProvider.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/life/MapleMonsterInformationProvider.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/life/MapleMonsterInformationProvider.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -44,306 +44,308 @@\n import tools.Randomizer;\n \n public class MapleMonsterInformationProvider {\n-\t// Author : LightPepsi\n-\n-\tprivate static final MapleMonsterInformationProvider instance = new MapleMonsterInformationProvider();\n-        \n-        public static MapleMonsterInformationProvider getInstance() {\n-\t\treturn instance;\n-\t}\n-        \n-        private final Map<Integer, List<MonsterDropEntry>> drops = new HashMap<>();\n-\tprivate final List<MonsterGlobalDropEntry> globaldrops = new ArrayList<>();\n-        private final Map<Integer, List<MonsterGlobalDropEntry>> continentdrops = new HashMap<>();\n-        \n-        private final Map<Integer, List<Integer>> dropsChancePool = new HashMap<>();    // thanks to ronan\n-        private final Set<Integer> hasNoMultiEquipDrops = new HashSet<>();\n-        private final Map<Integer, List<MonsterDropEntry>> extraMultiEquipDrops = new HashMap<>();\n-        \n-        private final Map<Pair<Integer, Integer>, Integer> mobAttackAnimationTime = new HashMap<>();\n-        private final Map<MobSkill, Integer> mobSkillAnimationTime = new HashMap<>();\n-        \n-        private final Map<Integer, Pair<Integer, Integer>> mobAttackInfo = new HashMap<>();\n-        \n-        private final Map<Integer, Boolean> mobBossCache = new HashMap<>();\n-        private final Map<Integer, String> mobNameCache = new HashMap<>();\n-\n-\tprotected MapleMonsterInformationProvider() {\n-\t\tretrieveGlobal();\n-\t}\n-        \n-        public final List<MonsterGlobalDropEntry> getRelevantGlobalDrops(int mapid) {\n-                int continentid = mapid / 100000000;\n-            \n-                List<MonsterGlobalDropEntry> contiItems = continentdrops.get(continentid);\n-                if (contiItems == null) {   // continent separated global drops found thanks to marcuswoon\n-                    contiItems = new ArrayList<>();\n-                    \n-                    for (MonsterGlobalDropEntry e : globaldrops) {\n-                        if (e.continentid < 0 || e.continentid == continentid) {\n-                            contiItems.add(e);\n-                        }\n+    // Author : LightPepsi\n+\n+    private static final MapleMonsterInformationProvider instance = new MapleMonsterInformationProvider();\n+\n+    public static MapleMonsterInformationProvider getInstance() {\n+        return instance;\n+    }\n+\n+    private final Map<Integer, List<MonsterDropEntry>> drops = new HashMap<>();\n+    private final List<MonsterGlobalDropEntry> globaldrops = new ArrayList<>();\n+    private final Map<Integer, List<MonsterGlobalDropEntry>> continentdrops = new HashMap<>();\n+\n+    private final Map<Integer, List<Integer>> dropsChancePool = new HashMap<>();    // thanks to ronan\n+    private final Set<Integer> hasNoMultiEquipDrops = new HashSet<>();\n+    private final Map<Integer, List<MonsterDropEntry>> extraMultiEquipDrops = new HashMap<>();\n+\n+    private final Map<Pair<Integer, Integer>, Integer> mobAttackAnimationTime = new HashMap<>();\n+    private final Map<MobSkill, Integer> mobSkillAnimationTime = new HashMap<>();\n+\n+    private final Map<Integer, Pair<Integer, Integer>> mobAttackInfo = new HashMap<>();\n+\n+    private final Map<Integer, Boolean> mobBossCache = new HashMap<>();\n+    private final Map<Integer, String> mobNameCache = new HashMap<>();\n+\n+    protected MapleMonsterInformationProvider() {\n+        retrieveGlobal();\n+    }\n+\n+    public final List<MonsterGlobalDropEntry> getRelevantGlobalDrops(int mapid) {\n+        int continentid = mapid / 100000000;\n+\n+        List<MonsterGlobalDropEntry> contiItems = continentdrops.get(continentid);\n+        if (contiItems == null) {   // continent separated global drops found thanks to marcuswoon\n+            contiItems = new ArrayList<>();\n+\n+            for (MonsterGlobalDropEntry e : globaldrops) {\n+                if (e.continentid < 0 || e.continentid == continentid) {\n+                    contiItems.add(e);\n+                }\n+            }\n+\n+            continentdrops.put(continentid, contiItems);\n+        }\n+\n+        return contiItems;\n+    }\n+\n+    private void retrieveGlobal() {\n+        PreparedStatement ps = null;\n+        ResultSet rs = null;\n+        Connection con = null;\n+\n+        try {\n+            con = DatabaseConnection.getConnection();\n+            ps = con.prepareStatement(\"SELECT * FROM drop_data_global WHERE chance > 0\");\n+            rs = ps.executeQuery();\n+\n+            while (rs.next()) {\n+                globaldrops.add(\n+                        new MonsterGlobalDropEntry(\n+                                rs.getInt(\"itemid\"),\n+                                rs.getInt(\"chance\"),\n+                                rs.getByte(\"continent\"),\n+                                rs.getInt(\"minimum_quantity\"),\n+                                rs.getInt(\"maximum_quantity\"),\n+                                rs.getShort(\"questid\")));\n+            }\n+\n+            rs.close();\n+            ps.close();\n+            con.close();\n+        } catch (SQLException e) {\n+            System.err.println(\"Error retrieving drop\" + e);\n+        } finally {\n+            try {\n+                if (ps != null && !ps.isClosed()) {\n+                    ps.close();\n+                }\n+                if (rs != null && !rs.isClosed()) {\n+                    rs.close();\n+                }\n+                if (con != null && !con.isClosed()) {\n+                    con.close();\n+                }\n+            } catch (SQLException ignore) {\n+                ignore.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    public List<MonsterDropEntry> retrieveEffectiveDrop(final int monsterId) {\n+        // this reads the drop entries searching for multi-equip, properly processing them\n+\n+        List<MonsterDropEntry> list = retrieveDrop(monsterId);\n+        if (hasNoMultiEquipDrops.contains(monsterId) || !ServerConstants.USE_MULTIPLE_SAME_EQUIP_DROP) {\n+            return list;\n+        }\n+\n+        List<MonsterDropEntry> multiDrops = extraMultiEquipDrops.get(monsterId), extra = new LinkedList<>();\n+        if (multiDrops == null) {\n+            multiDrops = new LinkedList<>();\n+\n+            for (MonsterDropEntry mde : list) {\n+                if (ItemConstants.isEquipment(mde.itemId) && mde.Maximum > 1) {\n+                    multiDrops.add(mde);\n+\n+                    int rnd = Randomizer.rand(mde.Minimum, mde.Maximum);\n+                    for (int i = 0; i < rnd - 1; i++) {\n+                        extra.add(mde);   // this passes copies of the equips' MDE with min/max quantity > 1, but idc it'll be unused anyways\n                     }\n-                    \n-                    continentdrops.put(continentid, contiItems);\n                 }\n-                \n-\t\treturn contiItems;\n-\t}\n-\n-\tprivate void retrieveGlobal() {\n-\t\tPreparedStatement ps = null;\n-\t\tResultSet rs = null;\n-                Connection con = null;\n-\n-\t\ttry {\n-                        con = DatabaseConnection.getConnection();\n-\t\t\tps = con.prepareStatement(\"SELECT * FROM drop_data_global WHERE chance > 0\");\n-\t\t\trs = ps.executeQuery();\n-\n-\t\t\twhile (rs.next()) {\n-\t\t\t\tglobaldrops.add(\n-\t\t\t\t\t\tnew MonsterGlobalDropEntry(\n-\t\t\t\t\t\t\t\trs.getInt(\"itemid\"),\n-\t\t\t\t\t\t\t\trs.getInt(\"chance\"),\n-\t\t\t\t\t\t\t\trs.getByte(\"continent\"),\n-\t\t\t\t\t\t\t\trs.getInt(\"minimum_quantity\"),\n-\t\t\t\t\t\t\t\trs.getInt(\"maximum_quantity\"),\n-\t\t\t\t\t\t\t\trs.getShort(\"questid\")));\n-\t\t\t}\n-                        \n-\t\t\trs.close();\n-\t\t\tps.close();\n-                        con.close();\n-\t\t} catch (SQLException e) {\n-                        System.err.println(\"Error retrieving drop\" + e);\n-\t\t} finally {\n-\t\t\ttry {\n-\t\t\t\tif (ps != null && !ps.isClosed()) { \n-\t\t\t\t\tps.close();\n-\t\t\t\t}\n-\t\t\t\tif (rs != null && !rs.isClosed()) {\n-\t\t\t\t\trs.close();\n-\t\t\t\t}\n-                                if (con != null && !con.isClosed()) {\n-\t\t\t\t\tcon.close();\n-\t\t\t\t}\n-\t\t\t} catch (SQLException ignore) {\n-                                ignore.printStackTrace();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-        public List<MonsterDropEntry> retrieveEffectiveDrop(final int monsterId) {\n-                // this reads the drop entries searching for multi-equip, properly processing them\n-            \n-                List<MonsterDropEntry> list = retrieveDrop(monsterId);\n-                if (hasNoMultiEquipDrops.contains(monsterId) || !ServerConstants.USE_MULTIPLE_SAME_EQUIP_DROP) {\n-\t\t\treturn list;\n-\t\t}\n-                \n-                List<MonsterDropEntry> multiDrops = extraMultiEquipDrops.get(monsterId), extra = new LinkedList<>();\n-                if(multiDrops == null) {\n-                        multiDrops = new LinkedList<>();\n-                        \n-                        for(MonsterDropEntry mde : list) {\n-                                if(ItemConstants.isEquipment(mde.itemId) && mde.Maximum > 1) {\n-                                        multiDrops.add(mde);\n-                                    \n-                                        int rnd = Randomizer.rand(mde.Minimum, mde.Maximum);\n-                                        for(int i = 0; i < rnd - 1; i++) {\n-                                                extra.add(mde);   // this passes copies of the equips' MDE with min/max quantity > 1, but idc it'll be unused anyways\n-                                        }\n-                                }\n-                        }\n-                        \n-                        if(!multiDrops.isEmpty()) extraMultiEquipDrops.put(monsterId, multiDrops);\n-                        else hasNoMultiEquipDrops.add(monsterId);\n-                } else {\n-                        for(MonsterDropEntry mde : multiDrops) {\n-                                int rnd = Randomizer.rand(mde.Minimum, mde.Maximum);\n-                                for(int i = 0; i < rnd - 1; i++) {\n-                                        extra.add(mde);\n-                                }\n-                        }\n+            }\n+\n+            if (!multiDrops.isEmpty()) {\n+                extraMultiEquipDrops.put(monsterId, multiDrops);\n+            } else {\n+                hasNoMultiEquipDrops.add(monsterId);\n+            }\n+        } else {\n+            for (MonsterDropEntry mde : multiDrops) {\n+                int rnd = Randomizer.rand(mde.Minimum, mde.Maximum);\n+                for (int i = 0; i < rnd - 1; i++) {\n+                    extra.add(mde);\n                 }\n-                \n-                List<MonsterDropEntry> ret = new LinkedList<>(list);\n-                ret.addAll(extra);\n-                \n-                return ret;\n+            }\n         }\n-        \n-\tpublic final List<MonsterDropEntry> retrieveDrop(final int monsterId) {\n-\t\tif (drops.containsKey(monsterId)) {\n-\t\t\treturn drops.get(monsterId);\n-\t\t}\n-\t\tfinal List<MonsterDropEntry> ret = new LinkedList<>();\n-\n-\t\tPreparedStatement ps = null;\n-\t\tResultSet rs = null;\n-                Connection con = null;\n-\t\ttry {\n-                        con = DatabaseConnection.getConnection();\n-\t\t\tps = con.prepareStatement(\"SELECT itemid, chance, minimum_quantity, maximum_quantity, questid FROM drop_data WHERE dropperid = ?\");\n-\t\t\tps.setInt(1, monsterId);\n-\t\t\trs = ps.executeQuery();\n-\n-\t\t\twhile (rs.next()) {\n-\t\t\t\tret.add(\n-                                    new MonsterDropEntry(\n-                                        rs.getInt(\"itemid\"),\n-                                        rs.getInt(\"chance\"),\n-                                        rs.getInt(\"minimum_quantity\"),\n-                                        rs.getInt(\"maximum_quantity\"),\n-                                        rs.getShort(\"questid\")));\n-\t\t\t}\n-                        \n+\n+        List<MonsterDropEntry> ret = new LinkedList<>(list);\n+        ret.addAll(extra);\n+\n+        return ret;\n+    }\n+\n+    public final List<MonsterDropEntry> retrieveDrop(final int monsterId) {\n+        if (drops.containsKey(monsterId)) {\n+            return drops.get(monsterId);\n+        }\n+        final List<MonsterDropEntry> ret = new LinkedList<>();\n+\n+        if (monsterId >= 9300127 && monsterId <= 9300136 || monsterId >= 9300315 && monsterId <= 9300324) {\n+            int dropArray[] = {2022157, 2022158, 2022159, 2022160, 2022161, 2022162, 2022163, 2022164, 2022165, 2022166, 2022167, 2022168, 2022169, 2022170, 2022171, 2022172, 2022173, 2022174, 2022175, 2022176, 2022177, 2022178, 4001129}; //These are the drops, -1 means meso :D\n+            for (int id : dropArray) {\n+                ret.add(new MonsterDropEntry(id, 2000, 1, 1, (short) 0));\n+            }\n+        } else {\n+            PreparedStatement ps = null;\n+            ResultSet rs = null;\n+            Connection con = null;\n+            try {\n+                con = DatabaseConnection.getConnection();\n+                ps = con.prepareStatement(\"SELECT itemid, chance, minimum_quantity, maximum_quantity, questid FROM drop_data WHERE dropperid = ?\");\n+                ps.setInt(1, monsterId);\n+                rs = ps.executeQuery();\n+\n+                while (rs.next()) {\n+                    ret.add(new MonsterDropEntry(rs.getInt(\"itemid\"), rs.getInt(\"chance\"), rs.getInt(\"minimum_quantity\"), rs.getInt(\"maximum_quantity\"), rs.getShort(\"questid\")));\n+                }\n+\n+                con.close();\n+            } catch (SQLException e) {\n+                e.printStackTrace();\n+                return ret;\n+            } finally {\n+                try {\n+                    if (ps != null && !ps.isClosed()) {\n+                        ps.close();\n+                    }\n+                    if (rs != null && !rs.isClosed()) {\n+                        rs.close();\n+                    }\n+                    if (con != null && !con.isClosed()) {\n                         con.close();\n-\t\t} catch (SQLException e) {\n-                        e.printStackTrace();\n-\t\t\treturn ret;\n-\t\t} finally {\n-\t\t\ttry {\n-\t\t\t\tif (ps != null && !ps.isClosed()) {\n-\t\t\t\t\tps.close();\n-\t\t\t\t}\n-\t\t\t\tif (rs != null && !rs.isClosed()) {\n-\t\t\t\t\trs.close();\n-\t\t\t\t}\n-                                if (con != null && !con.isClosed()) {\n-\t\t\t\t\tcon.close();\n-\t\t\t\t}\n-\t\t\t} catch (SQLException ignore) {\n-                                ignore.printStackTrace();\n-\t\t\t\treturn ret;\n-\t\t\t}\n-\t\t}\n-\t\tdrops.put(monsterId, ret);\n-\t\treturn ret;\n-\t}\n-        \n-        public final List<Integer> retrieveDropPool(final int monsterId) {  // ignores Quest and Party Quest items\n-\t\tif (dropsChancePool.containsKey(monsterId)) {\n-\t\t\treturn dropsChancePool.get(monsterId);\n-\t\t}\n-                \n-                MapleItemInformationProvider ii = MapleItemInformationProvider.getInstance();\n-                \n-                List<MonsterDropEntry> dropList = retrieveDrop(monsterId);\n-\t\tList<Integer> ret = new ArrayList<>();\n-                \n-                int accProp = 0;\n-                for(MonsterDropEntry mde : dropList) {\n-                        if(!ii.isQuestItem(mde.itemId) && !ii.isPartyQuestItem(mde.itemId)) {\n-                                accProp += mde.chance;\n-                        }\n-\n-                        ret.add(accProp);\n+                    }\n+                } catch (SQLException ignore) {\n+                    ignore.printStackTrace();\n+                    return ret;\n                 }\n-                \n-\t\tif(accProp == 0) ret.clear();    // don't accept mobs dropping no relevant items\n-                \n-                dropsChancePool.put(monsterId, ret);\n-\t\treturn ret;\n-\t}\n-        \n-        public final void setMobAttackAnimationTime(int monsterId, int attackPos, int animationTime) {\n-                mobAttackAnimationTime.put(new Pair<>(monsterId, attackPos), animationTime);\n+            }\n+        }\n+        drops.put(monsterId, ret);\n+        return ret;\n+    }\n+\n+    public final List<Integer> retrieveDropPool(final int monsterId) {  // ignores Quest and Party Quest items\n+        if (dropsChancePool.containsKey(monsterId)) {\n+            return dropsChancePool.get(monsterId);\n+        }\n+\n+        MapleItemInformationProvider ii = MapleItemInformationProvider.getInstance();\n+\n+        List<MonsterDropEntry> dropList = retrieveDrop(monsterId);\n+        List<Integer> ret = new ArrayList<>();\n+\n+        int accProp = 0;\n+        for (MonsterDropEntry mde : dropList) {\n+            if (!ii.isQuestItem(mde.itemId) && !ii.isPartyQuestItem(mde.itemId)) {\n+                accProp += mde.chance;\n+            }\n+\n+            ret.add(accProp);\n+        }\n+\n+        if (accProp == 0) {\n+            ret.clear();    // don't accept mobs dropping no relevant items\n         }\n-        \n-        public final Integer getMobAttackAnimationTime(int monsterId, int attackPos) {\n-                Integer time = mobAttackAnimationTime.get(new Pair<>(monsterId, attackPos));\n-                return time == null ? 0 : time;\n+        dropsChancePool.put(monsterId, ret);\n+        return ret;\n+    }\n+\n+    public final void setMobAttackAnimationTime(int monsterId, int attackPos, int animationTime) {\n+        mobAttackAnimationTime.put(new Pair<>(monsterId, attackPos), animationTime);\n+    }\n+\n+    public final Integer getMobAttackAnimationTime(int monsterId, int attackPos) {\n+        Integer time = mobAttackAnimationTime.get(new Pair<>(monsterId, attackPos));\n+        return time == null ? 0 : time;\n+    }\n+\n+    public final void setMobSkillAnimationTime(MobSkill skill, int animationTime) {\n+        mobSkillAnimationTime.put(skill, animationTime);\n+    }\n+\n+    public final Integer getMobSkillAnimationTime(MobSkill skill) {\n+        Integer time = mobSkillAnimationTime.get(skill);\n+        return time == null ? 0 : time;\n+    }\n+\n+    public final void setMobAttackInfo(int monsterId, int attackPos, int mpCon, int coolTime) {\n+        mobAttackInfo.put((monsterId << 3) + attackPos, new Pair<>(mpCon, coolTime));\n+    }\n+\n+    public final Pair<Integer, Integer> getMobAttackInfo(int monsterId, int attackPos) {\n+        if (attackPos < 0 || attackPos > 7) {\n+            return null;\n         }\n-        \n-        public final void setMobSkillAnimationTime(MobSkill skill, int animationTime) {\n-                mobSkillAnimationTime.put(skill, animationTime);\n+        return mobAttackInfo.get((monsterId << 3) + attackPos);\n+    }\n+\n+    public static ArrayList<Pair<Integer, String>> getMobsIDsFromName(String search) {\n+        MapleDataProvider dataProvider = MapleDataProviderFactory.getDataProvider(new File(\"wz/String.wz\"));\n+        ArrayList<Pair<Integer, String>> retMobs = new ArrayList<Pair<Integer, String>>();\n+        MapleData data = dataProvider.getData(\"Mob.img\");\n+        List<Pair<Integer, String>> mobPairList = new LinkedList<Pair<Integer, String>>();\n+        for (MapleData mobIdData : data.getChildren()) {\n+            int mobIdFromData = Integer.parseInt(mobIdData.getName());\n+            String mobNameFromData = MapleDataTool.getString(mobIdData.getChildByPath(\"name\"), \"NO-NAME\");\n+            mobPairList.add(new Pair<Integer, String>(mobIdFromData, mobNameFromData));\n         }\n-        \n-        public final Integer getMobSkillAnimationTime(MobSkill skill) {\n-                Integer time = mobSkillAnimationTime.get(skill);\n-                return time == null ? 0 : time;\n+        for (Pair<Integer, String> mobPair : mobPairList) {\n+            if (mobPair.getRight().toLowerCase().contains(search.toLowerCase())) {\n+                retMobs.add(mobPair);\n+            }\n         }\n-        \n-        public final void setMobAttackInfo(int monsterId, int attackPos, int mpCon, int coolTime) {\n-                mobAttackInfo.put((monsterId << 3) + attackPos, new Pair<>(mpCon, coolTime));\n+        return retMobs;\n+    }\n+\n+    public boolean isBoss(int id) {\n+        Boolean boss = mobBossCache.get(id);\n+        if (boss == null) {\n+            try {\n+                boss = MapleLifeFactory.getMonster(id).isBoss();\n+            } catch (NullPointerException npe) {\n+                boss = false;\n+            } catch (Exception e) {   //nonexistant mob\n+                boss = false;\n+\n+                e.printStackTrace();\n+                System.err.println(\"Nonexistant mob id \" + id);\n+            }\n+\n+            mobBossCache.put(id, boss);\n         }\n-        \n-        public final Pair<Integer, Integer> getMobAttackInfo(int monsterId, int attackPos) {\n-                if (attackPos < 0 || attackPos > 7) return null;\n-                return mobAttackInfo.get((monsterId << 3) + attackPos);\n+\n+        return boss;\n+    }\n+\n+    public String getMobNameFromId(int id) {\n+        String mobName = mobNameCache.get(id);\n+        if (mobName == null) {\n+            try {\n+                mobName = MapleLifeFactory.getMonster(id).getName();\n+            } catch (NullPointerException npe) {\n+                mobName = \"\"; //nonexistant mob\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+                System.err.println(\"Nonexistant mob id \" + id);\n+                mobName = \"\"; //nonexistant mob\n+            }\n+\n+            mobNameCache.put(id, mobName);\n         }\n \n-\tpublic static ArrayList<Pair<Integer, String>> getMobsIDsFromName(String search) {\n-\t\tMapleDataProvider dataProvider = MapleDataProviderFactory.getDataProvider(new File(\"wz/String.wz\"));\n-\t\tArrayList<Pair<Integer, String>> retMobs = new ArrayList<Pair<Integer, String>>();\n-\t\tMapleData data = dataProvider.getData(\"Mob.img\");\n-\t\tList<Pair<Integer, String>> mobPairList = new LinkedList<Pair<Integer, String>>();\n-\t\tfor (MapleData mobIdData : data.getChildren()) {\n-\t\t\tint mobIdFromData = Integer.parseInt(mobIdData.getName());\n-\t\t\tString mobNameFromData = MapleDataTool.getString(mobIdData.getChildByPath(\"name\"), \"NO-NAME\");\n-\t\t\tmobPairList.add(new Pair<Integer, String>(mobIdFromData, mobNameFromData));\n-\t\t}\n-\t\tfor (Pair<Integer, String> mobPair : mobPairList) {\n-\t\t\tif (mobPair.getRight().toLowerCase().contains(search.toLowerCase())) {\n-\t\t\t\tretMobs.add(mobPair);\n-\t\t\t}\n-\t\t}\n-\t\treturn retMobs;\n-\t}\n-\n-        public boolean isBoss(int id) {\n-                Boolean boss = mobBossCache.get(id);\n-                if (boss == null) {\n-                        try {\n-                                boss = MapleLifeFactory.getMonster(id).isBoss();\n-                        } catch (NullPointerException npe) {\n-                                boss = false;\n-                        } catch (Exception e) {   //nonexistant mob\n-                                boss = false;\n-                                \n-                                e.printStackTrace();\n-                                System.err.println(\"Nonexistant mob id \" + id);\n-                        }\n-                        \n-                        mobBossCache.put(id, boss);\n-                }\n-                \n-                return boss;\n-\t}\n-        \n-\tpublic String getMobNameFromId(int id) {\n-                String mobName = mobNameCache.get(id);\n-                if (mobName == null) {\n-                        try\n-                        {\n-                                mobName = MapleLifeFactory.getMonster(id).getName();\n-                        } \n-                        catch (NullPointerException npe)\n-                        {\n-                                mobName = \"\"; //nonexistant mob\n-                        }\n-                        catch (Exception e)\n-                        {\n-                                e.printStackTrace();\n-                                System.err.println(\"Nonexistant mob id \" + id);\n-                                mobName = \"\"; //nonexistant mob\n-                        }\n-                        \n-                        mobNameCache.put(id, mobName);\n-                }\n-                \n-                return mobName;\n-\t}\n-\n-\tpublic final void clearDrops() {\n-\t\tdrops.clear();\n-                hasNoMultiEquipDrops.clear();\n-                extraMultiEquipDrops.clear();\n-                dropsChancePool.clear();\n-\t\tglobaldrops.clear();\n-\t\tcontinentdrops.clear();\n-\t\tretrieveGlobal();\n-\t}\n-}\n\\ No newline at end of file\n+        return mobName;\n+    }\n+\n+    public final void clearDrops() {\n+        drops.clear();\n+        hasNoMultiEquipDrops.clear();\n+        extraMultiEquipDrops.clear();\n+        dropsChancePool.clear();\n+        globaldrops.clear();\n+        continentdrops.clear();\n+        retrieveGlobal();\n+    }\n+}"}, {"sha": "03606d2e5ee3820d4d63e7bab47bf35b9ecc6761", "filename": "src/server/life/MobSkill.java", "status": "modified", "additions": 106, "deletions": 99, "changes": 205, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/life/MobSkill.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/life/MobSkill.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/life/MobSkill.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -1,24 +1,24 @@\n /*\n-\tThis file is part of the OdinMS Maple Story Server\n-    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n-\t\t       Matthias Butz <matze@odinms.de>\n-\t\t       Jan Christian Meyer <vimes@odinms.de>\n-\n-    This program is free software: you can redistribute it and/or modify\n-    it under the terms of the GNU Affero General Public License as\n-    published by the Free Software Foundation version 3 as published by\n-    the Free Software Foundation. You may not use, modify or distribute\n-    this program under any other version of the GNU Affero General Public\n-    License.\n-\n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU Affero General Public License for more details.\n-\n-    You should have received a copy of the GNU Affero General Public License\n-    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-*/\n+ This file is part of the OdinMS Maple Story Server\n+ Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n+ Matthias Butz <matze@odinms.de>\n+ Jan Christian Meyer <vimes@odinms.de>\n+\n+ This program is free software: you can redistribute it and/or modify\n+ it under the terms of the GNU Affero General Public License as\n+ published by the Free Software Foundation version 3 as published by\n+ the Free Software Foundation. You may not use, modify or distribute\n+ this program under any other version of the GNU Affero General Public\n+ License.\n+\n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU Affero General Public License for more details.\n+\n+ You should have received a copy of the GNU Affero General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n package server.life;\n \n import java.awt.Point;\n@@ -44,6 +44,7 @@\n  * @author Danny (Leifde)\n  */\n public class MobSkill {\n+\n     private int skillId, skillLevel, mpCon;\n     private List<Integer> toSummon = new ArrayList<Integer>();\n     private int spawnEffect, hp, x, y;\n@@ -106,17 +107,17 @@ public void setLimit(int limit) {\n \n     public void applyDelayedEffect(final MapleCharacter player, final MapleMonster monster, final boolean skill, int animationTime) {\n         Runnable toRun = new Runnable() {\n-                            @Override\n-                            public void run() {\n-                                if(monster.isAlive()) {\n-                                    applyEffect(player, monster, skill, null);\n-                                }\n-                            }\n-                        };\n-        \n+            @Override\n+            public void run() {\n+                if (monster.isAlive()) {\n+                    applyEffect(player, monster, skill, null);\n+                }\n+            }\n+        };\n+\n         monster.getMap().getChannelServer().registerOverallAction(monster.getMap().getId(), toRun, animationTime);\n     }\n-    \n+\n     public void applyEffect(MapleCharacter player, MapleMonster monster, boolean skill, List<MapleCharacter> banishPlayers) {\n         MapleDisease disease = null;\n         Map<MonsterStatus, Integer> stats = new ArrayMap<MonsterStatus, Integer>();\n@@ -142,50 +143,50 @@ public void applyEffect(MapleCharacter player, MapleMonster monster, boolean ski\n             case 153:\n                 stats.put(MonsterStatus.MAGIC_DEFENSE_UP, Integer.valueOf(x));\n                 break;\n-\t    case 114:\n-\t\tif (lt != null && rb != null && skill) {\n-\t\t    List<MapleMapObject> objects = getObjectsInRange(monster, MapleMapObjectType.MONSTER);\n-\t\t    final int hps = (getX() / 1000) * (int) (950 + 1050 * Math.random());\n-\t\t    for (MapleMapObject mons : objects) {\n-\t\t\t((MapleMonster) mons).heal(hps, getY());\n-\t\t    }\n-\t\t} else {\n-\t\t    monster.heal(getX(), getY());\n-\t\t}\n-\t\tbreak;\n-\t    case 120:\n+            case 114:\n+                if (lt != null && rb != null && skill) {\n+                    List<MapleMapObject> objects = getObjectsInRange(monster, MapleMapObjectType.MONSTER);\n+                    final int hps = (getX() / 1000) * (int) (950 + 1050 * Math.random());\n+                    for (MapleMapObject mons : objects) {\n+                        ((MapleMonster) mons).heal(hps, getY());\n+                    }\n+                } else {\n+                    monster.heal(getX(), getY());\n+                }\n+                break;\n+            case 120:\n                 disease = MapleDisease.SEAL;\n-\t\tbreak;\n-\t    case 121:\n-\t    \tdisease = MapleDisease.DARKNESS;\n-\t\tbreak;\n-\t    case 122:\n-\t    \tdisease = MapleDisease.WEAKEN;\n-\t\tbreak;\n-\t    case 123:\n-\t    \tdisease = MapleDisease.STUN;\n-\t\tbreak;\n-\t    case 124:\n-\t    \tdisease = MapleDisease.CURSE;\n-\t\tbreak;\n-\t    case 125:\n-\t    \tdisease = MapleDisease.POISON;\n-\t\tbreak;\n-\t    case 126: // Slow\n-\t    \tdisease = MapleDisease.SLOW;\n-\t\tbreak;\n-\t    case 127:\n-\t\tif (lt != null && rb != null && skill) {\n-\t\t    for (MapleCharacter character : getPlayersInRange(monster, player)) {\n-\t\t\tcharacter.dispel();\n-\t\t    }\n-\t\t} else {\n-\t\t    player.dispel();\n-\t\t}\n-\t\tbreak;\n-\t    case 128: // Seduce\n-\t    \tdisease = MapleDisease.SEDUCE;\n-\t\tbreak;\n+                break;\n+            case 121:\n+                disease = MapleDisease.DARKNESS;\n+                break;\n+            case 122:\n+                disease = MapleDisease.WEAKEN;\n+                break;\n+            case 123:\n+                disease = MapleDisease.STUN;\n+                break;\n+            case 124:\n+                disease = MapleDisease.CURSE;\n+                break;\n+            case 125:\n+                disease = MapleDisease.POISON;\n+                break;\n+            case 126: // Slow\n+                disease = MapleDisease.SLOW;\n+                break;\n+            case 127:\n+                if (lt != null && rb != null && skill) {\n+                    for (MapleCharacter character : getPlayersInRange(monster, player)) {\n+                        character.dispel();\n+                    }\n+                } else {\n+                    player.dispel();\n+                }\n+                break;\n+            case 128: // Seduce\n+                disease = MapleDisease.SEDUCE;\n+                break;\n             case 129: // Banish\n                 if (lt != null && rb != null && skill) {\n                     for (MapleCharacter chr : getPlayersInRange(monster, player)) {\n@@ -214,35 +215,40 @@ public void applyEffect(MapleCharacter player, MapleMonster monster, boolean ski\n                     stats.put(MonsterStatus.MAGIC_IMMUNITY, Integer.valueOf(x));\n                 }\n                 break;\n-\t    case 143: // Weapon Reflect\n-                    stats.put(MonsterStatus.WEAPON_REFLECT, 10);\n-                    stats.put(MonsterStatus.WEAPON_IMMUNITY, 10);\n-                    reflection.add(x);\n-\t\tbreak;\n-\t    case 144: // Magic Reflect\n-                    stats.put(MonsterStatus.MAGIC_REFLECT, 10);\n-                    stats.put(MonsterStatus.MAGIC_IMMUNITY, 10);\n-                    reflection.add(x);\n-\t\tbreak;\n-\t    case 145: // Weapon / Magic reflect\n-                    stats.put(MonsterStatus.WEAPON_REFLECT, 10);\n-                    stats.put(MonsterStatus.WEAPON_IMMUNITY, 10);\n-                    stats.put(MonsterStatus.MAGIC_REFLECT, 10);\n-                    stats.put(MonsterStatus.MAGIC_IMMUNITY, 10);\n-                    reflection.add(x);\n+            case 143: // Weapon Reflect\n+                stats.put(MonsterStatus.WEAPON_REFLECT, 10);\n+                stats.put(MonsterStatus.WEAPON_IMMUNITY, 10);\n+                reflection.add(x);\n+                break;\n+            case 144: // Magic Reflect\n+                stats.put(MonsterStatus.MAGIC_REFLECT, 10);\n+                stats.put(MonsterStatus.MAGIC_IMMUNITY, 10);\n+                reflection.add(x);\n                 break;\n-            case 154: // accuracy up\n-            case 155: // avoid up\n-            case 156: // speed up\n+            case 145: // Weapon / Magic reflect\n+                stats.put(MonsterStatus.WEAPON_REFLECT, 10);\n+                stats.put(MonsterStatus.WEAPON_IMMUNITY, 10);\n+                stats.put(MonsterStatus.MAGIC_REFLECT, 10);\n+                stats.put(MonsterStatus.MAGIC_IMMUNITY, 10);\n+                reflection.add(x);\n+                break;\n+            case 154:\n+                stats.put(MonsterStatus.ACC, Integer.valueOf(x));\n+                break;\n+            case 155:\n+                stats.put(MonsterStatus.AVOID, Integer.valueOf(x));\n+                break;\n+            case 156:\n+                stats.put(MonsterStatus.SPEED, Integer.valueOf(x));\n                 break;\n             case 200: // summon\n                 int skillLimit = this.getLimit();\n                 MapleMap map = monster.getMap();\n-                \n+\n                 if (map.isDojoMap()) {  // spawns in dojo should be unlimited\n                     skillLimit = Integer.MAX_VALUE;\n                 }\n-                \n+\n                 if (map.getSpawnedMonstersOnMap() < 80) {\n                     List<Integer> summons = getSummons();\n                     int summonLimit = monster.countAvailableMobSummons(summons.size(), skillLimit);\n@@ -252,9 +258,10 @@ public void applyEffect(MapleCharacter player, MapleMonster monster, boolean ski\n \n                         for (Integer mobId : summons.subList(0, summonLimit)) {\n                             MapleMonster toSpawn = MapleLifeFactory.getMonster(mobId);\n-                            if(toSpawn != null) {\n-                                if(bossRushMap) toSpawn.disableDrops();  // no littering on BRPQ pls\n-\n+                            if (toSpawn != null) {\n+                                if (bossRushMap) {\n+                                    toSpawn.disableDrops();  // no littering on BRPQ pls\n+                                }\n                                 toSpawn.setPosition(monster.getPosition());\n                                 int ypos, xpos;\n                                 xpos = (int) monster.getPosition().getX();\n@@ -277,7 +284,7 @@ public void applyEffect(MapleCharacter player, MapleMonster monster, boolean ski\n                                         } else {\n                                             xpos = (int) (monster.getPosition().getX() + Randomizer.nextInt(1000) - 500);\n                                         }\n-                                        break;          \n+                                        break;\n                                 }\n                                 switch (map.getId()) {\n                                     case 220080001: //Pap map\n@@ -297,9 +304,9 @@ public void applyEffect(MapleCharacter player, MapleMonster monster, boolean ski\n                                 }\n                                 toSpawn.setPosition(new Point(xpos, ypos));\n                                 if (toSpawn.getId() == 8500004) {\n-                                        map.spawnFakeMonster(toSpawn);\n+                                    map.spawnFakeMonster(toSpawn);\n                                 } else {\n-                                        map.spawnMonsterWithEffect(toSpawn, getSpawnEffect(), toSpawn.getPosition());\n+                                    map.spawnMonsterWithEffect(toSpawn, getSpawnEffect(), toSpawn.getPosition());\n                                 }\n                                 monster.addSummonedMob(toSpawn);\n                             }"}, {"sha": "c6a926fde4ceb6e5cf8ff920e949b27daf2ca453", "filename": "src/server/maps/MapleMap.java", "status": "modified", "additions": 857, "deletions": 536, "changes": 1393, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/maps/MapleMap.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/maps/MapleMap.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/maps/MapleMap.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595"}, {"sha": "05a41ef13c081bb632f5031cff40d1a722f1993e", "filename": "src/server/maps/MapleMapFactory.java", "status": "modified", "additions": 75, "deletions": 40, "changes": 115, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/maps/MapleMapFactory.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/maps/MapleMapFactory.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/maps/MapleMapFactory.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -48,12 +48,14 @@\n import server.life.MaplePlayerNPC;\n import server.life.MaplePlayerNPCFactory;\n import scripting.event.EventInstanceManager;\n+import server.partyquest.GuardianSpawnPoint;\n import tools.DatabaseConnection;\n import tools.StringUtil;\n \n public class MapleMapFactory {\n+\n     private static Map<Integer, Float> mapRecoveryRate = new HashMap<>();\n-    \n+\n     private MapleDataProvider source;\n     private MapleData nameData;\n     private EventInstanceManager event;\n@@ -68,27 +70,36 @@ public MapleMapFactory(EventInstanceManager eim, MapleDataProvider source, Maple\n         this.world = world;\n         this.channel = channel;\n         this.event = eim;\n-        \n+\n         ReentrantReadWriteLock rrwl = new MonitoredReentrantReadWriteLock(MonitoredLockType.MAP_FACTORY);\n         this.mapsRLock = rrwl.readLock();\n         this.mapsWLock = rrwl.writeLock();\n     }\n-    \n+\n     public MapleMap resetMap(int mapid) {\n         mapsWLock.lock();\n         try {\n             maps.remove(Integer.valueOf(mapid));\n         } finally {\n             mapsWLock.unlock();\n         }\n-        \n+\n         return getMap(mapid);\n     }\n-    \n+\n     private void loadLifeFromWz(MapleMap map, MapleData mapData) {\n         for (MapleData life : mapData.getChildByPath(\"life\")) {\n+            life.getName();\n             String id = MapleDataTool.getString(life.getChildByPath(\"id\"));\n             String type = MapleDataTool.getString(life.getChildByPath(\"type\"));\n+            int team = MapleDataTool.getInt(\"team\", life, -1);\n+            if (map.isCPQMap2() && type.equals(\"m\")) {\n+                if((Integer.parseInt(life.getName()) % 2) == 0)  {\n+                    team = 0;\n+                } else {\n+                    team = 1;\n+                }\n+            } \n             int cy = MapleDataTool.getInt(life.getChildByPath(\"cy\"));\n             MapleData dF = life.getChildByPath(\"f\");\n             int f = (dF != null) ? MapleDataTool.getInt(dF) : 0;\n@@ -99,12 +110,11 @@ private void loadLifeFromWz(MapleMap map, MapleData mapData) {\n             int y = MapleDataTool.getInt(life.getChildByPath(\"y\"));\n             int hide = MapleDataTool.getInt(\"hide\", life, 0);\n             int mobTime = MapleDataTool.getInt(\"mobTime\", life, 0);\n-            int team = MapleDataTool.getInt(\"team\", life, -1);\n \n             loadLifeRaw(map, Integer.parseInt(id), type, cy, f, fh, rx0, rx1, x, y, hide, mobTime, team);\n         }\n     }\n-    \n+\n     private void loadLifeFromDb(MapleMap map) {\n         try {\n             Connection con = DatabaseConnection.getConnection();\n@@ -113,7 +123,7 @@ private void loadLifeFromDb(MapleMap map) {\n             ps.setInt(2, map.getWorld());\n \n             ResultSet rs = ps.executeQuery();\n-            while(rs.next()) {\n+            while (rs.next()) {\n                 int id = rs.getInt(\"life\");\n                 String type = rs.getString(\"type\");\n                 int cy = rs.getInt(\"cy\");\n@@ -137,12 +147,12 @@ private void loadLifeFromDb(MapleMap map) {\n             sqle.printStackTrace();\n         }\n     }\n-    \n+\n     private void loadLifeRaw(MapleMap map, int id, String type, int cy, int f, int fh, int rx0, int rx1, int x, int y, int hide, int mobTime, int team) {\n         AbstractLoadedMapleLife myLife = loadLife(id, type, cy, f, fh, rx0, rx1, x, y, hide);\n         if (myLife instanceof MapleMonster) {\n             MapleMonster monster = (MapleMonster) myLife;\n-            \n+\n             if (mobTime == -1) { //does not respawn, force spawn once\n                 map.spawnMonster(monster);\n             } else {\n@@ -155,10 +165,10 @@ private void loadLifeRaw(MapleMap map, int id, String type, int cy, int f, int f\n             map.addMapObject(myLife);\n         }\n     }\n-    \n+\n     private synchronized MapleMap loadMapFromWz(int mapid, Integer omapid) {\n         MapleMap map;\n-        \n+\n         mapsRLock.lock();\n         try {\n             map = maps.get(omapid);\n@@ -169,7 +179,7 @@ private synchronized MapleMap loadMapFromWz(int mapid, Integer omapid) {\n         if (map != null) {\n             return map;\n         }\n-        \n+\n         String mapName = getMapName(mapid);\n         MapleData mapData = source.getData(mapName);    // source.getData issue with giving nulls in rare ocasions found thanks to MedicOP\n         MapleData infoData = mapData.getChildByPath(\"info\");\n@@ -209,9 +219,9 @@ private synchronized MapleMap loadMapFromWz(int mapid, Integer omapid) {\n         bounds[0] = MapleDataTool.getInt(infoData.getChildByPath(\"VRTop\"));\n         bounds[1] = MapleDataTool.getInt(infoData.getChildByPath(\"VRBottom\"));\n \n-        if(bounds[0] == bounds[1]) {    // old-style baked map\n+        if (bounds[0] == bounds[1]) {    // old-style baked map\n             MapleData minimapData = mapData.getChildByPath(\"miniMap\");\n-            if(minimapData != null) {\n+            if (minimapData != null) {\n                 bounds[0] = MapleDataTool.getInt(minimapData.getChildByPath(\"centerX\")) * -1;\n                 bounds[1] = MapleDataTool.getInt(minimapData.getChildByPath(\"centerY\")) * -1;\n                 bounds[2] = MapleDataTool.getInt(minimapData.getChildByPath(\"height\"));\n@@ -272,7 +282,7 @@ private synchronized MapleMap loadMapFromWz(int mapid, Integer omapid) {\n                 map.addMapleArea(new Rectangle(x1, y1, (x2 - x1), (y2 - y1)));\n             }\n         }\n-        if(event == null) {\n+        if (event == null) {\n             try {\n                 Connection con = DatabaseConnection.getConnection();\n                 try (PreparedStatement ps = con.prepareStatement(\"SELECT * FROM playernpcs WHERE map = ? AND world = ?\")) {\n@@ -288,23 +298,47 @@ private synchronized MapleMap loadMapFromWz(int mapid, Integer omapid) {\n             } catch (SQLException e) {\n                 e.printStackTrace();\n             }\n-            \n+\n             List<MaplePlayerNPC> dnpcs = MaplePlayerNPCFactory.getDeveloperNpcsFromMapid(mapid);\n-            if(dnpcs != null) {\n-                for(MaplePlayerNPC dnpc : dnpcs) {\n+            if (dnpcs != null) {\n+                for (MaplePlayerNPC dnpc : dnpcs) {\n                     map.addPlayerNPCMapObject(dnpc);\n                 }\n             }\n         }\n-        \n+\n         loadLifeFromWz(map, mapData);\n         loadLifeFromDb(map);\n-        \n+\n+        if (map.isCPQMap()) {\n+            MapleData mcData = mapData.getChildByPath(\"monsterCarnival\");\n+            if (mcData != null) {\n+                MapleData guardianGenData = mcData.getChildByPath(\"guardianGenPos\");\n+                for (MapleData node : guardianGenData.getChildren()) {\n+                    GuardianSpawnPoint pt = new GuardianSpawnPoint(new Point(MapleDataTool.getIntConvert(\"x\", node), MapleDataTool.getIntConvert(\"y\", node)));\n+                    pt.setTeam(MapleDataTool.getIntConvert(\"team\", node, -1));\n+                    pt.setTaken(false);\n+                    map.addGuardianSpawnPoint(pt);\n+                }\n+            }\n+            if (mcData.getChildByPath(\"skill\") != null) {\n+                for (MapleData area : mcData.getChildByPath(\"skill\")) {\n+                    map.addSkillId(MapleDataTool.getInt(area));\n+                }\n+            }\n+            \n+            if (mcData.getChildByPath(\"mob\") != null) {\n+                for (MapleData area : mcData.getChildByPath(\"mob\")) {\n+                    map.addMobSpawn(MapleDataTool.getInt(area.getChildByPath(\"id\")), MapleDataTool.getInt(area.getChildByPath(\"spendCP\")));\n+                }\n+            }\n+        }\n+\n         if (mapData.getChildByPath(\"reactor\") != null) {\n             for (MapleData reactor : mapData.getChildByPath(\"reactor\")) {\n                 String id = MapleDataTool.getString(reactor.getChildByPath(\"id\"));\n                 if (id != null) {\n-                    MapleReactor newReactor = loadReactor(reactor, id);\n+                    MapleReactor newReactor = loadReactor(reactor, id, (byte) MapleDataTool.getInt(reactor.getChildByPath(\"f\"), 0));\n                     map.spawnReactor(newReactor);\n                 }\n             }\n@@ -313,7 +347,7 @@ private synchronized MapleMap loadMapFromWz(int mapid, Integer omapid) {\n             map.setMapName(MapleDataTool.getString(\"mapName\", nameData.getChildByPath(getMapStringName(omapid)), \"\"));\n             map.setStreetName(MapleDataTool.getString(\"streetName\", nameData.getChildByPath(getMapStringName(omapid)), \"\"));\n         } catch (Exception e) {\n-            if(omapid / 1000 != 1020) {     // explorer job introducion scenes\n+            if (omapid / 1000 != 1020) {     // explorer job introducion scenes\n                 e.printStackTrace();\n                 System.err.println(\"Not found mapid \" + omapid);\n             }\n@@ -332,13 +366,13 @@ private synchronized MapleMap loadMapFromWz(int mapid, Integer omapid) {\n         map.setTimeLimit(MapleDataTool.getIntConvert(\"timeLimit\", infoData, -1));\n         map.setFieldType(MapleDataTool.getIntConvert(\"fieldType\", infoData, 0));\n         map.setMobCapacity(MapleDataTool.getIntConvert(\"fixedMobCapacity\", infoData, 500));//Is there a map that contains more than 500 mobs?\n-        \n+\n         MapleData recData = infoData.getChildByPath(\"recovery\");\n-        if(recData != null) {\n+        if (recData != null) {\n             float recoveryRate = MapleDataTool.getFloat(recData);\n             mapRecoveryRate.put(mapid, recoveryRate);\n         }\n-        \n+\n         HashMap<Integer, Integer> backTypes = new HashMap<>();\n         try {\n             for (MapleData layer : mapData.getChildByPath(\"back\")) { // yolo\n@@ -351,7 +385,7 @@ private synchronized MapleMap loadMapFromWz(int mapid, Integer omapid) {\n             e.printStackTrace();\n             // swallow cause I'm cool\n         }\n-        \n+\n         map.setBackgroundTypes(backTypes);\n         map.generateMapDropRangeCache();\n \n@@ -361,21 +395,21 @@ private synchronized MapleMap loadMapFromWz(int mapid, Integer omapid) {\n         } finally {\n             mapsWLock.unlock();\n         }\n-        \n+\n         return map;\n     }\n-    \n+\n     public MapleMap getMap(int mapid) {\n         Integer omapid = Integer.valueOf(mapid);\n         MapleMap map;\n-        \n+\n         mapsRLock.lock();\n         try {\n             map = maps.get(omapid);\n         } finally {\n             mapsRLock.unlock();\n         }\n-        \n+\n         return (map != null) ? map : loadMapFromWz(mapid, omapid);\n     }\n \n@@ -387,7 +421,7 @@ public boolean isMapLoaded(int mapId) {\n             mapsRLock.unlock();\n         }\n     }\n-    \n+\n     private AbstractLoadedMapleLife loadLife(int id, String type, int cy, int f, int fh, int rx0, int rx1, int x, int y, int hide) {\n         AbstractLoadedMapleLife myLife = MapleLifeFactory.getLife(id, type);\n         myLife.setCy(cy);\n@@ -402,10 +436,11 @@ private AbstractLoadedMapleLife loadLife(int id, String type, int cy, int f, int\n         return myLife;\n     }\n \n-    private MapleReactor loadReactor(MapleData reactor, String id) {\n+    private MapleReactor loadReactor(MapleData reactor, String id, final byte FacingDirection) {\n         MapleReactor myReactor = new MapleReactor(MapleReactorFactory.getReactor(Integer.parseInt(id)), Integer.parseInt(id));\n         int x = MapleDataTool.getInt(reactor.getChildByPath(\"x\"));\n         int y = MapleDataTool.getInt(reactor.getChildByPath(\"y\"));\n+        myReactor.setFacingDirection(FacingDirection);\n         myReactor.setPosition(new Point(x, y));\n         myReactor.setDelay(MapleDataTool.getInt(reactor.getChildByPath(\"reactorTime\")) * 1000);\n         myReactor.setName(MapleDataTool.getString(reactor.getChildByPath(\"name\"), \"\"));\n@@ -442,7 +477,7 @@ private String getMapStringName(int mapid) {\n         } else if (mapid >= 677000000 && mapid < 677100000) {\n             builder.append(\"Episode1GL\");\n         } else if (mapid >= 670000000 && mapid < 682000000) {\n-            if((mapid >= 674030000 && mapid < 674040000) || (mapid >= 680100000 && mapid < 680200000)) {\n+            if ((mapid >= 674030000 && mapid < 674040000) || (mapid >= 680100000 && mapid < 680200000)) {\n                 builder.append(\"etc\");\n             } else {\n                 builder.append(\"weddingGL\");\n@@ -452,7 +487,7 @@ private String getMapStringName(int mapid) {\n         } else if (mapid >= 683000000 && mapid < 684000000) {\n             builder.append(\"event\");\n         } else if (mapid >= 800000000 && mapid < 900000000) {\n-            if((mapid >= 889100000 && mapid < 889200000)) {\n+            if ((mapid >= 889100000 && mapid < 889200000)) {\n                 builder.append(\"etc\");\n             } else {\n                 builder.append(\"jp\");\n@@ -480,17 +515,17 @@ public void setWorld(int world) {\n             mapsRLock.unlock();\n         }\n     }\n-    \n+\n     public void dispose() {\n         Collection<MapleMap> mapValues = getMaps().values();\n-        \n-        for(MapleMap map: mapValues) {\n+\n+        for (MapleMap map : mapValues) {\n             map.dispose();\n         }\n-        \n+\n         this.event = null;\n     }\n-    \n+\n     public static float getMapRecoveryRate(int mapid) {\n         Float recRate = mapRecoveryRate.get(mapid);\n         return recRate != null ? recRate : 1.0f;"}, {"sha": "42179421d5a09f612efe8507ce33895352b68678", "filename": "src/server/maps/MapleReactor.java", "status": "modified", "additions": 84, "deletions": 53, "changes": 137, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/maps/MapleReactor.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/maps/MapleReactor.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/maps/MapleReactor.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -1,27 +1,28 @@\n /*\n-\tThis file is part of the OdinMS Maple Story Server\n-    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n-\t\t       Matthias Butz <matze@odinms.de>\n-\t\t       Jan Christian Meyer <vimes@odinms.de>\n-\n-    This program is free software: you can redistribute it and/or modify\n-    it under the terms of the GNU Affero General Public License as\n-    published by the Free Software Foundation version 3 as published by\n-    the Free Software Foundation. You may not use, modify or distribute\n-    this program under any other version of the GNU Affero General Public\n-    License.\n-\n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU Affero General Public License for more details.\n-\n-    You should have received a copy of the GNU Affero General Public License\n-    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-*/\n+ This file is part of the OdinMS Maple Story Server\n+ Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n+ Matthias Butz <matze@odinms.de>\n+ Jan Christian Meyer <vimes@odinms.de>\n+\n+ This program is free software: you can redistribute it and/or modify\n+ it under the terms of the GNU Affero General Public License as\n+ published by the Free Software Foundation version 3 as published by\n+ the Free Software Foundation. You may not use, modify or distribute\n+ this program under any other version of the GNU Affero General Public\n+ License.\n+\n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU Affero General Public License for more details.\n+\n+ You should have received a copy of the GNU Affero General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n package server.maps;\n \n import client.MapleClient;\n+import client.status.MonsterStatus;\n import constants.ServerConstants;\n \n import java.awt.Rectangle;\n@@ -36,13 +37,15 @@\n import tools.MaplePacketCreator;\n import tools.Pair;\n import net.server.audit.locks.MonitoredLockType;\n+import server.partyquest.GuardianSpawnPoint;\n \n /**\n  *\n  * @author Lerk\n  * @author Ronan\n  */\n public class MapleReactor extends AbstractMapleMapObject {\n+\n     private int rid;\n     private MapleReactorStats stats;\n     private byte state;\n@@ -54,48 +57,50 @@\n     private boolean shouldCollect;\n     private boolean attackHit;\n     private ScheduledFuture<?> timeoutTask = null;\n+    private GuardianSpawnPoint guardian = null;\n+    private byte facingDirection = 0;\n     private Lock reactorLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.REACTOR, true);\n     private Lock hitLock = MonitoredReentrantLockFactory.createLock(MonitoredLockType.REACTOR_HIT, true);\n \n     public MapleReactor(MapleReactorStats stats, int rid) {\n-        this.evstate = (byte)0;\n+        this.evstate = (byte) 0;\n         this.stats = stats;\n         this.rid = rid;\n         this.alive = true;\n     }\n-    \n+\n     public void setShouldCollect(boolean collect) {\n         this.shouldCollect = collect;\n     }\n-    \n+\n     public boolean getShouldCollect() {\n         return shouldCollect;\n     }\n-    \n+\n     public void lockReactor() {\n         reactorLock.lock();\n     }\n-    \n+\n     public void unlockReactor() {\n         reactorLock.unlock();\n     }\n \n     public void setState(byte state) {\n         this.state = state;\n     }\n-    \n+\n     public byte getState() {\n         return state;\n     }\n-    \n+\n     public void setEventState(byte substate) {\n         this.evstate = substate;\n     }\n-    \n+\n     public byte getEventState() {\n         return evstate;\n     }\n-    \n+\n     public MapleReactorStats getStats() {\n         return stats;\n     }\n@@ -120,7 +125,7 @@ public MapleMapObjectType getType() {\n     public int getReactorType() {\n         return stats.getType(state);\n     }\n-    \n+\n     public boolean isRecentHitFromAttack() {\n         return attackHit;\n     }\n@@ -140,7 +145,7 @@ public MapleMap getMap() {\n     public boolean isAlive() {\n         return alive;\n     }\n-    \n+\n     public boolean isActive() {\n         return alive && stats.getType(state) != -1;\n     }\n@@ -172,10 +177,12 @@ public void resetReactorActions(int newState) {\n         cancelReactorTimeout();\n         setShouldCollect(true);\n         refreshReactorTimeout();\n-        \n-        if(map != null) map.searchItemReactors(this);\n+\n+        if (map != null) {\n+            map.searchItemReactors(this);\n+        }\n     }\n-    \n+\n     public void forceHitReactor(final byte newState) {\n         this.lockReactor();\n         try {\n@@ -185,30 +192,32 @@ public void forceHitReactor(final byte newState) {\n             this.unlockReactor();\n         }\n     }\n-    \n+\n     private void tryForceHitReactor(final byte newState) {  // weak hit state signal, if already changed reactor state before timeout then drop this\n-        if(!this.reactorLock.tryLock()) return;\n-        \n+        if (!this.reactorLock.tryLock()) {\n+            return;\n+        }\n+\n         try {\n             this.resetReactorActions(newState);\n             map.broadcastMessage(MaplePacketCreator.triggerReactor(this, (short) 0));\n         } finally {\n             this.reactorLock.unlock();\n         }\n     }\n-    \n+\n     public void cancelReactorTimeout() {\n         if (timeoutTask != null) {\n             timeoutTask.cancel(false);\n             timeoutTask = null;\n         }\n     }\n-    \n+\n     private void refreshReactorTimeout() {\n         int timeOut = stats.getTimeout(state);\n-        if(timeOut > -1) {\n+        if (timeOut > -1) {\n             final byte nextState = stats.getTimeoutState(state);\n-            \n+\n             timeoutTask = TimerManager.getInstance().schedule(new Runnable() {\n                 @Override\n                 public void run() {\n@@ -218,7 +227,7 @@ public void run() {\n             }, timeOut);\n         }\n     }\n-    \n+\n     public void delayedHitReactor(final MapleClient c, long delay) {\n         TimerManager.getInstance().schedule(new Runnable() {\n             @Override\n@@ -231,20 +240,22 @@ public void run() {\n     public void hitReactor(MapleClient c) {\n         hitReactor(false, 0, (short) 0, 0, c);\n     }\n-    \n+\n     public void hitReactor(boolean wHit, int charPos, short stance, int skillid, MapleClient c) {\n         try {\n-            if(!this.isActive()) {\n+            if (!this.isActive()) {\n                 return;\n             }\n-            \n-            if(hitLock.tryLock()) {\n+\n+            if (hitLock.tryLock()) {\n                 this.lockReactor();\n                 try {\n                     cancelReactorTimeout();\n                     attackHit = wHit;\n \n-                    if(ServerConstants.USE_DEBUG == true) c.getPlayer().dropMessage(5, \"Hitted REACTOR \" + this.getId() + \" with POS \" + charPos + \" , STANCE \" + stance + \" , SkillID \" + skillid + \" , STATE \" + stats.getType(state) + \" STATESIZE \" + stats.getStateSize(state));\n+                    if (ServerConstants.USE_DEBUG == true) {\n+                        c.getPlayer().dropMessage(5, \"Hitted REACTOR \" + this.getId() + \" with POS \" + charPos + \" , STANCE \" + stance + \" , SkillID \" + skillid + \" , STATE \" + stats.getType(state) + \" STATESIZE \" + stats.getStateSize(state));\n+                    }\n                     ReactorScriptManager.getInstance().onHit(c, this);\n \n                     int reactorType = stats.getType(state);\n@@ -253,7 +264,9 @@ public void hitReactor(boolean wHit, int charPos, short stance, int skillid, Map\n                             for (byte b = 0; b < stats.getStateSize(state); b++) {//YAY?\n                                 List<Integer> activeSkills = stats.getActiveSkills(state, b);\n                                 if (activeSkills != null) {\n-                                    if (!activeSkills.contains(skillid)) continue;\n+                                    if (!activeSkills.contains(skillid)) {\n+                                        continue;\n+                                    }\n                                 }\n                                 state = stats.getNextState(state, b);\n                                 if (stats.getNextState(state, b) == -1) {//end of reactor\n@@ -276,7 +289,7 @@ public void hitReactor(boolean wHit, int charPos, short stance, int skillid, Map\n \n                                     setShouldCollect(true);     // refresh collectability on item drop-based reactors\n                                     refreshReactorTimeout();\n-                                    if(stats.getType(state) == 100) {\n+                                    if (stats.getType(state) == 100) {\n                                         map.searchItemReactors(this);\n                                     }\n                                 }\n@@ -286,21 +299,23 @@ public void hitReactor(boolean wHit, int charPos, short stance, int skillid, Map\n                     } else {\n                         state++;\n                         map.broadcastMessage(MaplePacketCreator.triggerReactor(this, stance));\n-                        ReactorScriptManager.getInstance().act(c, this);\n+                        if (this.getId() != 9980000 && this.getId() != 9980001) {\n+                            ReactorScriptManager.getInstance().act(c, this);\n+                        }\n \n                         setShouldCollect(true);\n                         refreshReactorTimeout();\n-                        if(stats.getType(state) == 100) {\n+                        if (stats.getType(state) == 100) {\n                             map.searchItemReactors(this);\n                         }\n                     }\n                 } finally {\n                     this.unlockReactor();\n                 }\n-                \n+\n                 hitLock.unlock();\n             }\n-        } catch(Exception e) {\n+        } catch (Exception e) {\n             e.printStackTrace();\n         }\n     }\n@@ -316,4 +331,20 @@ public String getName() {\n     public void setName(String name) {\n         this.name = name;\n     }\n+\n+    public GuardianSpawnPoint getGuardian() {\n+        return guardian;\n+    }\n+\n+    public void setGuardian(GuardianSpawnPoint guardian) {\n+        this.guardian = guardian;\n+    }\n+\n+    public final void setFacingDirection(final byte facingDirection) {\n+        this.facingDirection = facingDirection;\n+    }\n+\n+    public final byte getFacingDirection() {\n+        return facingDirection;\n+    }\n }"}, {"sha": "f5a68fe7e9d6ff54afa07048604bb577add8d059", "filename": "src/server/maps/MapleReactorFactory.java", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/maps/MapleReactorFactory.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/maps/MapleReactorFactory.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/maps/MapleReactorFactory.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -38,6 +38,61 @@\n     private static MapleDataProvider data = MapleDataProviderFactory.getDataProvider(new File(System.getProperty(\"wzpath\") + \"/Reactor.wz\"));\n     private static Map<Integer, MapleReactorStats> reactorStats = new HashMap<Integer, MapleReactorStats>();\n \n+    \n+    public static final MapleReactorStats getReactorS(int rid) {\n+        MapleReactorStats stats = reactorStats.get(Integer.valueOf(rid));\n+        if (stats == null) {\n+            int infoId = rid;\n+            MapleData reactorData = data.getData(StringUtil.getLeftPaddedStr(Integer.toString(infoId) + \".img\", '0', 11));\n+            MapleData link = reactorData.getChildByPath(\"info/link\");\n+            if (link != null) {\n+                infoId = MapleDataTool.getIntConvert(\"info/link\", reactorData);\n+                stats = reactorStats.get(Integer.valueOf(infoId));\n+            }\n+            if (stats == null) {\n+                stats = new MapleReactorStats();\n+                reactorData = data.getData(StringUtil.getLeftPaddedStr(Integer.toString(infoId) + \".img\", '0', 11));\n+                if (reactorData == null) {\n+                    return stats;\n+                }\n+                boolean canTouch = MapleDataTool.getInt(\"info/activateByTouch\", reactorData, 0) > 0;\n+                boolean areaSet = false;\n+                boolean foundState = false;\n+                for (byte i = 0; true; i++) {\n+                    MapleData reactorD = reactorData.getChildByPath(String.valueOf(i));\n+                    if (reactorD == null) {\n+                        break;\n+                    }\n+                    MapleData reactorInfoData_ = reactorD.getChildByPath(\"event\");\n+                    if (reactorInfoData_ != null && reactorInfoData_.getChildByPath(\"0\") != null) {\n+                        MapleData reactorInfoData = reactorInfoData_.getChildByPath(\"0\");\n+                        Pair<Integer, Integer> reactItem = null;\n+                        int type = MapleDataTool.getIntConvert(\"type\", reactorInfoData);\n+                        if (type == 100) { //reactor waits for item\n+                            reactItem = new Pair<Integer, Integer>(MapleDataTool.getIntConvert(\"0\", reactorInfoData), MapleDataTool.getIntConvert(\"1\", reactorInfoData, 1));\n+                            if (!areaSet) { //only set area of effect for item-triggered reactors once\n+                                stats.setTL(MapleDataTool.getPoint(\"lt\", reactorInfoData));\n+                                stats.setBR(MapleDataTool.getPoint(\"rb\", reactorInfoData));\n+                                areaSet = true;\n+                            }\n+                        }\n+                        foundState = true;\n+                        stats.addState(i, type, reactItem, (byte) MapleDataTool.getIntConvert(\"state\", reactorInfoData), MapleDataTool.getIntConvert(\"timeOut\", reactorInfoData_, -1), (byte) (canTouch ? 2 : (MapleDataTool.getIntConvert(\"2\", reactorInfoData, 0) > 0 || reactorInfoData.getChildByPath(\"clickArea\") != null || type == 9 ? 1 : 0)));\n+                    } else {\n+                        stats.addState(i, 999, null, (byte) (foundState ? -1 : (i + 1)), 0, (byte) 0);\n+                    }\n+                }\n+                reactorStats.put(Integer.valueOf(infoId), stats);\n+                if (rid != infoId) {\n+                    reactorStats.put(Integer.valueOf(rid), stats);\n+                }\n+            } else { // stats exist at infoId but not rid; add to map\n+                reactorStats.put(Integer.valueOf(rid), stats);\n+            }\n+        }\n+        return stats;\n+    }\n+    \n     public static MapleReactorStats getReactor(int rid) {\n         MapleReactorStats stats = reactorStats.get(Integer.valueOf(rid));\n         if (stats == null) {"}, {"sha": "21f9d5f4c2e12baf831cc26631dfcb874b6cecc9", "filename": "src/server/maps/MapleReactorStats.java", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/maps/MapleReactorStats.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/maps/MapleReactorStats.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/maps/MapleReactorStats.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -22,6 +22,7 @@\n package server.maps;\n \n import java.awt.Point;\n+import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n@@ -58,6 +59,12 @@ public void addState(byte state, List<StateData> data, int timeOut) {\n         if(timeOut > -1) timeoutInfo.put(state, timeOut);\n     }\n     \n+    public void addState(byte state, int type, Pair<Integer, Integer> reactItem, byte nextState, int timeOut, byte canTouch) {\n+        List<StateData> data = new ArrayList<>();\n+        data.add(new StateData(type, reactItem, null, nextState));\n+        stateInfo.put(state, data);\n+    }\n+    \n     public int getTimeout(byte state) {\n         Integer i = timeoutInfo.get(state);\n         return (i == null) ? -1 : i;"}, {"sha": "b0e8cd8893168bb470a6d6ac552ee6731244ffa1", "filename": "src/server/maps/SavedLocationType.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/maps/SavedLocationType.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/maps/SavedLocationType.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/maps/SavedLocationType.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -31,6 +31,7 @@\n     EVENT,\n     BOSSPQ,\n     HAPPYVILLE,\n+    MONSTER_CARNIVAL,\n     DEVELOPER;\n \n     public static SavedLocationType fromString(String Str) {"}, {"sha": "9f918f22d4a422a26e3dbde83fde4c1657c456bb", "filename": "src/server/partyquest/GuardianSpawnPoint.java", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/partyquest/GuardianSpawnPoint.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/partyquest/GuardianSpawnPoint.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/partyquest/GuardianSpawnPoint.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -0,0 +1,43 @@\n+package server.partyquest;\n+\n+import java.awt.Point;\n+\n+/**\n+ *\n+ * @author David\n+ */\n+public class GuardianSpawnPoint {\n+\n+    private Point position;\n+    private boolean taken;\n+    private int team = -1;\n+\n+    public GuardianSpawnPoint(Point a) {\n+        this.position = a;\n+        this.taken = true;\n+    }\n+\n+    public Point getPosition() {\n+        return position;\n+    }\n+\n+    public void setPosition(Point position) {\n+        this.position = position;\n+    }\n+\n+    public boolean isTaken() {\n+        return taken;\n+    }\n+\n+    public void setTaken(boolean taken) {\n+        this.taken = taken;\n+    }\n+\n+    public int getTeam() {\n+        return team;\n+    }\n+\n+    public void setTeam(int team) {\n+        this.team = team;\n+    }\n+}"}, {"sha": "a38d2e66809d7662d8d075786721d797e409bf59", "filename": "src/server/partyquest/MapleCarnivalFactory.java", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/partyquest/MapleCarnivalFactory.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/partyquest/MapleCarnivalFactory.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/partyquest/MapleCarnivalFactory.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -0,0 +1,76 @@\n+package server.partyquest;\n+\n+import client.MapleDisease;\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.Map;\n+import server.life.MobSkillFactory;\n+import provider.MapleDataProvider;\n+import provider.MapleDataProviderFactory;\n+import provider.MapleData;\n+import provider.MapleDataTool;\n+import server.life.MobSkill;\n+\n+/**\n+    *@author Drago/Dragohe4rt\n+*/\n+public class MapleCarnivalFactory {\n+\n+    private final static MapleCarnivalFactory instance = new MapleCarnivalFactory();\n+    private final Map<Integer, MCSkill> skills = new HashMap<Integer, MCSkill>();\n+    private final Map<Integer, MCSkill> guardians = new HashMap<Integer, MCSkill>();\n+    private final MapleDataProvider dataRoot = MapleDataProviderFactory.getDataProvider(new File(System.getProperty(\"wzpath\") + \"/Skill.wz\"));\n+\n+    public MapleCarnivalFactory() {\n+        //whoosh\n+\tinitialize();\n+    }\n+\n+    public static final MapleCarnivalFactory getInstance() {\n+        return instance;\n+    }\n+\n+    private void initialize() {\n+        if (skills.size() != 0) {\n+            return;\n+        }\n+        for (MapleData z : dataRoot.getData(\"MCSkill.img\")) {\n+            skills.put(Integer.parseInt(z.getName()), new MCSkill(MapleDataTool.getInt(\"spendCP\", z, 0), MapleDataTool.getInt(\"mobSkillID\", z, 0), MapleDataTool.getInt(\"level\", z, 0), MapleDataTool.getInt(\"target\", z, 1) > 1));\n+        }\n+        for (MapleData z : dataRoot.getData(\"MCGuardian.img\")) {\n+            guardians.put(Integer.parseInt(z.getName()), new MCSkill(MapleDataTool.getInt(\"spendCP\", z, 0), MapleDataTool.getInt(\"mobSkillID\", z, 0), MapleDataTool.getInt(\"level\", z, 0), true));\n+        }\n+    }\n+\n+    public MCSkill getSkill(final int id) {\n+        return skills.get(id);\n+    }\n+\n+    public MCSkill getGuardian(final int id) {\n+        return guardians.get(id);\n+    }\n+\n+    public static class MCSkill {\n+\n+        public int cpLoss, skillid, level;\n+        public boolean targetsAll;\n+\n+        public MCSkill(int _cpLoss, int _skillid, int _level, boolean _targetsAll) {\n+            cpLoss = _cpLoss;\n+            skillid = _skillid;\n+            level = _level;\n+            targetsAll = _targetsAll;\n+        }\n+\n+        public MobSkill getSkill() {\n+            return MobSkillFactory.getMobSkill(skillid, 1); //level?\n+        }\n+\n+        public MapleDisease getDisease() {\n+            if (skillid <= 0) {\n+                return MapleDisease.getRandom();\n+            }\n+            return MapleDisease.getBySkill(skillid);\n+        }\n+    }\n+}"}, {"sha": "490322a2373594d204f9e7d28d358486d6c01c29", "filename": "src/server/partyquest/MonsterCarnival.java", "status": "modified", "additions": 453, "deletions": 138, "changes": 591, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/partyquest/MonsterCarnival.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/server/partyquest/MonsterCarnival.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/server/partyquest/MonsterCarnival.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -1,174 +1,489 @@\n-/*\n-\tThis file is part of the OdinMS Maple Story Server\n-    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n-\t\t       Matthias Butz <matze@odinms.de>\n-\t\t       Jan Christian Meyer <vimes@odinms.de>\n-\n-    This program is free software: you can redistribute it and/or modify\n-    it under the terms of the GNU Affero General Public License as\n-    published by the Free Software Foundation version 3 as published by\n-    the Free Software Foundation. You may not use, modify or distribute\n-    this program under any other version of the GNU Affero General Public\n-    License.\n-\n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU Affero General Public License for more details.\n-\n-    You should have received a copy of the GNU Affero General Public License\n-    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-*/\n-\n package server.partyquest;\n \n-import client.MapleCharacter;\n-import java.sql.Connection;\n-import java.sql.PreparedStatement;\n-import java.sql.SQLException;\n import java.util.concurrent.ScheduledFuture;\n+import client.MapleCharacter;\n+import constants.LinguaConstants;\n+import net.server.Server;\n+import net.server.channel.Channel;\n+import net.server.world.MapleParty;\n+import net.server.world.MaplePartyCharacter;\n import server.TimerManager;\n import server.maps.MapleMap;\n-import tools.DatabaseConnection;\n import tools.MaplePacketCreator;\n \n /**\n- *\n- * @author kevintjuh93 - LOST MOTIVATION >=(\n+ * @author Drago/Dragohe4rt\n  */\n+\n public class MonsterCarnival {\n-    private MonsterCarnivalParty red, blue;\n+\n+    public static int D = 3;\n+    public static int C = 2;\n+    public static int B = 1;\n+    public static int A = 0;\n+\n+    private MapleParty p1, p2;\n     private MapleMap map;\n-    private int room;\n-    private long time = 0;\n-    private long timeStarted = 0;\n-    private ScheduledFuture<?> schedule = null;\n-\n-        public MonsterCarnival(int room, byte channel, MonsterCarnivalParty red1, MonsterCarnivalParty blue1) {\n-            //this.map = Channel.getInstance(channel).getMapFactory().getMap(980000001 + (room * 100));\n-            this.room = room;\n-            this.red = red1;\n-            this.blue = blue1;\n-            this.timeStarted = System.currentTimeMillis();\n-            this.time = 600000;\n-            map.broadcastMessage(MaplePacketCreator.getClock((int) (time / 1000)));\n-\n-            for (MapleCharacter chr : red.getMembers())\n-                chr.setCarnival(this);\n-            for (MapleCharacter chr : blue.getMembers())\n-                chr.setCarnival(this);\n-            \n-            this.schedule = TimerManager.getInstance().schedule(new Runnable() {\n+    private ScheduledFuture<?> timer, effectTimer;\n+    private long startTime = 0;\n+    private int summons = 8, summonss = 8;\n+    private MapleCharacter leader1, leader2, Grupo1, Grupo2;\n+    private int redCP, blueCP, redTotalCP, blueTotalCP;\n+    private boolean cpq1;\n+\n+    public MonsterCarnival(MapleParty p1, MapleParty p2, int mapid, boolean cpq1) {\n+        try {\n+            this.cpq1 = cpq1;\n+            this.p1 = p1;\n+            this.p2 = p2;\n+            Channel cs = Server.getInstance().getWorld(p2.getLeader().getWorld()).getChannel(p2.getLeader().getChannel());\n+            p1.setEnemy(p2);\n+            p2.setEnemy(p1);\n+            map = cs.getMapFactory().resetMap(mapid);\n+            int redPortal = 0;\n+            int bluePortal = 0;\n+            if (map.isPurpleCPQMap()) {\n+                redPortal = 2;\n+                bluePortal = 1;\n+            }\n+            for (MaplePartyCharacter mpc : p1.getMembers()) {\n+                MapleCharacter mc = cs.getPlayerStorage().getCharacterByName(mpc.getName());\n+                if (mc != null) {\n+                    mc.setMonsterCarnival(this);\n+                    mc.setTeam(0);\n+                    mc.setFestivalPoints(0);\n+                    mc.changeMap(map, map.getPortal(redPortal));\n+                    mc.dropMessage(6, LinguaConstants.Linguas(mc).CPQEntrada);\n+                    if (p1.getLeader().getId() == mc.getId()) {\n+                        leader1 = mc;\n+                    }\n+                    Grupo1 = mc;\n+                }\n+            }\n+            for (MaplePartyCharacter mpc : p2.getMembers()) {\n+                MapleCharacter mc = cs.getPlayerStorage().getCharacterByName(mpc.getName());\n+                if (mc != null) {\n+                    mc.setMonsterCarnival(this);\n+                    mc.setTeam(1);\n+                    mc.setFestivalPoints(0);\n+                    mc.changeMap(map, map.getPortal(bluePortal));\n+                    mc.dropMessage(6, LinguaConstants.Linguas(mc).CPQEntrada);\n+                    if (p2.getLeader().getId() == mc.getId()) {\n+                        leader2 = mc;\n+                    }\n+                    Grupo2 = mc;\n+                }\n+            }\n+            if (Grupo1 == null || Grupo2 == null) {\n+                for (MaplePartyCharacter mpc : p2.getMembers()) {\n+                    mpc.getPlayer().dropMessage(5, LinguaConstants.Linguas(mpc.getPlayer()).CPQErro);\n+                }\n+                for (MaplePartyCharacter mpc : p2.getMembers()) {\n+                    mpc.getPlayer().dropMessage(5, LinguaConstants.Linguas(mpc.getPlayer()).CPQErro);\n+                }\n+                return;\n+            }\n+            Grupo1.getClient().announce(MaplePacketCreator.startMonsterCarnival(Grupo1, 0, 1));\n+            Grupo2.getClient().announce(MaplePacketCreator.startMonsterCarnival(Grupo2, 1, 0));\n+            startTime = System.currentTimeMillis() + 60 * 10000;\n+            timer = TimerManager.getInstance().schedule(new Runnable() {\n                 @Override\n                 public void run() {\n-                    if (red.getTotalCP() > blue.getTotalCP()) {\n-                        red.setWinner(true);\n-                        blue.setWinner(false);\n-                        red.displayMatchResult();\n-                        blue.displayMatchResult();\n-                    } else if (blue.getTotalCP() > red.getTotalCP()) {\n-                        red.setWinner(false);\n-                        blue.setWinner(true);\n-                        red.displayMatchResult();\n-                        blue.displayMatchResult();\n-                    } else {\n-                        red.setWinner(false);\n-                        blue.setWinner(false);\n-                        red.displayMatchResult();\n-                        blue.displayMatchResult();\n-                    }\n-                    saveResults();\n-                    warpOut();\n+                    timeUp();\n+                }\n+            }, 10 * 60 * 1000);\n+            effectTimer = TimerManager.getInstance().schedule(new Runnable() {\n+                @Override\n+                public void run() {\n+                    complete();\n+                }\n+            }, 10 * 60 * 1000 - 10 * 1000);\n+            TimerManager.getInstance().schedule(new Runnable() {\n+                @Override\n+                public void run() {\n+                    map.addClock(60 * 10);\n                 }\n+            }, 2000);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    public void playerDisconnected(int charid) {\n+        int team = -1;\n+        for (MaplePartyCharacter mpc : leader1.getParty().getMembers()) {\n+            if (mpc.getId() == charid) {\n+                team = 0;\n+            }\n+        }\n+        for (MaplePartyCharacter mpc : leader2.getParty().getMembers()) {\n+            if (mpc.getId() == charid) {\n+                team = 1;\n+            }\n+        }\n+        for (MapleCharacter chrMap : map.getAllPlayers()) {\n+            if (team == -1) {\n+                team = 1;\n+            }\n+            String teamS = \"\";\n+            switch (team) {\n+                case 0:\n+                    teamS = LinguaConstants.Linguas(chrMap).CPQVermelho;\n+                    break;\n+                case 1:\n+                    teamS = LinguaConstants.Linguas(chrMap).CPQAzul;\n+                    break;\n+            }\n+            chrMap.dropMessage(5, teamS + LinguaConstants.Linguas(chrMap).CPQPlayerExit);\n+        }\n+        earlyFinish();\n+    }\n+\n+    public void earlyFinish() {\n+        dispose(true);\n+    }\n+\n+    public void leftParty(int charid) {\n+        playerDisconnected(charid);\n+    }\n+\n+    protected void dispose() {\n+        dispose(false);\n+    }\n+\n+    public void summon() {\n+        this.summons--;\n+    }\n+\n+    public boolean canSummon() {\n+        return this.summons > 0;\n+    }\n+\n+    public void summons() {\n+        this.summonss--;\n+    }\n+\n+    public boolean canSummons() {\n+        return this.summonss > 0;\n+    }\n+\n+    protected void dispose(boolean warpout) {\n+        Channel cs = Server.getInstance().getWorld(p1.getLeader().getWorld()).getChannel(p1.getLeader().getChannel());\n+        MapleMap out;\n+        if (!cpq1) { // cpq2\n+            out = cs.getMapFactory().getMap(980030000);\n+        } else {\n+            out = cs.getMapFactory().getMap(980000000);\n+        }\n+        for (MaplePartyCharacter mpc : leader1.getParty().getMembers()) {\n+            MapleCharacter mc = cs.getPlayerStorage().getCharacterByName(mpc.getName());\n+            if (mc != null) {\n+                mc.resetCP();\n+                mc.setTeam(-1);\n+                mc.setMonsterCarnival(null);\n+                if (warpout) {\n+                    mc.changeMap(out, out.getPortal(0));\n+                }\n+            }\n+        }\n+        for (MaplePartyCharacter mpc : leader2.getParty().getMembers()) {\n+            MapleCharacter mc = cs.getPlayerStorage().getCharacterByName(mpc.getName());\n+            if (mc != null) {\n+                mc.resetCP();\n+                mc.setTeam(-1);\n+                mc.setMonsterCarnival(null);\n+                if (warpout) {\n+                    mc.changeMap(out, out.getPortal(0));\n+                }\n+            }\n+        }\n+        if (this.timer != null) {\n+            this.timer.cancel(true);\n+            this.timer = null;\n+        }\n+        if (this.effectTimer != null) {\n+            this.effectTimer.cancel(true);\n+            this.effectTimer = null;\n+        }\n+        redTotalCP = 0;\n+        blueTotalCP = 0;\n+        leader1.getParty().setEnemy(null);\n+        leader2.getParty().setEnemy(null);\n \n-            }, time);\n-           /* if (room == 0) {\n-                MapleData data = MapleDataProviderFactory.getDataProvider(new File(System.getProperty(\"wzpath\") + \"/Map.wz\")).getData(\"Map/Map9\" + (980000001 + (room * 100)) + \".img\").getChildByPath(\"monsterCarnival\");\n-                if (data != null) {\n-                    for (MapleData p : data.getChildByPath(\"mobGenPos\").getChildren()) {\n-                        MapleData team = p.getChildByPath(\"team\");\n-                       if (team != null) {\n-                           if (team.getData().equals(0))\n-                               redmonsterpoints.add(new Point(MapleDataTool.getInt(p.getChildByPath(\"x\")), MapleDataTool.getInt(p.getChildByPath(\"y\"))));\n-                           else\n-                                bluemonsterpoints.add(new Point(MapleDataTool.getInt(p.getChildByPath(\"x\")), MapleDataTool.getInt(p.getChildByPath(\"y\"))));\n-                        } else\n-                        monsterpoints.add(new Point(MapleDataTool.getInt(p.getChildByPath(\"x\")), MapleDataTool.getInt(p.getChildByPath(\"y\"))));\n+    }\n+\n+    public void exit() {\n+        dispose();\n+    }\n+\n+    public ScheduledFuture<?> getTimer() {\n+        return this.timer;\n+    }\n+\n+    public void finish(int winningTeam) {\n+        try {\n+            Channel cs = Server.getInstance().getWorld(p1.getLeader().getWorld()).getChannel(p1.getLeader().getChannel());\n+            if (winningTeam == 0) {\n+                for (MaplePartyCharacter mpc : leader1.getParty().getMembers()) {\n+                    MapleCharacter mc = cs.getPlayerStorage().getCharacterByName(mpc.getName());\n+                    if (mc != null) {\n+                        mc.gainFestivalPoints(this.redTotalCP);\n+                        mc.setMonsterCarnival(null);\n+                        if (cpq1) {\n+                            mc.changeMap(cs.getMapFactory().getMap(map.getId() + 2), cs.getMapFactory().getMap(map.getId() + 2).getPortal(0));\n+                        } else {\n+                            mc.changeMap(cs.getMapFactory().getMap(map.getId() + 200), cs.getMapFactory().getMap(map.getId() + 200).getPortal(0));\n+                        }\n+                        mc.setTeam(-1);\n+                        mc.dispelDebuffs();\n+                    }\n+                }\n+                for (MaplePartyCharacter mpc : leader2.getParty().getMembers()) {\n+                    MapleCharacter mc = cs.getPlayerStorage().getCharacterByName(mpc.getName());\n+                    if (mc != null) {\n+                        mc.gainFestivalPoints(this.blueTotalCP);\n+                        mc.setMonsterCarnival(null);\n+                        if (cpq1) {\n+                            mc.changeMap(cs.getMapFactory().getMap(map.getId() + 3), cs.getMapFactory().getMap(map.getId() + 3).getPortal(0));\n+                        } else {\n+                            mc.changeMap(cs.getMapFactory().getMap(map.getId() + 300), cs.getMapFactory().getMap(map.getId() + 300).getPortal(0));\n+                        }\n+                        mc.setTeam(-1);\n+                        mc.dispelDebuffs();\n                     }\n-                    for (MapleData p : data.getChildByPath(\"guardianGenPos\").getChildren()) {\n-                        MapleData team = p.getChildByPath(\"team\");\n-                       if (team != null) {\n-                           if (team.getData().equals(0))\n-                               redreactorpoints.add(new Point(MapleDataTool.getInt(p.getChildByPath(\"x\")), MapleDataTool.getInt(p.getChildByPath(\"y\"))));\n-                           else\n-                                bluereactorpoints.add(new Point(MapleDataTool.getInt(p.getChildByPath(\"x\")), MapleDataTool.getInt(p.getChildByPath(\"y\"))));\n-                        } else\n-                        reactorpoints.add(new Point(MapleDataTool.getInt(p.getChildByPath(\"x\")), MapleDataTool.getInt(p.getChildByPath(\"y\"))));\n+                }\n+            } else if (winningTeam == 1) {\n+                for (MaplePartyCharacter mpc : leader2.getParty().getMembers()) {\n+                    MapleCharacter mc = cs.getPlayerStorage().getCharacterByName(mpc.getName());\n+                    if (mc != null) {\n+                        mc.gainFestivalPoints(this.blueTotalCP);\n+                        mc.setMonsterCarnival(null);\n+                        if (cpq1) {\n+                            mc.changeMap(cs.getMapFactory().getMap(map.getId() + 2), cs.getMapFactory().getMap(map.getId() + 2).getPortal(0));\n+                        } else {\n+                            mc.changeMap(cs.getMapFactory().getMap(map.getId() + 200), cs.getMapFactory().getMap(map.getId() + 200).getPortal(0));\n+                        }\n+                        mc.setTeam(-1);\n+                        mc.dispelDebuffs();\n+                    }\n+                }\n+                for (MaplePartyCharacter mpc : leader1.getParty().getMembers()) {\n+                    MapleCharacter mc = cs.getPlayerStorage().getCharacterByName(mpc.getName());\n+                    if (mc != null) {\n+                        mc.gainFestivalPoints(this.redTotalCP);\n+                        mc.setMonsterCarnival(null);\n+                        if (cpq1) {\n+                            mc.changeMap(cs.getMapFactory().getMap(map.getId() + 3), cs.getMapFactory().getMap(map.getId() + 3).getPortal(0));\n+                        } else {\n+                            mc.changeMap(cs.getMapFactory().getMap(map.getId() + 300), cs.getMapFactory().getMap(map.getId() + 300).getPortal(0));\n+                        }\n+                        mc.setTeam(-1);\n+                        mc.dispelDebuffs();\n                     }\n                 }\n-            } */\n+            }\n+            dispose();\n+        } catch (Exception e) {\n+            e.printStackTrace();\n         }\n+    }\n \n-        public long getTimeLeft() {\n-            return time - (System.currentTimeMillis() - timeStarted);\n+    public void timeUp() {\n+        int cp1 = this.redTotalCP;\n+        int cp2 = this.blueTotalCP;\n+        if (cp1 == cp2) {\n+            extendTime();\n+            return;\n         }\n+        if (cp1 > cp2) {\n+            finish(0);\n+        } else {\n+            finish(1);\n+        }\n+    }\n+\n+    public long getTimeLeft() {\n+        return (startTime - System.currentTimeMillis());\n+    }\n \n-        public MonsterCarnivalParty getPartyRed() {\n-            return red;\n+    public int getTimeLeftSeconds() {\n+        return (int) (getTimeLeft() / 1000);\n+    }\n+\n+    public void extendTime() {\n+        for (MapleCharacter chrMap : map.getAllPlayers()) {\n+            chrMap.dropMessage(5, LinguaConstants.Linguas(chrMap).CPQTempoExtendido);\n         }\n+        startTime = System.currentTimeMillis() + 3 * 1000;\n+        map.addClock(3 * 60);\n+        timer = TimerManager.getInstance().schedule(new Runnable() {\n+            @Override\n+            public void run() {\n+                timeUp();\n+            }\n+        }, 3 * 60 * 1000);\n+        effectTimer = TimerManager.getInstance().schedule(new Runnable() {\n+            @Override\n+            public void run() {\n+                complete();\n+            }\n+        }, 3 * 60 * 1000 - 10);\n+    }\n \n-        public MonsterCarnivalParty getPartyBlue() {\n-            return blue;\n+    public void complete() {\n+        int cp1 = this.redTotalCP;\n+        int cp2 = this.blueTotalCP;\n+        if (cp1 == cp2) {\n+            return;\n+        }\n+        boolean redWin = cp1 > cp2;\n+        int chnl = leader1.getClient().getChannel();\n+        int chnl1 = leader2.getClient().getChannel();\n+        if (chnl != chnl1) {\n+            throw new RuntimeException(\"Os l\ufffdderes est\ufffdo em canais diferentes.\");\n         }\n \n-        public MonsterCarnivalParty oppositeTeam(MonsterCarnivalParty team) {\n-            if (team == red)\n-                return blue;\n-            else\n-                return red;\n+        Channel cs = Server.getInstance().getWorld(p1.getLeader().getWorld()).getChannel(p1.getLeader().getChannel());\n+        map.killAllMonsters();\n+        for (MaplePartyCharacter mpc : leader1.getParty().getMembers()) {\n+            MapleCharacter mc;\n+            mc = cs.getPlayerStorage().getCharacterByName(mpc.getName());\n+            if (mc != null) {\n+                if (redWin) {\n+                    mc.getClient().announce(MaplePacketCreator.showEffect(\"quest/carnival/win\"));\n+                    mc.getClient().announce(MaplePacketCreator.playSound(\"MobCarnival/Win\"));\n+                    mc.dispelDebuffs();\n+                } else {\n+                    mc.getClient().announce(MaplePacketCreator.showEffect(\"quest/carnival/lose\"));\n+                    mc.getClient().announce(MaplePacketCreator.playSound(\"MobCarnival/Lose\"));\n+                    mc.dispelDebuffs();\n+                }\n+            }\n+        }\n+        for (MaplePartyCharacter mpc : leader2.getParty().getMembers()) {\n+            MapleCharacter mc;\n+            mc = cs.getPlayerStorage().getCharacterByName(mpc.getName());\n+            if (mc != null) {\n+                if (!redWin) {\n+                    mc.getClient().announce(MaplePacketCreator.showEffect(\"quest/carnival/win\"));\n+                    mc.getClient().announce(MaplePacketCreator.playSound(\"MobCarnival/Win\"));\n+                    mc.dispelDebuffs();\n+                } else {\n+                    mc.getClient().announce(MaplePacketCreator.showEffect(\"quest/carnival/lose\"));\n+                    mc.getClient().announce(MaplePacketCreator.playSound(\"MobCarnival/Lose\"));\n+                    mc.dispelDebuffs();\n+                }\n+            }\n         }\n+    }\n+\n+    public MapleParty getRed() {\n+        return p1;\n+    }\n+\n+    public void setRed(MapleParty p1) {\n+        this.p1 = p1;\n+    }\n+\n+    public MapleParty getBlue() {\n+        return p2;\n+    }\n+\n+    public void setBlue(MapleParty p2) {\n+        this.p2 = p2;\n+    }\n+\n+    public MapleCharacter getLeader1() {\n+        return leader1;\n+    }\n \n-        public void playerLeft(MapleCharacter chr) {\n-            map.broadcastMessage(chr, MaplePacketCreator.leaveCPQ(chr));\n+    public void setLeader1(MapleCharacter leader1) {\n+        this.leader1 = leader1;\n+    }\n+\n+    public MapleCharacter getLeader2() {\n+        return leader2;\n+    }\n+\n+    public void setLeader2(MapleCharacter leader2) {\n+        this.leader2 = leader2;\n+    }\n+\n+    public MapleCharacter getEnemyLeader(int team) {\n+        switch (team) {\n+            case 0:\n+                return leader2;\n+            case 1:\n+                return leader1;\n         }\n+        return null;\n+    }\n \n-        private void warpOut() {\n-            this.schedule = TimerManager.getInstance().schedule(new Runnable() {\n-                @Override\n-                public void run() {\n-                    red.warpOut();\n-                    blue.warpOut();\n-                }\n-            }, 12000);\n+    public int getBlueCP() {\n+        return blueCP;\n+    }\n+\n+    public void setBlueCP(int blueCP) {\n+        this.blueCP = blueCP;\n+    }\n+\n+    public int getBlueTotalCP() {\n+        return blueTotalCP;\n+    }\n+\n+    public void setBlueTotalCP(int blueTotalCP) {\n+        this.blueTotalCP = blueTotalCP;\n+    }\n+\n+    public int getRedCP() {\n+        return redCP;\n+    }\n+\n+    public void setRedCP(int redCP) {\n+        this.redCP = redCP;\n+    }\n+\n+    public int getRedTotalCP() {\n+        return redTotalCP;\n+    }\n+\n+    public void setRedTotalCP(int redTotalCP) {\n+        this.redTotalCP = redTotalCP;\n+    }\n+\n+    public int getTotalCP(int team) {\n+        if (team == 0) {\n+            return redTotalCP;\n+        } else if (team == 1) {\n+            return blueTotalCP;\n+        } else {\n+            throw new RuntimeException(\"Equipe desconhecida\");\n         }\n+    }\n \n-        public int getRoom() {\n-            return room;\n+    public void setTotalCP(int totalCP, int team) {\n+        if (team == 0) {\n+            this.redTotalCP = totalCP;\n+        } else if (team == 1) {\n+            this.blueTotalCP = totalCP;\n         }\n+    }\n \n-        public void saveResults() {\n-                Connection con = null;\n-                try {\n-                    con = DatabaseConnection.getConnection();\n-                    PreparedStatement ps = con.prepareStatement(\"INSERT INTO carnivalresults VALUES (?,?,?,?)\");\n-                    for (MapleCharacter chr : red.getMembers()) {\n-                        ps.setInt(1, chr.getId());\n-                        ps.setInt(2, chr.getCP());\n-                        ps.setInt(3, red.getTotalCP());\n-                        ps.setInt(4, red.isWinner() ? 1 : 0);\n-                        ps.execute();\n-                    }\n-                    for (MapleCharacter chr : blue.getMembers()) {\n-                        ps.setInt(1, chr.getId());\n-                        ps.setInt(2, chr.getCP());\n-                        ps.setInt(3, blue.getTotalCP());\n-                        ps.setInt(4, blue.isWinner() ? 1 : 0);\n-                        ps.execute();\n-                    }\n-                    ps.close();\n-                    con.close();\n-                } catch (SQLException ex) {\n-                    ex.printStackTrace();\n-                }\n+    public int getCP(int team) {\n+        if (team == 0) {\n+            return redCP;\n+        } else if (team == 1) {\n+            return blueCP;\n+        } else {\n+            throw new RuntimeException(\"Equipe desconhecida\" + team);\n+        }\n+    }\n+\n+    public void setCP(int CP, int team) {\n+        if (team == 0) {\n+            this.redCP = CP;\n+        } else if (team == 1) {\n+            this.blueCP = CP;\n         }\n+    }\n }"}, {"sha": "171ce14f88f4701779a5b214b669bbf937a78e58", "filename": "src/tools/MaplePacketCreator.java", "status": "modified", "additions": 7635, "deletions": 7619, "changes": 15254, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/tools/MaplePacketCreator.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/tools/MaplePacketCreator.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/tools/MaplePacketCreator.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595"}, {"sha": "bc8351be8ad4501f0887001bde35371f12019bd9", "filename": "src/tools/data/output/GenericLittleEndianWriter.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/tools/data/output/GenericLittleEndianWriter.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/tools/data/output/GenericLittleEndianWriter.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/tools/data/output/GenericLittleEndianWriter.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -33,7 +33,7 @@\n  * @since Revision 323\n  */\n public class GenericLittleEndianWriter implements LittleEndianWriter {\n-    private static Charset ASCII = Charset.forName(MapleLanguageType.LANGUAGE_US.getAscii());\n+    private static Charset ASCII = Charset.forName(MapleLanguageType.LANGUAGE_PT_BR.getAscii());\n     private ByteOutputStream bos;\n \n     /**"}, {"sha": "95946051dec536d365c63a6c92de697cf8d5cc06", "filename": "src/tools/packets/Wedding.java", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/tools/packets/Wedding.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/90ad58f17feec67ea4a50c859ba472e94ef8a595/src/tools/packets/Wedding.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/tools/packets/Wedding.java?ref=90ad58f17feec67ea4a50c859ba472e94ef8a595", "patch": "@@ -18,7 +18,7 @@\n /**\n  * CField_Wedding, CField_WeddingPhoto, CWeddingMan, OnMarriageResult, and all Wedding/Marriage enum/structs.\n  * \n- * @author Eric\n+ * @author Eric edited by Drago/Dragohe4rt on Wishlist\n  */\n public class Wedding extends MaplePacketCreator {\n     private static final short MARRIAGE_REQUEST = 0x48;\n@@ -375,7 +375,7 @@ public int getItem() {\n     }\n \n     /**\n-     * Handles all of WeddingWishlist packets\n+     * Handles all of WeddingWishlist packets \n      * \n      *    @param mode\n      *    @param itemnames\n@@ -392,17 +392,16 @@ public int getItem() {\n         MaplePacketLittleEndianWriter mplew = new MaplePacketLittleEndianWriter();\n         mplew.writeShort(WEDDING_GIFT_RESULT);\n         mplew.write(mode);\n-        switch(mode) {\n+        switch (mode) {\n             case 0x09: { // Load Wedding Registry\n                 mplew.write(itemnames.size());\n                 for (String names : itemnames) {\n                     mplew.writeMapleAsciiString(names);\n                 }\n-                mplew.write(itemnames.size());\n-                for (String names : itemnames) {\n-                    mplew.writeMapleAsciiString(names);\n+                mplew.write(items.size());\n+                for (Item item : items) {\n+                    addItemInfo(mplew, item, true);\n                 }\n-                // need to load items somehow\n                 break;\n             }\n             case 0xA: // Load Bride's Wishlist \n@@ -415,30 +414,31 @@ public int getItem() {\n                         mplew.writeMapleAsciiString(names);\n                     }\n                 }\n-                switch (items.get((items.size() - 1)).getInventoryType()) {\n-                    case EQUIP:\n-                        mplew.writeLong(4);\n-                        break;\n-                    case USE:\n-                        mplew.writeLong(8);\n-                        break;\n-                    case SETUP:\n-                        mplew.writeLong(16);\n-                        break;\n-                    case ETC:\n-                        mplew.writeLong(32);\n-                        break;\n-                    default: // impossible flag, cash item can't be sent\n-                        if (items.get((items.size() - 1)).getInventoryType() != MapleInventoryType.CASH) {\n-                            mplew.writeLong(0);\n-                        }\n-                }\n-                if (mode == 0xA) { // random unknown bytes involved within Bride's Wishlist\n-                    mplew.writeInt(0);\n+                if (items.size() >= 1) {\n+                    switch (items.get((items.size() - 1)).getInventoryType()) {\n+                        case EQUIP:\n+                            mplew.writeLong(4);\n+                            break;\n+                        case USE:\n+                            mplew.writeLong(8);\n+                            break;\n+                        case SETUP:\n+                            mplew.writeLong(16);\n+                            break;\n+                        case ETC:\n+                            mplew.writeLong(32);\n+                            break;\n+                        default: // impossible flag, cash item can't be sent\n+                            if (items.get((items.size() - 1)).getInventoryType() != MapleInventoryType.CASH) {\n+                                mplew.writeLong(0);\n+                            }\n+                    }\n+                } else {\n+                    mplew.writeLong(0);\n                 }\n                 mplew.write(items.size());\n                 for (Item item : items) {\n-                    MaplePacketCreator.addItemInfo(mplew, item, true);\n+                    addItemInfo(mplew, item, true);\n                 }\n                 break;\n             }"}]}]},
