{"fetchDate": "2019-12-19", "content": [{"sha": "67ab83a09b2e6db0bbe0a9a8b05e2ebd222a690d", "node_id": "MDY6Q29tbWl0NDUwODIwMjM6NjdhYjgzYTA5YjJlNmRiMGJiZTBhOWE4YjA1ZTJlYmQyMjJhNjkwZA==", "commit": {"author": {"name": "ronancpl", "email": "rcpl2010@gmail.com", "date": "2018-03-12T19:16:07Z"}, "committer": {"name": "ronancpl", "email": "rcpl2010@gmail.com", "date": "2018-03-12T19:16:07Z"}, "message": "MoveLifeHandler update\n\nEXPERIMENTAL PATCH: Applied an improved version of the MoveLifeHandler. This update requires proper investigation and feedback for acceptance.", "tree": {"sha": "d4a804f6547644cad59b14c04287a4f8b87b7a35", "url": "https://api.github.com/repos/ronancpl/HeavenMS/git/trees/d4a804f6547644cad59b14c04287a4f8b87b7a35"}, "url": "https://api.github.com/repos/ronancpl/HeavenMS/git/commits/67ab83a09b2e6db0bbe0a9a8b05e2ebd222a690d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/ronancpl/HeavenMS/commits/67ab83a09b2e6db0bbe0a9a8b05e2ebd222a690d", "html_url": "https://github.com/ronancpl/HeavenMS/commit/67ab83a09b2e6db0bbe0a9a8b05e2ebd222a690d", "comments_url": "https://api.github.com/repos/ronancpl/HeavenMS/commits/67ab83a09b2e6db0bbe0a9a8b05e2ebd222a690d/comments", "author": {"login": "ronancpl", "id": 9257761, "node_id": "MDQ6VXNlcjkyNTc3NjE=", "avatar_url": "https://avatars2.githubusercontent.com/u/9257761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ronancpl", "html_url": "https://github.com/ronancpl", "followers_url": "https://api.github.com/users/ronancpl/followers", "following_url": "https://api.github.com/users/ronancpl/following{/other_user}", "gists_url": "https://api.github.com/users/ronancpl/gists{/gist_id}", "starred_url": "https://api.github.com/users/ronancpl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ronancpl/subscriptions", "organizations_url": "https://api.github.com/users/ronancpl/orgs", "repos_url": "https://api.github.com/users/ronancpl/repos", "events_url": "https://api.github.com/users/ronancpl/events{/privacy}", "received_events_url": "https://api.github.com/users/ronancpl/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ronancpl", "id": 9257761, "node_id": "MDQ6VXNlcjkyNTc3NjE=", "avatar_url": "https://avatars2.githubusercontent.com/u/9257761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ronancpl", "html_url": "https://github.com/ronancpl", "followers_url": "https://api.github.com/users/ronancpl/followers", "following_url": "https://api.github.com/users/ronancpl/following{/other_user}", "gists_url": "https://api.github.com/users/ronancpl/gists{/gist_id}", "starred_url": "https://api.github.com/users/ronancpl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ronancpl/subscriptions", "organizations_url": "https://api.github.com/users/ronancpl/orgs", "repos_url": "https://api.github.com/users/ronancpl/repos", "events_url": "https://api.github.com/users/ronancpl/events{/privacy}", "received_events_url": "https://api.github.com/users/ronancpl/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77234e29df091fc8e72d341062461f23300fe9f5", "url": "https://api.github.com/repos/ronancpl/HeavenMS/commits/77234e29df091fc8e72d341062461f23300fe9f5", "html_url": "https://github.com/ronancpl/HeavenMS/commit/77234e29df091fc8e72d341062461f23300fe9f5"}], "stats": {"total": 200, "additions": 124, "deletions": 76}, "files": [{"sha": "6e6b474f335b5571ebf7d71543bc829089f82842", "filename": "src/net/server/channel/handlers/MoveLifeHandler.java", "status": "modified", "additions": 106, "deletions": 75, "changes": 181, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/67ab83a09b2e6db0bbe0a9a8b05e2ebd222a690d/src/net/server/channel/handlers/MoveLifeHandler.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/67ab83a09b2e6db0bbe0a9a8b05e2ebd222a690d/src/net/server/channel/handlers/MoveLifeHandler.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/net/server/channel/handlers/MoveLifeHandler.java?ref=67ab83a09b2e6db0bbe0a9a8b05e2ebd222a690d", "patch": "@@ -1,8 +1,8 @@\n /*\n-\tThis file is part of the OdinMS Maple Story Server\n+    This file is part of the OdinMS Maple Story Server\n     Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>\n-\t\t       Matthias Butz <matze@odinms.de>\n-\t\t       Jan Christian Meyer <vimes@odinms.de>\n+               Matthias Butz <matze@odinms.de>\n+               Jan Christian Meyer <vimes@odinms.de>\n \n     This program is free software: you can redistribute it and/or modify\n     it under the terms of the GNU Affero General Public License as\n@@ -27,9 +27,10 @@\n import java.util.ArrayList;\n import java.util.List;\n import server.life.MapleMonster;\n+import server.life.MobAttackInfo;\n+import server.life.MobAttackInfoFactory;\n import server.life.MobSkill;\n import server.life.MobSkillFactory;\n-import server.maps.MapleMap;\n import server.maps.MapleMapObject;\n import server.maps.MapleMapObjectType;\n import server.movement.LifeMovementFragment;\n@@ -38,77 +39,107 @@\n import tools.Randomizer;\n import tools.data.input.SeekableLittleEndianAccessor;\n \n+/**\n+ * @author Danny (Leifde)\n+ * @author ExtremeDevilz\n+ */\n public final class MoveLifeHandler extends AbstractMovementPacketHandler {\n-    @Override\n-    public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c) {\n-        MapleMap map = c.getPlayer().getMap();\n-        List<MapleCharacter> banishPlayers = new ArrayList<>();\n-        \n-        int objectid = slea.readInt();\n-        short moveid = slea.readShort();\n+\t@Override\n+\tpublic final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c) {\n+\t\tint objectid = slea.readInt();\n+\t\tshort moveid = slea.readShort();\n+\t\tMapleMapObject mmo = c.getPlayer().getMap().getMapObject(objectid);\n+\t\tif (mmo == null || mmo.getType() != MapleMapObjectType.MONSTER) {\n+\t\t\treturn;\n+\t\t}\n+\t\tMapleMonster monster = (MapleMonster) mmo;\n+\t\tList<LifeMovementFragment> res = null;\n+                List<MapleCharacter> banishPlayers = new ArrayList<>();\n+\t\tbyte pNibbles = slea.readByte();\n+\t\tbyte rawActivity = slea.readByte();\n+\t\tbyte useSkillId = slea.readByte();\n+\t\tbyte useSkillLevel = slea.readByte();\n+\t\tshort pOption = slea.readShort();\n+                slea.skip(8);\n \n-        MapleMapObject mmo = map.getMapObject(objectid);\n-        if (mmo == null || mmo.getType() != MapleMapObjectType.MONSTER) {\n-            return;\n-        }\n-        MapleMonster monster = (MapleMonster) mmo;\n-        List<LifeMovementFragment> res;\n-        byte skillByte = slea.readByte();\n-        byte skill = slea.readByte();\n-        int skill_1 = slea.readByte() & 0xFF;\n-        byte skill_2 = slea.readByte();\n-        byte skill_3 = slea.readByte();\n-        byte skill_4 = slea.readByte();\n-        slea.read(8);\n-        MobSkill toUse = null;\n-        if (skillByte == 1 && monster.getNoSkills() > 0) {\n-            int random = Randomizer.nextInt(monster.getNoSkills());\n-            Pair<Integer, Integer> skillToUse = monster.getSkills().get(random);\n-            toUse = MobSkillFactory.getMobSkill(skillToUse.getLeft(), skillToUse.getRight());\n-            int percHpLeft = (monster.getHp() / monster.getMaxHp()) * 100;\n-            if (toUse.getHP() < percHpLeft || !monster.canUseSkill(toUse)) {\n-                toUse = null;\n-            }\n-        }\n-        if ((skill_1 >= 100 && skill_1 <= 200) && monster.hasSkill(skill_1, skill_2)) {\n-            MobSkill skillData = MobSkillFactory.getMobSkill(skill_1, skill_2);\n-            if (skillData != null && monster.canUseSkill(skillData)) {\n-                skillData.applyEffect(c.getPlayer(), monster, true, banishPlayers);\n-            }\n-        }\n-        slea.readByte();\n-        slea.readInt(); // whatever\n-        short start_x = slea.readShort(); // hmm.. startpos?\n-        short start_y = slea.readShort(); // hmm...\n-        Point startPos = new Point(start_x, start_y);\n-        res = parseMovement(slea);\n-        if (monster.getController() != c.getPlayer()) {\n-            if (monster.isAttackedBy(c.getPlayer())) {// aggro and controller change\n-                monster.switchController(c.getPlayer(), true);\n-            } else {\n-                return;\n-            }\n-        } else if (skill == -1 && monster.isControllerKnowsAboutAggro() && !monster.isMobile() && !monster.isFirstAttack()) {\n-            monster.setControllerHasAggro(false);\n-            monster.setControllerKnowsAboutAggro(false);\n-        }\n-        boolean aggro = monster.isControllerHasAggro();\n-        if (toUse != null) {\n-                c.announce(MaplePacketCreator.moveMonsterResponse(objectid, moveid, monster.getMp(), aggro, toUse.getSkillId(), toUse.getSkillLevel()));\n-        } else {\n-            c.announce(MaplePacketCreator.moveMonsterResponse(objectid, moveid, monster.getMp(), aggro));\n-        }\n-        if (aggro) {\n-            monster.setControllerKnowsAboutAggro(true);\n-        }\n-        if (res != null) {\n-            map.broadcastMessage(c.getPlayer(), MaplePacketCreator.moveMonster(skillByte, skill, skill_1, skill_2, skill_3, skill_4, objectid, startPos, res), monster.getPosition());\n-            updatePosition(res, monster, -1);\n-            map.moveMonster(monster, monster.getPosition());\n-        }\n+\t\tif (rawActivity >= 0) {\n+\t\t\trawActivity = (byte) (rawActivity & 0xFF >> 1);\n+\t\t}\n \n-        for (MapleCharacter chr : banishPlayers) {\n-            chr.changeMapBanish(monster.getBanish().getMap(), monster.getBanish().getPortal(), monster.getBanish().getMsg());\n-        }\n-    }\n-}\n+\t\tboolean isAttack = inRangeInclusive(rawActivity, 12, 20);\n+\t\tboolean isSkill = inRangeInclusive(rawActivity, 21, 25);\n+\n+\t\tbyte attackId = (byte) (isAttack ? rawActivity - 12 : -1);\n+\t\tboolean nextMovementCouldBeSkill = (pNibbles & 0x0F) != 0;\n+\t\tboolean pUnk = (pNibbles & 0xF0) != 0;\n+\n+\t\tint nextCastSkill = useSkillId;\n+\t\tint nextCastSkillLevel = useSkillLevel;\n+\t\t\n+\t\tMobSkill toUse = null;\n+\t\t\n+\t\tint percHpLeft = (int) ((monster.getHp() / monster.getMaxHp()) * 100);\n+\n+\t\tif (nextMovementCouldBeSkill && monster.getNoSkills() > 0) {\n+\t\t\tint Random = Randomizer.nextInt(monster.getNoSkills());\n+\t\t\tPair<Integer, Integer> skillToUse = monster.getSkills().get(Random);\n+\t\t\tnextCastSkill = skillToUse.getLeft();\n+\t\t\tnextCastSkillLevel = skillToUse.getRight();\n+\t\t\ttoUse = MobSkillFactory.getMobSkill(nextCastSkill, nextCastSkillLevel);\n+\n+\t\t\tif (isSkill || isAttack) {\n+\t\t\t\tif (nextCastSkill != toUse.getSkillId() || nextCastSkillLevel != toUse.getSkillLevel()) {\n+\t\t\t\t\t//toUse.resetAnticipatedSkill();\n+\t\t\t\t\treturn;\n+\t\t\t\t} else if (toUse.getHP() < percHpLeft) {\n+\t\t\t\t\ttoUse = null;\n+\t\t\t\t} else if (monster.canUseSkill(toUse)) {\n+\t\t\t\t\ttoUse.applyEffect(c.getPlayer(), monster, true, banishPlayers);\n+\t\t\t\t\t//System.out.println(\"Applied: \" + nextCastSkill + \" Level: \" + nextCastSkillLevel);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tMobAttackInfo mobAttack = MobAttackInfoFactory.getMobAttackInfo(monster, attackId);\n+\t\t\t\t//System.out.println(\"Attacked\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tslea.readByte();\n+\t\tslea.readInt(); // whatever\n+\t\tshort start_x = slea.readShort(); // hmm.. startpos?\n+\t\tshort start_y = slea.readShort(); // hmm...\n+\t\tPoint startPos = new Point(start_x, start_y);\n+\t\tres = parseMovement(slea);\n+\t\tif (monster.getController() != c.getPlayer()) {\n+\t\t\tif (monster.isAttackedBy(c.getPlayer())) {\n+\t\t\t\tmonster.switchController(c.getPlayer(), true);\n+\t\t\t} else {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t} else if (rawActivity == -1 && monster.isControllerKnowsAboutAggro() && !monster.isMobile() && !monster.isFirstAttack()) {\n+\t\t\tmonster.setControllerHasAggro(false);\n+\t\t\tmonster.setControllerKnowsAboutAggro(false);\n+\t\t}\n+\t\tboolean aggro = monster.isControllerHasAggro();\n+\t\tif (toUse != null) {\n+\t\t\tc.announce(MaplePacketCreator.moveMonsterResponse(objectid, moveid, monster.getMp(), aggro, toUse.getSkillId(), toUse.getSkillLevel()));\n+\t\t} else {\n+\t\t\tc.announce(MaplePacketCreator.moveMonsterResponse(objectid, moveid, monster.getMp(), aggro));\n+\t\t}\n+\t\tif (aggro) {\n+\t\t\tmonster.setControllerKnowsAboutAggro(true);\n+\t\t}\n+\t\tif (res != null) {\n+\t\t\tc.getPlayer().getMap().broadcastMessage(c.getPlayer(), MaplePacketCreator.moveMonster(objectid, nextMovementCouldBeSkill, rawActivity, useSkillId, useSkillLevel, pOption, startPos, res), monster.getPosition());\n+\t\t\tupdatePosition(res, monster, -1);\n+\t\t\tc.getPlayer().getMap().moveMonster(monster, monster.getPosition());\n+\t\t}\n+                \n+                for (MapleCharacter chr : banishPlayers) {\n+                       chr.changeMapBanish(monster.getBanish().getMap(), monster.getBanish().getPortal(), monster.getBanish().getMsg());\n+                }\n+\t}\n+\n+\tpublic static boolean inRangeInclusive(Byte pVal, Integer pMin, Integer pMax) {\n+\t\treturn !(pVal < pMin) || (pVal > pMax);\n+\t}\n+}\n\\ No newline at end of file"}, {"sha": "c4db45f322e77cc84176e49a38f367b3ff2a5242", "filename": "src/tools/MaplePacketCreator.java", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/ronancpl/HeavenMS/blob/67ab83a09b2e6db0bbe0a9a8b05e2ebd222a690d/src/tools/MaplePacketCreator.java", "raw_url": "https://github.com/ronancpl/HeavenMS/raw/67ab83a09b2e6db0bbe0a9a8b05e2ebd222a690d/src/tools/MaplePacketCreator.java", "contents_url": "https://api.github.com/repos/ronancpl/HeavenMS/contents/src/tools/MaplePacketCreator.java?ref=67ab83a09b2e6db0bbe0a9a8b05e2ebd222a690d", "patch": "@@ -2081,7 +2081,23 @@ private static void serializeMovementList(LittleEndianWriter lew, List<LifeMovem\n                 serializeMovementList(mplew, moves);\n                 return mplew.getPacket();\n         }\n-\n+        \n+        public static byte[] moveMonster(int oid, boolean skillPossible, int skill, int skillId, int skillLevel, int pOption, Point startPos, List<LifeMovementFragment> moves) {\n+                final MaplePacketLittleEndianWriter mplew = new MaplePacketLittleEndianWriter();\n+                mplew.writeShort(SendOpcode.MOVE_MONSTER.getValue());\n+                mplew.writeInt(oid);\n+                mplew.write(0);\n+                mplew.writeBool(skillPossible);\n+                mplew.write(skill);\n+                mplew.write(skillId);\n+                mplew.write(skillLevel);\n+                mplew.writeShort(pOption);\n+                mplew.writePos(startPos);\n+                serializeMovementList(mplew, moves);\n+                return mplew.getPacket();\n+        }\n+        \n+        /*\n         public static byte[] moveMonster(int useskill, int skill, int skill_1, int skill_2, int skill_3, int skill_4, int oid, Point startPos, List<LifeMovementFragment> moves) {\n                 final MaplePacketLittleEndianWriter mplew = new MaplePacketLittleEndianWriter();\n                 mplew.writeShort(SendOpcode.MOVE_MONSTER.getValue());\n@@ -2097,6 +2113,7 @@ private static void serializeMovementList(LittleEndianWriter lew, List<LifeMovem\n                 serializeMovementList(mplew, moves);\n                 return mplew.getPacket();\n         }\n+        */\n         \n         public static byte[] summonAttack(int cid, int summonOid, byte direction, List<SummonAttackEntry> allDamage) {\n                 final MaplePacketLittleEndianWriter mplew = new MaplePacketLittleEndianWriter();"}]}]},
