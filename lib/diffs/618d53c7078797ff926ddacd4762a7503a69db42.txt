diff --git a/docs/mychanges_ptbr.txt b/docs/mychanges_ptbr.txt
index bdb3c8686..135190d9f 100644
--- a/docs/mychanges_ptbr.txt
+++ b/docs/mychanges_ptbr.txt
@@ -1847,4 +1847,6 @@ Corrigido caso de XML parser em MapleSkillBookInformationParser não lidando com
 Corrigido jogadores podendo explorar mecânica de checagem de match, não respondendo ao match e sendo permitido se registrar em um novo sem ter respondido ao anterior.
 Corrigido caso de dupe com itens ao serem colocados no storage.
 Adicionado sistema de "qualquer NPC scriptável", com apoio do GabrielSin.
-Adicionado server flag para checagem de IP's ao logar jogadores.
\ No newline at end of file
+Adicionado server flag para checagem de IP's ao logar jogadores.
+Corrigido mobskills não sendo devidamente aplicados devido a um deslize anterior que tentaria aplicar indevidamente 2x "uso de skill" (uma das vezes deveria ser somente checagem de rotina).
+Corrigido puppets de arqueiros interrompendo mob statuses para o dono ao serem lançados em campo.
\ No newline at end of file
diff --git a/src/net/server/channel/handlers/MoveLifeHandler.java b/src/net/server/channel/handlers/MoveLifeHandler.java
index 29822708c..727859343 100644
--- a/src/net/server/channel/handlers/MoveLifeHandler.java
+++ b/src/net/server/channel/handlers/MoveLifeHandler.java
@@ -95,7 +95,7 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)
                         if (castPos != -1) {
                                 toUse = MobSkillFactory.getMobSkill(useSkillId, useSkillLevel);
                                 
-                                if (monster.canUseSkill(toUse)) {
+                                if (monster.canUseSkill(toUse, true)) {
                                         int animationTime = MapleMonsterInformationProvider.getInstance().getMobSkillAnimationTime(toUse);
                                         if(animationTime > 0 && toUse.getSkillId() != 129) {
                                                 toUse.applyDelayedEffect(player, monster, true, animationTime);
@@ -126,7 +126,7 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)
                                 nextSkillLevel = skillToUse.getRight();
                                 nextUse = MobSkillFactory.getMobSkill(nextSkillId, nextSkillLevel);
                                 
-                                if (!(nextUse != null && monster.canUseSkill(nextUse) && nextUse.getHP() >= (int) (((float) monster.getHp() / monster.getMaxHp()) * 100) && mobMp >= nextUse.getMpCon())) {
+                                if (!(nextUse != null && monster.canUseSkill(nextUse, false) && nextUse.getHP() >= (int) (((float) monster.getHp() / monster.getMaxHp()) * 100) && mobMp >= nextUse.getMpCon())) {
                                         // thanks OishiiKawaiiDesu for noticing mobs trying to cast skills they are not supposed to be able
                                         
                                         nextSkillId = 0;
diff --git a/src/server/life/MapleMonster.java b/src/server/life/MapleMonster.java
index 31a6f28b5..c0ecb3853 100644
--- a/src/server/life/MapleMonster.java
+++ b/src/server/life/MapleMonster.java
@@ -964,6 +964,19 @@ public boolean hasBossHPBar() {
         return isBoss() && getTagColor() > 0;
     }
     
+    public void announceMonsterStatus(MapleClient client) {
+        statiLock.lock();
+        try {
+            if (stati.size() > 0) {
+                for (final MonsterStatusEffect mse : this.stati.values()) {
+                    client.announce(MaplePacketCreator.applyMonsterStatus(getObjectId(), mse, null));
+                }
+            }
+        } finally {
+            statiLock.unlock();
+        }
+    }
+    
     @Override
     public void sendSpawnData(MapleClient client) {
         if (hp.get() <= 0) { // mustn't monsterLock this function
@@ -975,16 +988,7 @@ public void sendSpawnData(MapleClient client) {
             client.announce(MaplePacketCreator.spawnMonster(this, false));
         }
         
-        statiLock.lock();
-        try {
-            if (stati.size() > 0) {
-                for (final MonsterStatusEffect mse : this.stati.values()) {
-                    client.announce(MaplePacketCreator.applyMonsterStatus(getObjectId(), mse, null));
-                }
-            }
-        } finally {
-            statiLock.unlock();
-        }
+        announceMonsterStatus(client);
         
         if (hasBossHPBar()) {
             client.announceBossHpBar(this, this.hashCode(), makeBossHPBarPacket());
@@ -1395,7 +1399,7 @@ public int getSkillPos(int skillId, int level) {
         return -1;
     }
     
-    public boolean canUseSkill(MobSkill toUse) {
+    public boolean canUseSkill(MobSkill toUse, boolean apply) {
         if (toUse == null) {
             return false;
         }
@@ -1426,7 +1430,9 @@ public boolean canUseSkill(MobSkill toUse) {
             }
             */
             
-            this.usedSkill(toUse);
+            if (apply) {
+                this.usedSkill(toUse);
+            }
         } finally {
             monsterLock.unlock();
         }
@@ -2072,8 +2078,10 @@ private void aggroRefreshPuppetVisibility(MapleCharacter chrController, MapleSum
         }
         chrController.announce(MaplePacketCreator.removeSummon(puppet, false));
         
+        MapleClient c = chrController.getClient();
         for (MapleMonster mob : puppetControlled) {
             chrController.announce(MaplePacketCreator.controlMonster(mob, false, mob.isControllerHasAggro()));
+            mob.announceMonsterStatus(c);   // thanks BHB for noticing puppets disrupting mobstatuses for bowmans
         }
         chrController.announce(MaplePacketCreator.spawnSummon(puppet, false));
     }
