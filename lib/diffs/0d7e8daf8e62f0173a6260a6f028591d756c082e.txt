diff --git a/launch_server_linux.sh b/launch_server_linux.sh
new file mode 100644
index 000000000..46ac04b7b
--- /dev/null
+++ b/launch_server_linux.sh
@@ -0,0 +1,3 @@
+#!/bin/sh
+export CLASSPATH=".:dist/*" 
+java -Xmx3000m -Dwzpath=wz/ net.server.Server
\ No newline at end of file
diff --git a/nbproject/build-impl.xml b/nbproject/build-impl.xml
index 6fd0f0e47..e5512415f 100644
--- a/nbproject/build-impl.xml
+++ b/nbproject/build-impl.xml
@@ -54,43 +54,7 @@ is divided into following sections:
         <property file="nbproject/project.properties"/>
     </target>
     <target depends="-pre-init,-init-private,-init-user,-init-project,-init-macrodef-property" name="-do-init">
-        <j2seproject1:property name="platform.home" value="platforms.${platform.active}.home"/>
-        <j2seproject1:property name="platform.bootcp" value="platforms.${platform.active}.bootclasspath"/>
-        <j2seproject1:property name="platform.compiler" value="platforms.${platform.active}.compile"/>
-        <j2seproject1:property name="platform.javac.tmp" value="platforms.${platform.active}.javac"/>
-        <condition property="platform.javac" value="${platform.home}/bin/javac">
-            <equals arg1="${platform.javac.tmp}" arg2="$${platforms.${platform.active}.javac}"/>
-        </condition>
-        <property name="platform.javac" value="${platform.javac.tmp}"/>
-        <j2seproject1:property name="platform.java.tmp" value="platforms.${platform.active}.java"/>
-        <condition property="platform.java" value="${platform.home}/bin/java">
-            <equals arg1="${platform.java.tmp}" arg2="$${platforms.${platform.active}.java}"/>
-        </condition>
-        <property name="platform.java" value="${platform.java.tmp}"/>
-        <j2seproject1:property name="platform.javadoc.tmp" value="platforms.${platform.active}.javadoc"/>
-        <condition property="platform.javadoc" value="${platform.home}/bin/javadoc">
-            <equals arg1="${platform.javadoc.tmp}" arg2="$${platforms.${platform.active}.javadoc}"/>
-        </condition>
-        <property name="platform.javadoc" value="${platform.javadoc.tmp}"/>
-        <condition property="platform.invalid" value="true">
-            <or>
-                <contains string="${platform.javac}" substring="$${platforms."/>
-                <contains string="${platform.java}" substring="$${platforms."/>
-                <contains string="${platform.javadoc}" substring="$${platforms."/>
-            </or>
-        </condition>
-        <fail unless="platform.home">Must set platform.home</fail>
-        <fail unless="platform.bootcp">Must set platform.bootcp</fail>
-        <fail unless="platform.java">Must set platform.java</fail>
-        <fail unless="platform.javac">Must set platform.javac</fail>
-        <fail if="platform.invalid">
- The J2SE Platform is not correctly set up.
- Your active platform is: ${platform.active}, but the corresponding property "platforms.${platform.active}.home" is not found in the project's properties files. 
- Either open the project in the IDE and setup the Platform with the same name or add it manually.
- For example like this:
-     ant -Duser.properties.file=&lt;path_to_property_file&gt; jar (where you put the property "platforms.${platform.active}.home" in a .properties file)
-  or ant -Dplatforms.${platform.active}.home=&lt;path_to_JDK_home&gt; jar (where no properties file is used) 
-  </fail>
+        <property name="platform.java" value="${java.home}/bin/java"/>
         <available file="${manifest.file}" property="manifest.available"/>
         <condition property="splashscreen.available">
             <and>
@@ -157,7 +121,9 @@ is divided into following sections:
             </and>
         </condition>
         <condition property="have.tests">
-            <or/>
+            <or>
+                <available file="${test.scripts.dir}"/>
+            </or>
         </condition>
         <condition property="have.sources">
             <or>
@@ -217,6 +183,15 @@ is divided into following sections:
         <condition else="" property="javac.profile.cmd.line.arg" value="-profile ${javac.profile}">
             <isset property="profile.available"/>
         </condition>
+        <condition else="false" property="jdkBug6558476">
+            <and>
+                <matches pattern="1\.[56]" string="${java.specification.version}"/>
+                <not>
+                    <os family="unix"/>
+                </not>
+            </and>
+        </condition>
+        <property name="javac.fork" value="${jdkBug6558476}"/>
         <property name="jar.index" value="false"/>
         <property name="jar.index.metainf" value="${jar.index}"/>
         <property name="copylibs.rebase" value="true"/>
@@ -249,6 +224,7 @@ is divided into following sections:
     </target>
     <target depends="-pre-init,-init-private,-init-user,-init-project,-do-init" name="-init-check">
         <fail unless="src.dir">Must set src.dir</fail>
+        <fail unless="test.scripts.dir">Must set test.scripts.dir</fail>
         <fail unless="build.dir">Must set build.dir</fail>
         <fail unless="dist.dir">Must set dist.dir</fail>
         <fail unless="build.classes.dir">Must set build.classes.dir</fail>
@@ -284,7 +260,7 @@ is divided into following sections:
                 <property location="${build.dir}/empty" name="empty.dir"/>
                 <mkdir dir="${empty.dir}"/>
                 <mkdir dir="@{apgeneratedsrcdir}"/>
-                <javac debug="@{debug}" deprecation="${javac.deprecation}" destdir="@{destdir}" encoding="${source.encoding}" excludes="@{excludes}" executable="${platform.javac}" fork="yes" includeantruntime="false" includes="@{includes}" source="${javac.source}" sourcepath="@{sourcepath}" srcdir="@{srcdir}" target="${javac.target}" tempdir="${java.io.tmpdir}">
+                <javac debug="@{debug}" deprecation="${javac.deprecation}" destdir="@{destdir}" encoding="${source.encoding}" excludes="@{excludes}" fork="${javac.fork}" includeantruntime="false" includes="@{includes}" source="${javac.source}" sourcepath="@{sourcepath}" srcdir="@{srcdir}" target="${javac.target}" tempdir="${java.io.tmpdir}">
                     <src>
                         <dirset dir="@{gensrcdir}" erroronmissingdir="false">
                             <include name="*"/>
@@ -324,7 +300,7 @@ is divided into following sections:
             <sequential>
                 <property location="${build.dir}/empty" name="empty.dir"/>
                 <mkdir dir="${empty.dir}"/>
-                <javac debug="@{debug}" deprecation="${javac.deprecation}" destdir="@{destdir}" encoding="${source.encoding}" excludes="@{excludes}" executable="${platform.javac}" fork="yes" includeantruntime="false" includes="@{includes}" source="${javac.source}" sourcepath="@{sourcepath}" srcdir="@{srcdir}" target="${javac.target}" tempdir="${java.io.tmpdir}">
+                <javac debug="@{debug}" deprecation="${javac.deprecation}" destdir="@{destdir}" encoding="${source.encoding}" excludes="@{excludes}" fork="${javac.fork}" includeantruntime="false" includes="@{includes}" source="${javac.source}" sourcepath="@{sourcepath}" srcdir="@{srcdir}" target="${javac.target}" tempdir="${java.io.tmpdir}">
                     <src>
                         <dirset dir="@{gensrcdir}" erroronmissingdir="false">
                             <include name="*"/>
@@ -405,7 +381,7 @@ is divided into following sections:
             <element name="customize" optional="true"/>
             <sequential>
                 <property name="junit.forkmode" value="perTest"/>
-                <junit dir="${work.dir}" errorproperty="tests.failed" failureproperty="tests.failed" fork="true" forkmode="${junit.forkmode}" jvm="${platform.java}" showoutput="true" tempdir="${build.dir}">
+                <junit dir="${work.dir}" errorproperty="tests.failed" failureproperty="tests.failed" fork="true" forkmode="${junit.forkmode}" showoutput="true" tempdir="${build.dir}">
                     <test methods="@{testmethods}" name="@{testincludes}" todir="${build.test.results.dir}"/>
                     <syspropertyset>
                         <propertyref prefix="test-sys-prop."/>
@@ -428,8 +404,11 @@ is divided into following sections:
             <element name="customize" optional="true"/>
             <sequential>
                 <property name="junit.forkmode" value="perTest"/>
-                <junit dir="${work.dir}" errorproperty="tests.failed" failureproperty="tests.failed" fork="true" forkmode="${junit.forkmode}" jvm="${platform.java}" showoutput="true" tempdir="${build.dir}">
+                <junit dir="${work.dir}" errorproperty="tests.failed" failureproperty="tests.failed" fork="true" forkmode="${junit.forkmode}" showoutput="true" tempdir="${build.dir}">
                     <batchtest todir="${build.test.results.dir}">
+                        <fileset dir="${test.scripts.dir}" excludes="@{excludes},${excludes}" includes="@{includes}">
+                            <filename name="@{testincludes}"/>
+                        </fileset>
                         <fileset dir="${build.test.classes.dir}" excludes="@{excludes},${excludes},${test.binaryexcludes}" includes="${test.binaryincludes}">
                             <filename name="${test.binarytestincludes}"/>
                         </fileset>
@@ -458,9 +437,13 @@ is divided into following sections:
                 <condition else="" property="testng.methods.arg" value="@{testincludes}.@{testmethods}">
                     <isset property="test.method"/>
                 </condition>
-                <union id="test.set"/>
+                <union id="test.set">
+                    <fileset dir="${test.scripts.dir}" excludes="@{excludes},**/*.xml,${excludes}" includes="@{includes}">
+                        <filename name="@{testincludes}"/>
+                    </fileset>
+                </union>
                 <taskdef classname="org.testng.TestNGAntTask" classpath="${run.test.classpath}" name="testng"/>
-                <testng classfilesetref="test.set" failureProperty="tests.failed" jvm="${platform.java}" listeners="org.testng.reporters.VerboseReporter" methods="${testng.methods.arg}" mode="${testng.mode}" outputdir="${build.test.results.dir}" suitename="HeavenMS" testname="TestNG tests" workingDir="${work.dir}">
+                <testng classfilesetref="test.set" failureProperty="tests.failed" listeners="org.testng.reporters.VerboseReporter" methods="${testng.methods.arg}" mode="${testng.mode}" outputdir="${build.test.results.dir}" suitename="HeavenMS" testname="TestNG tests" workingDir="${work.dir}">
                     <xmlfileset dir="${build.test.classes.dir}" includes="@{testincludes}"/>
                     <propertyset>
                         <propertyref prefix="test-sys-prop."/>
@@ -540,7 +523,7 @@ is divided into following sections:
             <element name="customize" optional="true"/>
             <sequential>
                 <property name="junit.forkmode" value="perTest"/>
-                <junit dir="${work.dir}" errorproperty="tests.failed" failureproperty="tests.failed" fork="true" forkmode="${junit.forkmode}" jvm="${platform.java}" showoutput="true" tempdir="${build.dir}">
+                <junit dir="${work.dir}" errorproperty="tests.failed" failureproperty="tests.failed" fork="true" forkmode="${junit.forkmode}" showoutput="true" tempdir="${build.dir}">
                     <test methods="@{testmethods}" name="@{testincludes}" todir="${build.test.results.dir}"/>
                     <syspropertyset>
                         <propertyref prefix="test-sys-prop."/>
@@ -565,8 +548,11 @@ is divided into following sections:
             <element name="customize" optional="true"/>
             <sequential>
                 <property name="junit.forkmode" value="perTest"/>
-                <junit dir="${work.dir}" errorproperty="tests.failed" failureproperty="tests.failed" fork="true" forkmode="${junit.forkmode}" jvm="${platform.java}" showoutput="true" tempdir="${build.dir}">
+                <junit dir="${work.dir}" errorproperty="tests.failed" failureproperty="tests.failed" fork="true" forkmode="${junit.forkmode}" showoutput="true" tempdir="${build.dir}">
                     <batchtest todir="${build.test.results.dir}">
+                        <fileset dir="${test.scripts.dir}" excludes="@{excludes},${excludes}" includes="@{includes}">
+                            <filename name="@{testincludes}"/>
+                        </fileset>
                         <fileset dir="${build.test.classes.dir}" excludes="@{excludes},${excludes},${test.binaryexcludes}" includes="${test.binaryincludes}">
                             <filename name="${test.binarytestincludes}"/>
                         </fileset>
@@ -742,9 +728,6 @@ is divided into following sections:
                     <classpath>
                         <path path="@{classpath}"/>
                     </classpath>
-                    <bootclasspath>
-                        <path path="${platform.bootcp}"/>
-                    </bootclasspath>
                 </nbjpdastart>
             </sequential>
         </macrodef>
@@ -760,9 +743,7 @@ is divided into following sections:
         </macrodef>
     </target>
     <target name="-init-debug-args">
-        <exec executable="${platform.java}" outputproperty="version-output">
-            <arg value="-version"/>
-        </exec>
+        <property name="version-output" value="java version &quot;${ant.java.version}"/>
         <condition property="have-jdk-older-than-1.4">
             <or>
                 <contains string="${version-output}" substring="java version &quot;1.0"/>
@@ -787,7 +768,7 @@ is divided into following sections:
             <attribute default="${debug.classpath}" name="classpath"/>
             <element name="customize" optional="true"/>
             <sequential>
-                <java classname="@{classname}" dir="${work.dir}" fork="true" jvm="${platform.java}">
+                <java classname="@{classname}" dir="${work.dir}" fork="true">
                     <jvmarg line="${endorsed.classpath.cmd.line.arg}"/>
                     <jvmarg line="${debug-args-line}"/>
                     <jvmarg value="-Xrunjdwp:transport=${debug-transport},address=${jpda.address}"/>
@@ -814,7 +795,7 @@ is divided into following sections:
             <attribute default="jvm" name="jvm"/>
             <element name="customize" optional="true"/>
             <sequential>
-                <java classname="@{classname}" dir="${work.dir}" fork="true" jvm="${platform.java}">
+                <java classname="@{classname}" dir="${work.dir}" fork="true">
                     <jvmarg line="${endorsed.classpath.cmd.line.arg}"/>
                     <jvmarg value="-Dfile.encoding=${runtime.encoding}"/>
                     <redirector errorencoding="${runtime.encoding}" inputencoding="${runtime.encoding}" outputencoding="${runtime.encoding}"/>
@@ -1012,7 +993,7 @@ is divided into following sections:
         <j2seproject3:copylibs manifest="${tmp.manifest.file}"/>
         <echo level="info">To run this application from the command line without Ant, try:</echo>
         <property location="${dist.jar}" name="dist.jar.resolved"/>
-        <echo level="info">${platform.java} -jar "${dist.jar.resolved}"</echo>
+        <echo level="info">java -jar "${dist.jar.resolved}"</echo>
     </target>
     <target depends="init,compile,-pre-pre-jar,-pre-jar,-do-jar-create-manifest,-do-jar-copy-manifest,-do-jar-set-mainclass,-do-jar-set-profile,-do-jar-set-splashscreen" if="do.archive" name="-do-jar-jar" unless="do.mkdist">
         <j2seproject1:jar manifest="${tmp.manifest.file}"/>
@@ -1221,13 +1202,10 @@ is divided into following sections:
                 </not>
             </and>
         </condition>
-        <exec executable="${platform.java}" failonerror="false" outputproperty="platform.version.output">
-            <arg value="-version"/>
-        </exec>
         <condition else="" property="bug5101868workaround" value="*.java">
-            <matches multiline="true" pattern="1\.[56](\..*)?" string="${platform.version.output}"/>
+            <matches pattern="1\.[56](\..*)?" string="${java.version}"/>
         </condition>
-        <javadoc additionalparam="-J-Dfile.encoding=${file.encoding} ${javadoc.additionalparam}" author="${javadoc.author}" charset="UTF-8" destdir="${dist.javadoc.dir}" docencoding="UTF-8" encoding="${javadoc.encoding.used}" executable="${platform.javadoc}" failonerror="true" noindex="${javadoc.noindex}" nonavbar="${javadoc.nonavbar}" notree="${javadoc.notree}" private="${javadoc.private}" source="${javac.source}" splitindex="${javadoc.splitindex}" use="${javadoc.use}" useexternalfile="true" version="${javadoc.version}" windowtitle="${javadoc.windowtitle}">
+        <javadoc additionalparam="-J-Dfile.encoding=${file.encoding} ${javadoc.additionalparam}" author="${javadoc.author}" charset="UTF-8" destdir="${dist.javadoc.dir}" docencoding="UTF-8" encoding="${javadoc.encoding.used}" failonerror="true" noindex="${javadoc.noindex}" nonavbar="${javadoc.nonavbar}" notree="${javadoc.notree}" private="${javadoc.private}" source="${javac.source}" splitindex="${javadoc.splitindex}" use="${javadoc.use}" useexternalfile="true" version="${javadoc.version}" windowtitle="${javadoc.windowtitle}">
             <classpath>
                 <path path="${javac.classpath}"/>
             </classpath>
@@ -1266,11 +1244,13 @@ is divided into following sections:
         <!-- You can override this target in the ../build.xml file. -->
     </target>
     <target if="do.depend.true" name="-compile-test-depend">
-        <j2seproject3:depend classpath="${javac.test.classpath}" destdir="${build.test.classes.dir}" srcdir=""/>
+        <j2seproject3:depend classpath="${javac.test.classpath}" destdir="${build.test.classes.dir}" srcdir="${test.scripts.dir}"/>
     </target>
     <target depends="init,deps-jar,compile,-pre-pre-compile-test,-pre-compile-test,-compile-test-depend" if="have.tests" name="-do-compile-test">
-        <j2seproject3:javac apgeneratedsrcdir="${build.test.classes.dir}" classpath="${javac.test.classpath}" debug="true" destdir="${build.test.classes.dir}" processorpath="${javac.test.processorpath}" srcdir=""/>
-        <copy todir="${build.test.classes.dir}"/>
+        <j2seproject3:javac apgeneratedsrcdir="${build.test.classes.dir}" classpath="${javac.test.classpath}" debug="true" destdir="${build.test.classes.dir}" processorpath="${javac.test.processorpath}" srcdir="${test.scripts.dir}"/>
+        <copy todir="${build.test.classes.dir}">
+            <fileset dir="${test.scripts.dir}" excludes="${build.classes.excludes},${excludes}" includes="${includes}"/>
+        </copy>
     </target>
     <target name="-post-compile-test">
         <!-- Empty placeholder for easier customization. -->
@@ -1284,8 +1264,10 @@ is divided into following sections:
     <target depends="init,deps-jar,compile,-pre-pre-compile-test,-pre-compile-test-single" if="have.tests" name="-do-compile-test-single">
         <fail unless="javac.includes">Must select some files in the IDE or set javac.includes</fail>
         <j2seproject3:force-recompile destdir="${build.test.classes.dir}"/>
-        <j2seproject3:javac apgeneratedsrcdir="${build.test.classes.dir}" classpath="${javac.test.classpath}" debug="true" destdir="${build.test.classes.dir}" excludes="" includes="${javac.includes}" processorpath="${javac.test.processorpath}" sourcepath="" srcdir=""/>
-        <copy todir="${build.test.classes.dir}"/>
+        <j2seproject3:javac apgeneratedsrcdir="${build.test.classes.dir}" classpath="${javac.test.classpath}" debug="true" destdir="${build.test.classes.dir}" excludes="" includes="${javac.includes}" processorpath="${javac.test.processorpath}" sourcepath="${test.scripts.dir}" srcdir="${test.scripts.dir}"/>
+        <copy todir="${build.test.classes.dir}">
+            <fileset dir="${test.scripts.dir}" excludes="${build.classes.excludes},${excludes}" includes="${includes}"/>
+        </copy>
     </target>
     <target name="-post-compile-test-single">
         <!-- Empty placeholder for easier customization. -->
diff --git a/nbproject/genfiles.properties b/nbproject/genfiles.properties
index 4d5b6615f..8346fd394 100644
--- a/nbproject/genfiles.properties
+++ b/nbproject/genfiles.properties
@@ -1,8 +1,8 @@
-build.xml.data.CRC32=92113194
+build.xml.data.CRC32=d58eb2a3
 build.xml.script.CRC32=ff13faf5
 build.xml.stylesheet.CRC32=8064a381@1.75.2.48
 # This file is used by a NetBeans-based IDE to track changes in generated files such as build-impl.xml.
 # Do not edit this file. You may delete it but then the IDE will never regenerate such files for you.
-nbproject/build-impl.xml.data.CRC32=92113194
-nbproject/build-impl.xml.script.CRC32=cef58264
+nbproject/build-impl.xml.data.CRC32=d58eb2a3
+nbproject/build-impl.xml.script.CRC32=17919f88
 nbproject/build-impl.xml.stylesheet.CRC32=876e7a8f@1.75.2.48
diff --git a/nbproject/private/private.properties b/nbproject/private/private.properties
index 67c9c2796..2ae0c5498 100644
--- a/nbproject/private/private.properties
+++ b/nbproject/private/private.properties
@@ -3,4 +3,4 @@ do.depend=false
 do.jar=true
 javac.debug=true
 javadoc.preview=true
-user.properties.file=C:\\Users\\RonanLana\\AppData\\Roaming\\NetBeans\\8.0.2\\build.properties
+user.properties.file=C:\\Users\\diego.matos\\AppData\\Roaming\\NetBeans\\8.0.2\\build.properties
diff --git a/nbproject/private/private.xml b/nbproject/private/private.xml
index 3287222d2..25e98e099 100644
--- a/nbproject/private/private.xml
+++ b/nbproject/private/private.xml
@@ -2,6 +2,12 @@
 <project-private xmlns="http://www.netbeans.org/ns/project-private/1">
     <editor-bookmarks xmlns="http://www.netbeans.org/ns/editor-bookmarks/2" lastBookmarkId="2"/>
     <open-files xmlns="http://www.netbeans.org/ns/projectui-open-files/2">
-        <group/>
+        <group>
+            <file>file:/C:/Users/diego.matos/Documents/MS/servergit/HeavenMS/HeavenMS/scripts/npc/2103013.js</file>
+            <file>file:/C:/Users/diego.matos/Documents/MS/servergit/HeavenMS/HeavenMS/src/scripting/npc/NPCConversationManager.java</file>
+            <file>file:/C:/Users/diego.matos/Documents/MS/servergit/HeavenMS/HeavenMS/scripts/npc/2101015.js</file>
+            <file>file:/C:/Users/diego.matos/Documents/MS/servergit/HeavenMS/HeavenMS/scripts/npc/2101017.js</file>
+            <file>file:/C:/Users/diego.matos/Documents/MS/servergit/HeavenMS/HeavenMS/scripts/npc/2101016.js</file>
+        </group>
     </open-files>
 </project-private>
diff --git a/nbproject/project.properties b/nbproject/project.properties
index 861f8eb51..1a918780d 100644
--- a/nbproject/project.properties
+++ b/nbproject/project.properties
@@ -84,7 +84,7 @@ manifest.custom.permissions=
 manifest.file=manifest.mf
 meta.inf.dir=${src.dir}/META-INF
 mkdist.disabled=false
-platform.active=JDK_1.7
+platform.active=default_platform
 project.license=gpl30_msv2
 project.licensePath=./nbproject/licenseheader.txt
 run.classpath=\
@@ -97,5 +97,6 @@ run.jvmargs=-Xmx2048m -Dwzpath=wz/
 run.test.classpath=\
     ${javac.test.classpath}:\
     ${build.test.classes.dir}
-source.encoding=UTF-8
+source.encoding=ISO-8859-1
 src.dir=${file.reference.MapleSolaxia-src}
+test.scripts.dir=scripts
diff --git a/nbproject/project.xml b/nbproject/project.xml
index aed1c5635..4cb4077b4 100644
--- a/nbproject/project.xml
+++ b/nbproject/project.xml
@@ -4,11 +4,12 @@
     <configuration>
         <data xmlns="http://www.netbeans.org/ns/j2se-project/3">
             <name>HeavenMS</name>
-            <explicit-platform explicit-source-supported="true"/>
             <source-roots>
                 <root id="src.dir"/>
             </source-roots>
-            <test-roots/>
+            <test-roots>
+                <root id="test.scripts.dir"/>
+            </test-roots>
         </data>
     </configuration>
 </project>
diff --git a/scripts/event/AirPlane.js b/scripts/event/AirPlane.js
index f530de71b..a075c820e 100644
--- a/scripts/event/AirPlane.js
+++ b/scripts/event/AirPlane.js
@@ -15,7 +15,7 @@ var  rideTime = 1 * 60 * 1000; //The time that require move to destination
 function init() {
     closeTime = em.getTransportationTime(closeTime);
     beginTime = em.getTransportationTime(beginTime);
-     rideTime = em.getTransportationTime(rideTime);
+    rideTime = em.getTransportationTime(rideTime);
     
     KC_bfd = em.getChannelServer().getMapFactory().getMap(540010100);
     CBD_bfd = em.getChannelServer().getMapFactory().getMap(540010001);
diff --git a/scripts/event/AmoriaPQ.js b/scripts/event/AmoriaPQ.js
deleted file mode 100644
index 87c07429f..000000000
--- a/scripts/event/AmoriaPQ.js
+++ /dev/null
@@ -1,291 +0,0 @@
-/*
-    This file is part of the HeavenMS MapleStory Server
-    Copyleft (L) 2016 - 2018 RonanLana
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Affero General Public License as
-    published by the Free Software Foundation version 3 as published by
-    the Free Software Foundation. You may not use, modify or distribute
-    this program under any other version of the GNU Affero General Public
-    License.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Affero General Public License for more details.
-
-    You should have received a copy of the GNU Affero General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-/**
- * @author: Ronan
- * @event: Amoria PQ
-*/
-
-var isPq = true;
-var onlyMarriedPlayers = true;
-var minPlayers = 6, maxPlayers = 6;
-var minLevel = 40, maxLevel = 255;
-var entryMap = 670010200;
-var exitMap = 670011000;
-var recruitMap = 670010100;
-var clearMap = 670010800;
-
-var minMapId = 670010200;
-var maxMapId = 670010800;
-
-var eventTime = 75;     // 75 minutes
-
-var lobbyRange = [0, 0];
-
-function init() {
-        setEventRequirements();
-}
-
-function setLobbyRange() {
-        return lobbyRange;
-}
-
-function setEventRequirements() {
-        var reqStr = "";
-        
-        reqStr += "\r\n    Number of players: ";
-        if(maxPlayers - minPlayers >= 1) reqStr += minPlayers + " ~ " + maxPlayers;
-        else reqStr += minPlayers;
-        
-        reqStr += "\r\n    Level range: ";
-        if(maxLevel - minLevel >= 1) reqStr += minLevel + " ~ " + maxLevel;
-        else reqStr += minLevel;
-        
-        reqStr += "\r\n    At least 1 of both genders";
-        if(onlyMarriedPlayers) reqStr += "\r\n    All married";
-        
-        reqStr += "\r\n    Time limit: ";
-        reqStr += eventTime + " minutes";
-        
-        em.setProperty("party", reqStr);
-}
-
-function setEventExclusives(eim) {
-        var itemSet = [4031594, 4031595, 4031596, 4031597];
-        eim.setExclusiveItems(itemSet);
-}
-
-function setEventRewards(eim) {
-        var itemSet, itemQty, evLevel, expStages;
-
-        evLevel = 1;    //Rewards at clear PQ
-        itemSet = [];
-        itemQty = [];
-        eim.setEventRewards(evLevel, itemSet, itemQty);
-        
-        expStages = [2000, 4000, 6000, 8000, 9000, 11000];    //bonus exp given on CLEAR stage signal
-        eim.setEventClearStageExp(expStages);
-}
-
-function getEligibleParty(party) {      //selects, from the given party, the team that is allowed to attempt this event
-        var eligible = [];
-        var hasLeader = false, hasNotMarried = false;
-        var mask = 0;
-        
-        if(party.size() > 0) {
-                var partyList = party.toArray();
-
-                for(var i = 0; i < party.size(); i++) {
-                        var ch = partyList[i];
-
-                        if(ch.getMapId() == recruitMap && ch.getLevel() >= minLevel && ch.getLevel() <= maxLevel) {
-                                if(ch.isLeader()) hasLeader = true;
-                                if(!ch.getPlayer().isMarried()) hasNotMarried = true;
-                                eligible.push(ch);
-                                
-                                mask |= (1 << ch.getPlayer().getGender());
-                        }
-                }
-        }
-        
-        if(!(hasLeader && eligible.length >= minPlayers && eligible.length <= maxPlayers && mask == 3)) eligible = [];
-        if(onlyMarriedPlayers && hasNotMarried) eligible = [];
-        return eligible;
-}
-
-function setup(level, lobbyid) {
-        var eim = em.newInstance("Amoria" + lobbyid);
-        eim.setProperty("level", level);
-        
-        eim.setProperty("marriedGroup", 0);
-        eim.setProperty("missCount", 0);
-        eim.setProperty("statusStg1", -1);
-        eim.setProperty("statusStg2", -1);
-        eim.setProperty("statusStg3", -1);
-        eim.setProperty("statusStg4", -1);
-        eim.setProperty("statusStg5", -1);
-        eim.setProperty("statusStg6", -1);
-        eim.setProperty("statusStgBonus", 0);
-        
-        eim.getInstanceMap(670010200).resetPQ(level);
-        eim.getInstanceMap(670010300).resetPQ(level);
-        eim.getInstanceMap(670010301).resetPQ(level);
-        eim.getInstanceMap(670010302).resetPQ(level);
-        eim.getInstanceMap(670010400).resetPQ(level);
-        eim.getInstanceMap(670010500).resetPQ(level);
-        eim.getInstanceMap(670010600).resetPQ(level);
-        eim.getInstanceMap(670010700).resetPQ(level);
-        eim.getInstanceMap(670010750).resetPQ(level);
-        eim.getInstanceMap(670010800).resetPQ(level);
-        
-        eim.getInstanceMap(670010200).toggleDrops();
-        eim.getInstanceMap(670010300).toggleDrops();
-        eim.getInstanceMap(670010301).toggleDrops();
-        eim.getInstanceMap(670010302).toggleDrops();
-        
-        eim.getInstanceMap(670010200).instanceMapForceRespawn();
-        eim.getInstanceMap(670010500).instanceMapForceRespawn();
-        
-        eim.getInstanceMap(670010750).shuffleReactors();
-        eim.getInstanceMap(670010800).shuffleReactors();
-        
-        var mapObj = eim.getInstanceMap(670010700);
-        var mobObj = Packages.server.life.MapleLifeFactory.getMonster(9400536);
-        mapObj.spawnMonsterOnGroundBelow(mobObj, new Packages.java.awt.Point(942, 478));
-        
-        respawnStages(eim);
-        
-        eim.startEventTimer(eventTime * 60000);
-        setEventRewards(eim);
-        setEventExclusives(eim);
-        
-        return eim;
-}
-
-function isTeamAllCouple(eim) {     // everyone partner of someone on the team
-        var eventPlayers = eim.getPlayers();
-    
-        for (var iterator = eventPlayers.iterator(); iterator.hasNext();) {
-                var chr = iterator.next();
-                
-                var pid = chr.getPartnerId();
-                if(pid <= 0 || eim.getPlayerById(pid) == null) {
-                        return false;
-                }
-        }
-        
-        return true;
-}
-
-function afterSetup(eim) {
-        if(isTeamAllCouple(eim)) {
-                eim.setIntProperty("marriedGroup", 1);
-        }
-}
-
-function respawnStages(eim) {}
-
-function playerEntry(eim, player) {
-        var map = eim.getMapInstance(entryMap);
-        player.changeMap(map, map.getPortal(0));
-}
-
-function scheduledTimeout(eim) {
-        if(eim.getIntProperty("statusStg6") == 1) {
-                eim.warpEventTeam(exitMap);
-        }
-        else {
-                end(eim);
-        }
-}
-
-function playerUnregistered(eim, player) {}
-
-function playerExit(eim, player) {
-        eim.unregisterPlayer(player);
-        player.changeMap(exitMap, 0);
-}
-
-function playerLeft(eim, player) {
-        if(!eim.isEventCleared()) {
-                playerExit(eim, player);
-        }
-}
-
-function changedMap(eim, player, mapid) {
-        if (mapid < minMapId || mapid > maxMapId) {
-                if (eim.isEventTeamLackingNow(true, minPlayers, player)) {
-                        eim.unregisterPlayer(player);
-                        end(eim);
-                }
-                else
-                        eim.unregisterPlayer(player);
-        }
-}
-
-function changedLeader(eim, leader) {
-        var mapid = leader.getMapId();
-        if (!eim.isEventCleared() && (mapid < minMapId || mapid > maxMapId)) {
-                end(eim);
-        }
-}
-
-function playerDead(eim, player) {}
-
-function playerRevive(eim, player) { // player presses ok on the death pop up.
-        if (eim.isEventTeamLackingNow(true, minPlayers, player)) {
-                eim.unregisterPlayer(player);
-                end(eim);
-        }
-        else
-                eim.unregisterPlayer(player);
-}
-
-function playerDisconnected(eim, player) {
-        if (eim.isEventTeamLackingNow(true, minPlayers, player)) {
-                eim.unregisterPlayer(player);
-                end(eim);
-        }
-        else
-                eim.unregisterPlayer(player);
-}
-
-function leftParty(eim, player) {
-        if (eim.isEventTeamLackingNow(false, minPlayers, player)) {
-                end(eim);
-        }
-        else
-                playerLeft(eim, player);
-}
-
-function disbandParty(eim) {
-        if (!eim.isEventCleared()) {
-                end(eim);
-        }
-}
-
-function monsterValue(eim, mobId) {
-        return 1;
-}
-
-function end(eim) {
-        var party = eim.getPlayers();
-        for (var i = 0; i < party.size(); i++) {
-                playerExit(eim, party.get(i));
-        }
-        eim.dispose();
-}
-
-function giveRandomEventReward(eim, player) {
-        eim.giveEventReward(player);
-}
-
-function clearPQ(eim) {
-        eim.stopEventTimer();
-        eim.setEventCleared();
-}
-
-function monsterKilled(mob, eim) {}
-
-function allMonstersDead(eim) {}
-
-function cancelSchedule() {}
-
-function dispose(eim) {}
diff --git a/scripts/npc/2101014.js b/scripts/npc/2101014.js
index 69dcacd2b..927d0e48e 100644
--- a/scripts/npc/2101014.js
+++ b/scripts/npc/2101014.js
@@ -1,108 +1,114 @@
-/*
-    This file is part of the OdinMS Maple Story Server
-    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>
-    Matthias Butz <matze@odinms.de>
-    Jan Christian Meyer <vimes@odinms.de>
+/*2101014.js - Lobby and Entrance
+ * @author Jvlaple
+ * For Jvlaple's AriantPQ
+ */
+importPackage(java.lang);
+importPackage(Packages.server.expeditions);
 
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Affero General Public License as
-    published by the Free Software Foundation version 3 as published by
-    the Free Software Foundation. You may not use, modify or distribute
-    this program under any other version of the GNU Affero General Public
-    License.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
-    See the GNU Affero General Public License for more details.
-
-    You should have received a copy of the GNU Affero General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-/*
-	NPC NAME: Cesar (2)
-	NPC ID: 2101014
-	Author: Vcoc
-	Function: AriantPQ
-*/
-
-status = -1;
-var sel;
-empty = [false, false, false];
+var status = 0;
+var toBan = -1;
+var choice;
+var arena;
+var arenaName;
+var type;
+var map;
+var exped = MapleExpeditionType.ARIANT;
+var exped1 = MapleExpeditionType.ARIANT1;
+var exped2 = MapleExpeditionType.ARIANT2;
 
 function start() {
-    if((cm.getPlayer().getLevel() < 19 || cm.getPlayer().getLevel() > 30) && !cm.getPlayer().isGM()){
-        cm.sendNext("You're not between level 20 and 30. Sorry, you may not participate.");
-        cm.dispose();
-        return;
-    }
-    var text = "What do you want?#b";
-    for(var i = 0; i < 3; i += 1)
-        if (cm.getPlayerCount(980010100 + (i * 100)) > 0)
-            if(cm.getPlayerCount(980010101 + (i * 100)) > 0)
-                continue;
-            else
-                text += "\r\n#L" + i + "# Battle Arena " + (i + 1) + "([" + cm.getPlayerCount(980010100 + (i * 100)) + "/" + cm.getPlayer().getAriantSlotsRoom(i) + "]  users: " + cm.getPlayer().getAriantRoomLeaderName(i) + ")#l";
-        else{
-            empty[i] = true;
-            text += "\r\n#L" + i + "# Battle Arena " + (i + 1) + "( Empty )#l";
-            if(cm.getPlayer().getAriantRoomLeaderName(i) != "")
-                cm.getPlayer().removeAriantRoom(i);
-        }
-    cm.sendSimple(text + "\r\n#L3# I'd like to know more about the competition.#l");
+    status = -1;
+    action(1, 0, 0);
 }
 
-function action(mode, type, selection){
-    status++;
-    if(mode != 1){
-        if(mode == 0 && type == 0)
-            status -= 2;
-        else{
+function action(mode, type, selection) {
+    if (mode == -1) {
+        cm.dispose();
+    } else {
+        if (mode == 0) {
             cm.dispose();
             return;
         }
-    }
-    if (status == 0){
-        if(sel == undefined)
-            sel = selection;
-        if(sel == 3)
-            cm.sendNext("What do you need to do? You must be new to this. Allow me explain in detail.");
-        else{
-            if(cm.getPlayer().getAriantRoomLeaderName(sel) != "" && empty[sel])
-                empty[sel] = false;
-            else if(cm.getPlayer().getAriantRoomLeaderName(sel) != ""){
-                cm.warp(980010100 + (sel * 100));
-                cm.dispose();
-                return;
-            }
-            if(!empty[sel]){
-                cm.sendNext("Another combatant has created the battle arena first. I advise you to either set up a new one, or join the battle arena that's already been set up.");
-                cm.dispose();
-                return;
-            }
-            cm.sendGetNumber("Up to how many participants can join in this match? (2~6 ppl)", 0, 2, 6);
+        if (mode == 1) {
+            status++;
+        } else {
+            status--;
         }
-    }else if (status == 1){
-        if(sel == 3)
-            cm.sendNextPrev("It's really simple, actually. You'll receive #b#t2270002##k from me, and your task is to eliminate a set amount of HP from the monster, then use #b#t2270002##k to absorb its monstrous power.");
-        else{
-            if(cm.getPlayer().getAriantRoomLeaderName(sel) != "" && empty[sel])
-                empty[sel] = false;
-            if(!empty[sel]){
-                cm.sendNext("Another combatant has created the battle arena first. I advise you to either set up a new one, or join the battle arena that's already been set up.");
-                cm.dispose();
-                return;
+        if (cm.getPlayer().getMapId() == 980010000) {
+            var expedicao = cm.getExpedition(exped);
+            var expedicao1 = cm.getExpedition(exped1);
+            var expedicao2 = cm.getExpedition(exped2);
+            if (status == 0) {
+                var toSnd = "Você gostaria de participar do Desafio #eAriant Coliseu#n?\r\n\r\n#e#r       (Escolha uma arena)#n#k\r\n#b";
+
+                if (cm.getClient().getChannelServer().getMapFactory().getMap(980010100).getCharacters().size() == 0 && expedicao == null) {
+                    toSnd += "#L0#Comece Ariant Coliseu (1)#l\r\n";
+                } else if (expedicao != null && cm.getClient().getChannelServer().getMapFactory().getMap(980010101).getCharacters().size() == 0) {
+                    toSnd += "#L0#Junte-se ao Ariant Coliseu (1)  Dono (" + expedicao.getLeader().getName() + ")" + " Membros Atuais: " + cm.getNomeDosMembrosExpedition(exped) + "\r\n";
+                }
+                if (cm.getClient().getChannelServer().getMapFactory().getMap(980010200).getCharacters().size() == 0 && expedicao1 == null) {
+                    toSnd += "#L1#Comece Ariant Coliseu (2)#l\r\n";
+                } else if (expedicao1 != null && cm.getClient().getChannelServer().getMapFactory().getMap(980010201).getCharacters().size() == 0) {
+                    toSnd += "#L1#Junte-se ao Ariant Coliseu (2)  Dono (" + expedicao1.getLeader().getName() + ")" + " Membros Atuais: " + cm.getNomeDosMembrosExpedition(exped1) + "\r\n";
+                }
+                if (cm.getClient().getChannelServer().getMapFactory().getMap(980010300).getCharacters().size() == 0 && expedicao2 == null) {
+                    toSnd += "#L2#Comece Ariant Coliseu (3)#l\r\n";
+                } else if (expedicao2 != null && cm.getClient().getChannelServer().getMapFactory().getMap(980010301).getCharacters().size() == 0) {
+                    toSnd += "#L2#Junte-se ao Ariant Coliseu (3)  Dono (" + expedicao2.getLeader().getName() + ")" + " Membros Atuais: " + cm.getNomeDosMembrosExpedition(exped2) + "\r\n";
+                }
+                if (toSnd.equals("Você gostaria de participar do Desafio #eAriant Coliseu#n?\r\n\r\n#e#r       (Escolha uma arena)#n#k\r\n#b")) {
+                    cm.sendOk("Todas as arenas esta ocupadas agora. Eu sugiro que você volte mais tarde ou mudar de canal.");
+                    cm.dispose();
+                } else {
+                    cm.sendSimple(toSnd);
+                }
+            } else if (status == 1) {
+                switch (selection) {
+                    case 0 :
+                        exped = MapleExpeditionType.ARIANT;
+                        expedicao = cm.getExpedition(exped);
+                        map = 980010100;
+                        break;
+                    case 1 :
+                        exped = MapleExpeditionType.ARIANT1;
+                        expedicao = cm.getExpedition(exped);
+                        map = 980010200;
+                        break;
+                    case 2 :
+                        exped = MapleExpeditionType.ARIANT2;
+                        expedicao = cm.getExpedition(exped);
+                        map = 980010300;
+                        break;
+                    default :
+                        exped = null;
+                        map = 0;
+                        return;
+                        break;
+                }
+                if (expedicao == null) {
+                    cm.createExpedition(exped);
+                    cm.warp(map, 0);
+                    cm.getPlayer().dropMessage("Sua Arena foi criada. Aguarde as pessoas entrarem agora!");
+                    cm.dispose();
+                } else {
+                    var playerAdd = expedicao.addMemberInt(cm.getPlayer());
+                    if (playerAdd == 3) {
+                        cm.sendOk("Desculpe, a Lobby esta cheia agora.");
+                        cm.dispose();
+                    } else {
+                        if (playerAdd == 0) {
+                            cm.warp(map, 0);
+                            cm.dispose();
+                        } else if (playerAdd == 2) {
+                            cm.sendOk("Desculpe, mas o líder pediu para nao ser autorizado a entrar.");
+                            cm.dispose();
+                        } else {
+                            cm.sendOk("erro.");
+                            cm.dispose();
+                        }
+                    }
+                } 
             }
-            cm.getPlayer().setAriantRoomLeader(sel, cm.getPlayer().getName());
-            cm.getPlayer().setAriantSlotRoom(sel, selection);
-            cm.warp(980010100 + (sel * 100));
-            cm.dispose();
         }
-    }else if (status == 2)
-        cm.sendNextPrev("It's simple. If you absorb the power of the monster #b#t2270002##k, then you'll make #b#t4031868##k, which is something Queen Areda loves. The combatant with the most jewels wins the match. It's actually a smart idea to prevent others from absorbing in order to win.");
-    else if (status == 3)
-        cm.sendNextPrev("One thing. Using #b#t2100067##k, you can steal #b#t4031868##k from your enemies. Warning: #rYou may not use pets for this.#k Understood?!");
-    else if (status == 4)
-        cm.dispose();
-}
+    }
+}
\ No newline at end of file
diff --git a/scripts/npc/2101015.js b/scripts/npc/2101015.js
new file mode 100644
index 000000000..f06653fb7
--- /dev/null
+++ b/scripts/npc/2101015.js
@@ -0,0 +1,37 @@
+var status = 0;
+
+importPackage(Packages.client);
+
+function start() {
+    status = -1;
+    action(1, 0, 0);
+}
+
+function action(mode, type, selection) {
+    if (mode == -1) {
+        cm.dispose();
+    } else {
+        if (mode == 0 && status == 0) {
+            cm.dispose();
+            return;
+        }
+        if (mode == 1)
+            status++;
+        else
+            status--;
+        if (status == 0) {
+            apqpontos = cm.getPlayer().getAriantPontos();
+            if (apqpontos < 100) {
+                cm.sendOk("A sua Pontuação de Arena de Batalha é #b" + apqpontos + "#k Pontos. Você precisa ultrapassar os #b100 Pontos#k para que eu possa lhe dar a #bCadeira de Praia com Palmeira#k.Estou ocupado, então fale comigo quando você tiver pontos suficientes e fale comigo novamente.")
+                cm.dispose();
+            }
+            if (apqpontos > 99) {
+                cm.sendNext("Uaaal, parece que você conseguiu os #b100 Pontos#k necessários para troca, vamos lá?!");
+            }
+        } else if (status == 1) {
+            cm.getPlayer().gainAriantPontos(-100);
+            cm.gainItem(3010018, 1);
+            cm.dispose();
+        }
+    }
+}
\ No newline at end of file
diff --git a/scripts/npc/2101016.js b/scripts/npc/2101016.js
new file mode 100644
index 000000000..ac3458300
--- /dev/null
+++ b/scripts/npc/2101016.js
@@ -0,0 +1,40 @@
+
+var status = 0;
+
+importPackage(Packages.client);
+
+function start() {
+    status = -1;
+    action(1, 0, 0);
+}
+
+function action(mode, type, selection) {
+    if (mode == -1) {
+        cm.dispose();
+    } else {
+        if (mode == 0 && status == 0) {
+            cm.dispose();
+            return;
+        }
+        if (mode == 1)
+            status++;
+        else
+            status--;
+        if (status == 0) {
+            copns = cm.getPlayer().countItem(4031868);
+            if (copns < 1) {
+                cm.sendOk("Que pena, você nao conseguiu nenhuma jóia!")
+                cm.dispose();
+            }
+            if (copns > 0 || !cm.getPlayer().isGM()) {
+                cm.sendNext("Ok, vamos ver...Você foi muito bem, e você trouxe #b" + copns + "#k jóias que eu adoro. Como você completou a partida, vou recompensá-lo com a pontuação da Arena de Batalhas de #b5 Pontos#k. Se você quiser saber mais sobre a pontuação de Arena de Batalha, então fale com #b#p2101015##k.");
+            }
+        } else if (status == 1) {
+            //cm.warp(980010020, 0);
+            cm.removeAll(4031868);
+            cm.getPlayer().gainExp(92.7 * cm.getPlayer().getExpRate() * copns, true, true);
+            cm.getPlayer().gainAriantPontos(3);
+            cm.dispose();
+        }
+    }
+}
\ No newline at end of file
diff --git a/scripts/npc/2101017.js b/scripts/npc/2101017.js
index 51c9ad5cf..3586e1707 100644
--- a/scripts/npc/2101017.js
+++ b/scripts/npc/2101017.js
@@ -1,150 +1,142 @@
-/*
-    This file is part of the OdinMS Maple Story Server
-    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>
-    Matthias Butz <matze@odinms.de>
-    Jan Christian Meyer <vimes@odinms.de>
+/*2101017.js
+ *Cesar
+ *@author Jvlaple
+ */
 
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Affero General Public License as
-    published by the Free Software Foundation version 3 as published by
-    the Free Software Foundation. You may not use, modify or distribute
-    this program under any other version of the GNU Affero General Public
-    License.
+importPackage(java.lang);
+importPackage(Packages.server.expeditions);
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
-    See the GNU Affero General Public License for more details.
 
-    You should have received a copy of the GNU Affero General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-/*
-	NPC NAME: Cesar (3)
-	NPC ID: 2101017
-	Author: Vcoc
-	Function: AriantPQ
-*/
-
-importPackage(Packages.tools);
-importPackage(Packages.client);
-
-status = -1;
-var sel;
+var status = 0;
+var toBan = -1;
+var choice;
+var arena;
+var arenaName;
+var type;
+var map;
+var exped = MapleExpeditionType.ARIANT;
+var exped1 = MapleExpeditionType.ARIANT1;
+var exped2 = MapleExpeditionType.ARIANT2;
+var expedicao;
+var expedMembers;
 
 function start() {
-    if((cm.getPlayer().getLevel() < 19 || cm.getPlayer().getLevel() > 30) && !cm.getPlayer().isGM()){
-        cm.sendNext("You're not between level 20 and 30. Sorry, you may not participate.");
-        cm.dispose();
-        return;
-    }
-    if(cm.getPlayer().getMapId() % 10 == 1)
-        cm.sendSimple("Do you have a request for me?\r\n#b#L0# Give me #t2270002# and #t2100067#.#l\r\n#L1# What should I do?#l\r\n#L2# Get me out of here.#l");
-    else
-        cm.sendSimple(cm.getPlayer().getAriantRoomLeaderName(((cm.getPlayer().getMapId() / 100) % 10) - 1) == cm.getPlayer().getName() ? "Would you like to start the match?#b\r\n#b#L3# Ready to enter the Battle Arena!!#l\r\n#L1# I'd like to kick another character.#l\r\n#L2# Get me out of here.#l" : "What do you want?#b\r\n#L2# Get me out of here.#l");
+    action(1, 0, 0);
 }
 
-function action(mode, type, selection){
-    status++;
-    if(mode != 1){
-        if(mode == 0 && type == 0)
-            status -= 2;
-        else{
+function action(mode, type, selection) {
+    
+    if (mode == -1) {
+        cm.dispose();
+    } else {
+        if (mode == 0) {
             cm.dispose();
             return;
         }
-    }
-    if(cm.getPlayer().getMapId() % 10 == 1){
-        if (status == 0){
-            if (sel == undefined)
-                sel = selection;
-            if(sel == 0){
-                if(cm.haveItem(2270002))
-                    cm.sendNext("You already have #b#t2270002##k.");
-            else if(cm.canHold(2270002) && cm.canHold(2100067)){
-                if(cm.haveItem(2100067))
-                    cm.removeAll(2100067);
-                    cm.gainItem(2270002, 50);
-                    cm.gainItem(2100067, 5);
-                    cm.sendNext("Now lower the HP of the monsters, and use #b#t2270002##k to absorb their power!");
-                }else
-                    cm.sendNext("Check and see if your Use inventory is full or not");
-                cm.dispose();
-            }else if(sel == 1)
-                cm.sendNext("What do you need to do? You must be new to this. Allow me explain in detail.");
-            else
-                cm.sendYesNo("Are you sure you want to leave?"); //No GMS like.
-        } else if (status == 1){
-            if(type == 1){
-                cm.removeAll(4031868);
-                cm.removeAll(2270002);
-                cm.removeAll(2100067);
-                cm.warp(980010020);
-                cm.dispose();
-                return;
+
+        if (cm.getPlayer().getMapId() == 980010100 || cm.getPlayer().getMapId() == 980010200 || cm.getPlayer().getMapId() == 980010300) {
+            if (cm.getPlayer().getMapId() == 980010100) {
+                exped = MapleExpeditionType.ARIANT;
+                expedicao = cm.getExpedition(exped);
+
+            } else if (cm.getPlayer().getMapId() == 980010200) {
+                exped = MapleExpeditionType.ARIANT1;
+                expedicao = cm.getExpedition(exped);
+            } else {
+                exped = MapleExpeditionType.ARIANT2;
+                expedicao = cm.getExpedition(exped);
             }
-            cm.sendNextPrev("It's really simple, actually. You'll receive #b#t2270002##k from me, and your task is to eliminate a set amount of HP from the monster, then use #b#t2270002##k to absorb its monstrous power.");
-        } else if (status == 2)
-            cm.sendNextPrev("It's simple. If you absorb the power of the monster #b#t2270002##k, then you'll make #b#t4031868##k, which is something Queen Areda loves. The combatant with the most jewels wins the match. It's actually a smart idea to prevent others from absorbing in order to win.");
-        else if (status == 3)
-            cm.sendNextPrev("One thing. Using #b#t2100067##k, you can steal #b#t4031868##k from your enemies. Warning: #rYou may not use pets for this.#k Understood?!");
-        else if (status == 4)
-            cm.dispose();
-    }else{
-        var nextchar = cm.getMap(cm.getPlayer().getMapId()).getCharacters().iterator();
-        if(status == 0){
-            if (sel == undefined)
-                sel = selection;
-            if(sel == 1)
-                if(cm.getPlayerCount(cm.getPlayer().getMapId()) > 1){
-                    var text = "Who would you like to kick from room?"; //Not GMS like text
-                    var name;
-                    for(var i = 0; nextchar.hasNext(); i++){
-                        name = nextchar.next().getName();
-                        if(!cm.getPlayer().getAriantRoomLeaderName(((cm.getPlayer().getMapId() / 100) % 10) - 1).equals(name))
-                            text += "\r\n#b#L" + i + "#" + name + "#l";
+            expedMembers = expedicao.getMemberList();
+            if (status == 0) {
+                if (cm.getIsLeaderExpedition(exped)) {
+                    cm.sendSimple("O que voce gostaria de fazer?#b\r\n\r\n#L1#Ver registro atual da arena!#l\r\n#L2#Banir player!#l\r\n#L3#Comece a luta!#l\r\n#L4#Sair desta arena!#l");
+                    status = 1;
+                } else {
+                    var toSend = "Voce tem atualmente essas pessoas em sua arena :\r\n#b";
+                    toSend += cm.getNomeDosMembrosExpedition(exped);
+                    cm.sendOk(toSend);
+                    cm.dispose();
+                }
+            } else if (status == 1) {
+                if (selection == 1) {
+                    var toSend = "Voce tem atualmente essas pessoas em sua arena :\r\n#b";
+                    toSend += cm.getNomeDosMembrosExpedition(exped);
+                    cm.sendOk(toSend);
+                    cm.dispose();
+                } else if (selection == 2) {
+                    var size = expedMembers.size();
+                    if (size == 1) {
+                        cm.sendOk("You are the only member of the expedition.");
+                        cm.dispose();
+                        return;
+                    }
+                    var text = "The following members make up your expedition (Click on them to expel them):\r\n";
+                    text += "\r\n\t\t1." + expedicao.getLeader().getName();
+                    for (var i = 1; i < size; i++) {
+                        text += "\r\n#b#L" + (i + 1) + "#" + (i + 1) + ". " + expedMembers.get(i).getValue() + "#l\n";
                     }
                     cm.sendSimple(text);
-                }else{
-                    cm.sendNext("There's no character that can be kicked right now.");
+                    status = 6;
+                } else if (selection == 3) {
+                    if (expedicao.getMembers().size() < 1) {
+                        cm.sendOk("Você precisa de mais que 2 jogadores para iniciar.");
+                        cm.dispose();
+                    } else {
+                        if (cm.getParty() != null) {
+                            cm.sendOk("Você não pode entrar na batalha em um grupo.");
+                            cm.dispose();
+                        }
+                        if (cm.getPlayer().getMapId() == 980010100) {
+                            cm.warpExpedition(980010101, exped);
+                        } else if (cm.getPlayer().getMapId() == 980010200) {
+                            cm.warpExpedition(980010201, exped);
+                        } else {
+                            cm.warpExpedition(980010301, exped);
+                        }
+                        cm.dispose();
+                    }
+                } else if (selection == 4) {
+                    cm.mapMessage(5, "O lider da Arena saiu.");
+                    cm.warpExpedition(980010000, null);
+                    cm.endExpedition(expedicao);
                     cm.dispose();
                 }
-            else if(sel == 2){
-                if(cm.getPlayer().getAriantRoomLeaderName(((cm.getPlayer().getMapId() / 100) % 10) - 1) == cm.getPlayer().getName())
-                    cm.sendYesNo("Are you sure you want to leave? You're the leader of the Arena, so if you leave, the whole Battle Arena will close.");
-                else
-                    cm.sendYesNo("Are you sure you want to leave?"); //No GMS like.
-            }else if(sel == 3)
-                if(cm.getPlayerCount(cm.getPlayer().getMapId()) > 1)
-                    cm.sendYesNo("The room is all set, and no other character may join this Battle Arena. Do you want to start the game right now?");
-                else{
-                    cm.sendNext("You'll need at least 2 participants inside in order to start the match.");
+            } else if (status == 6) {
+                if (selection > 0) {
+                    var banned = expedMembers.get(selection - 1);
+                    expedicao.ban(banned);
+                    cm.sendOk("You have banned " + banned.getValue() + " from the expedition.");
                     cm.dispose();
+                } else {
+                    cm.sendSimple(list);
+                    status = 2;
                 }
-        }else if (status == 1){
-            if(sel == 1){
-                for(var i = 0; nextchar.hasNext(); i++)
-                    if(i == selection){
-                        nextchar.next().changeMap(cm.getMap(980010000));
-                        break;
-                    }else
-                        nextchar.next();
-                cm.sendNext("Player have been kicked out of the Arena."); //Not GMS like
-            }else if(sel == 2){
-                if(cm.getPlayer().getAriantRoomLeaderName(((cm.getPlayer().getMapId() / 100) % 10) - 1) != cm.getPlayer().getName())
-                    cm.warp(980010000);
-                else{
-                    cm.getPlayer().removeAriantRoom((cm.getPlayer().getMapId() / 100) % 10);
-                    cm.mapMessage(6, cm.getPlayer().getName() + " has left the Arena, so the Arena will now close.");
-                    cm.warpMap(980010000);
+            }
+        } else if (cm.getPlayer().getMapId() == 980010101 || cm.getPlayer().getMapId() == 980010201 || cm.getPlayer().getMapId() == 980010301) {
+            if (cm.getPlayer().getMapId() == 980010100) {
+                exped = MapleExpeditionType.ARIANT;
+                expedicao = cm.getExpedition(exped);
+
+            } else if (cm.getPlayer().getMapId() == 980010200) {
+                exped = MapleExpeditionType.ARIANT1;
+                expedicao = cm.getExpedition(exped);
+            } else {
+                exped = MapleExpeditionType.ARIANT2;
+                expedicao = cm.getExpedition(exped);
+            }
+            if (status == 0) {
+                var gotTheBombs = expedicao.getProperty("gotBomb" + cm.getChar().getId());
+                if (gotTheBombs != null) {
+                    cm.sendOk("Eu ja lhe dei as bombas, por favor, mate os #eEscorpioes#n para conseguir mais na proxima!");
+                    cm.dispose();
+                } else {
+                    cm.sendOk("Eu lhe dei (5) #b#eBombas#k#n e (50) #b#eRochas Elementais#k#n.\r\nUse as rochas elementais para capturar os escorpioes para Sra.#r#eSpirit Jewels#k#n!");
+                    expedicao.setProperty("gotBomb" + cm.getChar().getId(), "got");
+                    cm.gainItem(2270002, 50);
+                    cm.gainItem(2100067, 5);
+                    cm.dispose();
                 }
-            }else{
-                cm.warpMap(cm.getPlayer().getMapId() + 1);
-            //}
-            //cm.getPlayer().getMap().broadcastMessage(MaplePacketCreator.updateAriantPQRanking(cm.getPlayer().getName(), 0, true));
             }
-            cm.dispose();
         }
     }
 }
diff --git a/src/client/MapleBuffStat.java b/src/client/MapleBuffStat.java
index aea3ca13e..57d368991 100644
--- a/src/client/MapleBuffStat.java
+++ b/src/client/MapleBuffStat.java
@@ -47,6 +47,7 @@
     GHOST_MORPH(0x20000L),
     AURA(0x40000L),
     CONFUSE(0x80000L),
+    ARIANT_PQ_SHIELD(0x40000L),
     
     // ------ COUPON feature ------
     
diff --git a/src/client/MapleCharacter.java b/src/client/MapleCharacter.java
index 146f65eb1..5b1a6ce82 100644
--- a/src/client/MapleCharacter.java
+++ b/src/client/MapleCharacter.java
@@ -1,25 +1,3 @@
-/* 
- This file is part of the OdinMS Maple Story Server
- Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>
- Matthias Butz <matze@odinms.de>
- Jan Christian Meyer <vimes@odinms.de>
-
- This program is free software: you can redistribute it and/or modify
- it under the terms of the GNU Affero General Public License as
- published by the Free Software Foundation version 3 as published by
- the Free Software Foundation. You may not use, modify or distribute
- this program under any otheer version of the GNU Affero General Public
- License.
-
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; witout even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU Affero General Public License for more details.
-
-
- You should have received a copy of the GNU Affero General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
 package client;
 
 import java.awt.Point;
@@ -126,7 +104,6 @@
 import constants.ExpTable;
 import constants.GameConstants;
 import constants.ItemConstants;
-import constants.LinguaConstants;
 import constants.ServerConstants;
 import constants.skills.Aran;
 import constants.skills.Beginner;
@@ -320,7 +297,9 @@
     private int banishSp = -1;
     private long banishTime = 0;
     private long lastExpGainTime;
-
+    public ScheduledFuture<?> pqMapleMap;
+    public ScheduledFuture<?> ariantScore;
+    
     private MapleCharacter() {
         super.setListener(new AbstractCharacterListener() {
             @Override
@@ -1944,12 +1923,14 @@ public final void pickupItem(MapleMapObject ob, int petIndex) {     // yes, one
                             this.getMonsterBook().addCard(client, mItem.getItemId());
                         }
                     } else if (MapleInventoryManipulator.addFromDrop(client, mItem, true)) {
-                    } else if (mItem.getItemId() == 4031868) {
-                        this.getMap().broadcastMessage(MaplePacketCreator.updateAriantPQRanking(this.getName(), this.getItemQuantity(4031868, false), false));
                     } else {
                         client.announce(MaplePacketCreator.enableActions());
                         return;
                     }
+                    if (mItem.getItemId() == 4031868) {
+                        updateAriantScore();
+                        getMap().broadcastMessage(MaplePacketCreator.updateAriantPQRanking(this.getName(), this.getItemQuantity(4031868, false), false));
+                    }
 
                     this.getMap().pickItemDrop(pickupPacket, mapitem);
                 } else if (!hasSpaceInventory) {
@@ -5780,6 +5761,22 @@ public void leaveMap() {
         if (hpDecreaseTask != null) {
             hpDecreaseTask.cancel(false);
         }
+        cancelPqMapleMap();
+        cancelAriantScore();
+    }
+    
+    public void cancelPqMapleMap() {
+        if (pqMapleMap != null) {
+            pqMapleMap.cancel(true);
+            pqMapleMap = null;
+        }
+    }
+    
+    public void cancelAriantScore() {
+        if (ariantScore != null) {
+            ariantScore.cancel(true);
+            ariantScore = null;
+        }
     }
 
     private int getChangedJobSp(MapleJob newJob) {
@@ -7007,12 +7004,12 @@ public void mount(int id, int skillid) {
 
     private void playerDead() {
         if (this.getMap().isCPQMap()) {
-            int lost = getCP();
-            if (lost > 6) {
-                lost = 6;
+            int losing = getMap().getDeathCP();
+            if (getCP() < losing) {
+                losing = getCP();
             }
-            getMap().broadcastMessage(MaplePacketCreator.playerDiedMessage(getName(), lost, getTeam()));
-            gainCP(-lost);
+            getMap().broadcastMessage(MaplePacketCreator.playerDiedMessage(getName(), losing, getTeam()));
+            gainCP(-losing);
             return;
         }
         cancelAllBuffs(false);
@@ -10226,4 +10223,41 @@ public void obterItens() {
             getClient().getAbstractPlayerInteraction().gainItem(item.getItemId(), item.getQuantity());
         }
     }
+    
+    public int getAriantScore() {
+        return this.countItem(4031868);
+    }
+
+    public void updateAriantScore() {
+        this.getMap().broadcastMessage(MaplePacketCreator.updateAriantPQRanking(this.getName(), getAriantScore(), false));
+    }
+    
+    public void disease(int type, int level) {
+        if (MapleDisease.getBySkill(type) == null) {
+            return;
+        }
+        giveDebuff(MapleDisease.getBySkill(type), MobSkillFactory.getMobSkill(type, level));
+    }
+    
+    public void shield() {
+        List<Pair<MapleBuffStat, Integer>> ldsstat = Collections.singletonList(new Pair<MapleBuffStat, Integer>(MapleBuffStat.ARIANT_PQ_SHIELD, 1));
+        getMap().broadcastMessage(this, MaplePacketCreator.giveForeignBuff(id, ldsstat), false);
+    }
+
+    public ScheduledFuture<?> getPqMapleMap() {
+        return pqMapleMap;
+    }
+
+    public void setPqMapleMap(ScheduledFuture<?> pqMapleMap) {
+        this.pqMapleMap = pqMapleMap;
+    }
+
+    public ScheduledFuture<?> getAriantScoreBord() {
+        return ariantScore;
+    }
+
+    public void setAriantScore(ScheduledFuture<?> ariantScore) {
+        this.ariantScore = ariantScore;
+    }
+    
 }
diff --git a/src/client/MapleClient.java b/src/client/MapleClient.java
index 2df77a0e2..55f2713da 100644
--- a/src/client/MapleClient.java
+++ b/src/client/MapleClient.java
@@ -81,6 +81,8 @@
 import net.server.audit.locks.MonitoredLockType;
 import net.server.audit.locks.factory.MonitoredReentrantLockFactory;
 import net.server.coordinator.MapleLoginBypassCoordinator;
+import server.expeditions.MapleExpedition;
+import server.expeditions.MapleExpeditionType;
 
 public class MapleClient {
 
@@ -767,7 +769,7 @@ public void updateLoginState(int newstate) {
         try {
             Connection con = DatabaseConnection.getConnection();
             try (PreparedStatement ps = con.prepareStatement("UPDATE accounts SET loggedin = ?, lastlogin = ? WHERE id = ?")) {
-                                // using sql currenttime here could potentially break the login, thanks Arnah for pointing this out
+                // using sql currenttime here could potentially break the login, thanks Arnah for pointing this out
 
                 ps.setInt(1, newstate);
                 ps.setTimestamp(2, new java.sql.Timestamp(Server.getInstance().getCurrentTime()));
@@ -884,6 +886,9 @@ private void removePlayer(World wserv, boolean serverTransition) {
                 if (player.getMonsterCarnival() != null) {
                     player.getMonsterCarnival().playerDisconnected(getPlayer().getId());
                 }
+
+                cancelarAriantPQ();
+
             }
 
             if (player.getMap() != null) {
@@ -899,6 +904,20 @@ private void removePlayer(World wserv, boolean serverTransition) {
         }
     }
 
+    public void cancelarAriantPQ() {
+        MapleExpedition exp = null;
+        if (player.getMapId() == 980010101) {
+            exp = player.getClient().getAbstractPlayerInteraction().getExpedition(MapleExpeditionType.ARIANT);
+        } else if (player.getMapId() == 980010201) {
+            exp = player.getClient().getAbstractPlayerInteraction().getExpedition(MapleExpeditionType.ARIANT1);
+        } else {
+            exp = player.getClient().getAbstractPlayerInteraction().getExpedition(MapleExpeditionType.ARIANT2);
+        }
+        if (exp != null && (player.getMapId() == 980010101 || player.getMapId() == 980010201 || player.getMapId() == 980010301) && player.getMap().getAllPlayer().size() == 1) {
+            getAbstractPlayerInteraction().endExpedition(exp);
+        }
+    }
+
     public final void disconnect(final boolean shutdown, final boolean cashshop) {
         if (canDisconnect()) {
             ThreadManager.getInstance().newTask(new Runnable() {
@@ -985,7 +1004,7 @@ private void disconnectInternal(boolean shutdown, boolean cashshop) {//once per
                         chrg.setCharacter(null);
                     }
                     wserv.removePlayer(player);
-                                        //getChannelServer().removePlayer(player); already being done
+                    //getChannelServer().removePlayer(player); already being done
 
                     player.saveCooldowns();
                     player.cancelAllDebuffs();
@@ -1448,7 +1467,7 @@ public void changeChannel(int channel) {
         player.cancelDiseaseExpireTask();
         player.cancelSkillCooldownTask();
         player.cancelQuestExpirationTask();
-		//Cancelling magicdoor? Nope
+        //Cancelling magicdoor? Nope
         //Cancelling mounts? Noty
 
         player.getInventory(MapleInventoryType.EQUIPPED).checked(false); //test
diff --git a/src/client/MapleDisease.java b/src/client/MapleDisease.java
index f84ad4f1d..3c636a491 100644
--- a/src/client/MapleDisease.java
+++ b/src/client/MapleDisease.java
@@ -29,7 +29,7 @@
     SEDUCE(0x80, 128),
     FISHABLE(0x100),
     ZOMBIFY(0x4000),
-    CONFUSE(0x80000),
+    CONFUSE(0x80000, 132),
     STUN(0x2000000000000L, 123),
     POISON(0x4000000000000L, 125),
     SEAL(0x8000000000000L, 120),
diff --git a/src/constants/GameConstants.java b/src/constants/GameConstants.java
index d8cfc98e9..4b5135bed 100644
--- a/src/constants/GameConstants.java
+++ b/src/constants/GameConstants.java
@@ -20,6 +20,7 @@
 public class GameConstants {
     public static String[] WORLD_NAMES = {"Scania", "Bera", "Broa", "Windia", "Khaini", "Bellocan", "Mardia", "Kradia", "Yellonde", "Demethos", "Galicia", "El Nido", "Zenith", "Arcenia", "Kastia", "Judis", "Plana", "Kalluna", "Stius", "Croa", "Medere"};
     public static final int[]  OWL_DATA = new int[]{1082002, 2070005, 2070006, 1022047, 1102041, 2044705, 2340000, 2040017, 1092030, 2040804};
+    public static final String[] stats = {"tuc", "reqLevel", "reqJob", "reqSTR", "reqDEX", "reqINT", "reqLUK", "reqPOP", "cash", "cursed", "success", "setItemID", "equipTradeBlock", "durability", "randOption", "randStat", "masterLevel", "reqSkillLevel", "elemDefault", "incRMAS", "incRMAF", "incRMAI", "incRMAL", "canLevel", "skill", "charmEXP"};
     public static final int[] CASH_DATA = new int[]{50200004, 50200069, 50200117, 50100008, 50000047};
     
     // Ronan's rates upgrade system
diff --git a/src/net/server/Server.java b/src/net/server/Server.java
index ca0bdbbc9..0df856fd7 100644
--- a/src/net/server/Server.java
+++ b/src/net/server/Server.java
@@ -88,6 +88,7 @@
 import java.util.TimeZone;
 import net.server.coordinator.MapleSessionCoordinator;
 import server.CashShop.CashItemFactory;
+import server.MapleItemInformationProvider;
 import server.MapleSkillbookInformationProvider;
 import server.ThreadManager;
 import server.TimerManager;
@@ -924,6 +925,7 @@ public void init() {
         //MapleItemInformationProvider.getInstance().getAllItems(); //unused, rofl
 
         CashItemFactory.getSpecialCashItems();
+        MapleItemInformationProvider.getInstance().getAllItems();
         System.out.println("Items loaded in " + ((System.currentTimeMillis() - timeToTake) / 1000.0) + " seconds");
         
 	timeToTake = System.currentTimeMillis();
diff --git a/src/net/server/channel/handlers/TakeDamageHandler.java b/src/net/server/channel/handlers/TakeDamageHandler.java
index 9a67b895a..dc44f2ccb 100644
--- a/src/net/server/channel/handlers/TakeDamageHandler.java
+++ b/src/net/server/channel/handlers/TakeDamageHandler.java
@@ -34,7 +34,6 @@
 import constants.ItemConstants;
 import constants.ServerConstants;
 import constants.skills.Aran;
-import constants.skills.Corsair;
 
 import java.awt.Point;
 import java.util.Collections;
@@ -44,6 +43,7 @@
 import net.AbstractMaplePacketHandler;
 import client.inventory.manipulator.MapleInventoryManipulator;
 import server.MapleStatEffect;
+import server.life.MapleLifeFactory;
 import server.life.MapleLifeFactory.loseItem;
 import server.life.MapleMonster;
 import server.life.MobAttackInfo;
@@ -87,15 +87,19 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)
                     }
                 }
                 
-                if (attacker != null) {
+                if (attacker != null || monsteridfrom == 9300166) {
                     List<loseItem> loseItems;
                     
-                    if (attacker.isBuffed(MonsterStatus.NEUTRALISE)) {
+                    if (monsteridfrom != 9300166 && attacker.isBuffed(MonsterStatus.NEUTRALISE)) {
                         return;
                     }
                     if (damage > 0) {
                         MapleMonster assaulter = map.getMonsterById(monsteridfrom);
                         
+                        if (monsteridfrom == 9300166) {
+                            assaulter = MapleLifeFactory.getMonster(monsteridfrom);
+                        } 
+                        
                         if(assaulter != null) {
                             loseItems = assaulter.getStats().loseItem();
                             if (loseItems != null) {
@@ -106,8 +110,14 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)
                                 for (loseItem loseItem : loseItems) {
                                     type = ItemConstants.getInventoryType(loseItem.getId());
                                     for (byte b = 0; b < loseItem.getX(); b++) {//LOL?
+                                        boolean buffAtivo = false;
                                         if (Randomizer.nextInt(100) < loseItem.getChance()) {
-                                            if (chr.haveItem(loseItem.getId())) {
+                                            for (Integer inteiro : chr.getAvailableBuffs()) {
+                                                if (inteiro == -2022269) {
+                                                    buffAtivo = true;
+                                                }
+                                            }
+                                            if (chr.haveItem(loseItem.getId()) && !buffAtivo) {
                                                 pos.x = (int) (playerpos + ((d % 2 == 0) ? (25 * (d + 1) / 2) : -(25 * (d / 2))));
                                                 MapleInventoryManipulator.removeById(c, type, loseItem.getId(), 1, false, false);
                                                 map.spawnItemDrop(chr, chr, new Item(loseItem.getId(), (short) 0, (short) 1), map.calcDropPos(pos, chr.getPosition()), true, true);
@@ -118,7 +128,9 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)
                                         }
                                     }
                                 }
-                                map.removeMapObject(attacker);
+                                if(monsteridfrom != 9300166) {
+                                    map.removeMapObject(attacker);
+                                }
                             }
                         }
                     }
diff --git a/src/net/server/channel/handlers/UseCatchItemHandler.java b/src/net/server/channel/handlers/UseCatchItemHandler.java
index 753fefbe6..34cc3e582 100644
--- a/src/net/server/channel/handlers/UseCatchItemHandler.java
+++ b/src/net/server/channel/handlers/UseCatchItemHandler.java
@@ -1,24 +1,24 @@
 /*
-    This file is part of the OdinMS Maple Story Server
-    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>
-               Matthias Butz <matze@odinms.de>
-               Jan Christian Meyer <vimes@odinms.de>
+ This file is part of the OdinMS Maple Story Server
+ Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>
+ Matthias Butz <matze@odinms.de>
+ Jan Christian Meyer <vimes@odinms.de>
 
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Affero General Public License as
-    published by the Free Software Foundation version 3 as published by
-    the Free Software Foundation. You may not use, modify or distribute
-    this program under any other version of the GNU Affero General Public
-    License.
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU Affero General Public License as
+ published by the Free Software Foundation version 3 as published by
+ the Free Software Foundation. You may not use, modify or distribute
+ this program under any other version of the GNU Affero General Public
+ License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Affero General Public License for more details.
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU Affero General Public License for more details.
 
-    You should have received a copy of the GNU Affero General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
+ You should have received a copy of the GNU Affero General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
 package net.server.channel.handlers;
 
 import client.MapleCharacter;
@@ -29,6 +29,7 @@
 import net.AbstractMaplePacketHandler;
 import net.server.Server;
 import client.inventory.manipulator.MapleInventoryManipulator;
+import server.MapleItemInformationProvider;
 import server.life.MapleMonster;
 import tools.MaplePacketCreator;
 import tools.data.input.SeekableLittleEndianAccessor;
@@ -38,6 +39,7 @@
  * @author kevintjuh93
  */
 public final class UseCatchItemHandler extends AbstractMaplePacketHandler {
+
     @Override
     public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c) {
         MapleCharacter chr = c.getPlayer();
@@ -48,140 +50,37 @@ public final void handlePacket(SeekableLittleEndianAccessor slea, MapleClient c)
         int itemId = slea.readInt();
         int monsterid = slea.readInt();
 
+        int itemGanho = MapleItemInformationProvider.getInstance().getCreatItem(itemId);
+        int mobItem = MapleItemInformationProvider.getInstance().getMobItem(itemId);
+        int timeCatch = MapleItemInformationProvider.getInstance().getUseDelay(itemId);
+        int mobHp = MapleItemInformationProvider.getInstance().getMobHP(itemId);
+
         MapleMonster mob = chr.getMap().getMonsterByOid(monsterid);
         if (chr.getInventory(ItemConstants.getInventoryType(itemId)).countById(itemId) <= 0) {
-           return;
+            return;
         }
         if (mob == null) {
-           return;
+            return;
         }
-        switch (itemId) {
-            case 2270000:
-                if (mob.getId() == 9300101) {
+
+        if (itemGanho != 0 && mobItem == mob.getId()) {
+            if (timeCatch != 0 && (abm.getLastSpam(10) + timeCatch) < currentServerTime()) {
+                if (mobHp != 0 && mob.getHp() < ((mob.getMaxHp() / 100) * mobHp)) {
                     chr.getMap().broadcastMessage(MaplePacketCreator.catchMonster(monsterid, itemId, (byte) 1));
                     mob.getMap().killMonster(mob, null, false);
                     MapleInventoryManipulator.removeById(c, MapleInventoryType.USE, itemId, 1, true, true);
-                    MapleInventoryManipulator.addById(c, 1902000, (short) 1, "", -1);
-                 }
-                c.announce(MaplePacketCreator.enableActions());
-                break;
-            case 2270001:
-                if (mob.getId() == 9500197) {
-                    if ((abm.getLastSpam(10) + 1000) < currentServerTime()) {
-                        if (mob.getHp() < ((mob.getMaxHp() / 10) * 4)) {
-                            chr.getMap().broadcastMessage(MaplePacketCreator.catchMonster(monsterid, itemId, (byte) 1));
-                            mob.getMap().killMonster(mob, null, false);
-                            MapleInventoryManipulator.removeById(c, MapleInventoryType.USE, itemId, 1, true, true);
-                            MapleInventoryManipulator.addById(c, 4031830, (short) 1, "", -1);
-                        } else {
-                            abm.spam(10);
-                            c.announce(MaplePacketCreator.catchMessage(0));
-                        }
-                    }
-                    c.announce(MaplePacketCreator.enableActions());
-                }
-                break;
-            case 2270002:
-                if (mob.getId() == 9300157) {
-                    if ((abm.getLastSpam(10) + 800) < currentServerTime()) {
-                        if (mob.getHp() < ((mob.getMaxHp() / 10) * 4)) {
-                            if (Math.random() < 0.5) { // 50% chance
-                                chr.getMap().broadcastMessage(MaplePacketCreator.catchMonster(monsterid, itemId, (byte) 1));
-                                mob.getMap().killMonster(mob, null, false);
-                                MapleInventoryManipulator.removeById(c, MapleInventoryType.USE, itemId, 1, true, true);
-                                MapleInventoryManipulator.addById(c, 4031868, (short) 1, "", -1);
-                            } else {
-                                chr.getMap().broadcastMessage(MaplePacketCreator.catchMonster(monsterid, itemId, (byte) 0));
-                            }
-                            abm.spam(10);
-                        } else {
-                            c.announce(MaplePacketCreator.catchMessage(0));
-                        }
+                    MapleInventoryManipulator.addById(c, itemGanho, (short) 1, "", -1);
+                    if (itemGanho == 4031868) {
+                        chr.updateAriantScore();
                     }
-                c.announce(MaplePacketCreator.enableActions());
-                }
-                break;
-            case 2270003:
-                if (mob.getId() == 9500320) {
-                    if (mob.getHp() < ((mob.getMaxHp() / 10) * 4)) {
-                        chr.getMap().broadcastMessage(MaplePacketCreator.catchMonster(monsterid, itemId, (byte) 1));
-                        mob.getMap().killMonster(mob, null, false);
-                        MapleInventoryManipulator.removeById(c, MapleInventoryType.USE, itemId, 1, true, true);
-                        MapleInventoryManipulator.addById(c, 4031887, (short) 1, "", -1);
-                    } else {
-                        c.announce(MaplePacketCreator.catchMessage(0));
-                    }
-                }
-                c.announce(MaplePacketCreator.enableActions());
-                break;
-            case 2270005:
-                if (mob.getId() == 9300187) {
-                    if (mob.getHp() < ((mob.getMaxHp() / 10) * 3)) {
-                        chr.getMap().broadcastMessage(MaplePacketCreator.catchMonster(monsterid, itemId, (byte) 1));
-                        mob.getMap().killMonster(mob, null, false);
-                        MapleInventoryManipulator.removeById(c, MapleInventoryType.USE, itemId, 1, true, true);
-                        MapleInventoryManipulator.addById(c, 2109001, (short) 1, "", -1);
-                    } else {
-                        c.announce(MaplePacketCreator.catchMessage(0));
-                    }
-                }
-                c.announce(MaplePacketCreator.enableActions());
-                break;
-            case 2270006:
-                if (mob.getId() == 9300189) {
-                    if (mob.getHp() < ((mob.getMaxHp() / 10) * 3)) {
-                        chr.getMap().broadcastMessage(MaplePacketCreator.catchMonster(monsterid, itemId, (byte) 1));
-                        mob.getMap().killMonster(mob, null, false);
-                        MapleInventoryManipulator.removeById(c, MapleInventoryType.USE, itemId, 1, true, true);
-                        MapleInventoryManipulator.addById(c, 2109002, (short) 1, "", -1);
-                    } else {
-                        c.announce(MaplePacketCreator.catchMessage(0));
-                    }
-                }
-                c.announce(MaplePacketCreator.enableActions());
-                break;
-            case 2270007:
-                if (mob.getId() == 9300191) {
-                    if (mob.getHp() < ((mob.getMaxHp() / 10) * 3)) {
-                        chr.getMap().broadcastMessage(MaplePacketCreator.catchMonster(monsterid, itemId, (byte) 1));
-                        mob.getMap().killMonster(mob, null, false);
-                        MapleInventoryManipulator.removeById(c, MapleInventoryType.USE, itemId, 1, true, true);
-                        MapleInventoryManipulator.addById(c, 2109003, (short) 1, "", -1);
-                    } else {
-                        c.announce(MaplePacketCreator.catchMessage(0));
-                    }
-                }
-                c.announce(MaplePacketCreator.enableActions());
-                break;
-            case 2270004:
-                if (mob.getId() == 9300175) {
-                    if (mob.getHp() < ((mob.getMaxHp() / 10) * 4)) {
-                    chr.getMap().broadcastMessage(MaplePacketCreator.catchMonster(monsterid, itemId, (byte) 1));
-                    mob.getMap().killMonster(mob, null, false);
-                    MapleInventoryManipulator.removeById(c, MapleInventoryType.USE, itemId, 1, true, true);
-                    MapleInventoryManipulator.addById(c, 4001169, (short) 1, "", -1);
-                    } else {
+                } else if (mobHp != 0 && mob.getId() != 9500336) {
+                    abm.spam(10);
                     c.announce(MaplePacketCreator.catchMessage(0));
-                    }
-                }
-                c.announce(MaplePacketCreator.enableActions());
-                break;
-            case 2270008:
-                if (mob.getId() == 9500336) {
-                    if ((abm.getLastSpam(10) + 3000) < currentServerTime()) {
-                        abm.spam(10);
-                        chr.getMap().broadcastMessage(MaplePacketCreator.catchMonster(monsterid, itemId, (byte) 1));
-                        mob.getMap().killMonster(mob, null, false);
-                        MapleInventoryManipulator.removeById(c, MapleInventoryType.USE, itemId, 1, true, true);
-                        MapleInventoryManipulator.addById(c, 2022323, (short) 1, "", -1);
-                    } else {
-                        chr.message("You cannot use the Fishing Net yet.");
-                    }
-                    c.announce(MaplePacketCreator.enableActions());
+                } else if (mob.getId() == 9500336) {
+                    chr.message("You cannot use the Fishing Net yet.");
                 }
-                break;
-            default:
-               // System.out.println("UseCatchItemHandler: \r\n" + slea.toString());
+            }
         }
+        c.announce(MaplePacketCreator.enableActions());
     }
 }
diff --git a/src/provider/MapleDataTool.java b/src/provider/MapleDataTool.java
index 25f4c7f81..cfef1b017 100644
--- a/src/provider/MapleDataTool.java
+++ b/src/provider/MapleDataTool.java
@@ -72,6 +72,25 @@ public static int getIntConvert(MapleData data) {
             return getInt(data);
         }
     }
+    
+    public static int getIntConvert(MapleData d, int def) {
+        if (d == null) {
+            return def;
+        }
+        if (d.getType() == MapleDataType.STRING) {
+	    String dd = getString(d);
+	    if (dd.endsWith("%")) {
+		dd = dd.substring(0, dd.length() - 1);
+	    }
+            try {
+                return Integer.parseInt(dd);
+            } catch (NumberFormatException nfe) {
+                return def;
+            }
+        } else {
+            return getInt(d, def);
+        }
+    }
 
     public static int getIntConvert(String path, MapleData data) {
         MapleData d = data.getChildByPath(path);
diff --git a/src/scripting/AbstractPlayerInteraction.java b/src/scripting/AbstractPlayerInteraction.java
index 83952bff2..a9e901956 100644
--- a/src/scripting/AbstractPlayerInteraction.java
+++ b/src/scripting/AbstractPlayerInteraction.java
@@ -55,7 +55,6 @@
 import client.MapleCharacter;
 import client.MapleClient;
 import client.MapleQuestStatus;
-import client.MapleStat;
 import client.SkillFactory;
 import client.inventory.Equip;
 import client.inventory.Item;
@@ -331,7 +330,7 @@ public boolean canHoldAllAfterRemoving(List<Integer> toAddItemids, List<Integer>
         return true;
     }
 
-        //---- \/ \/ \/ \/ \/ \/ \/  NOT TESTED  \/ \/ \/ \/ \/ \/ \/ \/ \/ ----
+    //---- \/ \/ \/ \/ \/ \/ \/  NOT TESTED  \/ \/ \/ \/ \/ \/ \/ \/ \/ ----
     public final MapleQuestStatus getQuestRecord(final int id) {
         return c.getPlayer().getQuestNAdd(MapleQuest.getInstance(id));
     }
@@ -340,7 +339,7 @@ public final MapleQuestStatus getQuestNoRecord(final int id) {
         return c.getPlayer().getQuestNoAdd(MapleQuest.getInstance(id));
     }
 
-        //---- /\ /\ /\ /\ /\ /\ /\  NOT TESTED  /\ /\ /\ /\ /\ /\ /\ /\ /\ ----
+    //---- /\ /\ /\ /\ /\ /\ /\  NOT TESTED  /\ /\ /\ /\ /\ /\ /\ /\ /\ ----
     public void openNpc(int npcid) {
         openNpc(npcid, null);
     }
@@ -745,7 +744,7 @@ public void givePartyExp(String PQ) {
     }
 
     public void givePartyExp(String PQ, boolean instance) {
-		//1 player  =  +0% bonus (100)
+        //1 player  =  +0% bonus (100)
         //2 players =  +0% bonus (100)
         //3 players =  +0% bonus (100)
         //4 players = +10% bonus (110)
@@ -1025,6 +1024,33 @@ public MapleExpedition getExpedition(MapleExpeditionType type) {
         return null;
     }
 
+    public String getNomeDosMembrosExpedition(MapleExpeditionType tipo) {
+        String membros = "";
+        MapleExpedition expedicao = getExpedition(tipo);
+        for (String memberName : expedicao.getMembers().values()) {
+            membros += "" + memberName + ", ";
+        }
+        return membros;
+    }
+    
+    public boolean getIsLeaderExpedition(MapleExpeditionType tipo) {
+        MapleExpedition expedicao = getExpedition(tipo);
+        return expedicao.isLeader(getPlayer());
+    }
+    
+    public void warpExpedition(int mapId, MapleExpeditionType tipo) {
+        if (tipo != null ) {
+            MapleExpedition expedicao = getExpedition(tipo);
+            for (MapleCharacter chr : expedicao.getActiveMembers()) {
+                chr.changeMap(mapId);
+            }
+        } else {
+            for (MapleCharacter chr : getMap().getAllPlayers()) {
+                chr.changeMap(mapId);
+            }
+        }
+    }
+
     public long getJailTimeLeft() {
         return getPlayer().getJailExpirationTimeLeft();
     }
diff --git a/src/scripting/event/EventInstanceManager.java b/src/scripting/event/EventInstanceManager.java
index 6c0fb043f..82de97df7 100644
--- a/src/scripting/event/EventInstanceManager.java
+++ b/src/scripting/event/EventInstanceManager.java
@@ -1,23 +1,23 @@
 /*
-	This file is part of the OdinMS Maple Story Server
-    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>
-		       Matthias Butz <matze@odinms.de>
-		       Jan Christian Meyer <vimes@odinms.de>
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Affero General Public License as
-    published by the Free Software Foundation version 3 as published by
-    the Free Software Foundation. You may not use, modify or distribute
-    this program under any other version of the GNU Affero General Public
-    License.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Affero General Public License for more details.
-
-    You should have received a copy of the GNU Affero General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ This file is part of the OdinMS Maple Story Server
+ Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>
+ Matthias Butz <matze@odinms.de>
+ Jan Christian Meyer <vimes@odinms.de>
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU Affero General Public License as
+ published by the Free Software Foundation version 3 as published by
+ the Free Software Foundation. You may not use, modify or distribute
+ this program under any other version of the GNU Affero General Public
+ License.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU Affero General Public License for more details.
+
+ You should have received a copy of the GNU Affero General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 package scripting.event;
 
@@ -80,1284 +80,1355 @@
  * @author Ronan
  */
 public class EventInstanceManager {
-	private Map<Integer, MapleCharacter> chars = new HashMap<>();
-        private int leaderId = -1;
-	private List<MapleMonster> mobs = new LinkedList<>();
-	private Map<MapleCharacter, Integer> killCount = new HashMap<>();
-	private EventManager em;
-        private EventScriptScheduler ess;
-	private MapleMapFactory mapFactory;
-	private String name;
-	private Properties props = new Properties();
-	private long timeStarted = 0;
-	private long eventTime = 0;
-	private MapleExpedition expedition = null;
-        private List<Integer> mapIds = new LinkedList<>();
-        
-        private final ReentrantReadWriteLock lock = new MonitoredReentrantReadWriteLock(MonitoredLockType.EIM, true);
-        private ReadLock rL = lock.readLock();
-        private WriteLock wL = lock.writeLock();
-        
-        private MonitoredReentrantLock pL = MonitoredReentrantLockFactory.createLock(MonitoredLockType.EIM_PARTY, true);
-        private MonitoredReentrantLock sL = MonitoredReentrantLockFactory.createLock(MonitoredLockType.EIM_SCRIPT, true);
-        
-        private ScheduledFuture<?> event_schedule = null;
-        private boolean disposed = false;
-        private boolean eventCleared = false;
-        private boolean eventStarted = false;
-        
-        // multi-leveled PQ rewards!
-        private Map<Integer, List<Integer>> collectionSet = new HashMap<>(ServerConstants.MAX_EVENT_LEVELS);
-        private Map<Integer, List<Integer>> collectionQty = new HashMap<>(ServerConstants.MAX_EVENT_LEVELS);
-        private Map<Integer, Integer> collectionExp = new HashMap<>(ServerConstants.MAX_EVENT_LEVELS);
-        
-        // Exp/Meso rewards by CLEAR on a stage
-        private List<Integer> onMapClearExp = new ArrayList<>();
-        private List<Integer> onMapClearMeso = new ArrayList<>();
-        
-        // registers player status on an event (null on this Map structure equals to 0)
-        private Map<Integer, Integer> playerGrid = new HashMap<>();
-        
-        // registers all opened gates on the event. Will help late characters to encounter next stages gates already opened
-        private Map<Integer, Pair<String, Integer>> openedGates = new HashMap<>();
-        
-        // forces deletion of items not supposed to be held outside of the event, dealt on a player's leaving moment.
-        private Set<Integer> exclusiveItems = new HashSet<>();
-        
-	public EventInstanceManager(EventManager em, String name) {
-		this.em = em;
-		this.name = name;
-                this.ess = new EventScriptScheduler();
-		mapFactory = new MapleMapFactory(this, MapleDataProviderFactory.getDataProvider(new File(System.getProperty("wzpath") + "/Map.wz")), MapleDataProviderFactory.getDataProvider(new File(System.getProperty("wzpath") + "/String.wz")), (byte) 0, (byte) 1);//Fk this
-		mapFactory.setChannel(em.getChannelServer().getId());
-	}
-        
-        public void setName(String name) {
-                this.name = name;
-        }
-
-	public EventManager getEm() {
-                sL.lock();
-                try {
-                        return em;
-                } finally {
-                        sL.unlock();
-                }
-	}
-        
-        public int getEventPlayersJobs() {
+
+    private Map<Integer, MapleCharacter> chars = new HashMap<>();
+    private int leaderId = -1;
+    private List<MapleMonster> mobs = new LinkedList<>();
+    private Map<MapleCharacter, Integer> killCount = new HashMap<>();
+    private EventManager em;
+    private EventScriptScheduler ess;
+    private MapleMapFactory mapFactory;
+    private String name;
+    private Properties props = new Properties();
+    private long timeStarted = 0;
+    private long eventTime = 0;
+    private MapleExpedition expedition = null;
+    private List<Integer> mapIds = new LinkedList<>();
+
+    private final ReentrantReadWriteLock lock = new MonitoredReentrantReadWriteLock(MonitoredLockType.EIM, true);
+    private ReadLock rL = lock.readLock();
+    private WriteLock wL = lock.writeLock();
+
+    private MonitoredReentrantLock pL = MonitoredReentrantLockFactory.createLock(MonitoredLockType.EIM_PARTY, true);
+    private MonitoredReentrantLock sL = MonitoredReentrantLockFactory.createLock(MonitoredLockType.EIM_SCRIPT, true);
+
+    private ScheduledFuture<?> event_schedule = null;
+    private boolean disposed = false;
+    private boolean eventCleared = false;
+    private boolean eventStarted = false;
+
+    // multi-leveled PQ rewards!
+    private Map<Integer, List<Integer>> collectionSet = new HashMap<>(ServerConstants.MAX_EVENT_LEVELS);
+    private Map<Integer, List<Integer>> collectionQty = new HashMap<>(ServerConstants.MAX_EVENT_LEVELS);
+    private Map<Integer, Integer> collectionExp = new HashMap<>(ServerConstants.MAX_EVENT_LEVELS);
+
+    // Exp/Meso rewards by CLEAR on a stage
+    private List<Integer> onMapClearExp = new ArrayList<>();
+    private List<Integer> onMapClearMeso = new ArrayList<>();
+
+    // registers player status on an event (null on this Map structure equals to 0)
+    private Map<Integer, Integer> playerGrid = new HashMap<>();
+
+    // registers all opened gates on the event. Will help late characters to encounter next stages gates already opened
+    private Map<Integer, Pair<String, Integer>> openedGates = new HashMap<>();
+
+    // forces deletion of items not supposed to be held outside of the event, dealt on a player's leaving moment.
+    private Set<Integer> exclusiveItems = new HashSet<>();
+
+    public EventInstanceManager(EventManager em, String name) {
+        this.em = em;
+        this.name = name;
+        this.ess = new EventScriptScheduler();
+        mapFactory = new MapleMapFactory(this, MapleDataProviderFactory.getDataProvider(new File(System.getProperty("wzpath") + "/Map.wz")), MapleDataProviderFactory.getDataProvider(new File(System.getProperty("wzpath") + "/String.wz")), (byte) 0, (byte) 1);//Fk this
+        mapFactory.setChannel(em.getChannelServer().getId());
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public EventManager getEm() {
+        sL.lock();
+        try {
+            return em;
+        } finally {
+            sL.unlock();
+        }
+    }
+
+    public int getEventPlayersJobs() {
                 //Bits -> 0: BEGINNER 1: WARRIOR 2: MAGICIAN
-                //        3: BOWMAN 4: THIEF 5: PIRATE
-            
-                int mask = 0;
-                for(MapleCharacter chr: getPlayers()) {
-                        mask |= (1 << chr.getJob().getJobNiche());
-                }
-                
-                return mask;
-        }
-        
-        public void applyEventPlayersItemBuff(int itemId) {
-                List<MapleCharacter> players = getPlayerList();
-                MapleStatEffect mse = MapleItemInformationProvider.getInstance().getItemEffect(itemId);
-                
-                if(mse != null) {
-                        for (MapleCharacter player: players) {
-                                mse.applyTo(player);
-                        }
-                }
+        //        3: BOWMAN 4: THIEF 5: PIRATE
+
+        int mask = 0;
+        for (MapleCharacter chr : getPlayers()) {
+            mask |= (1 << chr.getJob().getJobNiche());
         }
-        
-        public void applyEventPlayersSkillBuff(int skillId) {
-                applyEventPlayersSkillBuff(skillId, Integer.MAX_VALUE);
-        }
-        
-        public void applyEventPlayersSkillBuff(int skillId, int skillLv) {
-                List<MapleCharacter> players = getPlayerList();
-                Skill skill = SkillFactory.getSkill(skillId);
-                
-                if(skill != null) {
-                        MapleStatEffect mse = skill.getEffect(Math.min(skillLv, skill.getMaxLevel()));
-                        if(mse != null) {
-                                for (MapleCharacter player: players) {
-                                        mse.applyTo(player);
-                                }
-                        }
-                }
+
+        return mask;
+    }
+
+    public void applyEventPlayersItemBuff(int itemId) {
+        List<MapleCharacter> players = getPlayerList();
+        MapleStatEffect mse = MapleItemInformationProvider.getInstance().getItemEffect(itemId);
+
+        if (mse != null) {
+            for (MapleCharacter player : players) {
+                mse.applyTo(player);
+            }
         }
-        
-        public void giveEventPlayersExp(int gain) {
-                giveEventPlayersExp(gain, -1);
-        }
-        
-        public void giveEventPlayersExp(int gain, int mapId) {
-                if(gain == 0) return;
-                
-                List<MapleCharacter> players = getPlayerList();
-            
-                if(mapId == -1) {
-                        for(MapleCharacter mc: players) {
-                                mc.gainExp(gain * mc.getExpRate(), true, true);
-                        }
-                }
-                else {
-                        for(MapleCharacter mc: players) {
-                                if(mc.getMapId() == mapId) mc.gainExp(gain * mc.getExpRate(), true, true);
-                        }
-                }
-	}
-        
-        public void giveEventPlayersMeso(int gain) {
-                giveEventPlayersMeso(gain, -1);
-        }
-        
-        public void giveEventPlayersMeso(int gain, int mapId) {
-                if(gain == 0) return;
-                
-                List<MapleCharacter> players = getPlayerList();
-                
-                if(mapId == -1) {
-                        for(MapleCharacter mc: players) {
-                                mc.gainMeso(gain * mc.getMesoRate());
-                        }
-                }
-                else {
-                        for(MapleCharacter mc: players) {
-                                if(mc.getMapId() == mapId) mc.gainMeso(gain * mc.getMesoRate());
-                        }
-                }
-                
-	}
-
-        public synchronized void registerPlayer(final MapleCharacter chr) {
-                registerPlayer(chr, true);
-        }
-        
-	public synchronized void registerPlayer(final MapleCharacter chr, boolean runEntryScript) {
-		if (chr == null || !chr.isLoggedinWorld() || disposed) {
-			return;
-		}
-                
-                wL.lock();
-                try {
-                        if(chars.containsKey(chr.getId())) {
-                                return;
-                        }
+    }
 
-                        chars.put(chr.getId(), chr);
-                        chr.setEventInstance(this);
-                } finally {
-                        wL.unlock();
-                }
-                
-                if (runEntryScript) {
-                        try {
-                                em.getIv().invokeFunction("playerEntry", EventInstanceManager.this, chr);
-                        } catch (ScriptException | NoSuchMethodException ex) {
-                                ex.printStackTrace();
-                        }
-                }
-	}  
-        
-        public void exitPlayer(final MapleCharacter chr) {
-		if (chr == null || !chr.isLoggedin()){
-			return;
-		}
-		
-                unregisterPlayer(chr);
-                
-                try {
-                        em.getIv().invokeFunction("playerExit", EventInstanceManager.this, chr);
-                } catch (ScriptException | NoSuchMethodException ex) {
-                        ex.printStackTrace();
-                }
-	}
-        
-        public void dropMessage(int type, String message) {
-                for (MapleCharacter chr : getPlayers()) {
-                        chr.dropMessage(type, message);
+    public void applyEventPlayersSkillBuff(int skillId) {
+        applyEventPlayersSkillBuff(skillId, Integer.MAX_VALUE);
+    }
+
+    public void applyEventPlayersSkillBuff(int skillId, int skillLv) {
+        List<MapleCharacter> players = getPlayerList();
+        Skill skill = SkillFactory.getSkill(skillId);
+
+        if (skill != null) {
+            MapleStatEffect mse = skill.getEffect(Math.min(skillLv, skill.getMaxLevel()));
+            if (mse != null) {
+                for (MapleCharacter player : players) {
+                    mse.applyTo(player);
                 }
+            }
         }
+    }
 
-        public void restartEventTimer(long time) {
-                stopEventTimer();
-                startEventTimer(time);
+    public void giveEventPlayersExp(int gain) {
+        giveEventPlayersExp(gain, -1);
+    }
+
+    public void giveEventPlayersExp(int gain, int mapId) {
+        if (gain == 0) {
+            return;
         }
-        
-	public void startEventTimer(long time) {
-                timeStarted = System.currentTimeMillis();
-		eventTime = time;
-                
-                for(MapleCharacter chr: getPlayers()) {
-                        chr.announce(MaplePacketCreator.getClock((int) (time / 1000)));
-                }
-                
-                event_schedule = TimerManager.getInstance().schedule(new Runnable() {
-                        @Override
-                        public void run() {
-                                dismissEventTimer();
-                                
-                                try {
-                                        em.getIv().invokeFunction("scheduledTimeout", EventInstanceManager.this);
-                                } catch (ScriptException | NoSuchMethodException ex) {
-                                        Logger.getLogger(EventManager.class.getName()).log(Level.SEVERE, "Event '" + em.getName() + "' does not implement scheduledTimeout function.", ex);
-                                }
-                        }
-                }, time);
-	}
-        
-        public void addEventTimer(long time) {
-                if (event_schedule != null) {
-                        if (event_schedule.cancel(false)) {
-                                long nextTime = getTimeLeft() + time;
-                                eventTime += time;
-
-                                event_schedule = TimerManager.getInstance().schedule(new Runnable() {
-                                        @Override
-                                        public void run() {
-                                                dismissEventTimer();
-
-                                                try {
-                                                        em.getIv().invokeFunction("scheduledTimeout", EventInstanceManager.this);
-                                                } catch (ScriptException | NoSuchMethodException ex) {
-                                                        Logger.getLogger(EventManager.class.getName()).log(Level.SEVERE, "Event '" + em.getName() + "' does not implement scheduledTimeout function.", ex);
-                                                }
-                                        }
-                                }, nextTime);
-                        }
-                } else {
-                        startEventTimer(time);
+
+        List<MapleCharacter> players = getPlayerList();
+
+        if (mapId == -1) {
+            for (MapleCharacter mc : players) {
+                mc.gainExp(gain * mc.getExpRate(), true, true);
+            }
+        } else {
+            for (MapleCharacter mc : players) {
+                if (mc.getMapId() == mapId) {
+                    mc.gainExp(gain * mc.getExpRate(), true, true);
                 }
+            }
         }
-        
-        private void dismissEventTimer() {
-                for(MapleCharacter chr: getPlayers()) {
-                        chr.getClient().announce(MaplePacketCreator.removeClock());
-                }
-                
-                event_schedule = null;
-                eventTime = 0;
-                timeStarted = 0;
-        }
-        
-        public void stopEventTimer() {
-                if(event_schedule != null) {
-                        event_schedule.cancel(false);
-                        event_schedule = null;
-                }
-                
-                dismissEventTimer();
+    }
+
+    public void giveEventPlayersMeso(int gain) {
+        giveEventPlayersMeso(gain, -1);
+    }
+
+    public void giveEventPlayersMeso(int gain, int mapId) {
+        if (gain == 0) {
+            return;
         }
-        
-	public boolean isTimerStarted() {
-		return eventTime > 0 && timeStarted > 0;
-	}
 
-	public long getTimeLeft() {
-		return eventTime - (System.currentTimeMillis() - timeStarted);
-	}
+        List<MapleCharacter> players = getPlayerList();
 
-        public void registerParty(MapleCharacter chr) {
-                if (chr.isPartyLeader()) {
-                        registerParty(chr.getParty(), chr.getMap());
+        if (mapId == -1) {
+            for (MapleCharacter mc : players) {
+                mc.gainMeso(gain * mc.getMesoRate());
+            }
+        } else {
+            for (MapleCharacter mc : players) {
+                if (mc.getMapId() == mapId) {
+                    mc.gainMeso(gain * mc.getMesoRate());
                 }
+            }
         }
-        
-	public void registerParty(MapleParty party, MapleMap map) {
-		for (MaplePartyCharacter pc : party.getEligibleMembers()) {
-			MapleCharacter c = map.getCharacterById(pc.getId());
-			registerPlayer(c);
-		}
-	}
-
-	public void registerExpedition(MapleExpedition exped) {
-		expedition = exped;
-                registerExpeditionTeam(exped, exped.getRecruitingMap().getId());
-	}
-        
-        private void registerExpeditionTeam(MapleExpedition exped, int recruitMap) {
-		expedition = exped;
-                
-                for (MapleCharacter chr: exped.getActiveMembers()) {
-                        if (chr.getMapId() == recruitMap) {
-                                registerPlayer(chr);
-                        }
-                }
-	}
 
-	public void unregisterPlayer(final MapleCharacter chr) {
-                try {
-                        em.getIv().invokeFunction("playerUnregistered", EventInstanceManager.this, chr);
-                } catch (ScriptException | NoSuchMethodException ex) {
-                        Logger.getLogger(EventManager.class.getName()).log(Level.SEVERE, "Event '" + em.getName() + "' does not implement playerUnregistered function.", ex);
-                }
-                        
-                wL.lock();
-                try {
-                        chars.remove(chr.getId());
-                        chr.setEventInstance(null);
-                } finally {
-                        wL.unlock();
-                }
-                
-                gridRemove(chr);
-                dropExclusiveItems(chr);
-	}
-	
-	public int getPlayerCount() {
-                rL.lock();
-                try {
-                        return chars.size();
-                } finally {
-                        rL.unlock();
-                }
-	}
-        
-        public MapleCharacter getPlayerById(int id) {
-                rL.lock();
-                try {
-                        return chars.get(id);
-                } finally {
-                        rL.unlock();
-                }
-	}
+    }
 
-	public List<MapleCharacter> getPlayers() {
-                rL.lock();
-                try {
-                        return new ArrayList<>(chars.values());
-                } finally {
-                        rL.unlock();
-                }
-	}
-        
-        private List<MapleCharacter> getPlayerList() {
-                rL.lock();
-                try {
-                        return new LinkedList<>(chars.values());
-                } finally {
-                        rL.unlock();
-                }
+    public synchronized void registerPlayer(final MapleCharacter chr) {
+        registerPlayer(chr, true);
+    }
+
+    public synchronized void registerPlayer(final MapleCharacter chr, boolean runEntryScript) {
+        if (chr == null || !chr.isLoggedinWorld() || disposed) {
+            return;
         }
-        
-	public void registerMonster(MapleMonster mob) {
-		if (!mob.getStats().isFriendly()) { //We cannot register moon bunny
-			mobs.add(mob);
-		}
-	}
 
-	public void movePlayer(final MapleCharacter chr) {
-                try {
-                        em.getIv().invokeFunction("moveMap", EventInstanceManager.this, chr);
-                } catch (ScriptException | NoSuchMethodException ex) {
-                        ex.printStackTrace();
-                }
-	}
-        
-        public void changedMap(final MapleCharacter chr, final int mapId) {
-                try {
-                        em.getIv().invokeFunction("changedMap", EventInstanceManager.this, chr, mapId);
-                } catch (ScriptException | NoSuchMethodException ex) {} // optional
-	}
-        
-        public void afterChangedMap(final MapleCharacter chr, final int mapId) {
-                try {
-                        em.getIv().invokeFunction("afterChangedMap", EventInstanceManager.this, chr, mapId);
-                } catch (ScriptException | NoSuchMethodException ex) {} // optional
-	}
-        
-        public synchronized void changedLeader(final MapleCharacter ldr) {
+        wL.lock();
+        try {
+            if (chars.containsKey(chr.getId())) {
+                return;
+            }
+
+            chars.put(chr.getId(), chr);
+            chr.setEventInstance(this);
+        } finally {
+            wL.unlock();
+        }
+
+        if (runEntryScript) {
+            try {
+                em.getIv().invokeFunction("playerEntry", EventInstanceManager.this, chr);
+            } catch (ScriptException | NoSuchMethodException ex) {
+                ex.printStackTrace();
+            }
+        }
+    }
+
+    public void exitPlayer(final MapleCharacter chr) {
+        if (chr == null || !chr.isLoggedin()) {
+            return;
+        }
+
+        unregisterPlayer(chr);
+
+        try {
+            em.getIv().invokeFunction("playerExit", EventInstanceManager.this, chr);
+        } catch (ScriptException | NoSuchMethodException ex) {
+            ex.printStackTrace();
+        }
+    }
+
+    public void dropMessage(int type, String message) {
+        for (MapleCharacter chr : getPlayers()) {
+            chr.dropMessage(type, message);
+        }
+    }
+
+    public void restartEventTimer(long time) {
+        stopEventTimer();
+        startEventTimer(time);
+    }
+
+    public void startEventTimer(long time) {
+        timeStarted = System.currentTimeMillis();
+        eventTime = time;
+
+        for (MapleCharacter chr : getPlayers()) {
+            chr.announce(MaplePacketCreator.getClock((int) (time / 1000)));
+        }
+
+        event_schedule = TimerManager.getInstance().schedule(new Runnable() {
+            @Override
+            public void run() {
+                dismissEventTimer();
+
                 try {
-                        em.getIv().invokeFunction("changedLeader", EventInstanceManager.this, ldr);
+                    em.getIv().invokeFunction("scheduledTimeout", EventInstanceManager.this);
                 } catch (ScriptException | NoSuchMethodException ex) {
-                        ex.printStackTrace();
+                    Logger.getLogger(EventManager.class.getName()).log(Level.SEVERE, "Event '" + em.getName() + "' does not implement scheduledTimeout function.", ex);
                 }
-		
-                leaderId = ldr.getId();
-	}
-	
-	public void monsterKilled(final MapleMonster mob, final boolean hasKiller) {
-                int scriptResult = 0;
-                
-		sL.lock();
-                try {
-                        mobs.remove(mob);
-                        
-                        if(eventStarted) {
-                                scriptResult = 1;
-
-                                if (mobs.isEmpty()) {
-                                        scriptResult = 2;
-                                }
-                        }
-                } finally {
-                        sL.unlock();
-                }
-                
-                if (scriptResult > 0) {
+            }
+        }, time);
+    }
+
+    public void addEventTimer(long time) {
+        if (event_schedule != null) {
+            if (event_schedule.cancel(false)) {
+                long nextTime = getTimeLeft() + time;
+                eventTime += time;
+
+                event_schedule = TimerManager.getInstance().schedule(new Runnable() {
+                    @Override
+                    public void run() {
+                        dismissEventTimer();
+
                         try {
-                                em.getIv().invokeFunction("monsterKilled", mob, EventInstanceManager.this, hasKiller);
+                            em.getIv().invokeFunction("scheduledTimeout", EventInstanceManager.this);
                         } catch (ScriptException | NoSuchMethodException ex) {
-                                ex.printStackTrace();
-                        }
-                        
-                        if (scriptResult > 1) {
-                                try {
-                                        em.getIv().invokeFunction("allMonstersDead", EventInstanceManager.this, hasKiller);
-                                } catch (ScriptException | NoSuchMethodException ex) {
-                                        ex.printStackTrace();
-                                }
+                            Logger.getLogger(EventManager.class.getName()).log(Level.SEVERE, "Event '" + em.getName() + "' does not implement scheduledTimeout function.", ex);
                         }
-                }
+                    }
+                }, nextTime);
+            }
+        } else {
+            startEventTimer(time);
         }
-        
-        public void friendlyKilled(final MapleMonster mob, final boolean hasKiller) {
-                try {
-                        em.getIv().invokeFunction("friendlyKilled", mob, EventInstanceManager.this, hasKiller);
-                } catch (ScriptException | NoSuchMethodException ex) {} //optional
-	}
-
-	public void playerKilled(final MapleCharacter chr) {
-                ThreadManager.getInstance().newTask(new Runnable() {
-                        @Override
-                        public void run() {
-                                try {
-                                        em.getIv().invokeFunction("playerDead", EventInstanceManager.this, chr);
-                                } catch (ScriptException | NoSuchMethodException ex) {} // optional
-                        }
-                });
-	}
+    }
 
-        public void reviveMonster(final MapleMonster mob) {
-                try {
-                        em.getIv().invokeFunction("monsterRevive", EventInstanceManager.this, mob);
-                } catch (ScriptException | NoSuchMethodException ex) {} // optional
-	}
-        
-	public boolean revivePlayer(final MapleCharacter chr) {
-                try {
-                        Object b = em.getIv().invokeFunction("playerRevive", EventInstanceManager.this, chr);
-                        if (b instanceof Boolean) {
-                                return (Boolean) b;
-                        }
-                } catch (ScriptException | NoSuchMethodException ex) {} // optional
-                
-		return true;
-	}
-        
-	public void playerDisconnected(final MapleCharacter chr) {
-                try {
-                        em.getIv().invokeFunction("playerDisconnected", EventInstanceManager.this, chr);
-                } catch (ScriptException | NoSuchMethodException ex) {
-                        ex.printStackTrace();
+    private void dismissEventTimer() {
+        for (MapleCharacter chr : getPlayers()) {
+            chr.getClient().announce(MaplePacketCreator.removeClock());
+        }
+
+        event_schedule = null;
+        eventTime = 0;
+        timeStarted = 0;
+    }
+
+    public void stopEventTimer() {
+        if (event_schedule != null) {
+            event_schedule.cancel(false);
+            event_schedule = null;
+        }
+
+        dismissEventTimer();
+    }
+
+    public boolean isTimerStarted() {
+        return eventTime > 0 && timeStarted > 0;
+    }
+
+    public long getTimeLeft() {
+        return eventTime - (System.currentTimeMillis() - timeStarted);
+    }
+
+    public void registerParty(MapleCharacter chr) {
+        if (chr.isPartyLeader()) {
+            registerParty(chr.getParty(), chr.getMap());
+        }
+    }
+
+    public void registerParty(MapleParty party, MapleMap map) {
+        for (MaplePartyCharacter pc : party.getEligibleMembers()) {
+            MapleCharacter c = map.getCharacterById(pc.getId());
+            registerPlayer(c);
+        }
+    }
+
+    public void registerExpedition(MapleExpedition exped) {
+        expedition = exped;
+        registerExpeditionTeam(exped, exped.getRecruitingMap().getId());
+    }
+
+    private void registerExpeditionTeam(MapleExpedition exped, int recruitMap) {
+        expedition = exped;
+
+        for (MapleCharacter chr : exped.getActiveMembers()) {
+            if (chr.getMapId() == recruitMap) {
+                registerPlayer(chr);
+            }
+        }
+    }
+
+    public void unregisterPlayer(final MapleCharacter chr) {
+        try {
+            em.getIv().invokeFunction("playerUnregistered", EventInstanceManager.this, chr);
+        } catch (ScriptException | NoSuchMethodException ex) {
+            Logger.getLogger(EventManager.class.getName()).log(Level.SEVERE, "Event '" + em.getName() + "' does not implement playerUnregistered function.", ex);
+        }
+
+        wL.lock();
+        try {
+            chars.remove(chr.getId());
+            chr.setEventInstance(null);
+        } finally {
+            wL.unlock();
+        }
+
+        gridRemove(chr);
+        dropExclusiveItems(chr);
+    }
+
+    public int getPlayerCount() {
+        rL.lock();
+        try {
+            return chars.size();
+        } finally {
+            rL.unlock();
+        }
+    }
+
+    public MapleCharacter getPlayerById(int id) {
+        rL.lock();
+        try {
+            return chars.get(id);
+        } finally {
+            rL.unlock();
+        }
+    }
+
+    public List<MapleCharacter> getPlayers() {
+        rL.lock();
+        try {
+            return new ArrayList<>(chars.values());
+        } finally {
+            rL.unlock();
+        }
+    }
+
+    private List<MapleCharacter> getPlayerList() {
+        rL.lock();
+        try {
+            return new LinkedList<>(chars.values());
+        } finally {
+            rL.unlock();
+        }
+    }
+
+    public void registerMonster(MapleMonster mob) {
+        if (!mob.getStats().isFriendly()) { //We cannot register moon bunny
+            mobs.add(mob);
+        }
+    }
+
+    public void movePlayer(final MapleCharacter chr) {
+        try {
+            em.getIv().invokeFunction("moveMap", EventInstanceManager.this, chr);
+        } catch (ScriptException | NoSuchMethodException ex) {
+            ex.printStackTrace();
+        }
+    }
+
+    public void changedMap(final MapleCharacter chr, final int mapId) {
+        try {
+            em.getIv().invokeFunction("changedMap", EventInstanceManager.this, chr, mapId);
+        } catch (ScriptException | NoSuchMethodException ex) {
+        } // optional
+    }
+
+    public void afterChangedMap(final MapleCharacter chr, final int mapId) {
+        try {
+            em.getIv().invokeFunction("afterChangedMap", EventInstanceManager.this, chr, mapId);
+        } catch (ScriptException | NoSuchMethodException ex) {
+        } // optional
+    }
+
+    public synchronized void changedLeader(final MapleCharacter ldr) {
+        try {
+            em.getIv().invokeFunction("changedLeader", EventInstanceManager.this, ldr);
+        } catch (ScriptException | NoSuchMethodException ex) {
+            ex.printStackTrace();
+        }
+
+        leaderId = ldr.getId();
+    }
+
+    public void monsterKilled(final MapleMonster mob, final boolean hasKiller) {
+        int scriptResult = 0;
+
+        sL.lock();
+        try {
+            mobs.remove(mob);
+
+            if (eventStarted) {
+                scriptResult = 1;
+
+                if (mobs.isEmpty()) {
+                    scriptResult = 2;
                 }
-                
-                MapleEventRecallCoordinator.getInstance().storeEventInstance(chr.getId(), this);
-	}
-        
-	public void monsterKilled(MapleCharacter chr, final MapleMonster mob) {
+            }
+        } finally {
+            sL.unlock();
+        }
+
+        if (scriptResult > 0) {
+            try {
+                em.getIv().invokeFunction("monsterKilled", mob, EventInstanceManager.this, hasKiller);
+            } catch (ScriptException | NoSuchMethodException ex) {
+                ex.printStackTrace();
+            }
+
+            if (scriptResult > 1) {
                 try {
-                        int inc;
-                        
-                        if (ServerConstants.JAVA_8) {
-                                inc = (int)em.getIv().invokeFunction("monsterValue", EventInstanceManager.this, mob.getId());
-                        } else {
-                                inc = ((Double) em.getIv().invokeFunction("monsterValue", EventInstanceManager.this, mob.getId())).intValue();
-                        }
-                        
-                        if (inc != 0) {
-                                Integer kc = killCount.get(chr);
-                                if (kc == null) {
-                                        kc = inc;
-                                } else {
-                                        kc += inc;
-                                }
-                                killCount.put(chr, kc);
-                                if (expedition != null){
-                                        expedition.monsterKilled(chr, mob);
-                                }
-                        }
+                    em.getIv().invokeFunction("allMonstersDead", EventInstanceManager.this, hasKiller);
                 } catch (ScriptException | NoSuchMethodException ex) {
-                        ex.printStackTrace();
+                    ex.printStackTrace();
                 }
-	}
-
-	public int getKillCount(MapleCharacter chr) {
-		Integer kc = killCount.get(chr);
-		return (kc == null) ? 0 : kc;
-	}
-        
-        public void dispose() {
-                rL.lock();
-                try {
-                        for(MapleCharacter chr: chars.values()) chr.setEventInstance(null);
-                } finally {
-                        rL.unlock();
-                }
-                
-                dispose(false);
-        }
-        
-        public synchronized void dispose(boolean shutdown) {    // should not trigger any event script method after disposed
-                if(disposed) return;
-                
-                disposed = true;
+            }
+        }
+    }
+
+    public void friendlyKilled(final MapleMonster mob, final boolean hasKiller) {
+        try {
+            em.getIv().invokeFunction("friendlyKilled", mob, EventInstanceManager.this, hasKiller);
+        } catch (ScriptException | NoSuchMethodException ex) {
+        } //optional
+    }
+
+    public void playerKilled(final MapleCharacter chr) {
+        ThreadManager.getInstance().newTask(new Runnable() {
+            @Override
+            public void run() {
                 try {
-                        em.getIv().invokeFunction("dispose", EventInstanceManager.this);
+                    em.getIv().invokeFunction("playerDead", EventInstanceManager.this, chr);
                 } catch (ScriptException | NoSuchMethodException ex) {
-                        ex.printStackTrace();
-                }
-                
-                ess.dispose();
-                
-                wL.lock();
-                try {
-                        for(MapleCharacter chr: chars.values()) chr.setEventInstance(null);
-                        chars.clear();
-                        mobs.clear();
-                        ess = null;
-                } finally {
-                        wL.unlock();
-                }
-                
-                if(event_schedule != null) {
-                        event_schedule.cancel(false);
-                        event_schedule = null;
-                }
-                
-                killCount.clear();
-                mapIds.clear();
-                props.clear();
-                
-                disposeExpedition();
-                
-                sL.lock();
-                try {
-                        if(!eventCleared) em.disposeInstance(name);
-                } finally {
-                        sL.unlock();
+                } // optional
+            }
+        });
+    }
+
+    public void reviveMonster(final MapleMonster mob) {
+        try {
+            em.getIv().invokeFunction("monsterRevive", EventInstanceManager.this, mob);
+        } catch (ScriptException | NoSuchMethodException ex) {
+        } // optional
+    }
+
+    public boolean revivePlayer(final MapleCharacter chr) {
+        try {
+            Object b = em.getIv().invokeFunction("playerRevive", EventInstanceManager.this, chr);
+            if (b instanceof Boolean) {
+                return (Boolean) b;
+            }
+        } catch (ScriptException | NoSuchMethodException ex) {
+        } // optional
+
+        return true;
+    }
+
+    public void playerDisconnected(final MapleCharacter chr) {
+        try {
+            em.getIv().invokeFunction("playerDisconnected", EventInstanceManager.this, chr);
+        } catch (ScriptException | NoSuchMethodException ex) {
+            ex.printStackTrace();
+        }
+
+        MapleEventRecallCoordinator.getInstance().storeEventInstance(chr.getId(), this);
+    }
+
+    public void monsterKilled(MapleCharacter chr, final MapleMonster mob) {
+        try {
+            int inc;
+
+            if (ServerConstants.JAVA_8) {
+                inc = (int) em.getIv().invokeFunction("monsterValue", EventInstanceManager.this, mob.getId());
+            } else {
+                inc = ((Double) em.getIv().invokeFunction("monsterValue", EventInstanceManager.this, mob.getId())).intValue();
+            }
+
+            if (inc != 0) {
+                Integer kc = killCount.get(chr);
+                if (kc == null) {
+                    kc = inc;
+                } else {
+                    kc += inc;
                 }
-                
-                TimerManager.getInstance().schedule(new Runnable() {
-                        @Override
-                        public void run() {
-                                mapFactory.dispose();   // issues from instantly disposing some event objects found thanks to MedicOP
-                                wL.lock();
-                                try {
-                                        mapFactory = null;
-                                        em = null;
-                                } finally {
-                                        wL.unlock();
-                                }
-
-                                disposeLocks();
-                        }
-                }, 60 * 1000);
-	}
-        
-        private void disposeLocks() {
-            LockCollector.getInstance().registerDisposeAction(new Runnable() {
-                @Override
-                public void run() {
-                    emptyLocks();
+                killCount.put(chr, kc);
+                if (expedition != null) {
+                    expedition.monsterKilled(chr, mob);
                 }
-            });
+            }
+        } catch (ScriptException | NoSuchMethodException ex) {
+            ex.printStackTrace();
+        }
+    }
+
+    public int getKillCount(MapleCharacter chr) {
+        Integer kc = killCount.get(chr);
+        return (kc == null) ? 0 : kc;
+    }
+
+    public void dispose() {
+        rL.lock();
+        try {
+            for (MapleCharacter chr : chars.values()) {
+                chr.setEventInstance(null);
+            }
+        } finally {
+            rL.unlock();
+        }
+
+        dispose(false);
+    }
+
+    public synchronized void dispose(boolean shutdown) {    // should not trigger any event script method after disposed
+        if (disposed) {
+            return;
+        }
+
+        disposed = true;
+        try {
+            em.getIv().invokeFunction("dispose", EventInstanceManager.this);
+        } catch (ScriptException | NoSuchMethodException ex) {
+            ex.printStackTrace();
+        }
+
+        ess.dispose();
+
+        wL.lock();
+        try {
+            for (MapleCharacter chr : chars.values()) {
+                chr.setEventInstance(null);
+            }
+            chars.clear();
+            mobs.clear();
+            ess = null;
+        } finally {
+            wL.unlock();
         }
-        
-        private void emptyLocks() {
-                pL = pL.dispose();
-                sL = sL.dispose();
+
+        if (event_schedule != null) {
+            event_schedule.cancel(false);
+            event_schedule = null;
         }
 
-	public MapleMapFactory getMapFactory() {
-		return mapFactory;
-	}
+        killCount.clear();
+        mapIds.clear();
+        props.clear();
+
+        disposeExpedition();
+
+        sL.lock();
+        try {
+            if (!eventCleared) {
+                em.disposeInstance(name);
+            }
+        } finally {
+            sL.unlock();
+        }
 
-	public void schedule(final String methodName, long delay) {
-                rL.lock();
+        TimerManager.getInstance().schedule(new Runnable() {
+            @Override
+            public void run() {
+                mapFactory.dispose();   // issues from instantly disposing some event objects found thanks to MedicOP
+                wL.lock();
                 try {
-                        if (ess != null) {
-                                Runnable r = new Runnable() {
-                                        @Override
-                                        public void run() {
-                                                try {
-                                                        em.getIv().invokeFunction(methodName, EventInstanceManager.this);
-                                                } catch (ScriptException | NoSuchMethodException ex) {
-                                                        ex.printStackTrace();
-                                                }
-                                        }
-                                };
-
-                                ess.registerEntry(r, delay);
-                        }
+                    mapFactory = null;
+                    em = null;
                 } finally {
-                        rL.unlock();
+                    wL.unlock();
                 }
-	}
 
-	public String getName() {
-		return name;
-	}
+                disposeLocks();
+            }
+        }, 60 * 1000);
+    }
+
+    private void disposeLocks() {
+        LockCollector.getInstance().registerDisposeAction(new Runnable() {
+            @Override
+            public void run() {
+                emptyLocks();
+            }
+        });
+    }
+
+    private void emptyLocks() {
+        pL = pL.dispose();
+        sL = sL.dispose();
+    }
 
-	public MapleMap getMapInstance(int mapId) {
-		MapleMap map = mapFactory.getMap(mapId);
-                map.setEventInstance(this);
+    public MapleMapFactory getMapFactory() {
+        return mapFactory;
+    }
 
-		if (!mapFactory.isMapLoaded(mapId)) {
-                        sL.lock();
+    public void schedule(final String methodName, long delay) {
+        rL.lock();
+        try {
+            if (ess != null) {
+                Runnable r = new Runnable() {
+                    @Override
+                    public void run() {
                         try {
-                                if (em.getProperty("shuffleReactors") != null && em.getProperty("shuffleReactors").equals("true")) {
-                                        map.shuffleReactors();
-                                }
-                        } finally {
-                                sL.unlock();
+                            em.getIv().invokeFunction(methodName, EventInstanceManager.this);
+                        } catch (ScriptException | NoSuchMethodException ex) {
+                            ex.printStackTrace();
                         }
-		}
-		return map;
-	}
+                    }
+                };
 
-        public void setIntProperty(String key, Integer value) {
-                setProperty(key, value);
+                ess.registerEntry(r, delay);
+            }
+        } finally {
+            rL.unlock();
         }
-        
-        public void setProperty(String key, Integer value) {
-                setProperty(key, "" + value);
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public MapleMap getMapInstance(int mapId) {
+        MapleMap map = mapFactory.getMap(mapId);
+        map.setEventInstance(this);
+
+        if (!mapFactory.isMapLoaded(mapId)) {
+            sL.lock();
+            try {
+                if (em.getProperty("shuffleReactors") != null && em.getProperty("shuffleReactors").equals("true")) {
+                    map.shuffleReactors();
+                }
+            } finally {
+                sL.unlock();
+            }
         }
-        
-	public void setProperty(String key, String value) {
-                pL.lock();
-                try {
-                        props.setProperty(key, value);
-                } finally {
-                        pL.unlock();
-                }
-	}
+        return map;
+    }
 
-	public Object setProperty(String key, String value, boolean prev) {
-                pL.lock();
-                try {
-                        return props.setProperty(key, value);
-                } finally {
-                        pL.unlock();
-                }
-	}
+    public void setIntProperty(String key, Integer value) {
+        setProperty(key, value);
+    }
 
-	public String getProperty(String key) {
-                pL.lock();
-                try {
-                        return props.getProperty(key);
-                } finally {
-                        pL.unlock();
-                }
-	}
+    public void setProperty(String key, Integer value) {
+        setProperty(key, "" + value);
+    }
 
-        public int getIntProperty(String key) {
-                pL.lock();
-                try {
-                        return Integer.parseInt(props.getProperty(key));
-                } finally {
-                        pL.unlock();
-                }
+    public void setProperty(String key, String value) {
+        pL.lock();
+        try {
+            props.setProperty(key, value);
+        } finally {
+            pL.unlock();
+        }
+    }
+
+    public Object setProperty(String key, String value, boolean prev) {
+        pL.lock();
+        try {
+            return props.setProperty(key, value);
+        } finally {
+            pL.unlock();
+        }
+    }
+
+    public String getProperty(String key) {
+        pL.lock();
+        try {
+            return props.getProperty(key);
+        } finally {
+            pL.unlock();
+        }
+    }
+
+    public int getIntProperty(String key) {
+        pL.lock();
+        try {
+            return Integer.parseInt(props.getProperty(key));
+        } finally {
+            pL.unlock();
+        }
+    }
+
+    public void leftParty(final MapleCharacter chr) {
+        try {
+            em.getIv().invokeFunction("leftParty", EventInstanceManager.this, chr);
+        } catch (ScriptException | NoSuchMethodException ex) {
+            ex.printStackTrace();
         }
-	
-	public void leftParty(final MapleCharacter chr) {
-                try {
-                        em.getIv().invokeFunction("leftParty", EventInstanceManager.this, chr);
-                } catch (ScriptException | NoSuchMethodException ex) {
-                        ex.printStackTrace();
-                }
-	}
+    }
 
-	public void disbandParty() {
-		try {
-                        em.getIv().invokeFunction("disbandParty", EventInstanceManager.this);
-                } catch (ScriptException | NoSuchMethodException ex) {
-                        ex.printStackTrace();
-                }
-	}
+    public void disbandParty() {
+        try {
+            em.getIv().invokeFunction("disbandParty", EventInstanceManager.this);
+        } catch (ScriptException | NoSuchMethodException ex) {
+            ex.printStackTrace();
+        }
+    }
 
-	public void clearPQ() {
-                try {
-                        em.getIv().invokeFunction("clearPQ", EventInstanceManager.this);
-                } catch (ScriptException | NoSuchMethodException ex) {
-                        ex.printStackTrace();
-                }
-	}
+    public void clearPQ() {
+        try {
+            em.getIv().invokeFunction("clearPQ", EventInstanceManager.this);
+        } catch (ScriptException | NoSuchMethodException ex) {
+            ex.printStackTrace();
+        }
+    }
 
-	public void removePlayer(final MapleCharacter chr) {
-                try {
-                        em.getIv().invokeFunction("playerExit", EventInstanceManager.this, chr);
-                } catch (ScriptException | NoSuchMethodException ex) {
-                        ex.printStackTrace();
-                }
-	}
-
-	public boolean isLeader(MapleCharacter chr) {
-		return (chr.getParty().getLeaderId() == chr.getId());
-	}
-        
-        public boolean isEventLeader(MapleCharacter chr) {
-		return (chr.getId() == getLeaderId());
-	}
-        
-        public final MapleMap getInstanceMap(final int mapid) {
-                if (disposed) {
-                        return null;
-                }
-                mapIds.add(mapid);
-                return getMapFactory().getMap(mapid);
+    public void removePlayer(final MapleCharacter chr) {
+        try {
+            em.getIv().invokeFunction("playerExit", EventInstanceManager.this, chr);
+        } catch (ScriptException | NoSuchMethodException ex) {
+            ex.printStackTrace();
         }
-        
-        public final boolean disposeIfPlayerBelow(final byte size, final int towarp) {
-                if (disposed) {
-                        return true;
-                }
-                if(chars == null) {
-                        return false;
-                }
-                
-                MapleMap map = null;
-                if (towarp > 0) {
-                        map = this.getMapFactory().getMap(towarp);
-                }
-                
-                List<MapleCharacter> players = getPlayerList();
+    }
 
-                try {
-                        if (players.size() < size) {
-                                for (MapleCharacter chr : players) {
-                                        if (chr == null) {
-                                                continue;
-                                        }
-
-                                        unregisterPlayer(chr);
-                                        if (towarp > 0) {
-                                                chr.changeMap(map, map.getPortal(0));
-                                        }
-                                }
-
-                                dispose();
-                                return true;
-                        }
-                } catch (Exception ex) {
-                        ex.printStackTrace();
-                }
-                
-                return false;
+    public boolean isLeader(MapleCharacter chr) {
+        return (chr.getParty().getLeaderId() == chr.getId());
+    }
+
+    public boolean isEventLeader(MapleCharacter chr) {
+        return (chr.getId() == getLeaderId());
+    }
+
+    public final MapleMap getInstanceMap(final int mapid) {
+        if (disposed) {
+            return null;
         }
-        
-        public void spawnNpc(int npcId, Point pos, MapleMap map) {
-                MapleNPC npc = MapleLifeFactory.getNPC(npcId);
-                if (npc != null) {
-                        npc.setPosition(pos);
-                        npc.setCy(pos.y);
-                        npc.setRx0(pos.x + 50);
-                        npc.setRx1(pos.x - 50);
-                        npc.setFh(map.getFootholds().findBelow(pos).getId());
-                        map.addMapObject(npc);
-                        map.broadcastMessage(MaplePacketCreator.spawnNPC(npc));
-                }
+        mapIds.add(mapid);
+        return getMapFactory().getMap(mapid);
+    }
+
+    public final boolean disposeIfPlayerBelow(final byte size, final int towarp) {
+        if (disposed) {
+            return true;
+        }
+        if (chars == null) {
+            return false;
+        }
+
+        MapleMap map = null;
+        if (towarp > 0) {
+            map = this.getMapFactory().getMap(towarp);
         }
-        
-        public void dispatchUpdateQuestMobCount(int mobid, int mapid) {
-            Map<Integer, MapleCharacter> mapChars = getInstanceMap(mapid).getMapPlayers();
-            if(!mapChars.isEmpty()) {
-                List<MapleCharacter> eventMembers = getPlayers();
-                
-                for (MapleCharacter evChr : eventMembers) {
-                    MapleCharacter chr = mapChars.get(evChr.getId());
-
-                    if(chr != null && chr.isLoggedinWorld()) {
-                        chr.updateQuestMobCount(mobid);
+
+        List<MapleCharacter> players = getPlayerList();
+
+        try {
+            if (players.size() < size) {
+                for (MapleCharacter chr : players) {
+                    if (chr == null) {
+                        continue;
+                    }
+
+                    unregisterPlayer(chr);
+                    if (towarp > 0) {
+                        chr.changeMap(map, map.getPortal(0));
                     }
                 }
+
+                dispose();
+                return true;
             }
+        } catch (Exception ex) {
+            ex.printStackTrace();
         }
-        
-        public MapleMonster getMonster(int mid) {
-                return(MapleLifeFactory.getMonster(mid));
-        }
-        
-        private List<Integer> convertToIntegerArray(List<Double> list) {
-            List<Integer> intList;
-            if(ServerConstants.JAVA_8)
-                 intList=new ArrayList<Integer> (new ArrayList(java.util.Arrays.asList(list.toArray())));
-            else
-            {
-                 intList = new ArrayList<>();
-                for(Double d: list) intList.add(d.intValue());
-            }
-                return intList;
-        }
-        
-        public void setEventClearStageExp(List<Double> gain) {
-                onMapClearExp.clear();
-                onMapClearExp.addAll(convertToIntegerArray(gain));
-        }
-        
-        public void setEventClearStageMeso(List<Double> gain) {
-                onMapClearMeso.clear();
-                onMapClearMeso.addAll(convertToIntegerArray(gain));
-        }
-        
-        public Integer getClearStageExp(int stage) {    //stage counts from ONE.
-                if(stage > onMapClearExp.size()) return 0;
-                return onMapClearExp.get(stage - 1);
-        }
-        
-        public Integer getClearStageMeso(int stage) {   //stage counts from ONE.
-                if(stage > onMapClearMeso.size()) return 0;
-                return onMapClearMeso.get(stage - 1);
-        }
-        
-        public List<Integer> getClearStageBonus(int stage) {
-                List<Integer> list = new ArrayList<>();
-                list.add(getClearStageExp(stage));
-                list.add(getClearStageMeso(stage));
-                
-                return list;
-        }
-        
-        private void dropExclusiveItems(MapleCharacter chr) {
-                AbstractPlayerInteraction api = chr.getClient().getAbstractPlayerInteraction();
-                
-                for(Integer item: exclusiveItems) {
-                        api.removeAll(item);
+
+        return false;
+    }
+
+    public void spawnNpc(int npcId, Point pos, MapleMap map) {
+        MapleNPC npc = MapleLifeFactory.getNPC(npcId);
+        if (npc != null) {
+            npc.setPosition(pos);
+            npc.setCy(pos.y);
+            npc.setRx0(pos.x + 50);
+            npc.setRx1(pos.x - 50);
+            npc.setFh(map.getFootholds().findBelow(pos).getId());
+            map.addMapObject(npc);
+            map.broadcastMessage(MaplePacketCreator.spawnNPC(npc));
+        }
+    }
+
+    public void dispatchUpdateQuestMobCount(int mobid, int mapid) {
+        Map<Integer, MapleCharacter> mapChars = getInstanceMap(mapid).getMapPlayers();
+        if (!mapChars.isEmpty()) {
+            List<MapleCharacter> eventMembers = getPlayers();
+
+            for (MapleCharacter evChr : eventMembers) {
+                MapleCharacter chr = mapChars.get(evChr.getId());
+
+                if (chr != null && chr.isLoggedinWorld()) {
+                    chr.updateQuestMobCount(mobid);
                 }
+            }
         }
-        
-        public final void setExclusiveItems(List<Double> items) {
-                List<Integer> exclusive = convertToIntegerArray(items);
-                
-                wL.lock();
-                try {
-                        for(Integer item: exclusive) {
-                                exclusiveItems.add(item);
-                        }
-                } finally {
-                        wL.unlock();
-                }
+    }
+
+    public MapleMonster getMonster(int mid) {
+        return (MapleLifeFactory.getMonster(mid));
+    }
+
+    private List<Integer> convertToIntegerArray(List<Double> list) {
+        List<Integer> intList;
+        if (ServerConstants.JAVA_8) {
+            intList = new ArrayList<Integer>(new ArrayList(java.util.Arrays.asList(list.toArray())));
+        } else {
+            intList = new ArrayList<>();
+            for (Double d : list) {
+                intList.add(d.intValue());
+            }
         }
-        
-        public final void setEventRewards(List<Double> rwds, List<Double> qtys, int expGiven) {
-                setEventRewards(1, rwds, qtys, expGiven);
+        return intList;
+    }
+
+    public void setEventClearStageExp(List<Double> gain) {
+        onMapClearExp.clear();
+        onMapClearExp.addAll(convertToIntegerArray(gain));
+    }
+
+    public void setEventClearStageMeso(List<Double> gain) {
+        onMapClearMeso.clear();
+        onMapClearMeso.addAll(convertToIntegerArray(gain));
+    }
+
+    public Integer getClearStageExp(int stage) {    //stage counts from ONE.
+        if (stage > onMapClearExp.size()) {
+            return 0;
+        }
+        return onMapClearExp.get(stage - 1);
+    }
+
+    public Integer getClearStageMeso(int stage) {   //stage counts from ONE.
+        if (stage > onMapClearMeso.size()) {
+            return 0;
         }
-        
-        public final void setEventRewards(List<Double> rwds, List<Double> qtys) {
-                setEventRewards(1, rwds, qtys);
+        return onMapClearMeso.get(stage - 1);
+    }
+
+    public List<Integer> getClearStageBonus(int stage) {
+        List<Integer> list = new ArrayList<>();
+        list.add(getClearStageExp(stage));
+        list.add(getClearStageMeso(stage));
+
+        return list;
+    }
+
+    private void dropExclusiveItems(MapleCharacter chr) {
+        AbstractPlayerInteraction api = chr.getClient().getAbstractPlayerInteraction();
+
+        for (Integer item : exclusiveItems) {
+            api.removeAll(item);
         }
-        
-        public final void setEventRewards(int eventLevel, List<Double> rwds, List<Double> qtys) {
-                setEventRewards(eventLevel, rwds, qtys, 0);
+    }
+
+    public final void setExclusiveItems(List<Double> items) {
+        List<Integer> exclusive = convertToIntegerArray(items);
+
+        wL.lock();
+        try {
+            for (Integer item : exclusive) {
+                exclusiveItems.add(item);
+            }
+        } finally {
+            wL.unlock();
         }
-        
-        public final void setEventRewards(int eventLevel, List<Double> rwds, List<Double> qtys, int expGiven) {
-                // fixed EXP will be rewarded at the same time the random item is given
+    }
 
-                if(eventLevel <= 0 || eventLevel > ServerConstants.MAX_EVENT_LEVELS) return;
-                eventLevel--;    //event level starts from 1
+    public final void setEventRewards(List<Double> rwds, List<Double> qtys, int expGiven) {
+        setEventRewards(1, rwds, qtys, expGiven);
+    }
 
-                List<Integer> rewardIds = convertToIntegerArray(rwds);
-                List<Integer> rewardQtys = convertToIntegerArray(qtys);
+    public final void setEventRewards(List<Double> rwds, List<Double> qtys) {
+        setEventRewards(1, rwds, qtys);
+    }
 
-                //rewardsSet and rewardsQty hold temporary values
-                wL.lock();
-                try {
-                        collectionSet.put(eventLevel, rewardIds);
-                        collectionQty.put(eventLevel, rewardQtys);
-                        collectionExp.put(eventLevel, expGiven);
-                } finally {
-                        wL.unlock();
-                }
+    public final void setEventRewards(int eventLevel, List<Double> rwds, List<Double> qtys) {
+        setEventRewards(eventLevel, rwds, qtys, 0);
+    }
+
+    public final void setEventRewards(int eventLevel, List<Double> rwds, List<Double> qtys, int expGiven) {
+        // fixed EXP will be rewarded at the same time the random item is given
+
+        if (eventLevel <= 0 || eventLevel > ServerConstants.MAX_EVENT_LEVELS) {
+            return;
         }
-        
-        private byte getRewardListRequirements(int level) {
-                if(level >= collectionSet.size()) return 0;
+        eventLevel--;    //event level starts from 1
 
-                byte rewardTypes = 0;
-                List<Integer> list = collectionSet.get(level);
+        List<Integer> rewardIds = convertToIntegerArray(rwds);
+        List<Integer> rewardQtys = convertToIntegerArray(qtys);
 
-                for (Integer itemId : list) {
-                        rewardTypes |= (1 << ItemConstants.getInventoryType(itemId).getType());
-                }
+        //rewardsSet and rewardsQty hold temporary values
+        wL.lock();
+        try {
+            collectionSet.put(eventLevel, rewardIds);
+            collectionQty.put(eventLevel, rewardQtys);
+            collectionExp.put(eventLevel, expGiven);
+        } finally {
+            wL.unlock();
+        }
+    }
 
-                return rewardTypes;
+    private byte getRewardListRequirements(int level) {
+        if (level >= collectionSet.size()) {
+            return 0;
         }
-        
-        private boolean hasRewardSlot(MapleCharacter player, int eventLevel) {
-                byte listReq = getRewardListRequirements(eventLevel);   //gets all types of items present in the event reward list
 
-                //iterating over all valid inventory types
-                for(byte type = 1; type <= 5; type++) {
-                        if((listReq >> type) % 2 == 1 && !player.hasEmptySlot(type))
-                                return false;
-                }
+        byte rewardTypes = 0;
+        List<Integer> list = collectionSet.get(level);
 
-                return true;
+        for (Integer itemId : list) {
+            rewardTypes |= (1 << ItemConstants.getInventoryType(itemId).getType());
         }
-        
-        public final boolean giveEventReward(MapleCharacter player) {
-                return giveEventReward(player, 1);
-        }
-        
-        //gives out EXP & a random item in a similar fashion of when clearing KPQ, LPQ, etc.
-        public final boolean giveEventReward(MapleCharacter player, int eventLevel) {
-                List<Integer> rewardsSet, rewardsQty;
-                Integer rewardExp;
-            
-                rL.lock();
-                try {
-                        eventLevel--;       //event level starts counting from 1
-                        if(eventLevel >= collectionSet.size()) return true;
 
-                        rewardsSet = collectionSet.get(eventLevel);
-                        rewardsQty = collectionQty.get(eventLevel);
+        return rewardTypes;
+    }
 
-                        rewardExp = collectionExp.get(eventLevel);
-                } finally {
-                        rL.unlock();
-                }
-                        
-                if(rewardExp == null) rewardExp = 0;
+    private boolean hasRewardSlot(MapleCharacter player, int eventLevel) {
+        byte listReq = getRewardListRequirements(eventLevel);   //gets all types of items present in the event reward list
 
-                if(rewardsSet == null || rewardsSet.isEmpty()) {
-                        if(rewardExp > 0) player.gainExp(rewardExp);
-                        return true;
-                }
+        //iterating over all valid inventory types
+        for (byte type = 1; type <= 5; type++) {
+            if ((listReq >> type) % 2 == 1 && !player.hasEmptySlot(type)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
 
-                if(!hasRewardSlot(player, eventLevel)) return false;
+    public final boolean giveEventReward(MapleCharacter player) {
+        return giveEventReward(player, 1);
+    }
 
-                AbstractPlayerInteraction api = player.getClient().getAbstractPlayerInteraction();
-                int rnd = (int)Math.floor(Math.random() * rewardsSet.size());
+    //gives out EXP & a random item in a similar fashion of when clearing KPQ, LPQ, etc.
+    public final boolean giveEventReward(MapleCharacter player, int eventLevel) {
+        List<Integer> rewardsSet, rewardsQty;
+        Integer rewardExp;
 
-                api.gainItem(rewardsSet.get(rnd), rewardsQty.get(rnd).shortValue());
-                if(rewardExp > 0) player.gainExp(rewardExp);
+        rL.lock();
+        try {
+            eventLevel--;       //event level starts counting from 1
+            if (eventLevel >= collectionSet.size()) {
                 return true;
+            }
+
+            rewardsSet = collectionSet.get(eventLevel);
+            rewardsQty = collectionQty.get(eventLevel);
+
+            rewardExp = collectionExp.get(eventLevel);
+        } finally {
+            rL.unlock();
         }
-        
-        private void disposeExpedition() {
-                if (expedition != null) {
-                        expedition.dispose(eventCleared);
-                        
-                        sL.lock();
-                        try {
-                                em.getChannelServer().getExpeditions().remove(expedition);
-                        } finally {
-                                sL.unlock();
-                        }
-                        
-                        expedition = null;
-                }
+
+        if (rewardExp == null) {
+            rewardExp = 0;
         }
-        
-        public final synchronized void startEvent() {
-                eventStarted = true;
-                
-                try {
-                        em.getIv().invokeFunction("afterSetup", EventInstanceManager.this);
-                } catch (ScriptException | NoSuchMethodException ex) {
-                        ex.printStackTrace();
-                }
+
+        if (rewardsSet == null || rewardsSet.isEmpty()) {
+            if (rewardExp > 0) {
+                player.gainExp(rewardExp);
+            }
+            return true;
         }
-        
-        public final void setEventCleared() {
-                eventCleared = true;
-                
-                for (MapleCharacter chr : getPlayers()) {
-                        chr.awardQuestPoint(ServerConstants.QUEST_POINT_PER_EVENT_CLEAR);
-                }
-                
-                sL.lock();
-                try {
-                        em.disposeInstance(name);
-                } finally {
-                        sL.unlock();
-                }
-                
-                disposeExpedition();
+
+        if (!hasRewardSlot(player, eventLevel)) {
+            return false;
         }
-        
-        public final boolean isEventCleared() {
-                return eventCleared;
+
+        AbstractPlayerInteraction api = player.getClient().getAbstractPlayerInteraction();
+        int rnd = (int) Math.floor(Math.random() * rewardsSet.size());
+
+        api.gainItem(rewardsSet.get(rnd), rewardsQty.get(rnd).shortValue());
+        if (rewardExp > 0) {
+            player.gainExp(rewardExp);
         }
-        
-        public final boolean isEventDisposed() {
-                return disposed;
+        return true;
+    }
+
+    private void disposeExpedition() {
+        if (expedition != null) {
+            expedition.dispose(eventCleared);
+
+            sL.lock();
+            try {
+                em.getChannelServer().getExpeditions().remove(expedition);
+            } finally {
+                sL.unlock();
+            }
+
+            expedition = null;
         }
-        
-        private boolean isEventTeamLeaderOn() {
-                for(MapleCharacter chr: getPlayers()) {
-                        if(chr.getId() == getLeaderId()) return true;
-                }
-                
-                return false;
+    }
+
+    public final synchronized void startEvent() {
+        eventStarted = true;
+
+        try {
+            em.getIv().invokeFunction("afterSetup", EventInstanceManager.this);
+        } catch (ScriptException | NoSuchMethodException ex) {
+            ex.printStackTrace();
         }
-        
-        public final boolean checkEventTeamLacking(boolean leavingEventMap, int minPlayers) {
-                if(eventCleared && getPlayerCount() > 1) return false;
-                
-                if(!eventCleared && leavingEventMap && !isEventTeamLeaderOn()) return true;
-                if(getPlayerCount() < minPlayers) return true;
-                
-                return false;
+    }
+
+    public final void setEventCleared() {
+        eventCleared = true;
+
+        for (MapleCharacter chr : getPlayers()) {
+            chr.awardQuestPoint(ServerConstants.QUEST_POINT_PER_EVENT_CLEAR);
         }
-        
-        public final boolean isExpeditionTeamLackingNow(boolean leavingEventMap, int minPlayers, MapleCharacter quitter) {
-                if(eventCleared) {
-                        if(leavingEventMap && getPlayerCount() <= 1) return true;
-                } else {
-                        if(leavingEventMap && getLeaderId() == quitter.getId()) return true;
-                        if(getPlayerCount() <= (ServerConstants.USE_ENABLE_SOLO_EXPEDITIONS ? 1 : minPlayers)) return true;
-                }
-                
-                return false;
+
+        sL.lock();
+        try {
+            em.disposeInstance(name);
+        } finally {
+            sL.unlock();
         }
-        
-        public final boolean isEventTeamLackingNow(boolean leavingEventMap, int minPlayers, MapleCharacter quitter) {
-                if(eventCleared) {
-                        if(leavingEventMap && getPlayerCount() <= 1) return true;
-                } else {
-                        if(leavingEventMap && getLeaderId() == quitter.getId()) return true;
-                        if(getPlayerCount() <= minPlayers) return true;
-                }
-                
-                return false;
+
+        disposeExpedition();
+    }
+
+    public final boolean isEventCleared() {
+        return eventCleared;
+    }
+
+    public final boolean isEventDisposed() {
+        return disposed;
+    }
+
+    private boolean isEventTeamLeaderOn() {
+        for (MapleCharacter chr : getPlayers()) {
+            if (chr.getId() == getLeaderId()) {
+                return true;
+            }
         }
-        
-        public final boolean isEventTeamTogether() {
-                rL.lock();
-                try {
-                        if(chars.size() <= 1) return true;
-                        
-                        Iterator<MapleCharacter> iterator = chars.values().iterator();
-                        MapleCharacter mc = iterator.next();
-                        int mapId = mc.getMapId();
-                        
-                        for (; iterator.hasNext();) {
-                                mc = iterator.next();
-                                if(mc.getMapId() != mapId) return false;
-                        }
-                        
-                        return true;
-                } finally {
-                        rL.unlock();
-                }
+
+        return false;
+    }
+
+    public final boolean checkEventTeamLacking(boolean leavingEventMap, int minPlayers) {
+        if (eventCleared && getPlayerCount() > 1) {
+            return false;
         }
-        
-        public final void warpEventTeam(int warpFrom, int warpTo) {
-                List<MapleCharacter> players = getPlayerList();
-                
-                for (MapleCharacter chr : players) {
-                        if(chr.getMapId() == warpFrom)
-                                chr.changeMap(warpTo);
-                }
+
+        if (!eventCleared && leavingEventMap && !isEventTeamLeaderOn()) {
+            return true;
         }
-        
-        public final void warpEventTeam(int warpTo) {
-                List<MapleCharacter> players = getPlayerList();
-                
-                for (MapleCharacter chr : players) {
-                        chr.changeMap(warpTo);
-                }
+        if (getPlayerCount() < minPlayers) {
+            return true;
         }
-        
-        public final void warpEventTeamToMapSpawnPoint(int warpFrom, int warpTo, int toSp) {
-                List<MapleCharacter> players = getPlayerList();
-                
-                for (MapleCharacter chr : players) {
-                        if(chr.getMapId() == warpFrom)
-                                chr.changeMap(warpTo, toSp);
-                }
+
+        return false;
+    }
+
+    public final boolean isExpeditionTeamLackingNow(boolean leavingEventMap, int minPlayers, MapleCharacter quitter) {
+        if (eventCleared) {
+            if (leavingEventMap && getPlayerCount() <= 1) {
+                return true;
+            }
+        } else {
+            if (leavingEventMap && getLeaderId() == quitter.getId()) {
+                return true;
+            }
+            if (getPlayerCount() <= (ServerConstants.USE_ENABLE_SOLO_EXPEDITIONS ? 1 : minPlayers)) {
+                return true;
+            }
         }
-        
-        public final void warpEventTeamToMapSpawnPoint(int warpTo, int toSp) {
-                List<MapleCharacter> players = getPlayerList();
-                
-                for (MapleCharacter chr : players) {
-                        chr.changeMap(warpTo, toSp);
-                }
+
+        return false;
+    }
+
+    public final boolean isEventTeamLackingNow(boolean leavingEventMap, int minPlayers, MapleCharacter quitter) {
+        if (eventCleared) {
+            if (leavingEventMap && getPlayerCount() <= 1) {
+                return true;
+            }
+        } else {
+            if (leavingEventMap && getLeaderId() == quitter.getId()) {
+                return true;
+            }
+            if (getPlayerCount() <= minPlayers) {
+                return true;
+            }
         }
-        
-        public final int getLeaderId() {
-                rL.lock();
-                try {
-                        return leaderId;
-                } finally {
-                        rL.unlock();
+
+        return false;
+    }
+
+    public final boolean isEventTeamTogether() {
+        rL.lock();
+        try {
+            if (chars.size() <= 1) {
+                return true;
+            }
+
+            Iterator<MapleCharacter> iterator = chars.values().iterator();
+            MapleCharacter mc = iterator.next();
+            int mapId = mc.getMapId();
+
+            for (; iterator.hasNext();) {
+                mc = iterator.next();
+                if (mc.getMapId() != mapId) {
+                    return false;
                 }
+            }
+
+            return true;
+        } finally {
+            rL.unlock();
         }
-        
-        public MapleCharacter getLeader() {
-                rL.lock();
-                try {
-                        return chars.get(leaderId);
-                } finally {
-                        rL.unlock();
-                }
+    }
+
+    public final void warpEventTeam(int warpFrom, int warpTo) {
+        List<MapleCharacter> players = getPlayerList();
+
+        for (MapleCharacter chr : players) {
+            if (chr.getMapId() == warpFrom) {
+                chr.changeMap(warpTo);
+            }
         }
-        
-        public final void setLeader(MapleCharacter chr) {
-                wL.lock();
-                try {
-                        leaderId = chr.getId();
-                } finally {
-                        wL.unlock();
-                }
+    }
+
+    public final void warpEventTeam(int warpTo) {
+        List<MapleCharacter> players = getPlayerList();
+
+        for (MapleCharacter chr : players) {
+            chr.changeMap(warpTo);
         }
-        
-        public final void showWrongEffect() {
-                showWrongEffect(getLeader().getMapId());
-        }
-        
-        public final void showWrongEffect(int mapId) {
-                MapleMap map = getMapInstance(mapId);
-                map.broadcastMessage(MaplePacketCreator.showEffect("quest/party/wrong_kor"));
-                map.broadcastMessage(MaplePacketCreator.playSound("Party1/Failed"));
-        }
-        
-        public final void showClearEffect() {
-                showClearEffect(false);
-        }
-        
-        public final void showClearEffect(boolean hasGate) {
-                MapleCharacter leader = getLeader();
-                if(leader != null) showClearEffect(hasGate, leader.getMapId());
-        }
-        
-        public final void showClearEffect(int mapId) {
-                showClearEffect(false, mapId);
-        }
-        
-        public final void showClearEffect(boolean hasGate, int mapId) {
-                showClearEffect(hasGate, mapId, "gate", 2);
-        }
-        
-        public final void showClearEffect(int mapId, String mapObj, int newState) {
-                showClearEffect(true, mapId, mapObj, newState);
-        }
-        
-        public final void showClearEffect(boolean hasGate, int mapId, String mapObj, int newState) {
-                MapleMap map = getMapInstance(mapId);
-                map.broadcastMessage(MaplePacketCreator.showEffect("quest/party/clear"));
-                map.broadcastMessage(MaplePacketCreator.playSound("Party1/Clear"));
-                if(hasGate) {
-                        map.broadcastMessage(MaplePacketCreator.environmentChange(mapObj, newState));
-                        wL.lock();
-                        try {
-                                openedGates.put(map.getId(), new Pair<>(mapObj, newState));
-                        } finally {
-                                wL.unlock();
-                        }
-                }
+    }
+
+    public final void warpEventTeamToMapSpawnPoint(int warpFrom, int warpTo, int toSp) {
+        List<MapleCharacter> players = getPlayerList();
+
+        for (MapleCharacter chr : players) {
+            if (chr.getMapId() == warpFrom) {
+                chr.changeMap(warpTo, toSp);
+            }
         }
-        
-        public final void recoverOpenedGate(MapleCharacter chr, int thisMapId) {
-                Pair<String, Integer> gateData = null;
-            
-                rL.lock();
-                try {
-                        if(openedGates.containsKey(thisMapId)) {
-                                gateData = openedGates.get(thisMapId);
-                        }
-                } finally {
-                        rL.unlock();
-                }
-                
-                if(gateData != null) {
-                        chr.announce(MaplePacketCreator.environmentChange(gateData.getLeft(), gateData.getRight()));
-                }
+    }
+
+    public final void warpEventTeamToMapSpawnPoint(int warpTo, int toSp) {
+        List<MapleCharacter> players = getPlayerList();
+
+        for (MapleCharacter chr : players) {
+            chr.changeMap(warpTo, toSp);
         }
-        
-        public final void giveEventPlayersStageReward(int thisStage) {
-                List<Integer> list = getClearStageBonus(thisStage);     // will give bonus exp & mesos to everyone in the event
-                giveEventPlayersExp(list.get(0));
-                giveEventPlayersMeso(list.get(1));
-        }
-        
-        public final void linkToNextStage(int thisStage, String eventFamily, int thisMapId) {
-                giveEventPlayersStageReward(thisStage);
-                thisStage--;    //stages counts from ONE, scripts from ZERO
-            
-                MapleMap nextStage = getMapInstance(thisMapId);
-                MaplePortal portal = nextStage.getPortal("next00");
-                if (portal != null) {
-                        portal.setScriptName(eventFamily + thisStage);
-                }
+    }
+
+    public final int getLeaderId() {
+        rL.lock();
+        try {
+            return leaderId;
+        } finally {
+            rL.unlock();
+        }
+    }
+
+    public MapleCharacter getLeader() {
+        rL.lock();
+        try {
+            return chars.get(leaderId);
+        } finally {
+            rL.unlock();
+        }
+    }
+
+    public final void setLeader(MapleCharacter chr) {
+        wL.lock();
+        try {
+            leaderId = chr.getId();
+        } finally {
+            wL.unlock();
+        }
+    }
+
+    public final void showWrongEffect() {
+        showWrongEffect(getLeader().getMapId());
+    }
+
+    public final void showWrongEffect(int mapId) {
+        MapleMap map = getMapInstance(mapId);
+        map.broadcastMessage(MaplePacketCreator.showEffect("quest/party/wrong_kor"));
+        map.broadcastMessage(MaplePacketCreator.playSound("Party1/Failed"));
+    }
+
+    public final void showClearEffect() {
+        showClearEffect(false);
+    }
+
+    public final void showClearEffect(boolean hasGate) {
+        MapleCharacter leader = getLeader();
+        if (leader != null) {
+            showClearEffect(hasGate, leader.getMapId());
         }
-        
-        public final void linkPortalToScript(int thisStage, String portalName, String scriptName, int thisMapId) {
-                giveEventPlayersStageReward(thisStage);
-                thisStage--;    //stages counts from ONE, scripts from ZERO
-            
-                MapleMap nextStage = getMapInstance(thisMapId);
-                MaplePortal portal = nextStage.getPortal(portalName);
-                if (portal != null) {
-                        portal.setScriptName(scriptName);
-                }
+    }
+
+    public final void showClearEffect(int mapId) {
+        showClearEffect(false, mapId);
+    }
+
+    public final void showClearEffect(boolean hasGate, int mapId) {
+        showClearEffect(hasGate, mapId, "gate", 2);
+    }
+
+    public final void showClearEffect(int mapId, String mapObj, int newState) {
+        showClearEffect(true, mapId, mapObj, newState);
+    }
+
+    public final void showClearEffect(boolean hasGate, int mapId, String mapObj, int newState) {
+        MapleMap map = getMapInstance(mapId);
+        map.broadcastMessage(MaplePacketCreator.showEffect("quest/party/clear"));
+        map.broadcastMessage(MaplePacketCreator.playSound("Party1/Clear"));
+        if (hasGate) {
+            map.broadcastMessage(MaplePacketCreator.environmentChange(mapObj, newState));
+            wL.lock();
+            try {
+                openedGates.put(map.getId(), new Pair<>(mapObj, newState));
+            } finally {
+                wL.unlock();
+            }
         }
-        
-        // registers a player status in an event
-        public final void gridInsert(MapleCharacter chr, int newStatus) {
-                wL.lock();
-                try {
-                        playerGrid.put(chr.getId(), newStatus);
-                } finally {
-                        wL.unlock();
-                }
+    }
+
+    public final void recoverOpenedGate(MapleCharacter chr, int thisMapId) {
+        Pair<String, Integer> gateData = null;
+
+        rL.lock();
+        try {
+            if (openedGates.containsKey(thisMapId)) {
+                gateData = openedGates.get(thisMapId);
+            }
+        } finally {
+            rL.unlock();
         }
-        
-        // unregisters a player status in an event
-        public final void gridRemove(MapleCharacter chr) {
-                wL.lock();
-                try {
-                        playerGrid.remove(chr.getId());
-                } finally {
-                        wL.unlock();
-                }
+
+        if (gateData != null) {
+            chr.announce(MaplePacketCreator.environmentChange(gateData.getLeft(), gateData.getRight()));
         }
-        
-        // checks a player status
-        public final int gridCheck(MapleCharacter chr) {
-                rL.lock();
-                try {
-                        Integer i = playerGrid.get(chr.getId());
-                        return (i != null) ? i : -1;
-                } finally {
-                        rL.unlock();
-                }
+    }
+
+    public final void giveEventPlayersStageReward(int thisStage) {
+        List<Integer> list = getClearStageBonus(thisStage);     // will give bonus exp & mesos to everyone in the event
+        giveEventPlayersExp(list.get(0));
+        giveEventPlayersMeso(list.get(1));
+    }
+
+    public final void linkToNextStage(int thisStage, String eventFamily, int thisMapId) {
+        giveEventPlayersStageReward(thisStage);
+        thisStage--;    //stages counts from ONE, scripts from ZERO
+
+        MapleMap nextStage = getMapInstance(thisMapId);
+        MaplePortal portal = nextStage.getPortal("next00");
+        if (portal != null) {
+            portal.setScriptName(eventFamily + thisStage);
         }
-        
-        public final int gridSize() {
-                rL.lock();
-                try {
-                        return playerGrid.size();
-                } finally {
-                        rL.unlock();
-                }
+    }
+
+    public final void linkPortalToScript(int thisStage, String portalName, String scriptName, int thisMapId) {
+        giveEventPlayersStageReward(thisStage);
+        thisStage--;    //stages counts from ONE, scripts from ZERO
+
+        MapleMap nextStage = getMapInstance(thisMapId);
+        MaplePortal portal = nextStage.getPortal(portalName);
+        if (portal != null) {
+            portal.setScriptName(scriptName);
         }
-        
-        public final void gridClear() {
-                wL.lock();
-                try {
-                        playerGrid.clear();
-                } finally {
-                        wL.unlock();
-                }
+    }
+
+    // registers a player status in an event
+    public final void gridInsert(MapleCharacter chr, int newStatus) {
+        wL.lock();
+        try {
+            playerGrid.put(chr.getId(), newStatus);
+        } finally {
+            wL.unlock();
+        }
+    }
+
+    // unregisters a player status in an event
+    public final void gridRemove(MapleCharacter chr) {
+        wL.lock();
+        try {
+            playerGrid.remove(chr.getId());
+        } finally {
+            wL.unlock();
+        }
+    }
+
+    // checks a player status
+    public final int gridCheck(MapleCharacter chr) {
+        rL.lock();
+        try {
+            Integer i = playerGrid.get(chr.getId());
+            return (i != null) ? i : -1;
+        } finally {
+            rL.unlock();
+        }
+    }
+
+    public final int gridSize() {
+        rL.lock();
+        try {
+            return playerGrid.size();
+        } finally {
+            rL.unlock();
+        }
+    }
+
+    public final void gridClear() {
+        wL.lock();
+        try {
+            playerGrid.clear();
+        } finally {
+            wL.unlock();
+        }
+    }
+
+    public boolean activatedAllReactorsOnMap(int mapId, int minReactorId, int maxReactorId) {
+        return activatedAllReactorsOnMap(this.getMapInstance(mapId), minReactorId, maxReactorId);
+    }
+
+    public boolean activatedAllReactorsOnMap(MapleMap map, int minReactorId, int maxReactorId) {
+        if (map == null) {
+            return true;
         }
-        
-        public boolean activatedAllReactorsOnMap(int mapId, int minReactorId, int maxReactorId) {
-                return activatedAllReactorsOnMap(this.getMapInstance(mapId), minReactorId, maxReactorId);
-        }
-        
-        public boolean activatedAllReactorsOnMap(MapleMap map, int minReactorId, int maxReactorId) {
-                if(map == null) return true;
-            
-                for(MapleReactor mr : map.getReactorsByIdRange(minReactorId, maxReactorId)) {
-                        if(mr.getReactorType() != -1) {
-                                return false;
-                        }
-                }
 
-                return true;
+        for (MapleReactor mr : map.getReactorsByIdRange(minReactorId, maxReactorId)) {
+            if (mr.getReactorType() != -1) {
+                return false;
+            }
         }
+
+        return true;
+    }
 }
diff --git a/src/server/MapleItemInformationProvider.java b/src/server/MapleItemInformationProvider.java
index ccbf21cf5..6e013cc7f 100644
--- a/src/server/MapleItemInformationProvider.java
+++ b/src/server/MapleItemInformationProvider.java
@@ -116,6 +116,10 @@ public static MapleItemInformationProvider getInstance() {
     protected Map<Integer, Boolean> karmaCache = new HashMap<>();
     protected Map<Integer, Integer> triggerItemCache = new HashMap<>();
     protected Map<Integer, Integer> expCache = new HashMap<>();
+    protected Map<Integer, Integer> createItem = new HashMap<>();
+    protected Map<Integer, Integer> mobItem = new HashMap<>();
+    protected Map<Integer, Integer> useDelay = new HashMap<>();
+    protected Map<Integer, Integer> mobHP = new HashMap<>();
     protected Map<Integer, Integer> levelCache = new HashMap<>();
     protected Map<Integer, Pair<Integer, List<RewardItem>>> rewardCache = new HashMap<>();
     protected List<Pair<Integer, String>> itemNameCache = new ArrayList<>();
@@ -150,40 +154,6 @@ private MapleItemInformationProvider() {
         isPartyQuestItemCache.put(0, false);
     }
 
-//    public MapleInventoryType getInventoryType(int itemId) {
-//        if (inventoryTypeCache.containsKey(itemId)) {
-//            return inventoryTypeCache.get(itemId);
-//        }
-//        MapleInventoryType ret;
-//        String idStr = "0" + String.valueOf(itemId);
-//        MapleDataDirectoryEntry root = itemData.getRoot();
-//        for (MapleDataDirectoryEntry topDir : root.getSubdirectories()) {
-//            for (MapleDataFileEntry iFile : topDir.getFiles()) {
-//                if (iFile.getName().equals(idStr.substring(0, 4) + ".img")) {
-//                    ret = MapleInventoryType.getByWZName(topDir.getName());
-//                    inventoryTypeCache.put(itemId, ret);
-//                    return ret;
-//                } else if (iFile.getName().equals(idStr.substring(1) + ".img")) {
-//                    ret = MapleInventoryType.getByWZName(topDir.getName());
-//                    inventoryTypeCache.put(itemId, ret);
-//                    return ret;
-//                }
-//            }
-//        }
-//        root = equipData.getRoot();
-//        for (MapleDataDirectoryEntry topDir : root.getSubdirectories()) {
-//            for (MapleDataFileEntry iFile : topDir.getFiles()) {
-//                if (iFile.getName().equals(idStr + ".img")) {
-//                    ret = MapleInventoryType.EQUIP;
-//                    inventoryTypeCache.put(itemId, ret);
-//                    return ret;
-//                }
-//            }
-//        }
-//        ret = MapleInventoryType.UNDEFINED;
-//        inventoryTypeCache.put(itemId, ret);
-//        return ret;
-//    }
 
     public List<Pair<Integer, String>> getAllItems() {
         if (!itemNameCache.isEmpty()) {
@@ -1176,7 +1146,10 @@ public MapleStatEffect getItemEffect(int itemId) {
             if (item == null) {
                 return null;
             }
-            MapleData spec = item.getChildByPath("spec");
+            MapleData spec = item.getChildByPath("specEx");
+            if (spec == null) {
+                spec = item.getChildByPath("spec");
+            }
             ret = MapleStatEffect.loadItemEffectFromData(spec, itemId);
             itemEffects.put(Integer.valueOf(itemId), ret);
         }
@@ -1479,6 +1452,46 @@ public int getStateChangeItem(int itemId) {
             return triggerItem;
         }
     }
+    
+    public int getCreatItem(int itemId) {
+        if (createItem.containsKey(itemId)) {
+            return createItem.get(itemId);
+        } else {
+            int itemFrom = MapleDataTool.getIntConvert("info/create", getItemData(itemId), 0);
+            createItem.put(itemId, itemFrom);
+            return itemFrom;
+        }
+    }
+    
+    public int getMobItem(int itemId) {
+        if (mobItem.containsKey(itemId)) {
+            return mobItem.get(itemId);
+        } else {
+            int mobItemCatch = MapleDataTool.getIntConvert("info/mob", getItemData(itemId), 0);
+            mobItem.put(itemId, mobItemCatch);
+            return mobItemCatch;
+        }
+    }
+    
+    public int getUseDelay(int itemId) {
+        if (useDelay.containsKey(itemId)) {
+            return useDelay.get(itemId);
+        } else {
+            int mobUseDelay = MapleDataTool.getIntConvert("info/useDelay", getItemData(itemId), 0);
+            useDelay.put(itemId, mobUseDelay);
+            return mobUseDelay;
+        }
+    }
+    
+    public int getMobHP(int itemId) {
+        if (mobHP.containsKey(itemId)) {
+            return mobHP.get(itemId);
+        } else {
+            int mobHPItem = MapleDataTool.getIntConvert("info/mobHP", getItemData(itemId), 0);
+            mobHP.put(itemId, mobHPItem);
+            return mobHPItem;
+        }
+    }
 
     public int getExpById(int itemId) {
         if (expCache.containsKey(itemId)) {
diff --git a/src/server/MapleStatEffect.java b/src/server/MapleStatEffect.java
index 5c83c3228..aab3d17db 100644
--- a/src/server/MapleStatEffect.java
+++ b/src/server/MapleStatEffect.java
@@ -125,10 +125,10 @@
     private short watk, matk, wdef, mdef, acc, avoid, speed, jump;
     private short hp, mp;
     private double hpR, mpR;
-    private short mhpRRate, mmpRRate;
+    private short mhpRRate, mmpRRate, mobSkill, mobSkillLevel;
     private byte mhpR, mmpR;
     private short mpCon, hpCon;
-    private int duration;
+    private int duration, target, barrier, mob;
     private boolean overTime, repeatEffect;
     private int sourceid;
     private int moveTo;
@@ -208,6 +208,24 @@ private static MapleStatEffect loadFromData(MapleData source, int sourceid, bool
         ret.fatigue = MapleDataTool.getInt("incFatigue", source, 0);
         ret.repeatEffect = MapleDataTool.getInt("repeatEffect", source, 0) > 0;
 
+        MapleData mdd = source.getChildByPath("0");
+        if (mdd != null && mdd.getChildren().size() > 0) {
+            ret.mobSkill = (short) MapleDataTool.getInt("mobSkill", mdd, 0);
+            ret.mobSkillLevel = (short) MapleDataTool.getInt("level", mdd, 0);
+            ret.target = MapleDataTool.getInt("target", mdd, 0);
+        } else {
+            ret.mobSkill = 0;
+            ret.mobSkillLevel = 0;
+            ret.target = 0;
+        }
+        ret.barrier = MapleDataTool.getInt("barrier", source, 0);
+        
+        MapleData mdds = source.getChildByPath("mob");
+        if (mdds != null) {
+            if (mdds.getChildren()!= null && mdds.getChildren().size() > 0) {
+                ret.mob = MapleDataTool.getInt("mob", mdds, 0);
+            }
+        }
         ret.sourceid = sourceid;
         ret.skill = skill;
         if (!ret.skill && ret.duration > -1) {
@@ -228,8 +246,15 @@ private static MapleStatEffect loadFromData(MapleData source, int sourceid, bool
         ret.speed = (short) MapleDataTool.getInt("speed", source, 0);
         ret.jump = (short) MapleDataTool.getInt("jump", source, 0);
 
+        
+        if (MapleDataTool.getInt("barrier", source, 0) > 0) {
+            ret.barrier = MapleDataTool.getInt("barrier", source, 0);
+            addBuffStatPairToListIfNotZero(statups, MapleBuffStat.ARIANT_PQ_SHIELD, Integer.valueOf(1));
+        }
+        
         ret.mapProtection = mapProtection(sourceid);
         addBuffStatPairToListIfNotZero(statups, MapleBuffStat.MAP_PROTECTION, Integer.valueOf(ret.mapProtection));
+        
 
         if (ret.overTime && ret.getSummonMovementType() == null) {
             if (!skill) {
@@ -974,8 +999,19 @@ private boolean applyTo(MapleCharacter applyfrom, MapleCharacter applyto, boolea
                     applyfrom.dispelDebuff(debuff);
                 }
             }
+        } else if (mobSkill > 0 && mobSkillLevel > 0) {
+            if (target > 0) {
+                for (MapleCharacter chr : applyto.getMap().getAllPlayers()) {
+                    if (chr.getId() != applyto.getId()) {
+                        chr.disease(mobSkill, mobSkillLevel);
+                    }
+                }
+            } else {
+                applyto.disease(mobSkill, mobSkillLevel);
+            }
+        } else if (barrier > 0) {
+            applyto.shield();
         }
-
         return true;
     }
 
@@ -1195,7 +1231,6 @@ private void applyBuffEffect(MapleCharacter applyfrom, MapleCharacter applyto, b
 
                     localstatups = statups;
                 }
-
                 buff = MaplePacketCreator.giveBuff(localsourceid, localDuration, localstatups);
                 mbuff = MaplePacketCreator.showMonsterRiding(applyto.getId(), givemount);
                 localDuration = duration;
diff --git a/src/server/expeditions/MapleExpedition.java b/src/server/expeditions/MapleExpedition.java
index 8e55b12f9..cce3e8eab 100644
--- a/src/server/expeditions/MapleExpedition.java
+++ b/src/server/expeditions/MapleExpedition.java
@@ -1,25 +1,3 @@
-/*
-	This file is part of the OdinMS Maple Story Server
-    Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>
-		       Matthias Butz <matze@odinms.de>
-		       Jan Christian Meyer <vimes@odinms.de>
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Affero General Public License as
-    published by the Free Software Foundation version 3 as published by
-    the Free Software Foundation. You may not use, modify or distribute
-    this program under any other version of the GNU Affero General Public
-    License.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Affero General Public License for more details.
-
-    You should have received a copy of the GNU Affero General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
 package server.expeditions;
 
 import java.text.SimpleDateFormat;
@@ -41,6 +19,10 @@
 import tools.LogHelper;
 import tools.MaplePacketCreator;
 import client.MapleCharacter;
+import java.util.Properties;
+import net.server.audit.locks.MonitoredLockType;
+import net.server.audit.locks.MonitoredReentrantLock;
+import net.server.audit.locks.factory.MonitoredReentrantLockFactory;
 
 /**
  *
@@ -48,236 +30,307 @@
  */
 public class MapleExpedition {
 
-	private static final int [] EXPEDITION_BOSSES = {
-			8800000,// - Zakum's first body
-			8800001,// - Zakum's second body
-			8800002,// - Zakum's third body
-			8800003,// - Zakum's Arm 1
-			8800004,// - Zakum's Arm 2
-			8800005,// - Zakum's Arm 3
-			8800006,// - Zakum's Arm 4
-			8800007,// - Zakum's Arm 5
-			8800008,// - Zakum's Arm 6
-			8800009,// - Zakum's Arm 7
-			8800010,// - Zakum's Arm 8
-			8810000,// - Horntail's Left Head
-			8810001,// - Horntail's Right Head
-			8810002,// - Horntail's Head A
-			8810003,// - Horntail's Head B
-			8810004,// - Horntail's Head C
-			8810005,// - Horntail's Left Hand
-			8810006,// - Horntail's Right Hand
-			8810007,// - Horntail's Wings
-			8810008,// - Horntail's Legs
-			8810009,// - Horntail's Tails
-			9420546,// - Scarlion Boss
-			9420547,// - Scarlion Boss
-			9420548,// - Angry Scarlion Boss
-			9420549,// - Furious Scarlion Boss
-			9420541,// - Targa
-			9420542,// - Targa
-			9420543,// - Angry Targa
-			9420544,// - Furious Targa
-	};
-	
-	private MapleCharacter leader;
-	private MapleExpeditionType type;
-	private boolean registering;
-	private MapleMap startMap;
-	private List<String> bossLogs;
-	private ScheduledFuture<?> schedule;
-	private Map<Integer, String> members = new ConcurrentHashMap<>();
-	private List<Integer> banned = new CopyOnWriteArrayList<>();
-	private long startTime;
-
-	public MapleExpedition(MapleCharacter player, MapleExpeditionType met) {
-		leader = player;
-		members.put(player.getId(), player.getName());
-                startMap = player.getMap();
-		type = met;
-		bossLogs = new CopyOnWriteArrayList<>();
-		beginRegistration();
-	}
-
-	private void beginRegistration() {
-		registering = true;
-                leader.announce(MaplePacketCreator.getClock(type.getRegistrationTime() * 60));
-		startMap.broadcastMessage(leader, MaplePacketCreator.serverNotice(6, "[Expedition] " + leader.getName() + " has been declared the expedition captain. Please register for the expedition."), false);
-                leader.announce(MaplePacketCreator.serverNotice(6, "[Expedition] You have become the expedition captain. Gather enough people for your team then talk to the NPC to start."));
-		scheduleRegistrationEnd();
-	}
-
-	private void scheduleRegistrationEnd() {
-		final MapleExpedition exped = this;
-                startTime = System.currentTimeMillis() + type.getRegistrationTime() * 60 * 1000;
-                
-		schedule = TimerManager.getInstance().schedule(new Runnable() { 
-			@Override
-			public void run() {
-				if (registering){
-                                        startMap.getChannelServer().getExpeditions().remove(exped);
-					startMap.broadcastMessage(MaplePacketCreator.serverNotice(6, "[Expedition] The time limit has been reached. Expedition has been disbanded."));
-                                        
-                                        dispose(false);
-				}
-			}
-		}, type.getRegistrationTime() * 60 * 1000);
-	}
-
-	public void dispose(boolean log){
-                broadcastExped(MaplePacketCreator.removeClock());
-            
-                if (schedule != null){
-			schedule.cancel(false);
-		}
-		if (log && !registering){
-			LogHelper.logExpedition(this);
-		}
-	}
-
-	public void start(){
-		registering = false;
-		broadcastExped(MaplePacketCreator.removeClock());
-		broadcastExped(MaplePacketCreator.serverNotice(6, "[Expedition] The expedition has started! Good luck, brave heroes!"));
-		startTime = System.currentTimeMillis();
-		Server.getInstance().broadcastGMMessage(startMap.getWorld(), MaplePacketCreator.serverNotice(6, "[Expedition] " + type.toString() + " Expedition started with leader: " + leader.getName()));
-	}
-
-	public String addMember(MapleCharacter player) {
-		if (!registering){
-			return "Sorry, this expedition is already underway. Registration is closed!";
-		}
-		if (banned.contains(player.getId())){
-			return "Sorry, you've been banned from this expedition by #b" + leader.getName() + "#k.";
-		}
-		if (members.size() >= type.getMaxSize()){ //Would be a miracle if anybody ever saw this
-			return "Sorry, this expedition is full!";
-		}
-                
-                members.put(player.getId(), player.getName());
-                player.announce(MaplePacketCreator.getClock((int)(startTime - System.currentTimeMillis()) / 1000));
-                broadcastExped(MaplePacketCreator.serverNotice(6, "[Expedition] " + player.getName() + " has joined the expedition!"));
-                return "You have registered for the expedition successfully!";
-	}
-
-	private void broadcastExped(byte[] packet){
-		for (MapleCharacter chr : getActiveMembers()){
-                        chr.announce(packet);
-		}
-	}
-
-	public boolean removeMember(MapleCharacter chr) {
-		if(members.remove(chr.getId()) != null) {
-                    chr.announce(MaplePacketCreator.removeClock());
-                    broadcastExped(MaplePacketCreator.serverNotice(6, "[Expedition] " + chr.getName() + " has left the expedition."));
-                    chr.dropMessage(6, "[Expedition] You have left this expedition.");
-                    return true;
+    private static final int[] EXPEDITION_BOSSES = {
+        8800000,// - Zakum's first body
+        8800001,// - Zakum's second body
+        8800002,// - Zakum's third body
+        8800003,// - Zakum's Arm 1
+        8800004,// - Zakum's Arm 2
+        8800005,// - Zakum's Arm 3
+        8800006,// - Zakum's Arm 4
+        8800007,// - Zakum's Arm 5
+        8800008,// - Zakum's Arm 6
+        8800009,// - Zakum's Arm 7
+        8800010,// - Zakum's Arm 8
+        8810000,// - Horntail's Left Head
+        8810001,// - Horntail's Right Head
+        8810002,// - Horntail's Head A
+        8810003,// - Horntail's Head B
+        8810004,// - Horntail's Head C
+        8810005,// - Horntail's Left Hand
+        8810006,// - Horntail's Right Hand
+        8810007,// - Horntail's Wings
+        8810008,// - Horntail's Legs
+        8810009,// - Horntail's Tails
+        9420546,// - Scarlion Boss
+        9420547,// - Scarlion Boss
+        9420548,// - Angry Scarlion Boss
+        9420549,// - Furious Scarlion Boss
+        9420541,// - Targa
+        9420542,// - Targa
+        9420543,// - Angry Targa
+        9420544,// - Furious Targa
+    };
+
+    private MapleCharacter leader;
+    private MapleExpeditionType type;
+    private boolean registering;
+    private MapleMap startMap;
+    private List<String> bossLogs;
+    private ScheduledFuture<?> schedule;
+    private Map<Integer, String> members = new ConcurrentHashMap<>();
+    private List<Integer> banned = new CopyOnWriteArrayList<>();
+    private long startTime;
+    private Properties props = new Properties();
+    private MonitoredReentrantLock pL = MonitoredReentrantLockFactory.createLock(MonitoredLockType.EIM_PARTY, true);
+
+    public MapleExpedition(MapleCharacter player, MapleExpeditionType met) {
+        leader = player;
+        members.put(player.getId(), player.getName());
+        startMap = player.getMap();
+        type = met;
+        bossLogs = new CopyOnWriteArrayList<>();
+        beginRegistration();
+    }
+
+    private void beginRegistration() {
+        registering = true;
+        leader.announce(MaplePacketCreator.getClock(type.getRegistrationTime() * 60));
+        startMap.broadcastMessage(leader, MaplePacketCreator.serverNotice(6, "[Expedition] " + leader.getName() + " has been declared the expedition captain. Please register for the expedition."), false);
+        leader.announce(MaplePacketCreator.serverNotice(6, "[Expedition] You have become the expedition captain. Gather enough people for your team then talk to the NPC to start."));
+
+        if (!MapleExpeditionType.ARIANT.equals(type) && !MapleExpeditionType.ARIANT1.equals(type) && !MapleExpeditionType.ARIANT2.equals(type)) {
+            scheduleRegistrationEnd();
+        }
+    }
+
+    private void scheduleRegistrationEnd() {
+        final MapleExpedition exped = this;
+        startTime = System.currentTimeMillis() + type.getRegistrationTime() * 60 * 1000;
+
+        schedule = TimerManager.getInstance().schedule(new Runnable() {
+            @Override
+            public void run() {
+                if (registering) {
+                    startMap.getChannelServer().getExpeditions().remove(exped);
+                    startMap.broadcastMessage(MaplePacketCreator.serverNotice(6, "[Expedition] The time limit has been reached. Expedition has been disbanded."));
+
+                    dispose(false);
                 }
-                
-                return false;
-	}
+            }
+        }, type.getRegistrationTime() * 60 * 1000);
+    }
 
-	public MapleExpeditionType getType() {
-		return type;
-	}
-        
-        public List<MapleCharacter> getActiveMembers() {    // thanks MedicOP for figuring out an issue with broadcasting packets to offline members
-                PlayerStorage ps = startMap.getWorldServer().getPlayerStorage();
-                
-                List<MapleCharacter> activeMembers = new LinkedList<>();
-		for (Integer chrid : getMembers().keySet()){
-                        MapleCharacter chr = ps.getCharacterById(chrid);
-                        if (chr != null && chr.isLoggedinWorld()) {
-                                activeMembers.add(chr);
-                        }
-		}
-                
-                return activeMembers;
+    public void dispose(boolean log) {
+        broadcastExped(MaplePacketCreator.removeClock());
+
+        if (schedule != null) {
+            schedule.cancel(false);
         }
         
-        public Map<Integer, String> getMembers() {
-                return new HashMap<>(members);
-	}
-        
-        public List<Entry<Integer, String>> getMemberList() {
-                List<Entry<Integer, String>> memberList = new LinkedList<>();
-                Entry<Integer, String> leaderEntry = null;
-                
-                for (Entry<Integer, String> e : getMembers().entrySet()) {
-                        if (!isLeader(e.getKey())) {
-                                memberList.add(e);
-                        } else {
-                                leaderEntry = e;
-                        }
-                }
-                
-                if (leaderEntry != null) {
-                        memberList.add(0, leaderEntry);
+        props.clear();
+        if (log && !registering) {
+            LogHelper.logExpedition(this);
+        }
+    }
+
+    public void start() {
+        if (MapleExpeditionType.ARIANT.equals(type) || MapleExpeditionType.ARIANT1.equals(type) || MapleExpeditionType.ARIANT2.equals(type)) {
+            startTime = System.currentTimeMillis() + type.getRegistrationTime() * 60 * 1000;
+        }
+        registering = false;
+        broadcastExped(MaplePacketCreator.removeClock());
+        broadcastExped(MaplePacketCreator.serverNotice(6, "[Expedition] The expedition has started! Good luck, brave heroes!"));
+        broadcastExped(MaplePacketCreator.getClock((int) (startTime - System.currentTimeMillis()) / 1000));
+        Server.getInstance().broadcastGMMessage(startMap.getWorld(), MaplePacketCreator.serverNotice(6, "[Expedition] " + type.toString() + " Expedition started with leader: " + leader.getName()));
+    }
+
+    public String addMember(MapleCharacter player) {
+        if (!registering) {
+            return "Sorry, this expedition is already underway. Registration is closed!";
+        }
+        if (banned.contains(player.getId())) {
+            return "Sorry, you've been banned from this expedition by #b" + leader.getName() + "#k.";
+        }
+        if (members.size() >= type.getMaxSize()) { //Would be a miracle if anybody ever saw this
+            return "Sorry, this expedition is full!";
+        }
+
+        members.put(player.getId(), player.getName());
+        player.announce(MaplePacketCreator.getClock((int) (startTime - System.currentTimeMillis()) / 1000));
+        broadcastExped(MaplePacketCreator.serverNotice(6, "[Expedition] " + player.getName() + " has joined the expedition!"));
+        return "You have registered for the expedition successfully!";
+    }
+
+    public int addMemberInt(MapleCharacter player) {
+        if (!registering) {
+            return 1; //"Sorry, this expedition is already underway. Registration is closed!";
+        }
+        if (banned.contains(player.getId())) {
+            return 2; //"Sorry, you've been banned from this expedition by #b" + leader.getName() + "#k.";
+        }
+        if (members.size() >= type.getMaxSize()) { //Would be a miracle if anybody ever saw this
+            return 3; //"Sorry, this expedition is full!";
+        }
+
+        members.put(player.getId(), player.getName());
+        player.announce(MaplePacketCreator.getClock((int) (startTime - System.currentTimeMillis()) / 1000));
+        broadcastExped(MaplePacketCreator.serverNotice(6, "[Expedition] " + player.getName() + " has joined the expedition!"));
+        return 0; //"You have registered for the expedition successfully!";
+    }
+
+    private void broadcastExped(byte[] packet) {
+        for (MapleCharacter chr : getActiveMembers()) {
+            chr.announce(packet);
+        }
+    }
+
+    public boolean removeMember(MapleCharacter chr) {
+        if (members.remove(chr.getId()) != null) {
+            chr.announce(MaplePacketCreator.removeClock());
+            broadcastExped(MaplePacketCreator.serverNotice(6, "[Expedition] " + chr.getName() + " has left the expedition."));
+            chr.dropMessage(6, "[Expedition] You have left this expedition.");
+            return true;
+        }
+
+        return false;
+    }
+
+    public MapleExpeditionType getType() {
+        return type;
+    }
+
+    public List<MapleCharacter> getActiveMembers() {    // thanks MedicOP for figuring out an issue with broadcasting packets to offline members
+        PlayerStorage ps = startMap.getWorldServer().getPlayerStorage();
+
+        List<MapleCharacter> activeMembers = new LinkedList<>();
+        for (Integer chrid : getMembers().keySet()) {
+            MapleCharacter chr = ps.getCharacterById(chrid);
+            if (chr != null && chr.isLoggedinWorld()) {
+                activeMembers.add(chr);
+            }
+        }
+
+        return activeMembers;
+    }
+
+    public Map<Integer, String> getMembers() {
+        return new HashMap<>(members);
+    }
+
+    public List<Entry<Integer, String>> getMemberList() {
+        List<Entry<Integer, String>> memberList = new LinkedList<>();
+        Entry<Integer, String> leaderEntry = null;
+
+        for (Entry<Integer, String> e : getMembers().entrySet()) {
+            if (!isLeader(e.getKey())) {
+                memberList.add(e);
+            } else {
+                leaderEntry = e;
+            }
+        }
+
+        if (leaderEntry != null) {
+            memberList.add(0, leaderEntry);
+        }
+
+        return memberList;
+    }
+
+    public void ban(Entry<Integer, String> chr) {
+        int cid = chr.getKey();
+        if (!banned.contains(cid)) {
+            banned.add(cid);
+            members.remove(cid);
+
+            broadcastExped(MaplePacketCreator.serverNotice(6, "[Expedition] " + chr.getValue() + " has been banned from the expedition."));
+
+            MapleCharacter player = startMap.getWorldServer().getPlayerStorage().getCharacterById(cid);
+            if (player != null && player.isLoggedinWorld()) {
+                player.announce(MaplePacketCreator.removeClock());
+                player.dropMessage(6, "[Expedition] You have been banned from this expedition.");
+                if (MapleExpeditionType.ARIANT.equals(type) || MapleExpeditionType.ARIANT1.equals(type) || MapleExpeditionType.ARIANT2.equals(type)) {
+                    player.changeMap(980010000);
                 }
-            
-                return memberList;
-	}
+            }
+        }
+    }
 
-	public MapleCharacter getLeader(){
-		return leader;
-	}
-        
-        public MapleMap getRecruitingMap() {
-                return startMap;
+    public void monsterKilled(MapleCharacter chr, MapleMonster mob) {
+        for (int i = 0; i < EXPEDITION_BOSSES.length; i++) {
+            if (mob.getId() == EXPEDITION_BOSSES[i]) { //If the monster killed was a boss
+                String timeStamp = new SimpleDateFormat("HH:mm:ss").format(new Date());
+                bossLogs.add(">" + mob.getName() + " was killed after " + LogHelper.getTimeString(startTime) + " - " + timeStamp + "\r\n");
+                return;
+            }
         }
+    }
+    
+    public void setProperty(String key, String value) {
+        pL.lock();
+        try {
+            props.setProperty(key, value);
+        } finally {
+            pL.unlock();
+        }
+    }
+
+    public String getProperty(String key) {
+        pL.lock();
+        try {
+            return props.getProperty(key);
+        } finally {
+            pL.unlock();
+        }
+    }
+    
+    public MapleCharacter getLeader() {
+        return leader;
+    }
 
-	public boolean contains(MapleCharacter player) {
-                return members.containsKey(player.getId()) || isLeader(player);
-	}
+    public MapleMap getRecruitingMap() {
+        return startMap;
+    }
 
-	public boolean isLeader(MapleCharacter player) {
-		return isLeader(player.getId());
-	}
-        
-        public boolean isLeader(int playerid) {
-		return leader.getId() == playerid;
-	}
-
-	public boolean isRegistering(){
-		return registering;
-	}
-
-	public boolean isInProgress(){
-		return !registering;
-	}
-
-	public void ban(Entry<Integer, String> chr) {
-                int cid = chr.getKey();
-                
-		if (!banned.contains(cid)) {
-			banned.add(cid);
-			members.remove(cid);
-                        
-                        broadcastExped(MaplePacketCreator.serverNotice(6, "[Expedition] " + chr.getValue() + " has been banned from the expedition."));
-                        
-                        MapleCharacter player = startMap.getWorldServer().getPlayerStorage().getCharacterById(cid);
-                        if (player != null && player.isLoggedinWorld()) {
-                                player.announce(MaplePacketCreator.removeClock());
-                                player.dropMessage(6, "[Expedition] You have been banned from this expedition.");
-                        }
-		}
-	}
-
-	public long getStartTime(){
-		return startTime;
-	}
-	
-	public List<String> getBossLogs(){
-		return bossLogs;
-	}
-	
-	public void monsterKilled(MapleCharacter chr, MapleMonster mob) {
-		for (int i = 0; i < EXPEDITION_BOSSES.length; i++){
-			if (mob.getId() == EXPEDITION_BOSSES[i]){ //If the monster killed was a boss
-				String timeStamp = new SimpleDateFormat("HH:mm:ss").format(new Date());
-				bossLogs.add(">" + mob.getName() + " was killed after " + LogHelper.getTimeString(startTime) + " - " + timeStamp + "\r\n");
-				return;
-			}
-		}
-	}
+    public boolean contains(MapleCharacter player) {
+        return members.containsKey(player.getId()) || isLeader(player);
+    }
+
+    public boolean isLeader(MapleCharacter player) {
+        return isLeader(player.getId());
+    }
+
+    public boolean isLeader(int playerid) {
+        return leader.getId() == playerid;
+    }
+
+    public boolean isRegistering() {
+        return registering;
+    }
+
+    public boolean isInProgress() {
+        return !registering;
+    }
+
+    public long getStartTime() {
+        return startTime;
+    }
+
+    public List<String> getBossLogs() {
+        return bossLogs;
+    }
+
+    public MapleMap getStartMap() {
+        return startMap;
+    }
+
+    public void setStartMap(MapleMap startMap) {
+        this.startMap = startMap;
+    }
+
+    public ScheduledFuture<?> getSchedule() {
+        return schedule;
+    }
+
+    public void setSchedule(ScheduledFuture<?> schedule) {
+        this.schedule = schedule;
+    }
+
+    public List<Integer> getBanned() {
+        return banned;
+    }
+
+    public void setBanned(List<Integer> banned) {
+        this.banned = banned;
+    }
 }
diff --git a/src/server/expeditions/MapleExpeditionType.java b/src/server/expeditions/MapleExpeditionType.java
index 393ce34b1..e3740a3e2 100644
--- a/src/server/expeditions/MapleExpeditionType.java
+++ b/src/server/expeditions/MapleExpeditionType.java
@@ -39,6 +39,9 @@
     HORNTAIL(6, 30, 100, 255, 5),
     CHAOS_ZAKUM(6, 30, 120, 255, 5),
     CHAOS_HORNTAIL(6, 30, 120, 255, 5),
+    ARIANT(2, 4, 20, 30, 5),
+    ARIANT1(2, 4, 20, 30, 5),
+    ARIANT2(2, 4, 20, 30, 5),
     PINKBEAN(6, 30, 120, 255, 5),
     CWKPQ(6, 30, 90, 255, 5);   // CWKPQ min-level 90, found thanks to Cato
     
diff --git a/src/server/life/Element.java b/src/server/life/Element.java
index 063447f6c..9d22fd9b8 100644
--- a/src/server/life/Element.java
+++ b/src/server/life/Element.java
@@ -22,8 +22,23 @@
 package server.life;
 
 public enum Element {
-    NEUTRAL, FIRE, ICE, LIGHTING, POISON, HOLY, DARK;
+    NEUTRAL(0), PHYSICAL(1), FIRE(2, true), ICE(3, true), LIGHTING(4), POISON(5), HOLY(6, true), DARKNESS(7);
 
+    private int value;
+    private boolean special = false;
+    private Element(int v) {
+	this.value = v;
+    }
+
+    private Element(int v, boolean special) {
+	this.value = v;
+	this.special = special;
+    }
+
+    public boolean isSpecial() {
+	return special;
+    }
+    
     public static Element getFromChar(char c) {
         switch (Character.toUpperCase(c)) {
             case 'F':
@@ -37,10 +52,14 @@ public static Element getFromChar(char c) {
             case 'H':
                 return HOLY;
             case 'D':
-            	return DARK;
+            	return DARKNESS;
             case 'P':
                 return NEUTRAL;
         }
         throw new IllegalArgumentException("unknown elemnt char " + c);
     }
+    
+    public int getValue() {
+	return value;
+    }
 }
diff --git a/src/server/life/MapleLifeFactory.java b/src/server/life/MapleLifeFactory.java
index 086958806..edfa5f7cf 100644
--- a/src/server/life/MapleLifeFactory.java
+++ b/src/server/life/MapleLifeFactory.java
@@ -299,7 +299,7 @@ public String getMsg() {
         private int id;
         private byte chance, x;
 
-        private loseItem(int id, byte chance, byte x) {
+        public loseItem(int id, byte chance, byte x) {
             this.id = id;
             this.chance = chance;
             this.x = x;
diff --git a/src/server/life/MapleMonsterInformationProvider.java b/src/server/life/MapleMonsterInformationProvider.java
index 4854d125b..f40bbf23a 100644
--- a/src/server/life/MapleMonsterInformationProvider.java
+++ b/src/server/life/MapleMonsterInformationProvider.java
@@ -186,7 +186,12 @@ private void retrieveGlobal() {
         if (monsterId >= 9300127 && monsterId <= 9300136 || monsterId >= 9300315 && monsterId <= 9300324) {
             int dropArray[] = {2022157, 2022158, 2022159, 2022160, 2022161, 2022162, 2022163, 2022164, 2022165, 2022166, 2022167, 2022168, 2022169, 2022170, 2022171, 2022172, 2022173, 2022174, 2022175, 2022176, 2022177, 2022178, 4001129}; //These are the drops, -1 means meso :D
             for (int id : dropArray) {
-                ret.add(new MonsterDropEntry(id, 2000, 1, 1, (short) 0));
+                ret.add(new MonsterDropEntry(id, 20000, 1, 1, (short) 0));
+            }
+        } else if (monsterId == 9300157) {
+            int dropArray[] = {2022266, 2022267, 2022268, 2022269}; //These are the drops, -1 means meso :D
+            for (int id : dropArray) {
+                ret.add(new MonsterDropEntry(id, 20000, 1, 1, (short) 0));
             }
         } else {
             PreparedStatement ps = null;
diff --git a/src/server/maps/MapleMap.java b/src/server/maps/MapleMap.java
index c6a926fde..9cdcb6bd2 100644
--- a/src/server/maps/MapleMap.java
+++ b/src/server/maps/MapleMap.java
@@ -1,24 +1,3 @@
-/*
- This file is part of the OdinMS Maple Story Server
- Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc>
- Matthias Butz <matze@odinms.de>
- Jan Christian Meyer <vimes@odinms.de>
-
- This program is free software: you can redistribute it and/or modify
- it under the terms of the GNU Affero General Public License as
- published by the Free Software Foundation version 3 as published by
- the Free Software Foundation. You may not use, modify or distribute
- this program under any other version of the GNU Affero General Public
- License.
-
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU Affero General Public License for more details.
-
- You should have received a copy of the GNU Affero General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
 package server.maps;
 
 import client.MapleBuffStat;
@@ -84,9 +63,9 @@
 import server.life.MonsterGlobalDropEntry;
 import server.life.SpawnPoint;
 import scripting.event.EventInstanceManager;
+import server.expeditions.MapleExpedition;
+import server.expeditions.MapleExpeditionType;
 import server.life.MaplePlayerNPC;
-import server.life.MobSkill;
-import server.life.MobSkillFactory;
 import server.life.MonsterListener;
 import server.partyquest.GuardianSpawnPoint;
 import server.partyquest.MapleCarnivalFactory;
@@ -162,6 +141,13 @@
     private MapleSnowball snowball0 = null;
     private MapleSnowball snowball1 = null;
     private MapleCoconut coconut;
+    
+    //CPQ
+    private int maxMobs;
+    private int maxReactors;
+    private int deathCP;
+    private int timeDefault;
+    private int timeExpand;
 
     //locks
     private ReadLock chrRLock;
@@ -2499,6 +2485,42 @@ public void run() {
             if (mmd != null) {
                 mmd.registerPlayer(chr);
             }
+        } else if (mapid == 980010101 || mapid == 980010201 || mapid == 980010301) { // AriantPQ
+            int pqTimer = (10 * 60 * 1000);
+            int pqTimerBord = (9 * 60 * 1000) + 50 * 1000;
+
+            chr.announce(MaplePacketCreator.getClock(pqTimer / 1000));
+
+            chr.setAriantScore(TimerManager.getInstance().schedule(new Runnable() {
+                @Override
+                public void run() {
+                    if (chr.getMapId() == 980010101 || chr.getMapId() == 980010201 || chr.getMapId() == 980010301) {
+                        broadcastMessage(MaplePacketCreator.showAriantScoreBoard());
+                        killAllMonsters();
+                    }
+                }
+            }, pqTimerBord));
+
+            chr.setPqMapleMap(TimerManager.getInstance().schedule(new Runnable() {
+                @Override
+                public void run() {
+                    if (chr.getMapId() == 980010101 || chr.getMapId() == 980010201 || chr.getMapId() == 980010301) {
+                        MapleExpedition exp = null;
+                        if (chr.getMapId() == 980010101) {
+                            exp = chr.getClient().getAbstractPlayerInteraction().getExpedition(MapleExpeditionType.ARIANT);
+                        } else if (chr.getMapId() == 980010201) {
+                            exp = chr.getClient().getAbstractPlayerInteraction().getExpedition(MapleExpeditionType.ARIANT1);
+                        } else {
+                            exp = chr.getClient().getAbstractPlayerInteraction().getExpedition(MapleExpeditionType.ARIANT2);
+                        }
+                        chr.changeMap(980010010, 0);
+                        chr.cancelPqMapleMap();
+                        if (exp != null) {
+                            chr.getClient().getAbstractPlayerInteraction().endExpedition(exp);
+                        }
+                    }
+                }
+            }, pqTimer));
         }
 
         MaplePet[] pets = chr.getPets();
@@ -4350,7 +4372,7 @@ public final void addMobSpawn(int mobId, int spendCP) {
     public final List<Pair<Integer, Integer>> getMobsToSpawn() {
         return mobsToSpawn;
     }
-    
+
     public boolean isCPQWinnerMap() {
         switch (this.getId()) {
             case 980000103:
@@ -4382,4 +4404,44 @@ public boolean isCPQLoserMap() {
         }
         return false;
     }
+    
+    public int getMaxMobs() {
+        return maxMobs;
+    }
+
+    public void setMaxMobs(int maxMobs) {
+        this.maxMobs = maxMobs;
+    }
+
+    public int getMaxReactors() {
+        return maxReactors;
+    }
+
+    public void setMaxReactors(int maxReactors) {
+        this.maxReactors = maxReactors;
+    }
+
+    public int getDeathCP() {
+        return deathCP;
+    }
+
+    public void setDeathCP(int deathCP) {
+        this.deathCP = deathCP;
+    }
+
+    public int getTimeDefault() {
+        return timeDefault;
+    }
+
+    public void setTimeDefault(int timeDefault) {
+        this.timeDefault = timeDefault;
+    }
+
+    public int getTimeExpand() {
+        return timeExpand;
+    }
+
+    public void setTimeExpand(int timeExpand) {
+        this.timeExpand = timeExpand;
+    }
 }
diff --git a/src/server/maps/MapleMapFactory.java b/src/server/maps/MapleMapFactory.java
index 05a41ef13..d4e1e19b3 100644
--- a/src/server/maps/MapleMapFactory.java
+++ b/src/server/maps/MapleMapFactory.java
@@ -94,12 +94,12 @@ private void loadLifeFromWz(MapleMap map, MapleData mapData) {
             String type = MapleDataTool.getString(life.getChildByPath("type"));
             int team = MapleDataTool.getInt("team", life, -1);
             if (map.isCPQMap2() && type.equals("m")) {
-                if((Integer.parseInt(life.getName()) % 2) == 0)  {
+                if ((Integer.parseInt(life.getName()) % 2) == 0) {
                     team = 0;
                 } else {
                     team = 1;
                 }
-            } 
+            }
             int cy = MapleDataTool.getInt(life.getChildByPath("cy"));
             MapleData dF = life.getChildByPath("f");
             int f = (dF != null) ? MapleDataTool.getInt(dF) : 0;
@@ -313,6 +313,11 @@ private synchronized MapleMap loadMapFromWz(int mapid, Integer omapid) {
         if (map.isCPQMap()) {
             MapleData mcData = mapData.getChildByPath("monsterCarnival");
             if (mcData != null) {
+                map.setDeathCP(MapleDataTool.getIntConvert("deathCP", mcData, 0));
+                map.setMaxMobs(MapleDataTool.getIntConvert("mobGenMax", mcData, 0));
+                map.setTimeDefault(MapleDataTool.getIntConvert("timeDefault", mcData, 0));
+                map.setTimeExpand(MapleDataTool.getIntConvert("timeExpand", mcData, 0));
+                map.setMaxReactors(MapleDataTool.getIntConvert("guardianGenMax", mcData, 0));
                 MapleData guardianGenData = mcData.getChildByPath("guardianGenPos");
                 for (MapleData node : guardianGenData.getChildren()) {
                     GuardianSpawnPoint pt = new GuardianSpawnPoint(new Point(MapleDataTool.getIntConvert("x", node), MapleDataTool.getIntConvert("y", node)));
@@ -320,18 +325,19 @@ private synchronized MapleMap loadMapFromWz(int mapid, Integer omapid) {
                     pt.setTaken(false);
                     map.addGuardianSpawnPoint(pt);
                 }
-            }
-            if (mcData.getChildByPath("skill") != null) {
-                for (MapleData area : mcData.getChildByPath("skill")) {
-                    map.addSkillId(MapleDataTool.getInt(area));
+                if (mcData.getChildByPath("skill") != null) {
+                    for (MapleData area : mcData.getChildByPath("skill")) {
+                        map.addSkillId(MapleDataTool.getInt(area));
+                    }
                 }
-            }
-            
-            if (mcData.getChildByPath("mob") != null) {
-                for (MapleData area : mcData.getChildByPath("mob")) {
-                    map.addMobSpawn(MapleDataTool.getInt(area.getChildByPath("id")), MapleDataTool.getInt(area.getChildByPath("spendCP")));
+
+                if (mcData.getChildByPath("mob") != null) {
+                    for (MapleData area : mcData.getChildByPath("mob")) {
+                        map.addMobSpawn(MapleDataTool.getInt(area.getChildByPath("id")), MapleDataTool.getInt(area.getChildByPath("spendCP")));
+                    }
                 }
             }
+
         }
 
         if (mapData.getChildByPath("reactor") != null) {
diff --git a/src/server/partyquest/MonsterCarnival.java b/src/server/partyquest/MonsterCarnival.java
index 490322a23..1b03e989c 100644
--- a/src/server/partyquest/MonsterCarnival.java
+++ b/src/server/partyquest/MonsterCarnival.java
@@ -14,7 +14,6 @@
 /**
  * @author Drago/Dragohe4rt
  */
-
 public class MonsterCarnival {
 
     public static int D = 3;
@@ -36,6 +35,8 @@ public MonsterCarnival(MapleParty p1, MapleParty p2, int mapid, boolean cpq1) {
             this.cpq1 = cpq1;
             this.p1 = p1;
             this.p2 = p2;
+            setSummons(map.getMaxMobs());
+            setSummonss(map.getMaxMobs());
             Channel cs = Server.getInstance().getWorld(p2.getLeader().getWorld()).getChannel(p2.getLeader().getChannel());
             p1.setEnemy(p2);
             p2.setEnemy(p1);
@@ -91,17 +92,17 @@ public MonsterCarnival(MapleParty p1, MapleParty p2, int mapid, boolean cpq1) {
                 public void run() {
                     timeUp();
                 }
-            }, 10 * 60 * 1000);
+            }, (map.getTimeDefault() - 10) * 1000);
             effectTimer = TimerManager.getInstance().schedule(new Runnable() {
                 @Override
                 public void run() {
                     complete();
                 }
-            }, 10 * 60 * 1000 - 10 * 1000);
+            }, (map.getTimeDefault() - 10) * 1000 - 10 * 1000);
             TimerManager.getInstance().schedule(new Runnable() {
                 @Override
                 public void run() {
-                    map.addClock(60 * 10);
+                    map.addClock(map.getTimeDefault() - 10);
                 }
             }, 2000);
         } catch (Exception e) {
@@ -321,13 +322,13 @@ public void extendTime() {
             public void run() {
                 timeUp();
             }
-        }, 3 * 60 * 1000);
+        }, map.getTimeExpand() * 1000);
         effectTimer = TimerManager.getInstance().schedule(new Runnable() {
             @Override
             public void run() {
                 complete();
             }
-        }, 3 * 60 * 1000 - 10);
+        }, map.getTimeExpand() * 1000 - 10);
     }
 
     public void complete() {
@@ -486,4 +487,20 @@ public void setCP(int CP, int team) {
             this.blueCP = CP;
         }
     }
+
+    public int getSummons() {
+        return summons;
+    }
+
+    public void setSummons(int summons) {
+        this.summons = summons;
+    }
+
+    public int getSummonss() {
+        return summonss;
+    }
+
+    public void setSummonss(int summonss) {
+        this.summonss = summonss;
+    }
 }
diff --git a/src/server/partyquest/MonsterCarnivalParty.java b/src/server/partyquest/MonsterCarnivalParty.java
deleted file mode 100644
index f066d7474..000000000
--- a/src/server/partyquest/MonsterCarnivalParty.java
+++ /dev/null
@@ -1,125 +0,0 @@
-package server.partyquest;
-
-import client.MapleCharacter;
-import java.util.LinkedList;
-import java.util.List;
-import server.maps.MapleMap;
-import tools.MaplePacketCreator;
-
-/**
- * @author Rob
- */
-public class MonsterCarnivalParty {
-
-    private List<MapleCharacter> members = new LinkedList<>();
-    private MapleCharacter leader;
-    private byte team;
-    private short availableCP = 0, totalCP = 0;
-    private int summons = 7;
-    private boolean winner = false;
-
-    public MonsterCarnivalParty(final MapleCharacter owner, final List<MapleCharacter> members1, final byte team1) {
-        leader = owner;
-        members = members1;
-        team = team1;
-
-        for (final MapleCharacter chr : members) {
-            chr.setCarnivalParty(this);
-            chr.setTeam(team);
-        }
-    }
-
-    public final MapleCharacter getLeader() {
-        return leader;
-    }
-
-    public void addCP(MapleCharacter player, int ammount) {
-        totalCP += ammount;
-        availableCP += ammount;
-        player.addCP(ammount);
-    }
-
-    public int getTotalCP() {
-        return totalCP;
-    }
-
-    public int getAvailableCP() {
-        return availableCP;
-    }
-
-    public void useCP(MapleCharacter player, int ammount) {
-        availableCP -= ammount;
-        player.useCP(ammount);
-    }
-
-    public List<MapleCharacter> getMembers() {
-        return members;
-    }
-
-    public int getTeam() {
-        return team;
-    }
-
-    public void warpOut(final int map) {
-        for (MapleCharacter chr : members) {
-            chr.changeMap(map, 0);
-            chr.setCarnivalParty(null);
-            chr.setCarnival(null);
-        }
-        members.clear();
-    }
-
-    public void warp(final MapleMap map, final int portalid) {
-        for (MapleCharacter chr : members) {
-            chr.changeMap(map, map.getPortal(portalid));
-        }
-    }
-
-    public void warpOut() {
-        if (winner == true)
-            warpOut(980000003 + (leader.getCarnival().getRoom() * 100));
-        else
-            warpOut(980000004 + (leader.getCarnival().getRoom() * 100));
-    }
-
-    public boolean allInMap(MapleMap map) {
-        boolean status = true;
-        for (MapleCharacter chr : members) {
-            if (chr.getMap() != map) {
-                status = false;
-            }
-        }
-        return status;
-    }
-
-    public void removeMember(MapleCharacter chr) {
-        members.remove(chr);
-        chr.changeMap(980000010);
-        chr.setCarnivalParty(null);
-        chr.setCarnival(null);
-    }
-
-    public boolean isWinner() {
-        return winner;
-    }
-
-    public void setWinner(boolean status) {
-        winner = status;
-    }
-
-    public void displayMatchResult() {
-        final String effect = winner ? "quest/carnival/win" : "quest/carnival/lose";
-
-        for (final MapleCharacter chr : members) {
-            chr.announce(MaplePacketCreator.showEffect(effect));
-        }
-    }
-
-    public void summon() {
-        this.summons--;
-    }
-
-    public boolean canSummon() {
-        return this.summons > 0;
-    }
-}
diff --git a/src/tools/MaplePacketCreator.java b/src/tools/MaplePacketCreator.java
index 171ce14f8..301419701 100644
--- a/src/tools/MaplePacketCreator.java
+++ b/src/tools/MaplePacketCreator.java
@@ -4988,7 +4988,7 @@ private static void addPetInfo(final MaplePacketLittleEndianWriter mplew, MapleP
 
     public static byte[] updateAriantPQRanking(String name, int score, boolean empty) {
         final MaplePacketLittleEndianWriter mplew = new MaplePacketLittleEndianWriter();
-        mplew.writeShort(SendOpcode.ARIANT_SCORE.getValue());
+        mplew.writeShort(SendOpcode.ARIANT_ARENA_USER_SCORE.getValue());
         mplew.write(empty ? 0 : 1);
         if (!empty) {
             mplew.writeMapleAsciiString(name);
@@ -4996,6 +4996,12 @@ private static void addPetInfo(final MaplePacketLittleEndianWriter mplew, MapleP
         }
         return mplew.getPacket();
     }
+    
+    public static byte[] showAriantScoreBoard() {
+        MaplePacketLittleEndianWriter mplew = new MaplePacketLittleEndianWriter();
+        mplew.writeShort(SendOpcode.ARIANT_ARENA_SHOW_RESULT.getValue());
+        return mplew.getPacket();
+    }
 
     public static byte[] catchMessage(int message) { // not done, I guess
         final MaplePacketLittleEndianWriter mplew = new MaplePacketLittleEndianWriter();
